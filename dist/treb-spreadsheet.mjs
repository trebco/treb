/*! TREB v28.10.4. Copyright 2018-2024 trebco, llc. All rights reserved. LGPL: https://treb.app/license */
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// treb-base-types/src/area.ts
var IsCellAddress = (obj) => {
  return obj !== null && typeof obj === "object" && "row" in obj && "column" in obj;
};
var IsArea = (obj) => {
  return obj !== null && typeof obj === "object" && "start" in obj && IsCellAddress(obj.start) && "end" in obj && IsCellAddress(obj.end);
};
var Area = class _Area {
  // }, IterableIterator<ICellAddress> {
  // tslint:disable-next-line:variable-name
  start_;
  // tslint:disable-next-line:variable-name
  end_;
  /**
   *
   * @param start
   * @param end
   * @param normalize: calls the normalize function
   */
  constructor(start, end = start, normalize = false) {
    this.end_ = this.PatchNull(end);
    this.start_ = this.PatchNull(start);
    if (normalize)
      this.Normalize();
  }
  static FromColumn(column) {
    return new _Area({ row: Infinity, column });
  }
  static FromRow(row) {
    return new _Area({ row, column: Infinity });
  }
  static ColumnToLabel(c) {
    let s = String.fromCharCode(65 + c % 26);
    while (c > 25) {
      c = Math.floor(c / 26) - 1;
      s = String.fromCharCode(65 + c % 26) + s;
    }
    return s;
  }
  static CellAddressToLabel(address, sheet_id = false) {
    const prefix = sheet_id ? `${address.sheet_id || 0}!` : "";
    return prefix + (address.absolute_column ? "$" : "") + this.ColumnToLabel(address.column) + (address.absolute_row ? "$" : "") + (address.row + 1);
  }
  /**
   * merge two areas and return a new area.
   * UPDATE to support arbitrary arguments
   */
  static Join(base, ...args) {
    const area = new _Area(base.start, base.end);
    for (const arg of args) {
      if (arg) {
        area.ConsumeAddress(arg.start);
        area.ConsumeAddress(arg.end);
      }
    }
    return area;
  }
  /**
   * creates an area that expands the original area in all directions
   * (except at the top/left edges)
   */
  static Bleed(area, length = 1) {
    return new _Area({
      row: Math.max(0, area.start.row - length),
      column: Math.max(0, area.start.column - length),
      sheet_id: area.start.sheet_id
    }, {
      row: area.end.row + length,
      column: area.end.column + length
    });
  }
  /**
   * adjust an area in response to an insert/delete operation.
   * I noticed we were doing this in several places. moved here to unify.
   * 
   * @param source - the starting area. we'll create a new object to return
   * (we will not mutate in place)
   */
  static PatchArea(source, options) {
    const { before_column, column_count, before_row, row_count } = options;
    let area = new _Area(source.start, source.end);
    const sheet_id = source.start.sheet_id;
    if (column_count && before_column <= area.end.column) {
      if (column_count > 0) {
        if (before_column <= area.start.column) {
          area.Shift(0, column_count);
        } else if (before_column > area.start.column && before_column <= area.end.column) {
          area.ConsumeAddress({ row: area.end.row, column: area.end.column + column_count });
        } else {
          console.warn(`AA X case 1`, before_column, column_count, JSON.stringify(area));
        }
      } else if (column_count < 0) {
        if (before_column - column_count <= area.start.column) {
          area.Shift(0, column_count);
        } else if (before_column <= area.start.column && before_column - column_count > area.end.column) {
          return false;
        } else if (before_column <= area.start.column) {
          const last_column = before_column - column_count - 1;
          area = new _Area({
            row: area.start.row,
            column: last_column + 1 + column_count,
            sheet_id
          }, {
            row: area.end.row,
            column: area.end.column + column_count
          });
        } else if (before_column <= area.end.column) {
          const last_column = before_column - column_count - 1;
          if (last_column >= area.end.column) {
            area = new _Area({
              row: area.start.row,
              column: area.start.column,
              sheet_id
            }, {
              row: area.end.row,
              column: before_column - 1
            });
          } else {
            area = new _Area({
              row: area.start.row,
              column: area.start.column,
              sheet_id
            }, {
              row: area.end.row,
              column: area.start.column + area.columns + column_count - 1
            });
          }
        } else {
          console.warn(`AA X case 2`, before_column, column_count, JSON.stringify(area));
        }
      }
    }
    if (row_count && before_row <= area.end.row) {
      if (row_count > 0) {
        if (before_row <= area.start.row) {
          area.Shift(row_count, 0);
        } else if (before_row > area.start.row && before_row <= area.end.row) {
          area.ConsumeAddress({ row: area.end.row + row_count, column: area.end.column });
        } else {
          console.warn(`AA X case 3`, before_row, row_count, JSON.stringify(area));
        }
      } else if (row_count < 0) {
        if (before_row - row_count <= area.start.row) {
          area.Shift(row_count, 0);
        } else if (before_row <= area.start.row && before_row - row_count > area.end.row) {
          return false;
        } else if (before_row <= area.start.row) {
          const last_row = before_row - row_count - 1;
          area = new _Area({
            column: area.start.column,
            row: last_row + 1 + row_count,
            sheet_id
          }, {
            column: area.end.column,
            row: area.end.row + row_count
          });
        } else if (before_row <= area.end.row) {
          const last_row = before_row - row_count - 1;
          if (last_row >= area.end.row) {
            area = new _Area({
              column: area.start.column,
              row: area.start.row,
              sheet_id
            }, {
              column: area.end.column,
              row: before_row - 1
            });
          } else {
            area = new _Area({
              column: area.start.column,
              row: area.start.row,
              sheet_id
            }, {
              column: area.end.column,
              row: area.start.row + area.rows + row_count - 1
            });
          }
        } else {
          console.warn(`AA X case 4`, before_row, row_count, JSON.stringify(area));
        }
      }
    }
    return area;
  }
  /** accessor returns a _copy_ of the start address */
  get start() {
    return { ...this.start_ };
  }
  /** accessor */
  set start(value) {
    this.start_ = value;
  }
  /** accessor returns a _copy_ of the end address */
  get end() {
    return { ...this.end_ };
  }
  /** accessor */
  set end(value) {
    this.end_ = value;
  }
  /** returns number of rows, possibly infinity */
  get rows() {
    if (this.start_.row === Infinity || this.end_.row === Infinity)
      return Infinity;
    return this.end_.row - this.start_.row + 1;
  }
  /** returns number of columns, possibly infinity */
  get columns() {
    if (this.start_.column === Infinity || this.end_.column === Infinity)
      return Infinity;
    return this.end_.column - this.start_.column + 1;
  }
  /** returns number of cells, possibly infinity */
  get count() {
    return this.rows * this.columns;
  }
  /** returns flag indicating this is the entire sheet, usually after "select all" */
  get entire_sheet() {
    return this.entire_row && this.entire_column;
  }
  /** returns flag indicating this range includes infinite rows */
  get entire_column() {
    return this.start_.row === Infinity;
  }
  /** returns flag indicating this range includes infinite columns */
  get entire_row() {
    return this.start_.column === Infinity;
  }
  PatchNull(address) {
    const copy = { ...address };
    if (copy.row === null) {
      copy.row = Infinity;
    }
    if (copy.column === null) {
      copy.column = Infinity;
    }
    return copy;
  }
  SetSheetID(id) {
    this.start_.sheet_id = id;
  }
  Normalize() {
    const start = { ...this.start_ };
    const end = { ...this.end_ };
    if (start.row === Infinity || end.row === Infinity) {
      start.row = end.row = Infinity;
    } else if (start.row > end.row) {
      start.row = this.end_.row;
      start.absolute_row = this.end_.absolute_row;
      end.row = this.start_.row;
      end.absolute_row = this.start_.absolute_row;
    }
    if (start.column === Infinity || end.column === Infinity) {
      start.column = end.column = Infinity;
    } else if (start.column > end.column) {
      start.column = this.end_.column;
      start.absolute_column = this.end_.absolute_column;
      end.column = this.start_.column;
      end.absolute_column = this.start_.absolute_column;
    }
    this.start_ = start;
    this.end_ = end;
  }
  /** returns the top-left cell in the area */
  TopLeft() {
    const address = { row: 0, column: 0 };
    if (!this.entire_row)
      address.column = this.start.column;
    if (!this.entire_column)
      address.row = this.start.row;
    return address;
  }
  /** returns the bottom-right cell in the area */
  BottomRight() {
    const address = { row: 0, column: 0 };
    if (!this.entire_row)
      address.column = this.end.column;
    if (!this.entire_column)
      address.row = this.end.row;
    return address;
  }
  ContainsRow(row) {
    return this.entire_column || row >= this.start_.row && row <= this.end_.row;
  }
  ContainsColumn(column) {
    return this.entire_row || column >= this.start_.column && column <= this.end_.column;
  }
  Contains(address) {
    return (this.entire_column || address.row >= this.start_.row && address.row <= this.end_.row) && (this.entire_row || address.column >= this.start_.column && address.column <= this.end_.column);
  }
  /**
   * returns true if this area completely contains the argument area
   * (also if areas are ===, as a side effect). note that this returns
   * true if A contains B, but not vice-versa
   */
  ContainsArea(area) {
    return this.start.column <= area.start.column && this.end.column >= area.end.column && this.start.row <= area.start.row && this.end.row >= area.end.row;
  }
  /**
   * returns true if there's an intersection. note that this won't work
   * if there are infinities -- needs real area ?
   */
  Intersects(area) {
    return !(area.start.column > this.end.column || this.start.column > area.end.column || area.start.row > this.end.row || this.start.row > area.end.row);
  }
  Equals(area) {
    return area.start_.row === this.start_.row && area.start_.column === this.start_.column && area.end_.row === this.end_.row && area.end_.column === this.end_.column;
  }
  Clone() {
    return new _Area(this.start, this.end);
  }
  Array() {
    if (this.entire_column || this.entire_row)
      throw new Error("can't convert infinite area to array");
    const array = new Array(this.rows * this.columns);
    const sheet_id = this.start_.sheet_id;
    let index = 0;
    for (let row = this.start_.row; row <= this.end_.row; row++) {
      for (let column = this.start_.column; column <= this.end_.column; column++) {
        array[index++] = { row, column, sheet_id };
      }
    }
    return array;
  }
  get left() {
    const area = new _Area(this.start_, this.end_);
    area.end_.column = area.start_.column;
    return area;
  }
  get right() {
    const area = new _Area(this.start_, this.end_);
    area.start_.column = area.end_.column;
    return area;
  }
  get top() {
    const area = new _Area(this.start_, this.end_);
    area.end_.row = area.start_.row;
    return area;
  }
  get bottom() {
    const area = new _Area(this.start_, this.end_);
    area.start_.row = area.end_.row;
    return area;
  }
  /** shifts range in place */
  Shift(rows, columns) {
    this.start_.row += rows;
    this.start_.column += columns;
    this.end_.row += rows;
    this.end_.column += columns;
    return this;
  }
  /** Resizes range in place so that it includes the given address */
  ConsumeAddress(addr) {
    if (!this.entire_row) {
      if (addr.column < this.start_.column)
        this.start_.column = addr.column;
      if (addr.column > this.end_.column)
        this.end_.column = addr.column;
    }
    if (!this.entire_column) {
      if (addr.row < this.start_.row)
        this.start_.row = addr.row;
      if (addr.row > this.end_.row)
        this.end_.row = addr.row;
    }
  }
  /** Resizes range in place so that it includes the given area (merge) */
  ConsumeArea(area) {
    this.ConsumeAddress(area.start);
    this.ConsumeAddress(area.end);
  }
  /** resizes range in place (updates end) */
  Resize(rows, columns) {
    this.end_.row = this.start_.row + rows - 1;
    this.end_.column = this.start_.column + columns - 1;
    return this;
  }
  Iterate(f) {
    if (this.entire_column || this.entire_row) {
      console.warn(`don't iterate infinite area`);
      return;
    }
    for (let c = this.start_.column; c <= this.end_.column; c++) {
      for (let r = this.start_.row; r <= this.end_.row; r++) {
        f({ column: c, row: r, sheet_id: this.start_.sheet_id });
      }
    }
  }
  /* *
     * testing: we may have to polyfill for IE11, or just not use it at
     * all, depending on support level... but it works OK (kind of a clumsy
     * implementation though).
     *
     * as it turns out we don't really use iteration that much (I thought
     * we did) so it's probably not worth the polyfill...
     *
     * /
    public next(): IteratorResult<ICellAddress> {
  
      // sanity
  
      if (this.entire_column || this.entire_row) {
        console.warn('don\'t iterate over infinte range');
        return { value: undefined, done: true };
      }
  
      // return current, unless it's OOB; if so, advance
  
      if (this.iterator_index.column > this.end.column) {
        this.iterator_index.column = this.start_.column;
        this.iterator_index.row++;
  
        if (this.iterator_index.row > this.end.row) {
          this.ResetIterator();
          return { value: undefined, done: true };
        }
  
      }
  
      const result = { value: { ...this.iterator_index }, done: false };
      this.iterator_index.column++;
  
      return result;
    }
  
    public [Symbol.iterator](): IterableIterator <ICellAddress> {
      return this;
    }
    */
  /**
   * returns the range in A1-style spreadsheet addressing. if the
   * entire sheet is selected, returns nothing (there's no way to
   * express that in A1 notation). returns the row numbers for entire
   * columns and vice-versa for rows.
   */
  get spreadsheet_label() {
    let s;
    if (this.entire_sheet)
      return "";
    if (this.entire_column) {
      s = _Area.ColumnToLabel(this.start_.column);
      s += ":" + _Area.ColumnToLabel(this.end_.column);
      return s;
    }
    if (this.entire_row) {
      s = String(this.start_.row + 1);
      s += ":" + (this.end_.row + 1);
      return s;
    }
    s = _Area.CellAddressToLabel(this.start_);
    if (this.columns > 1 || this.rows > 1)
      return s + ":" + _Area.CellAddressToLabel(this.end_);
    return s;
  }
  /**
   * FIXME: is this different than what would be returned if
   * we just used the default json serializer? (...)
   * 
   * NOTE: we could return just the start if size === 1. if
   * you pass an undefined to the Area class ctor it will reuse
   * the start.
   * 
   */
  toJSON() {
    return {
      start: { ...this.start_ },
      end: { ...this.end_ }
    };
  }
  /*
  private ResetIterator() {
    this.iterator_index = {
      row: this.start_.row,
      column: this.start_.column,
      sheet_id: this.start_.sheet_id,
    };
  }
  */
};

// treb-base-types/src/value-type.ts
var IsComplex = (value) => {
  return typeof value === "object" && !!value && typeof value.real === "number" && typeof value.imaginary === "number";
};
var ComplexToString = (value) => {
  if (value.real) {
    if (value.imaginary) {
      if (value.imaginary > 0) {
        return `${value.real} + ${value.imaginary}i`;
      } else {
        return `${value.real} - ${Math.abs(value.imaginary)}i`;
      }
    } else {
      return value.real.toString();
    }
  } else if (value.imaginary) {
    return value.imaginary + "i";
  } else {
    return "0";
  }
};
var IsDimensionedQuantity = (value) => {
  return typeof value === "object" && !!value && typeof value.value === "number" && typeof value.unit === "string";
};
var ValueTypeList = [
  "undefined",
  "formula",
  "string",
  "number",
  "boolean",
  "object",
  "error",
  "complex",
  "array",
  "dimensioned_quantity"
];
var GetValueType = (value) => {
  switch (typeof value) {
    case "undefined":
      return 0 /* undefined */;
    case "number":
      return 3 /* number */;
    case "boolean":
      return 4 /* boolean */;
    case "object":
      if (value === null) {
        return 0 /* undefined */;
      } else if (IsComplex(value)) {
        return 7 /* complex */;
      } else if (IsDimensionedQuantity(value)) {
        return 9 /* dimensioned_quantity */;
      }
      return 5 /* object */;
    case "string":
      if (value[0] === "=") {
        return 1 /* formula */;
      }
      return 2 /* string */;
    default:
      return 6 /* error */;
  }
};

// treb-base-types/src/cell.ts
var Cell = class {
  // --- static methods -------------------------------------------------------
  static StringToColumn(s) {
    let index = 0;
    s = s.toUpperCase();
    for (let i = 0; i < s.length; i++) {
      index *= 26;
      index += s.charCodeAt(i) - 64;
    }
    return index - 1;
  }
  /*
    public static FormulaDependencies(formula: string): Area[] {
  
      const dependencies = [];
  
      if (!formula) return []; // also matches ""
      if (formula.trim()[0] !== '=') return [];
  
      const results = parser.Parse(formula);
  
      for (const key of Object.keys(results.dependencies.addresses)){
        const address = results.dependencies.addresses[key];
        dependencies.push(new Area(address));
      }
  
      for (const key of Object.keys(results.dependencies.ranges)){
        const range = results.dependencies.ranges[key];
        dependencies.push(new Area(range.start, range.end, true));
      }
  
      // dedupe (...)
  
      return dependencies;
  
    }
    */
  /*
    public static GetValueType(value: unknown): ValueType {
  
      switch (typeof value){
        
        case 'undefined':
          return ValueType.undefined;
  
        case 'number':
          return ValueType.number;
  
        case 'boolean':
          return ValueType.boolean;
  
        case 'object':
          if (value === null) {
            return ValueType.undefined;
          }
          return ValueType.object;
  
        case 'string':
          if (value[0] === '=') {
            return ValueType.formula;
          }
          return ValueType.string;
  
        default: // function or symbol
          return ValueType.error;
  
      }
    }
    */
  // --- class fields ---------------------------------------------------------
  // the basic value, which can be omitted (in the case of an array cell)
  value;
  // any;
  // the value type, js intrinics plus a special type for formula
  type = 0 /* undefined */;
  // the calculated value, returned from calculation service
  calculated;
  // |FunctionError; // any;
  // the calculated type. we're separating calculation from rendering, since
  // we may calculate values that we don't need to render.
  calculated_type;
  // the value formatted as a string, for display. this is separate from the
  // calculated value, because the renderer might still need to check the
  // value in the case of negative color or value-based styling.
  formatted;
  /**
   * rendered type may be different than value type: could be a function
   * returns a number, or an error. rendering an empty value should result
   * in a string, so you can test on this type -- it should never be 0
   * (or undefined) if the cell has been rendered.
   * 
   * NOTE: no one really uses this. it's only read in two places -- one in
   * grid to check if it's a number and we want to format as % (which seems 
   * wrong anyway, because what if it's a function?) -- and in sheet, as a 
   * flag indicating we have already rendered it (it gets flushed on change).
   * 
   * so we could maybe remove it or switch to a boolean or something... is 
   * boolean any smaller than number?
   */
  rendered_type;
  // style is an index into the style dictionary, not the actual style
  // data (FIXME: if style is an object, this would just be a pointer, so
  // why not just use a reference?)
  // style:number = 0;
  style;
  /** if this cell is part of an array, pointer to the area. */
  area;
  /**
   * if this cell is merged, pointer to the area
   */
  merge_area;
  /** this cell is part of a table */
  table;
  /**
   * opaque data for cell rendering, we can cache some data
   * that's reused frequently (is that wasting space?)
   *
   * render data will be flushed any time there is any change to
   * the cell data or style.
   *
   * UPDATE: renderer data is no longer flushed. we set a dirty flag.
   */
  renderer_data;
  /**
   * step 1: invert flag (dirty -> clean)
   */
  render_clean = [];
  note;
  /**
   * moving hyperlink in here, as a cell property. hyperlink will not be
   * removed on value change, but will be removed on clear/delete.
   */
  hyperlink;
  /* flag indicates do not paint */
  editing;
  /** 
   * TODO: add a return value which affects control flow. default/falsy should
   * behave as now, for backwards compatibility; but it should be possible to
   * return a value that says "don't exit the standard rendering process"
   * 
   * UPDATE: return value now means "I have handled this", so if you paint you
   * should return true. that's a breaking change but we should get help from
   * tooling.
   */
  render_function;
  // (options: RenderFunctionOptions) => RenderFunctionResult;
  click_function;
  // (options: ClickFunctionOptions) => ClickFunctionResult;
  /** 
   * moving locked property to style. not because it's properly a style,
   * or not properly a property of cell, but rather because that will allow
   * us to cascade the property over areas.
   */
  /** not editable */
  // public locked?: boolean;
  validation;
  // --- class methods --------------------------------------------------------
  constructor(value, value_type) {
    if (typeof value !== "undefined")
      this.Set(value, value_type);
  }
  /** type guard */
  ValueIsNumber() {
    return this.type === 3 /* number */;
  }
  /** type guard */
  ValueIsFormula() {
    return this.type === 1 /* formula */;
  }
  /** type guard */
  ValueIsBoolean() {
    return this.type === 4 /* boolean */;
  }
  /** type guard */
  ValueIsComplex() {
    return this.type === 7 /* complex */;
  }
  ///
  /** flush style information and things that rely on it (formatted value) */
  FlushStyle() {
    this.formatted = this.rendered_type = this.style = void 0;
    this.render_clean = [];
  }
  /** flush array information */
  FlushArray() {
    this.area = void 0;
  }
  /** flush cached data: formatted and calculated */
  FlushCache() {
    this.calculated = this.calculated_type = this.formatted = this.rendered_type = this.render_function = this.click_function = void 0;
    this.render_clean = [];
  }
  Reset() {
    this.type = 0 /* undefined */;
    this.value = this.note = this.hyperlink = this.formatted = this.rendered_type = this.style = this.calculated = this.calculated_type = this.area = this.renderer_data = this.render_function = this.click_function = void 0;
    this.render_clean = [];
  }
  Set(value, type = GetValueType(value)) {
    this.value = value;
    this.type = type;
    this.formatted = this.rendered_type = this.style = this.calculated = this.calculated_type = this.render_function = this.click_function = this.area = void 0;
    this.render_clean = [];
  }
  /** 
   * sets calculated value and flushes cached value 
   */
  SetCalculatedValue(value, type = GetValueType(value)) {
    if (value === void 0) {
      value = 0;
      type = 3 /* number */;
    }
    if (this.calculated === value) {
      return;
    }
    this.calculated = value;
    this.calculated_type = type;
    this.formatted = this.rendered_type = void 0;
    this.render_clean = [];
  }
  /* *
     * composite method for setting value or error, based on value
     * not used? (...)
     * /
    public SetCalculatedValueOrError(value: any, type?: ValueType): void {
  
      console.info("SCVE", value, type);
  
      if (typeof type === 'undefined') {
        if (typeof value === 'object' && value.error) {
          type = ValueType.error;
          value = value.error;
        }
        else {
          type = GetValueType(value);
        }
      }
      if (this.calculated === value) return;
      this.calculated = value;
      this.calculated_type = type;
      this.formatted = this.rendered_type = undefined;
      this.render_clean = [];
    }
    */
  /**
   * get value -- calculation result (not formatted) or literal. for
   * literal strings, we strip leading apostrophes (these are used to
   * prevent parsing of literal strings that look like other things).
   */
  GetValue() {
    if (this.calculated_type)
      return this.calculated;
    if (typeof this.value === "string" && this.value[0] === "'") {
      return this.value.slice(1);
    }
    return this.value;
  }
  /* *
     * new version of GetValue that preserves errors. for non-errors this
     * behaves identically to the original GetValue. for errors, returns
     * an error object {error: string};
     * /
    public GetValue2(): CellValue | {error: CellValue} {
      if (this.calculated_type) {
        return (this.calculated_type === ValueType.error) ?
          { error: this.calculated } : this.calculated;
      }
      // if (this.type === ValueType.string &&
      //    this.value && this.value[0] === '\'') return this.value.slice(1);
      if (typeof this.value === 'string' && this.value[0] === '\'') { return this.value.slice(1); } // @see GetValue
  
      return this.value;
    }
    */
  /* *
     * we have an issue where a reference to an empty cell winds up returning
     * a string, goes into a numerical calculation, and slows everything down.
     *
     * this is kind of a corner case. it's not that there's a reference to an
     * empty cell -- that works OK. there's a reference to a cell, which is
     * itself a reference to an empty cell. that's why it's a function, which
     * is being returned as a string.
     *
     * in this case because it's the function value, I think returning 0 is ok.
     * BUT, it still might make sense to return undefined.
     * /
    public GetValue3(): CellValue|{error: string} { // |FunctionError {
  
      // so... what is this? shouldn't this be an object? (...)
     
      if (this.calculated_type) {
        return (this.calculated_type === ValueType.error) ?
          { error: this.calculated as string } : this.calculated;
      }
  
      if (this.type === ValueType.formula) {
        // formula, but no calc type... undefined or zero? (...)
        return 0; // undefined;
      }
      // if (this.type === ValueType.string &&
      //    this.value && this.value[0] === '\'') return this.value.slice(1);
      if (typeof this.value === 'string' && this.value[0] === '\'') { return this.value.slice(1); } // @see GetValue
  
      return this.value;
    }
    */
  /**
   * this function follows the rule of GetValue3, which is: if the type
   * is a function but there is no calculated value, then return 0.
   */
  GetValue4() {
    if (this.calculated_type) {
      return {
        type: this.calculated_type,
        value: this.calculated
      };
    }
    if (this.type === 1 /* formula */) {
      return {
        type: 3 /* number */,
        value: 0
      };
    }
    return {
      type: this.type,
      value: typeof this.value === "string" && this.value[0] === "'" ? this.value.slice(1) : this.value
      // @see GetValue 
    };
  }
  /**
   * set note. set undefined to clear.
   */
  SetNote(note) {
    this.note = note;
    this.render_clean = [];
  }
  /** sets error (FIXME: error type) */
  SetCalculationError(err = "ERR") {
    this.SetCalculatedValue(err, 6 /* error */);
  }
  SetArray(area) {
    this.type = 0 /* undefined */;
    this.value = this.formatted = this.rendered_type = this.style = this.hyperlink = // note?
    this.calculated = this.calculated_type = void 0;
    this.area = area;
    this.render_clean = [];
  }
  SetArrayHead(area, value) {
    this.type = GetValueType(value);
    this.value = value;
    this.formatted = this.rendered_type = this.style = this.calculated = this.calculated_type = void 0;
    this.area = area;
    this.render_clean = [];
  }
};

// treb-base-types/src/cells.ts
var IsFlatData = (test) => {
  return !test.cells;
};
var IsFlatDataArray = (test) => {
  return !!test[0] && IsFlatData(test[0]);
};
var IsNestedRowArray = (test) => {
  return !!test[0] && test[0].row !== void 0;
};
var ValueTypeMap = ValueTypeList.map((key, index) => ({ [key]: index })).reduce((set, value) => ({ ...set, ...value }), {});
var Cells = class {
  /** switching to row-major */
  data = [];
  // tslint:disable-next-line:variable-name
  rows_ = 0;
  // tslint:disable-next-line:variable-name
  columns_ = 0;
  get rows() {
    return this.rows_;
  }
  get columns() {
    return this.columns_;
  }
  /**
   * the sheet wants to make sure this row exists, probably because it has
   * a header. so we will update our dimensions to match. we don't actually
   * add data.
   *
   * this is not serialized. specific headers aren't serialized either, at
   * the moment, so it's sort of irrelevant. if we start serializing headers,
   * the deserialization routine can call this function to pad out, so we
   * don't need to store it here.
   */
  EnsureRow(row) {
    this.rows_ = Math.max(row + 1, this.rows_);
  }
  /** @see EnsureRow */
  EnsureColumn(column) {
    this.columns_ = Math.max(column + 1, this.columns_);
  }
  /**
   * this class does none of the validation/correction
   * required when inserting rows/columns. that should
   * be done by external logic. this method only does
   * the mechanical work of inserting rows/columns.
   */
  InsertColumns(before = 0, count = 1) {
    const pre = JSON.parse(JSON.stringify(this.data[13]));
    this.data = this.data.map((row) => {
      if (row.length >= before) {
        const tmp = row.slice(0, before);
        let index = before + count;
        const after = row.slice(before);
        for (let i = 0; i < after.length; i++) {
          tmp[index++] = after[i];
        }
        return tmp;
      }
      return row;
    });
    this.columns_ += count;
  }
  DeleteColumns(index, count = 1) {
    this.data.forEach((row) => row.splice(index, count));
    this.columns_ -= count;
  }
  DeleteRows(index, count = 1) {
    this.data.splice(index, count);
    this.rows_ -= count;
  }
  /**
   * this class does none of the validation/correction
   * required when inserting rows/columns. that should
   * be done by external logic. this method only does
   * the mechanical work of inserting rows/columns.
   */
  InsertRows(before = 0, count = 1) {
    const args = [before, 0, []];
    for (let i = 1; i < count; i++)
      args.push([]);
    Array.prototype.splice.apply(this.data, args);
    this.rows_ += count;
  }
  /**
   * return the given cell or `undefined`, optionally creating
   * new cells as necessary
   *
   * @param create_new always return a cell
   */
  GetCell(address, create_new) {
    const { row, column } = address;
    if (!this.data[row]) {
      if (create_new) {
        this.data[row] = [];
        this.rows_ = Math.max(this.rows_, row + 1);
      } else
        return void 0;
    }
    if (!this.data[row][column]) {
      if (create_new) {
        this.data[row][column] = new Cell();
        this.columns_ = Math.max(this.columns_, column + 1);
      }
    }
    return this.data[row][column];
  }
  /**
     * apply function to range or address. skips empty cells (for now...)
     * (already have this function, it's called "IterateArea". "Apply" is better.)
     * /
    public Apply(target: ICellAddress|IArea, func: (cell: Cell) => void): void {
  
      if (IsCellAddress(target)) {
        target = new Area(target);
      }
  
      const start = target.start;
      const end = target.end;
  
      for (let r = start.row; r <= end.row; r++) {
        if (this.data[r]) {
          const row = this.data[r];
          for (let c = start.column; c < end.column; c++) {
            if (this.data[r][c]) {
              func.call(undefined, row[c]);
            }
          }
        }
      }
  
    }
    */
  /** returns an existing cell or creates a new cell. */
  EnsureCell(address) {
    const { row, column } = address;
    let ref = this.data[row];
    if (!ref) {
      this.data[row] = ref = [];
      this.rows_ = Math.max(this.rows_, row + 1);
    }
    let cell = ref[column];
    if (!cell) {
      cell = ref[column] = new Cell();
      this.columns_ = Math.max(this.columns_, column + 1);
    }
    return cell;
  }
  /**
   * with the update, we assume the passed-in data is row-major.
   * when reading an older file, transpose.
   */
  FromArray(data = [], transpose = false) {
    this.data = [];
    let rows = 0;
    let columns = 0;
    if (transpose) {
      columns = data.length;
      for (let c = 0; c < columns; c++) {
        const ref = data[c];
        rows = Math.max(rows, ref.length);
        for (let r = 0; r < ref.length; r++) {
          if (!this.data[r])
            this.data[r] = [];
          this.data[r][c] = new Cell(ref[r]);
        }
      }
    } else {
      rows = data.length;
      for (let r = 0; r < rows; r++) {
        const column = [];
        const ref = data[r];
        columns = Math.max(columns, ref.length);
        for (let c = 0; c < ref.length; c++)
          column[c] = new Cell(ref[c]);
        this.data[r] = column;
      }
    }
    this.rows_ = rows;
    this.columns_ = columns;
  }
  SerializedTypeToValueType(type) {
    if (!type) {
      return void 0;
    }
    if (typeof type === "number") {
      return type;
    }
    return ValueTypeMap[type] || void 0;
  }
  ValueTypeToSerializedType(type) {
    return type ? ValueTypeList[type] : void 0;
  }
  /**
   * this method is used for importing legacy data validation types. in those
   * those we used a numeric enum. we're just dropping that altogether (c.f.
   * ValueType, which we're keeping) so we need to translate for backcompat. 
   * it's ugly, but it gets us to a better place. we can probably drop at some
   * point in the future.
   * 
   * export enum ValidationType {
   *   List = 'list',
   *   Date = 'date',
   *   Range = 'range',
   *   Number = 'number',
   *   Boolean = 'boolean',
   * }
   * 
   */
  ImportDataValidation(value) {
    if (typeof value.type === "number") {
      const types = ["list", "date", "range", "number", "boolean"];
      value.type = types[value.type];
      if (!value.type) {
        return void 0;
      }
    }
    return value;
  }
  /**
   * UPDATE: adding optional style refs, for export
   */
  FromJSON(data = [], style_refs) {
    this.data = [];
    if (!IsFlatDataArray(data)) {
      const new_data = [];
      if (IsNestedRowArray(data)) {
        for (const block of data) {
          for (const cell of block.cells) {
            new_data.push({ ...cell, row: block.row });
          }
        }
      } else {
        for (const block of data) {
          for (const cell of block.cells) {
            new_data.push({ ...cell, column: block.column });
          }
        }
      }
      data = new_data;
    }
    const tables = [];
    for (const obj of data) {
      if (!this.data[obj.row])
        this.data[obj.row] = [];
      const cell = new Cell(obj.value);
      if (typeof obj.calculated !== "undefined") {
        cell.SetCalculatedValue(obj.calculated, this.SerializedTypeToValueType(obj.calculated_type));
      }
      if (style_refs) {
        if (typeof obj.style_ref !== "undefined") {
          cell.style = style_refs[obj.style_ref];
        }
      }
      if (typeof obj.note !== "undefined") {
        cell.note = obj.note;
      }
      if (typeof obj.hyperlink !== "undefined") {
        cell.hyperlink = obj.hyperlink;
      }
      if (this.data[obj.row][obj.column] && this.data[obj.row][obj.column].area) {
        cell.area = this.data[obj.row][obj.column].area;
      }
      this.data[obj.row][obj.column] = cell;
      if (obj.area) {
        const area = new Area(obj.area.start, obj.area.end);
        for (let row = area.start.row; row <= area.end.row; row++) {
          for (let column = area.start.column; column <= area.end.column; column++) {
            if (!this.data[row])
              this.data[row] = [];
            if (!this.data[row][column])
              this.data[row][column] = new Cell();
            this.data[row][column].area = area;
          }
        }
      }
      if (obj.table) {
        tables.push({
          ...obj.table
        });
      }
      if (obj.merge_area) {
        const merge_area = new Area(obj.merge_area.start, obj.merge_area.end);
        for (let row = merge_area.start.row; row <= merge_area.end.row; row++) {
          for (let column = merge_area.start.column; column <= merge_area.end.column; column++) {
            if (!this.data[row])
              this.data[row] = [];
            if (!this.data[row][column])
              this.data[row][column] = new Cell();
            this.data[row][column].merge_area = merge_area;
          }
        }
      }
      if (obj.validation) {
        cell.validation = this.ImportDataValidation(obj.validation);
      }
    }
    for (const table of tables) {
      for (let row = table.area.start.row; row <= table.area.end.row; row++) {
        for (let column = table.area.start.column; column <= table.area.end.column; column++) {
          if (!this.data[row])
            this.data[row] = [];
          if (!this.data[row][column])
            this.data[row][column] = new Cell();
          this.data[row][column].table = table;
        }
      }
    }
    this.rows_ = this.data.length;
    this.columns_ = this.data.reduce((max, row) => Math.max(max, row.length), 0);
  }
  toJSON(options = {}) {
    let start_column = 0;
    let start_row = 0;
    let end_row = this.data.length - 1;
    let end_column;
    if (options.subset) {
      start_column = options.subset.start.column;
      start_row = options.subset.start.row;
      end_row = options.subset.end.row;
    }
    const data = [];
    let last_row = -1;
    let last_col = -1;
    const row_keys = {};
    const column_keys = {};
    for (let row = start_row; row <= end_row; row++) {
      if (this.data[row]) {
        const ref = this.data[row];
        end_column = ref.length - 1;
        if (options.subset)
          end_column = options.subset.end.column;
        for (let column = start_column; column <= end_column; column++) {
          const cell = ref[column];
          const merge_head = cell && cell.merge_area && cell.merge_area.start.row === row && cell.merge_area.start.column === column;
          const array_head = cell && cell.area && cell.area.start.row === row && cell.area.start.column === column;
          const table_head = cell && cell.table && cell.table.area.start.row === row && cell.table.area.start.column === column;
          const is_empty = cell ? cell.type === 2 /* string */ && !cell.value : true;
          if (cell && (!is_empty || options.preserve_empty_strings) && (merge_head || cell.type || cell.calculated_type && options.expand_arrays || cell.calculated_type && options.calculated_value || cell.note || cell.validation || options.decorated_cells && cell.style && (cell.style.fill || cell.style.border_bottom || cell.style.border_top || cell.style.border_left || cell.style.border_right))) {
            const obj = { row, column, value: cell.value };
            if (cell.note) {
              obj.note = cell.note;
            }
            if (cell.hyperlink) {
              obj.hyperlink = cell.hyperlink;
            }
            if (options.preserve_type) {
              obj.type = this.ValueTypeToSerializedType(cell.type);
            }
            if (options.sheet_id)
              obj.sheet_id = options.sheet_id;
            if (options.calculated_value && typeof cell.calculated !== "undefined") {
              obj.calculated = cell.calculated;
              if (options.preserve_type || cell.calculated_type === 6 /* error */) {
                obj.calculated_type = this.ValueTypeToSerializedType(cell.calculated_type);
              }
            }
            if (cell.table && table_head) {
              if (options.tables) {
                obj.table = JSON.parse(JSON.stringify(cell.table));
              }
            }
            if (cell.area && array_head) {
              obj.area = cell.area.toJSON();
            }
            if (cell.merge_area) {
              obj.merge_area = cell.merge_area.toJSON();
            }
            if (cell.validation) {
              obj.validation = cell.validation;
            }
            if (options.cell_style_refs && options.cell_style_refs[column] && options.cell_style_refs[column][row]) {
              obj.style_ref = options.cell_style_refs[column][row];
              options.cell_style_refs[column][row] = 0;
            }
            row_keys[row] = row;
            column_keys[column] = column;
            last_row = Math.max(row, last_row);
            last_col = Math.max(column, last_col);
            data.push(obj);
          }
        }
      }
    }
    if (options.nested) {
      const row_key_map = Object.keys(row_keys);
      const col_key_map = Object.keys(column_keys);
      if (row_key_map.length <= col_key_map.length && row_key_map.length) {
        const cells = {};
        const new_data = [];
        for (const element of data) {
          const { row, ...remainder } = element;
          if (!cells[element.row])
            cells[element.row] = [];
          cells[element.row].push(remainder);
        }
        for (const key of row_key_map) {
          const row = Number(key);
          new_data.push({ row, cells: cells[row] });
        }
        return { data: new_data, rows: last_row, columns: last_col + 1 };
      } else if (col_key_map.length) {
        const cells = {};
        const new_data = [];
        for (const element of data) {
          const { column, ...remainder } = element;
          if (!cells[element.column])
            cells[element.column] = [];
          cells[element.column].push(remainder);
        }
        for (const key of col_key_map) {
          const column = Number(key);
          new_data.push({ column, cells: cells[column] });
        }
        return { data: new_data, rows: last_row, columns: last_col + 1 };
      }
    }
    return { data, rows: last_row + 1, columns: last_col + 1 };
  }
  GetAll(transpose = false) {
    return this.GetRange({ row: 0, column: 0 }, { row: this.rows_ - 1, column: this.columns_ - 1 }, transpose);
  }
  /** simply cannot make this work with overloads (prove me wrong) */
  Normalize2(from, to) {
    if (from.column === Infinity) {
      from = { ...from, column: 0 };
    }
    if (from.row === Infinity) {
      from = { ...from, row: 0 };
    }
    if (to.column === Infinity) {
      to = { ...to, column: this.columns_ - 1 };
    }
    if (to.row === Infinity) {
      to = { ...to, row: this.rows_ - 1 };
    }
    return { from, to };
  }
  /** simply cannot make this work with overloads (prove me wrong) */
  Normalize1(from) {
    if (from.column === Infinity) {
      from = { ...from, column: 0 };
    }
    if (from.row === Infinity) {
      from = { ...from, row: 0 };
    }
    return from;
  }
  /**
   * get raw values (i.e. not calculated). anything outside of actual
   * range will be undefined OR not populated. 
   *
   * to match GetRange, we return a single value in the case of a single cell,
   * or a matrix.
   *
   * NOTE that I'm not sure this is good behavior. if you're going to
   * return a single value for one cell, you should return a vector for
   * a single row OR a single column. alternatively, you should always
   * return a matrix.
   * 
   * @param from
   * @param to
   * @param transpose
   */
  RawValue(from, to = from) {
    ({ from, to } = this.Normalize2(from, to));
    if (from.row === to.row && from.column === to.column) {
      if (this.data[from.row] && this.data[from.row][from.column]) {
        return this.data[from.row][from.column].value;
      }
      return void 0;
    }
    const result = [];
    const rows = this.data.slice(from.row, to.row + 1);
    const start = from.column;
    const end = to.column + 1;
    for (const source of rows) {
      const target = [];
      for (let column = start, index = 0; column < end; column++, index++) {
        const cell = source[column];
        target.push(cell ? cell.value : void 0);
      }
      result.push(target);
    }
    return result;
  }
  /** gets range as values */
  GetRange(from, to, transpose = false) {
    if (to) {
      ({ from, to } = this.Normalize2(from, to));
    } else {
      from = this.Normalize1(from);
    }
    if (!to || from === to || from.column === to.column && from.row === to.row) {
      if (this.data[from.row] && this.data[from.row][from.column]) {
        return this.data[from.row][from.column].GetValue();
      }
      return void 0;
    }
    const value = [];
    if (transpose) {
      for (let c = from.column; c <= to.column; c++) {
        const column = [];
        for (let r = from.row; r <= to.row; r++) {
          if (this.data[r] && this.data[r][c])
            column.push(this.data[r][c].GetValue());
          else
            column.push(void 0);
        }
        value.push(column);
      }
    } else {
      for (let r = from.row; r <= to.row; r++) {
        const row = [];
        for (let c = from.column; c <= to.column; c++) {
          if (this.data[r] && this.data[r][c])
            row.push(this.data[r][c].GetValue());
          else
            row.push(void 0);
        }
        value.push(row);
      }
    }
    return value;
  }
  /* *
     * updated version of GetRange that preserves errors, by calling
     * the GetValue2 cell function.
     * /
    public GetRange2(from: ICellAddress, to?: ICellAddress, transpose = false) {
  
      if (!to || from === to || (from.column === to.column && from.row === to.row )){
        if (this.data[from.row] && this.data[from.row][from.column]){
          return this.data[from.row][from.column].GetValue2();
        }
        return undefined;
      }
  
      const value = [];
  
      if (transpose){
        for ( let c = from.column; c <= to.column; c++ ){
          const column = [];
          for ( let r = from.row; r <= to.row; r++ ){
            if (this.data[r] && this.data[r][c]) column.push(this.data[r][c].GetValue2());
            else column.push(undefined);
          }
          value.push(column);
        }
      }
      else {
        for ( let r = from.row; r <= to.row; r++ ){
          const row = [];
          for ( let c = from.column; c <= to.column; c++ ){
            if (this.data[r] && this.data[r][c]) row.push(this.data[r][c].GetValue2());
            else row.push(undefined);
          }
          value.push(row);
        }
      }
  
      return value;
  
    }
    */
  GetRange4(from, to = from, transpose = false) {
    ({ from, to } = this.Normalize2(from, to));
    if (from.row === to.row && from.column === to.column) {
      if (this.data[from.row] && this.data[from.row][from.column]) {
        return this.data[from.row][from.column].GetValue4();
      }
      return { value: void 0, type: 0 /* undefined */ };
    }
    const value = [];
    if (transpose) {
      for (let c = from.column; c <= to.column; c++) {
        const column = [];
        for (let r = from.row; r <= to.row; r++) {
          if (this.data[r] && this.data[r][c])
            column.push(this.data[r][c].GetValue4());
          else
            column.push({ type: 0 /* undefined */ });
        }
        value.push(column);
      }
    } else {
      for (let r = from.row; r <= to.row; r++) {
        const row = [];
        for (let c = from.column; c <= to.column; c++) {
          if (this.data[r] && this.data[r][c])
            row.push(this.data[r][c].GetValue4());
          else
            row.push({ type: 0 /* undefined */ });
        }
        value.push(row);
      }
    }
    return { type: 8 /* array */, value };
  }
  /**
   * apply function to address/area
   * @deprecated - use Apply2
   */
  Apply(area, f, create_missing_cells = false) {
    if (IsCellAddress(area)) {
      area = new Area(area);
    }
    if (area.entire_column || area.entire_row) {
      throw new Error(`don't iterate infinite cells`);
    }
    const start = area.start;
    const end = area.end;
    if (create_missing_cells) {
      for (let r = start.row; r <= end.row; r++) {
        if (!this.data[r])
          this.data[r] = [];
        const row = this.data[r];
        for (let c = start.column; c <= end.column; c++) {
          if (!row[c])
            row[c] = new Cell();
          f(row[c], c, r);
        }
      }
    } else {
      for (let r = start.row; r <= end.row; r++) {
        if (this.data[r]) {
          const row = this.data[r];
          for (let c = start.column; c <= end.column; c++) {
            if (row[c])
              f(row[c], c, r);
          }
        }
      }
    }
  }
  /**
   * apply function to address/area
   * 
   * this version lets you abort by returning false from the callback function
   */
  Apply2(area, func, create_missing_cells = false) {
    if (IsCellAddress(area)) {
      area = new Area(area);
    }
    if (area.entire_column || area.entire_row) {
      throw new Error(`don't iterate infinite cells`);
    }
    const start = area.start;
    const end = area.end;
    if (create_missing_cells) {
      for (let r = start.row; r <= end.row; r++) {
        if (!this.data[r])
          this.data[r] = [];
        const row = this.data[r];
        for (let c = start.column; c <= end.column; c++) {
          if (!row[c])
            row[c] = new Cell();
          if (!func(row[c], c, r)) {
            return;
          }
        }
      }
    } else {
      for (let r = start.row; r <= end.row; r++) {
        if (this.data[r]) {
          const row = this.data[r];
          for (let c = start.column; c <= end.column; c++) {
            if (row[c]) {
              if (!func(row[c], c, r)) {
                return;
              }
            }
          }
        }
      }
    }
  }
  /**
   * set area. shortcut to reduce overhead. consolidates single value
   * and array value methods, although the implementation is separate.
   *
   * watch out for typed arrays, which do not satisfy Array.isArray
   * 
   * when would this function get a 1D typed array? can't figure that out.
   * just drop for the time being.
   * 
   */
  SetArea(area, values) {
    if (ArrayBuffer.isView(values)) {
      throw new Error("ABIV");
    }
    if (Array.isArray(values)) {
      for (let r = area.start.row, i = 0; r <= area.end.row; r++, i++) {
        if (!this.data[r])
          this.data[r] = [];
        const row = this.data[r];
        if (values[i]) {
          for (let c = area.start.column, j = 0; c <= area.end.column; c++, j++) {
            if (!row[c])
              row[c] = new Cell();
            row[c].Set(values[i][j]);
          }
        }
      }
    } else {
      const value_type = GetValueType(values);
      for (let r = area.start.row; r <= area.end.row; r++) {
        if (!this.data[r])
          this.data[r] = [];
        const row = this.data[r];
        for (let c = area.start.column; c <= area.end.column; c++) {
          if (!row[c])
            row[c] = new Cell();
          row[c].Set(values, value_type);
        }
      }
    }
    this.rows_ = Math.max(this.rows_, area.end.row + 1);
    this.columns_ = Math.max(this.columns_, area.end.column + 1);
  }
  /**
   * iterates over all cells (using loops) and runs function per-cell.
   * FIXME: switch to indexing on empty indexes? (...)
   */
  IterateAll(func) {
    for (const row of this.data) {
      if (row) {
        for (const cell of row) {
          if (cell) {
            func(cell);
          }
        }
      }
    }
  }
  /** moved from sheet, so we can do it non-functional style (for perf) */
  FlushCellStyles() {
    for (const row of this.data) {
      if (row) {
        for (const cell of row) {
          if (cell) {
            cell.FlushStyle();
          }
        }
      }
    }
  }
  /** moved from sheet, so we can do it non-functional style (for perf) */
  FlushCachedValues() {
    for (const row of this.data) {
      if (row) {
        for (const cell of row) {
          if (cell) {
            cell.FlushCache();
          }
        }
      }
    }
  }
};

// treb-base-types/src/localization.ts
var Localization = class {
  static locale = "en-us";
  // default, for node
  static decimal_separator = ".";
  static argument_separator = ",";
  static grouping_separator = ",";
  static date_components = {
    short_days: [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ],
    long_days: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ],
    short_months: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    long_months: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  };
  /**
   * update the locale. this will be called on module load (should
   * be just once), but can be called subsequently to update.
   *
   * priority:
   * (1) function argument
   * (2) get parameter
   * (3) navigator.languages[0]
   * (4) navigator.language
   *
   * regarding languages[0] vs language, see
   * https://stackoverflow.com/a/33204290
   *
   * @param locale explicitly set locale
   */
  static UpdateLocale(locale) {
    if (locale) {
      this.locale = locale;
    } else if (typeof self !== "undefined") {
      const location = self?.document?.location;
      if (location && location.search && /locale=([^?&]+?)(?:\?|$|&)/.test(location.search)) {
        const match = location.search.match(/locale=(.*?)(?:\?|$|&)/);
        if (match)
          this.locale = match[1];
        console.info("override locale", this.locale);
      } else if (typeof navigator !== "undefined") {
        if (navigator.languages && navigator.languages[0]) {
          this.locale = navigator.languages[0];
        } else {
          this.locale = navigator.language;
        }
      }
    }
    if (this.locale === "C") {
      console.warn("Locale not set, defaulting to en-us");
      this.locale = "en-us";
    }
    const decimal_separator = new Intl.NumberFormat(
      this.locale,
      { minimumFractionDigits: 1 }
    ).format(3.3).replace(/\d/g, "");
    this.decimal_separator = decimal_separator === "," ? "," : ".";
    if (this.decimal_separator === ",") {
      this.argument_separator = ";";
      this.grouping_separator = " ";
    } else {
      this.argument_separator = ",";
      this.grouping_separator = ",";
    }
    let date = new Date(2e3, 0, 2, 12, 0, 0, 0);
    this.UpdateDateComponent(0, 0, date);
    date = new Date(2e3, 1, 7, 12, 0, 0, 0);
    this.UpdateDateComponent(1, 1, date);
    date = new Date(2e3, 2, 7, 12, 0, 0, 0);
    this.UpdateDateComponent(2, 2, date);
    date = new Date(2e3, 3, 5, 12, 0, 0, 0);
    this.UpdateDateComponent(3, 3, date);
    date = new Date(2e3, 4, 4, 12, 0, 0, 0);
    this.UpdateDateComponent(4, 4, date);
    date = new Date(2e3, 5, 2, 12, 0, 0, 0);
    this.UpdateDateComponent(5, 5, date);
    date = new Date(2e3, 6, 1, 12, 0, 0, 0);
    this.UpdateDateComponent(6, 6, date);
    date = new Date(2e3, 7, 1, 12, 0, 0, 0);
    this.UpdateDateComponent(7, -1, date);
    date = new Date(2e3, 8, 1, 12, 0, 0, 0);
    this.UpdateDateComponent(8, -1, date);
    date = new Date(2e3, 9, 1, 12, 0, 0, 0);
    this.UpdateDateComponent(9, -1, date);
    date = new Date(2e3, 10, 1, 12, 0, 0, 0);
    this.UpdateDateComponent(10, -1, date);
    date = new Date(2e3, 11, 1, 12, 0, 0, 0);
    this.UpdateDateComponent(11, -1, date);
  }
  static UpdateDateComponent(month_index, day_index, date) {
    if (day_index >= 0) {
      this.date_components.short_days[day_index] = date.toLocaleString(this.locale, { weekday: "short" });
      this.date_components.long_days[day_index] = date.toLocaleString(this.locale, { weekday: "long" });
    }
    if (month_index >= 0) {
      this.date_components.short_months[month_index] = date.toLocaleString(this.locale, { month: "short" });
      this.date_components.long_months[month_index] = date.toLocaleString(this.locale, { month: "long" });
    }
  }
};
Localization.UpdateLocale();

// treb-base-types/src/rectangle.ts
var Rectangle = class _Rectangle {
  constructor(left = 0, top = 0, width = 0, height = 0) {
    this.left = left;
    this.top = top;
    this.width = width;
    this.height = height;
  }
  get right() {
    return this.left + this.width;
  }
  get bottom() {
    return this.top + this.height;
  }
  /**
   * create a rectangle from an object that looks 
   * like a rectangle, probably a serialized object
   */
  static Create(obj) {
    return new _Rectangle(
      obj.left || 0,
      obj.top || 0,
      obj.width || 0,
      obj.height || 0
    );
  }
  static IsRectangle(obj) {
    return typeof obj === "object" && typeof obj?.left === "number" && typeof obj?.top === "number" && typeof obj?.width === "number" && typeof obj?.height === "number";
  }
  /** returns a new rect shifted from this one by (x,y) */
  Shift(x = 0, y = 0) {
    return new _Rectangle(this.left + x, this.top + y, this.width, this.height);
  }
  Scale(scale_x = 1, scale_y = scale_x) {
    return new _Rectangle(this.left * scale_x, this.top * scale_y, this.width * scale_x, this.height * scale_y);
  }
  /** returns a new rect expanded from this one by (x,y) */
  Expand(x = 0, y = 0) {
    return new _Rectangle(this.left, this.top, this.width + x, this.height + y);
  }
  /** returns a new rectangle that combines this rectangle with the argument */
  Combine(rect) {
    return new _Rectangle(
      Math.min(this.left, rect.left),
      Math.min(this.top, rect.top),
      Math.max(this.right, rect.right) - Math.min(this.left, rect.left),
      Math.max(this.bottom, rect.bottom) - Math.min(this.top, rect.top)
    );
  }
  /*
     * removing this method as part of cleaning up bitwise flags.
     * if you need this method, rewrite it to use explicit flags.
     *
    public CheckEdges(x: number, y: number, border = 16): number{
  
      let edge = 0;
  
      // tslint:disable-next-line:no-bitwise
      if (x - this.left < border) edge |= 1;
  
      // tslint:disable-next-line:no-bitwise
      if (this.right - x < border) edge |= 2;
  
      // tslint:disable-next-line:no-bitwise
      if (y - this.top < border) edge |= 4;
  
      // tslint:disable-next-line:no-bitwise
      if (this.bottom - y < border) edge |= 8;
  
      return edge;
    }
    */
  /**
   * check if rectangle contains the given coordinates, optionally with
   * some added padding
   */
  Contains(x, y, padding = 0) {
    return x >= this.left - padding && x <= this.left + this.width + padding && y >= this.top - padding && y <= this.top + this.height + padding;
  }
  /** convenience method for canvas */
  ContextFill(context) {
    context.fillRect(this.left, this.top, this.width, this.height);
  }
  /** convenience method for canvas */
  ContextStroke(context) {
    context.strokeRect(this.left, this.top, this.width, this.height);
  }
  /** clamp coordinate to rectangle */
  Clamp(x, y) {
    x = Math.min(Math.max(x, this.left), this.right);
    y = Math.min(Math.max(y, this.top), this.bottom);
    return { x, y };
  }
  /** convenience method for html element style */
  ApplyStyle(element) {
    element.style.top = this.top + "px";
    element.style.left = this.left + "px";
    element.style.width = this.width + "px";
    element.style.height = this.height + "px";
  }
  toJSON() {
    return {
      top: this.top,
      left: this.left,
      width: this.width,
      height: this.height
    };
  }
};

// treb-base-types/src/style.ts
var empty_json = JSON.stringify({});
var Style = {
  /**
   * note that there are no default colors; those should be set
   * in grid when style is applied. that way the default colors for
   * border, text and background colors will be theme-dependent and
   * can change.
   * 
   * @internal
   */
  DefaultProperties: {
    horizontal_align: "",
    vertical_align: "",
    number_format: "General",
    // '0.######',   // use symbolic, e.g. "general"
    nan: "NaN",
    font_size: { unit: "pt", value: 10.5 },
    font_face: "sans-serif",
    bold: false,
    // drop "font_"
    italic: false,
    // ...
    underline: false,
    // ...
    strike: false,
    // 
    text: { theme: 1 },
    border_top: 0,
    // adding defaults so these prune propery
    border_left: 0,
    border_right: 0,
    border_bottom: 0
  },
  /**
   * this is a utility function for callers that use borders, to
   * reduce testing and facilitate reusable methods
   * 
   * @internal
   */
  CompositeBorders: (style) => {
    return {
      top: {
        width: style.border_top || 0,
        color: style.border_top_fill || {}
      },
      left: {
        width: style.border_left || 0,
        color: style.border_left_fill || {}
      },
      right: {
        width: style.border_right || 0,
        color: style.border_right_fill || {}
      },
      bottom: {
        width: style.border_bottom || 0,
        color: style.border_bottom_fill || {}
      }
    };
  },
  /**
   * merge. returns a new object, does not update dest in place.
   * NOTE: if it does not update dest in place, then what would be
   * the use case for a non-delta merge? (...)
   * 
   * @internal
   */
  Merge: (dest, src, delta = true) => {
    const properties = delta ? { ...dest, ...src } : { ...src };
    return JSON.parse(JSON.stringify(properties));
  },
  /** @internal */
  Composite: (list) => {
    return JSON.parse(JSON.stringify(list.reduce((composite, item) => ({ ...composite, ...item }), {})));
  },
  /** @internal */
  Empty: (style) => {
    return JSON.stringify(style) === empty_json;
  },
  /** 
   * this looks like a type guard, we should switch to a union
   * type and then add real type guards
   * 
   * @internal 
   */
  ValidColor: (color) => {
    return !!(color && !color.none && (color.text || color.theme || color.theme === 0));
  },
  /** @internal */
  ParseFontSize: (text = "", default_unit = "em") => {
    const match = text.match(/(-*[\d.]+)\s*(\S*)/);
    if (match) {
      const value = Number(match[1]);
      if (!value || isNaN(value) || value < 0) {
        return {};
      }
      const unit = match[2].toLowerCase() || default_unit;
      if (unit === "pt" || unit === "em" || unit === "%" || unit === "px") {
        return {
          font_size: { unit, value }
        };
      }
    }
    return {};
  },
  /**
   * returns the font size of the properties argument as a ratio of the 
   * base argument. this is intended to show the relative font size of 
   * a spreadsheet cell; so anything with no value should be "1", and
   * everything else is relative to that.
   * 
   * we prefer relative sizes (em, essentially) to fixed sizes because
   * we may have different base font sizes on different platforms (we do,
   * in fact, on windows because calibri is too small).
   * 
   * using relative sizes helps ensure that it looks similar, if not 
   * identical, on different platforms.
   * 
   * @internal
   */
  RelativeFontSize: (properties, base) => {
    let base_pt = 12;
    let props_pt = 12;
    switch (properties.font_size?.unit) {
      case "pt":
        if (!properties.font_size.value) {
          return 1;
        }
        props_pt = properties.font_size.value;
        break;
      case "px":
        if (!properties.font_size.value) {
          return 1;
        }
        props_pt = Math.round(properties.font_size.value * 300 / 4) / 100;
        break;
      case "em":
        return properties.font_size.value || 1;
      case "%":
        return (properties.font_size.value || 100) / 100;
      default:
        return 1;
    }
    switch (base.font_size?.unit) {
      case "pt":
        if (!base.font_size.value) {
          return 1;
        }
        base_pt = base.font_size.value;
        break;
      case "px":
        if (!base.font_size.value) {
          return 1;
        }
        base_pt = Math.round(base.font_size.value * 300 / 4) / 100;
        break;
      default:
        return 1;
    }
    return props_pt / base_pt;
  },
  /** @internal */
  FontSize: (properties, prefer_points = true) => {
    const value = properties.font_size?.value;
    switch (properties.font_size?.unit) {
      case "pt":
        return (value || 12) + "pt";
      case "px":
        if (prefer_points) {
          const points = Math.round((value || 16) * 300 / 4) / 100;
          return points + "pt";
        }
        return (value || 16) + "px";
      case "em":
        return (value || 1) + "em";
      case "%":
        return (value || 100) + "%";
    }
    return "";
  },
  /**
   * returns a string representation suitable for canvas (or style)
   */
  Font: (properties, scale = 1) => {
    const parts = [];
    if (properties.bold) {
      parts.push("bold");
    }
    if (properties.italic) {
      parts.push("italic");
    }
    parts.push(((properties.font_size?.value || 0) * scale).toFixed(2) + (properties.font_size?.unit || "pt"));
    parts.push(properties.font_face || "");
    return parts.join(" ");
  }
};

// treb-base-types/src/union.ts
var Is2DArray = (obj) => {
  return !!obj && Array.isArray(obj) && Array.isArray(obj[0]);
};
var Box = (value, type) => {
  if (typeof type === "undefined") {
    type = GetValueType(value);
  }
  return {
    value,
    type
  };
};
var ComplexOrReal = (value) => {
  if (value.imaginary) {
    return {
      type: 7 /* complex */,
      value
    };
  }
  return { type: 3 /* number */, value: value.real };
};

// treb-base-types/src/color.ts
var ColorFunctions = {
  /** darken rgb color by amount (%), optionally relative */
  Darken: (r, g, b, amount, relative = false) => {
    let { h, s, l } = ColorFunctions.RGBToHSL(r, g, b);
    if (relative)
      l -= l * amount / 100;
    else
      l -= amount / 100;
    l = Math.max(0, Math.min(1, l));
    return ColorFunctions.HSLToRGB(h, s, l);
  },
  /** lighten rgb color by amount (%), optionally relative */
  Lighten: (r, g, b, amount, relative = false) => {
    let { h, s, l } = ColorFunctions.RGBToHSL(r, g, b);
    if (relative)
      l += l * amount / 100;
    else
      l += amount / 100;
    l = Math.max(0, Math.min(1, l));
    return ColorFunctions.HSLToRGB(h, s, l);
  },
  RGBToHSL: (r, g, b) => {
    r /= 255;
    g /= 255;
    b /= 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h = 0;
    let s = 0;
    const l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
      }
      h /= 6;
    }
    return { h: h * 360, s, l };
  },
  HSLToRGB: (h, s, l) => {
    let r;
    let g;
    let b;
    if (s === 0) {
      r = g = b = l;
    } else {
      h = h / 360;
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = ColorFunctions.HueToRGB(p, q, h + 1 / 3);
      g = ColorFunctions.HueToRGB(p, q, h);
      b = ColorFunctions.HueToRGB(p, q, h - 1 / 3);
    }
    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    };
  },
  HueToRGB: (p, q, t) => {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p + (q - p) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }
};

// treb-base-types/src/dom-utilities.ts
var SVGNS = "http://www.w3.org/2000/svg";
var DOMContext = class _DOMContext {
  static instances = [];
  /** 
   * FIXME: how about we default to document, so it won't break? 
   * that will make it harder to debug though. 
   */
  static GetInstance(doc) {
    for (const instance2 of this.instances) {
      if (instance2.doc === doc) {
        return instance2;
      }
    }
    const instance = new _DOMContext(doc);
    this.instances.push(instance);
    return instance;
  }
  /** ugh sloppy */
  doc;
  // placeholder temp
  /** ugh sloppy */
  view;
  /*
    public get document(): Document {
      return this.doc;
    }
  
    public get window(): (Window & typeof globalThis) {
      return this.view;
    }
    */
  /** class for `instanceof` comparison */
  get HTMLElement() {
    return this.view?.HTMLElement;
  }
  constructor(doc) {
    if (doc) {
      this.doc = doc;
      this.view = doc?.defaultView;
    }
  }
  /** wrapper for window.getSelection */
  GetSelection() {
    return this.view?.getSelection();
  }
  /** creates a div and assigns class name/names */
  Div(classes, parent, options) {
    return this.Create("div", classes, parent, options);
  }
  ClassNames(element, classes) {
    element.classList.add(...(Array.isArray(classes) ? classes : [classes]).reduce((arr, entry) => [...arr, ...entry.split(/\s+/g)], []));
  }
  SVG(tag, classes, parent) {
    const element = this.doc.createElementNS(SVGNS, tag);
    if (classes) {
      this.ClassNames(element, classes);
    }
    if (parent) {
      parent.appendChild(element);
    }
    return element;
  }
  /**
   * this is a wrapper for createTextNode. but if we want to expose 
   * the element/node classes (@see HTMLElement, above) then this 
   * should properly be the Text class and not a method. So we should
   * rename it. 
   * 
   * @param data 
   * @returns 
   */
  Text(data) {
    return this.doc.createTextNode(data);
  }
  Fragment() {
    return this.doc.createDocumentFragment();
  }
  /** better typing */
  Create(tag, classes, parent, options) {
    const element = this.doc.createElement(tag);
    if (classes) {
      this.ClassNames(element, classes);
    }
    if (options) {
      if (options.attrs) {
        for (const [key, value] of Object.entries(options.attrs)) {
          element.setAttribute(key, value);
        }
      }
      if (options.data) {
        for (const [key, value] of Object.entries(options.data)) {
          element.dataset[key] = value;
        }
      }
      if (options.text) {
        element.textContent = options.text;
      }
      if (options.html) {
        element.innerHTML = options.html;
      }
      if (options.events) {
        for (const [key, value] of Object.entries(options.events)) {
          element.addEventListener(key, value);
        }
      }
      if (options.style) {
        for (const [key, value] of Object.entries(options.style)) {
          element.style[key] = value;
        }
      }
    }
    if (parent) {
      parent.appendChild(element);
    }
    return element;
  }
};

// treb-base-types/src/theme.ts
var DefaultTheme = {
  grid_color: "#ccc",
  note_marker_color: "#d2c500",
  mode: "light",
  offset_cache: {},
  offset_light: "#fff",
  offset_dark: "#000"
};
var ThemeColor = (theme, color) => {
  return ThemeColor2(theme, color, 0);
};
var TintedColor = (theme, index, tint) => {
  if (theme.mode === "dark") {
    tint = -tint;
  }
  if (!theme.tint_cache) {
    theme.tint_cache = [];
  }
  if (!theme.tint_cache[index]) {
    theme.tint_cache[index] = {};
  }
  let color = theme.tint_cache[index][tint];
  if (!color) {
    const rgb = (theme.theme_colors_rgb ? theme.theme_colors_rgb[index] : [0, 0, 0]) || [0, 0, 0];
    let tinted;
    if (tint > 0) {
      tinted = ColorFunctions.Lighten(rgb[0], rgb[1], rgb[2], tint * 100, true);
    } else {
      tinted = ColorFunctions.Darken(rgb[0], rgb[1], rgb[2], -tint * 100, true);
    }
    color = `rgb(${tinted.r},${tinted.g},${tinted.b})`;
    theme.tint_cache[index][tint] = color;
  }
  return color;
};
var ThemeColor2 = (theme, color, default_index) => {
  if (color?.offset) {
    if (color.offset.offset) {
      console.warn("invalid offset color");
      return "";
    }
    const resolved = ThemeColor2(theme, color.offset);
    if (theme.offset_cache && theme.offset_cache[resolved]) {
      return theme.offset_cache[resolved];
    }
    let offset = theme.offset_light;
    if (resolved) {
      const match = resolved.match(/rgb\((\d+), (\d+), (\d+)\)/);
      if (match) {
        const hsl = ColorFunctions.RGBToHSL(Number(match[1]), Number(match[2]), Number(match[3]));
        if (hsl.l > 0.65) {
          offset = theme.offset_dark;
        }
      } else {
        console.warn(`can't offset against color`, resolved);
      }
      if (!theme.offset_cache) {
        theme.offset_cache = {};
      }
      theme.offset_cache[resolved] = offset;
    } else {
      console.warn(`can't resolve offset color`, color.offset);
    }
    return offset;
  }
  if (color?.text) {
    return color.text === "none" ? "" : color.text;
  }
  if (color?.theme || color?.theme === 0) {
    if (color.tint) {
      return TintedColor(theme, color.theme, color.tint);
    }
    return theme.theme_colors ? theme.theme_colors[color.theme] : "";
  }
  if (default_index || default_index === 0) {
    return theme.theme_colors ? theme.theme_colors[default_index] : "";
  }
  return "";
};
var ParseFontSize = (size) => {
  let value = 10;
  let unit = "pt";
  const match = size.match(/^([\d.]+)(\D.*)$/);
  if (match) {
    value = Number(match[1]);
    unit = match[2];
  }
  return { value, unit };
};
var StyleFromCSS = (css) => {
  const { value, unit } = ParseFontSize(css.fontSize || "");
  const style = {
    fill: { text: css.backgroundColor },
    // || 'none',
    text: { text: css.color },
    font_size: {
      unit,
      value
    },
    font_face: css.fontFamily
  };
  if (/italic/i.test(css.font)) {
    style.italic = true;
  }
  if (css.fontWeight === "700") {
    style.bold = true;
  }
  return style;
};
var DeriveColorScheme = (theme, context) => {
  const foreground_color = theme.grid_cell?.text;
  const background_color = theme.grid_cell?.fill;
  context.fillStyle = foreground_color?.text || "";
  context.fillRect(0, 0, 3, 3);
  const fg = ColorFunctions.RGBToHSL(...Array.from(context.getImageData(1, 1, 1, 1).data));
  context.fillStyle = background_color?.text || "";
  context.fillRect(0, 0, 3, 3);
  const bg = ColorFunctions.RGBToHSL(...Array.from(context.getImageData(1, 1, 1, 1).data));
  return fg.l > bg.l ? "dark" : "light";
};
var ThemeColorTable = (theme_color, tint = 0.7) => {
  const borders = {
    border_top: 1,
    border_top_fill: { theme: theme_color },
    border_bottom: 1,
    border_bottom_fill: { theme: theme_color }
  };
  return {
    header: {
      // text: { theme: theme.mode === 'dark' ? 1 : 0, },
      // text: { text: '#fff' },
      text: { offset: { theme: theme_color } },
      fill: { theme: theme_color },
      bold: true,
      ...borders
    },
    odd: {
      fill: { theme: theme_color, tint },
      ...borders
    },
    even: {
      ...borders
    },
    total: {
      ...borders,
      border_top: 2
    }
  };
};
var LoadThemeProperties = (container) => {
  const theme = JSON.parse(JSON.stringify(DefaultTheme));
  const DOM = DOMContext.GetInstance(container.ownerDocument);
  const Append = (parent, classes) => {
    return DOM.Div(classes, parent);
  };
  const ElementCSS = (parent, classes) => {
    return DOM.view?.getComputedStyle(Append(parent, classes));
  };
  const node = Append(container, "");
  const CSS = ElementCSS.bind(0, node);
  let css = CSS("grid-cells");
  theme.grid_cell = StyleFromCSS(css);
  theme.grid_color = css.stroke || "";
  css = CSS("grid-headers");
  theme.headers = StyleFromCSS(css);
  theme.headers_grid_color = css.stroke;
  if (!theme.headers_grid_color || theme.headers_grid_color === "none") {
    theme.headers_grid_color = theme.grid_color;
  }
  css = CSS("treb-offset-dark");
  if (css.color) {
    theme.offset_dark = css.color;
  }
  css = CSS("treb-offset-light");
  if (css.color) {
    theme.offset_light = css.color;
  }
  css = CSS("note-marker");
  theme.note_marker_color = css.backgroundColor;
  node.style.color = "rgba(1,2,3,.4)";
  css = CSS("");
  const compare = css.color;
  theme.theme_colors = [
    theme.grid_cell.fill?.text || "rgb(255, 255, 255)",
    theme.grid_cell.text?.text || "rgb(51, 51, 51)"
  ];
  for (let i = 1; i < 32; i++) {
    css = CSS(`theme-color-${i}`);
    if (!css.color || css.color === compare) {
      break;
    }
    theme.theme_colors.push(css.color);
  }
  const canvas = DOM.Create("canvas");
  canvas.width = 3;
  canvas.height = 3;
  const context = canvas.getContext("2d", { willReadFrequently: true });
  if (context) {
    theme.mode = DeriveColorScheme(theme, context);
  }
  if (context) {
    theme.theme_colors_rgb = theme.theme_colors.map((color) => {
      context.fillStyle = color;
      context.fillRect(0, 0, 3, 3);
      const imagedata = context.getImageData(1, 1, 1, 1);
      return Array.from(imagedata.data);
    });
  }
  theme.table = ThemeColorTable(4);
  node.parentElement?.removeChild(node);
  return theme;
};

// treb-base-types/src/table.ts
var DefaultTableSortOptions = {
  column: 0,
  type: "auto",
  asc: true
};

// treb-utils/src/event_source.ts
var subscription_token_generator = 1e3;
var EventSource = class {
  /* * pass-through modules: these are peers * /
  private pass_through: Array<EventSource<T>> = [];
  */
  constructor(verbose = false, log_id) {
    this.verbose = verbose;
    this.log_id = log_id;
  }
  // implements IEventSource<T> {
  /** pending events */
  queue = [];
  /** flag indicating whether we have already triggered a callback */
  dispatched = false;
  /** regular subscriptions */
  subscribers = [];
  /**
   * FIXME: does anybody call this with an array? it's no longer
   * necessary for multiple messages to prevent extra callbacks...
   */
  Publish(event) {
    if (this.verbose) {
      console.info(`es publish (${this.log_id})`, event);
    }
    if (Array.isArray(event)) {
      this.queue.push(...event);
    } else {
      this.queue.push(event);
    }
    if (!this.dispatched) {
      this.dispatched = true;
      Promise.resolve().then(() => {
        const events = this.queue.slice(0);
        this.dispatched = false;
        this.queue = [];
        for (const queued_event of events) {
          for (const subscription of this.subscribers) {
            subscription.subscriber(queued_event);
          }
        }
      });
    }
  }
  /**
   * subscription returns a token which can be used to cancel subscription.
   * this token is a number, guaranteed to be !0 so you can test for falsy.
   */
  Subscribe(subscriber) {
    const token = subscription_token_generator++;
    this.subscribers.push({ subscriber, token });
    return token;
  }
  /** cancel a single subscription */
  Cancel(token) {
    this.subscribers = this.subscribers.filter((subscription) => subscription.token !== token);
  }
  /**
   * cancel all subscriptions AND ALL PASS-THROUGH SOURCES.
   */
  CancelAll() {
    this.subscribers = [];
  }
  /* *
   * pass-through (redirected) subscription, synchronous on this end. does
   * not support unsubscribe atm (FIXME)
   * /
  public PassThrough(source: EventSource<T>) {
    this.pass_through.push(source);
  }
  */
};

// treb-utils/src/measurement.ts
var Measurement = class {
  /** canvas used for color measurement */
  static color_measurement_canvas;
  /**
   * node used for text metrics. this has to be added to
   * the DOM, so it's fixed and shifted off screen.
   */
  static text_measurement_node;
  /** cache for color lookups */
  static color_cache = {};
  static MeasureColorARGB(color) {
    const bytes = this.MeasureColor(color);
    let argb = "FF";
    for (let i = 0; i < 3; i++) {
      const hex = bytes[i].toString(16);
      if (hex.length === 0)
        argb += "00";
      else if (hex.length === 1)
        argb += `0${hex}`;
      else
        argb += hex;
    }
    return argb.toUpperCase();
  }
  /**
   * measure a color. turns symbolic or rgb colors into rgb values.
   * 
   * UPDATE: prefill with #fff. that prevents it from randomly returning
   * the last value, if the color doesn't work for some reason.
   */
  static MeasureColor(color) {
    let cached = this.color_cache[color];
    if (cached) {
      return cached;
    }
    if (!this.color_measurement_canvas) {
      this.color_measurement_canvas = document.createElement("canvas");
      this.color_measurement_canvas.width = 1;
      this.color_measurement_canvas.height = 1;
    }
    const context = this.color_measurement_canvas.getContext("2d", {
      willReadFrequently: true
    });
    if (context) {
      context.fillStyle = "#fff";
      context.fillRect(0, 0, 1, 1);
      context.fillStyle = color;
      context.fillRect(0, 0, 1, 1);
      cached = new Uint8ClampedArray(context.getImageData(0, 0, 1, 1).data);
      this.color_cache[color] = cached;
      return cached;
    }
    return new Uint8ClampedArray(3);
  }
  static EnsureMeasurementNode() {
    if (!this.text_measurement_node) {
      const node = document.querySelector(".treb-chart-measurement-node");
      if (node) {
        this.text_measurement_node = node;
      } else {
        this.text_measurement_node = document.createElement("div");
        this.text_measurement_node.classList.add("treb-chart-measurement-node");
        this.text_measurement_node.style.margin = "0px";
        this.text_measurement_node.style.padding = "0px";
        this.text_measurement_node.style.height = "initial";
        this.text_measurement_node.style.width = "initial";
        this.text_measurement_node.style.whiteSpace = "nowrap";
        this.text_measurement_node.style.position = "fixed";
        this.text_measurement_node.style.border = "0px";
        this.text_measurement_node.style.border = "1px solid red";
        this.text_measurement_node.style.boxSizing = "content-box";
        this.text_measurement_node.style.top = this.text_measurement_node.style.left = "-1000px";
        document.body.appendChild(this.text_measurement_node);
      }
    }
  }
  /* *
   * check if font is loaded, based on the theory that the alternatives
   * will be different sizes. note that this probably doesn't test weights
   * or italics properly, as those can be emulated without the specific face.
   *
   * I guess the thing to do in that case would be to load the alternate faces
   * first, and assume they are loaded serially (they're not).
   *
   * @param font_face
   * @param italic
   * @param bold
   * /
  public static FontLoaded(font_face: string, italic = false, weight = 400): boolean {
    const face = `${italic ? 'italic' : ''} ${weight} 20pt ${font_face}`;
    const m1 = this.MeasureText(`${face}, sans-serif`, `check font`);
    const m2 = this.MeasureText(`${face}, serif`, `check font`);
    const m3 = this.MeasureText(`${face}, monospace`, `check font`);
    return (m1.width === m2.width && m2.width === m3.width);
  }
  */
  /**
   * measure width, height of text, accounting for rotation
   */
  static MeasureText(font, text, angle = 0) {
    this.EnsureMeasurementNode();
    this.text_measurement_node.style.font = font;
    if (/\n/.test(text)) {
      text = text.replace(/\n/g, "<BR/>");
      this.text_measurement_node.innerHTML = text;
    } else {
      this.text_measurement_node.textContent = text;
    }
    this.text_measurement_node.style.lineHeight = "1em";
    if (angle) {
      this.text_measurement_node.style.transform = `rotate(${angle}deg)`;
    } else
      this.text_measurement_node.style.transform = "";
    const rect = this.text_measurement_node.getBoundingClientRect();
    return {
      width: rect.width,
      height: rect.height
    };
  }
};

// treb-utils/src/serialize_html.ts
var default_properties;
var GetAppliedStyle = (node, computed, defaults) => {
  const applied = {};
  Array.prototype.forEach.call(computed, (key) => {
    if (computed[key] !== defaults[key]) {
      applied[key] = computed[key];
    }
  });
  return (Object.keys(applied).map((key) => `${key}: ${applied[key]}`).join("; ") + "; " + (node.getAttribute("style") || "")).trim().replace(/"/g, "'");
};
var RenderNode = (node, defaults) => {
  const clone = node.cloneNode(false);
  const computed = getComputedStyle(node);
  const style = GetAppliedStyle(node, computed, defaults);
  clone.removeAttribute("class");
  clone.setAttribute("style", style);
  Array.prototype.forEach.call(node.childNodes, (child) => {
    switch (child.nodeType) {
      case Node.ELEMENT_NODE:
        clone.appendChild(RenderNode(child, computed));
        break;
      case Node.TEXT_NODE:
        if (node.textContent) {
          clone.appendChild(document.createTextNode(node.textContent));
        }
        break;
      case Node.COMMENT_NODE:
        break;
      default:
        console.warn("unhandled node type in serialize", child);
    }
  });
  return clone;
};
var SerializeHTML = (node) => {
  if (!default_properties) {
    const defaults = {};
    const iframe = document.createElement("iframe");
    iframe.style.width = "10px";
    iframe.style.height = "10px";
    iframe.style.position = "absolute";
    iframe.style.left = "-100px";
    document.body.appendChild(iframe);
    const frame_document = iframe.contentDocument;
    if (frame_document) {
      const div = frame_document.createElement("div");
      frame_document.body.appendChild(div);
      const computed = getComputedStyle(div);
      Array.prototype.forEach.call(computed, (key) => defaults[key] = computed[key]);
    }
    document.body.removeChild(iframe);
    default_properties = defaults;
  }
  return RenderNode(node, default_properties);
};

// treb-utils/src/validate_uri.ts
var default_uri_options = {
  data: true,
  same_origin: true,
  remote: false
};
var ValidateURI = (resource, options = {}) => {
  const composite = {
    ...default_uri_options,
    ...options
  };
  try {
    const url = new URL(resource, document.location.href);
    if (url.protocol === "data:") {
      return composite.data ? url.href : void 0;
    }
    if (url.origin === document.location.origin) {
      return composite.same_origin ? url.href : void 0;
    }
    return composite.remote ? url.hash : void 0;
  } catch (err) {
    console.error(err);
  }
  return void 0;
};

// treb-utils/src/scale.ts
var Scale = (min, max, count = 6.5, limit_count = false, discrete = false) => {
  if (max === min) {
    max++;
    if (min) {
      min--;
    }
  } else {
    const rounded = Math.round(max * 1e5) / 1e5;
    if (Math.abs(rounded - max) / (max - min) < 1e-5) {
      max = rounded;
    }
  }
  const range = max - min;
  const log10 = Math.log(range) / Math.log(10);
  let scale = Math.floor(Math.abs(log10)) * (log10 < 0 ? -1 : 1) - 1;
  if (discrete) {
    scale = Math.max(0, scale);
  }
  const steps = discrete ? [1, 2, 5, 10, 15, 20, 25, 50, 100] : [0.1, 0.25, 0.5, 1, 2.5, 5, 10, 25, 50, 100];
  let step = -1;
  let delta = 0;
  for (const x of steps) {
    const test_step = x * Math.pow(10, scale);
    const test_min = Math.floor(min / test_step) * test_step;
    const test_max = Math.ceil(max / test_step) * test_step;
    const test_count = (test_max - test_min) / test_step;
    const test_delta = Math.abs(test_count - count);
    if (step < 0 || test_delta < delta) {
      if (!limit_count || test_count <= count) {
        delta = test_delta;
        step = test_step;
      }
    }
  }
  min = Math.floor(min / step) * step;
  max = Math.ceil(max / step) * step;
  count = Math.round((max - min) / step);
  return { scale, step, count, min, max };
};

// treb-base-types/src/gradient.ts
var Gradient = class {
  constructor(stops, theme, color_space = "RGB") {
    this.color_space = color_space;
    this.mapped = stops.map((stop) => {
      if (stop.value < 0 || stop.value > 1) {
        throw new Error("invalid stop value");
      }
      const rgb = Measurement.MeasureColor(ThemeColor2(theme, stop.color));
      let resolved = [];
      if (color_space === "HSL") {
        const hsl = ColorFunctions.RGBToHSL(rgb[0], rgb[1], rgb[2]);
        resolved = [hsl.h, hsl.s, hsl.l];
      } else {
        resolved = [...rgb];
      }
      return {
        ...stop,
        resolved
      };
    });
    this.mapped.sort((a, b) => a.value - b.value);
    if (this.mapped[0].value > 0) {
      this.mapped.unshift({
        ...this.mapped[0],
        value: 0
      });
    }
    if (this.mapped[this.mapped.length - 1].value < 1) {
      this.mapped.push({
        ...this.mapped[this.mapped.length - 1],
        value: 1
      });
    }
  }
  mapped;
  RenderColor(values) {
    if (this.color_space === "RGB") {
      return { text: `rgb(${values})` };
    }
    return { text: `hsl(${values[0]},${values[1] * 100}%,${values[2] * 100}%)` };
  }
  Interpolate(value) {
    value = Math.min(1, Math.max(0, value));
    for (const [index, stop] of this.mapped.entries()) {
      if (value === stop.value) {
        return this.RenderColor(stop.resolved);
      }
      if (value < stop.value) {
        const a = this.mapped[index - 1];
        const b = stop;
        const range = b.value - a.value;
        const advance = value - a.value;
        const values = [0, 1, 2].map((index2) => {
          return a.resolved[index2] + (b.resolved[index2] - a.resolved[index2]) / range * advance;
        });
        return this.RenderColor(values);
      }
    }
    return { text: "" };
  }
};

// treb-parser/src/parser.ts
var QuotedSheetNameRegex = /[\s-+=<>!()]/;
var IllegalSheetNameRegex = /['*\\]/;
var DOUBLE_QUOTE = 34;
var SINGLE_QUOTE = 39;
var NON_BREAKING_SPACE = 160;
var SPACE = 32;
var TAB = 9;
var CR = 10;
var LF = 13;
var ZERO = 48;
var NINE = 57;
var PERIOD = 46;
var PLUS = 43;
var MINUS = 45;
var OPEN_PAREN = 40;
var CLOSE_PAREN = 41;
var COMMA = 44;
var PERCENT = 37;
var UNDERSCORE = 95;
var DOLLAR_SIGN = 36;
var OPEN_BRACE = 123;
var CLOSE_BRACE = 125;
var OPEN_SQUARE_BRACKET = 91;
var CLOSE_SQUARE_BRACKET = 93;
var EXCLAMATION_MARK = 33;
var SEMICOLON = 59;
var HASH = 35;
var AT = 64;
var UC_A = 65;
var LC_A = 97;
var UC_E = 69;
var LC_E = 101;
var UC_Z = 90;
var LC_Z = 122;
var LC_I = 105;
var ACCENTED_RANGE_START = 192;
var ACCENTED_RANGE_END = 312;
var binary_operators_precendence = {
  "==": 6,
  "!=": 6,
  // FIXME: we should not support these (legacy)
  "<>": 6,
  "=": 6,
  // these are the appropriate equality operators for SL
  "<": 7,
  ">": 7,
  "<=": 7,
  ">=": 7,
  "+": 9,
  "-": 9,
  "&": 9,
  "*": 10,
  "/": 10,
  "^": 11,
  // highest math op
  ":": 13
  // range operator
};
var binary_operators = Object.keys(binary_operators_precendence).sort(
  (a, b) => b.length - a.length
);
var unary_operators = { "-": 100, "+": 100 };
var Parser = class {
  /**
   * argument separator. this can be changed prior to parsing/rendering.
   * FIXME: use an accessor to ensure type, outside of ts?
   */
  argument_separator = "," /* Comma */;
  /**
   * decimal mark. this can be changed prior to parsing/rendering.
   * FIXME: use an accessor to ensure type, outside of ts?
   */
  decimal_mark = "." /* Period */;
  /**
   * unifying flags
   */
  flags = {
    spreadsheet_semantics: true,
    dimensioned_quantities: false,
    fractions: true
  };
  r1c1_regex = /[rR]((?:\[[-+]{0,1}\d+\]|\d+))[cC]((?:\[[-+]{0,1}\d+\]|\d+))$/;
  /**
   * internal argument separator, as a number. this is set internally on
   * parse call, following the argument_separator value.
   */
  argument_separator_char = COMMA;
  /**
   * internal decimal mark, as a number.
   */
  decimal_mark_char = PERIOD;
  /**
   * imaginary number value. this is "i", except for those EE weirdos who 
   * use "j". although I guess those guys put it in front, so it won't really
   * work anyway... let's stick with "i" for now.
   */
  imaginary_char = LC_I;
  /**
   * imaginary number as text for matching
   */
  imaginary_number = "i";
  /**
   * internal counter for incrementing IDs
   */
  id_counter = 0;
  expression = "";
  data = [];
  index = 0;
  length = 0;
  /** success flag */
  valid = true;
  /** rolling error state */
  error_position;
  /** rolling error state */
  error;
  dependencies = {
    addresses: {},
    ranges: {}
  };
  // referenced addresses -- used to merge ranges/addresses, although I'm
  // not sure that's actually all that useful
  address_refcount = {};
  /**
   * full list of referenced addresses and ranges. we're adding this
   * to support highlighting, for which we need multiple instances
   * of a single address. the original dep list was used for graph dependencies,
   * so we compressed the list.
   *
   * FIXME: use a single list, i.e. something like
   *
   *   address -> [instance, instance]
   *
   * because that's a big API change it's going to have to wait. for now,
   * use a second list.
   *
   * UPDATE: adding (otherwise unused) tokens, which could be named ranges.
   * in the future we may pass in a list of names at parse time, and resolve
   * them; for now we are just listing names.
   */
  full_reference_list = [];
  parser_state = [];
  /**
   * save local configuration to a buffer, so it can be restored. we're doing
   * this because in a lot of places we're caching parser flagss, changing
   * them, and then restoring them. that's become repetitive, fragile to 
   * changes or new flags, and annoying.
   * 
   * config is managed in a list with push/pop semantics. we store it as 
   * JSON so there's no possibility we'll accidentally mutate.
   * 
   * FIXME: while we're at it why not migrate the separators -> flags, so
   * there's a single location for this kind of state? (...TODO)
   * 
   */
  Save() {
    const config = {
      flags: this.flags,
      argument_separator: this.argument_separator,
      decimal_mark: this.decimal_mark
    };
    this.parser_state.push(JSON.stringify(config));
  }
  /**
   * restore persisted config
   * @see Save
   */
  Restore() {
    const json = this.parser_state.shift();
    if (json) {
      try {
        const config = JSON.parse(json);
        this.flags = config.flags;
        this.argument_separator = config.argument_separator;
        this.decimal_mark = config.decimal_mark;
      } catch (err) {
        console.error(err);
      }
    } else {
      console.warn("No parser state to restore");
    }
  }
  /**
   * recursive tree walk.
   *
   * @param func function called on each node. for nodes that have children
   * (operations, calls, groups) return false to skip the subtree, or true to
   * traverse.
   */
  Walk(unit, func) {
    switch (unit.type) {
      case "address":
      case "missing":
      case "literal":
      case "complex":
      case "identifier":
      case "operator":
      case "structured-reference":
        func(unit);
        return;
      case "dimensioned":
        if (func(unit)) {
          this.Walk(unit.expression, func);
          this.Walk(unit.unit, func);
        }
        return;
      case "range":
        if (func(unit)) {
          this.Walk(unit.start, func);
          this.Walk(unit.end, func);
        }
        return;
      case "binary":
        if (func(unit)) {
          this.Walk(unit.left, func);
          this.Walk(unit.right, func);
        }
        return;
      case "unary":
        if (func(unit)) {
          this.Walk(unit.operand, func);
        }
        return;
      case "group":
        if (func(unit)) {
          unit.elements.forEach((element) => this.Walk(element, func));
        }
        return;
      case "call":
        if (func(unit)) {
          unit.args.forEach((arg) => this.Walk(arg, func));
        }
    }
  }
  /** utility: transpose array */
  Transpose(arr) {
    const m = arr.length;
    const transposed = [];
    let n = 0;
    for (let i = 0; i < m; i++) {
      if (Array.isArray(arr[i])) {
        n = Math.max(n, arr[i].length);
      }
    }
    for (let i = 0; i < n; i++) {
      transposed[i] = [];
      for (let j = 0; j < m; j++) {
        transposed[i][j] = arr[j][i];
      }
    }
    return transposed;
  }
  /**
   * renders the passed expression as a string.
   * @param unit base expression
   * @param offset offset for addresses, used to offset relative addresses
   * (and ranges). this is for copy-and-paste or move operations.
   * @param missing string to represent missing values (can be '', for functions)
   * 
   * FIXME: we're accumulating too many arguments. need to switch to an 
   * options object. do that after the structured reference stuff merges.
   * 
   */
  Render(unit, options = {}) {
    const offset = options.offset || { rows: 0, columns: 0 };
    const missing = options.missing ?? "(missing)";
    const {
      convert_decimal,
      convert_argument_separator,
      convert_imaginary_number,
      long_structured_references,
      table_name
    } = options;
    let separator = this.argument_separator + " ";
    if (convert_argument_separator === "," /* Comma */) {
      separator = ", ";
    } else if (convert_argument_separator === ";" /* Semicolon */) {
      separator = "; ";
    }
    let imaginary_character = this.imaginary_number;
    if (convert_imaginary_number) {
      imaginary_character = convert_imaginary_number;
    }
    const decimal = convert_decimal === "," /* Comma */ ? "," : ".";
    const decimal_rex = this.decimal_mark === "," /* Comma */ ? /,/ : /\./;
    const decimal_rex_g = this.decimal_mark === "," /* Comma */ ? /,/g : /\./g;
    switch (unit.type) {
      case "address":
        return this.AddressLabel(unit, offset);
      case "range":
        return this.AddressLabel(unit.start, offset) + ":" + this.AddressLabel(unit.end, offset);
      case "missing":
        return missing;
      case "array":
        return "{" + this.Transpose(unit.values).map((row) => row.map((value) => {
          if (typeof value === "string") {
            return '"' + value + '"';
          }
          return value;
        }).join(", ")).join("; ") + "}";
      case "binary":
        return this.Render(unit.left, options) + " " + unit.operator + " " + this.Render(unit.right, options);
      case "unary":
        return unit.operator + this.Render(unit.operand, options);
      case "complex":
        if (unit.text) {
          if (convert_decimal) {
            const text = unit.text;
            return text.replace(decimal_rex_g, decimal);
          } else {
            return unit.text;
          }
        } else {
          let imaginary_text = Math.abs(unit.imaginary).toString();
          if (convert_decimal === "," /* Comma */ || this.decimal_mark === "," /* Comma */) {
            imaginary_text = imaginary_text.replace(/\./, ",");
          }
          if (unit.real) {
            let real_text = unit.real.toString();
            if (convert_decimal === "," /* Comma */ || this.decimal_mark === "," /* Comma */) {
              real_text = real_text.replace(/\./, ",");
            }
            const i = Math.abs(unit.imaginary);
            return `${real_text}${unit.imaginary < 0 ? " - " : " + "}${i === 1 ? "" : imaginary_text}i`;
          } else if (unit.imaginary === -1) {
            return `-i`;
          } else if (unit.imaginary === 1) {
            return `i`;
          } else {
            return `${unit.imaginary < 0 ? "-" : ""}${imaginary_text}i`;
          }
        }
        break;
      case "literal":
        if (typeof unit.value === "string") {
          return '"' + unit.value.replace(/"/g, '""') + '"';
        } else if (convert_decimal && typeof unit.value === "number") {
          if (unit.text) {
            let text = unit.text;
            if (convert_decimal === "," /* Comma */ && this.decimal_mark === "." /* Period */) {
              text = text.replace(/,/g, "");
            }
            return text.replace(decimal_rex, decimal);
          } else {
            return unit.value.toString().replace(/\./, decimal);
          }
        } else if (unit.text)
          return unit.text;
        return unit.value.toString();
      case "identifier":
        return unit.name;
      case "operator":
        return "[" + unit.operator + "]";
      case "group":
        if (unit.explicit) {
          return "(" + unit.elements.map((x) => this.Render(x, options)).join(separator) + ")";
        } else {
          return unit.elements.map((x) => this.Render(x, options)).join(separator);
        }
      case "call":
        return unit.name + "(" + unit.args.map((x) => this.Render(x, options)).join(separator) + ")";
      case "dimensioned":
        return this.Render(unit.expression) + " " + this.Render(unit.unit);
      case "structured-reference": {
        let column = unit.column;
        if (/[^A-Za-z]/.test(column)) {
          column = "[" + column + "]";
        }
        let table = unit.table;
        if (!table && long_structured_references && table_name) {
          table = table_name;
        }
        switch (unit.scope) {
          case "all":
            return `${table}[[#all],${column}]`;
          case "row":
            if (long_structured_references) {
              return `${table}[[#this row],${column}]`;
            } else {
              return `${table}[@${column}]`;
            }
          case "column":
            return `${table}[${column}]`;
        }
        throw new Error("unhandled scope in structured reference");
      }
    }
    return "??";
  }
  /**
   * parses expression and returns the root of the parse tree, plus a
   * list of dependencies (addresses and ranges) found in the expression.
   *
   * NOTE that in the new address parsing structure, we will overlap ranges
   * and addresses (range corners). this is OK because ranges are mapped
   * to individual address dependencies. it's just sloppy (FIXME: refcount?)
   */
  Parse(expression) {
    expression = expression.trim();
    if (expression[0] === "=") {
      expression = expression.substr(1).trim();
    }
    this.expression = expression;
    this.data = [];
    this.length = expression.length;
    this.index = 0;
    this.valid = true;
    this.error_position = void 0;
    this.error = void 0;
    this.dependencies.addresses = {};
    this.dependencies.ranges = {};
    this.address_refcount = {};
    this.full_reference_list = [];
    this.id_counter = 0;
    switch (this.argument_separator) {
      case ";" /* Semicolon */:
        this.argument_separator_char = SEMICOLON;
        break;
      default:
        this.argument_separator_char = COMMA;
        break;
    }
    switch (this.decimal_mark) {
      case "," /* Comma */:
        this.decimal_mark_char = COMMA;
        break;
      default:
        this.decimal_mark_char = PERIOD;
        break;
    }
    for (let i = 0; i < this.length; i++) {
      this.data[i] = expression.charCodeAt(i);
    }
    const expr = this.ParseGeneric();
    const addresses = {};
    for (const key of Object.keys(this.dependencies.addresses)) {
      if (this.address_refcount[key]) {
        addresses[key] = this.dependencies.addresses[key];
      }
    }
    this.dependencies.addresses = addresses;
    return {
      expression: expr || void 0,
      valid: this.valid,
      error: this.error,
      error_position: this.error_position,
      dependencies: this.dependencies,
      separator: this.argument_separator,
      decimal_mark: this.decimal_mark,
      full_reference_list: this.full_reference_list.slice(0)
    };
  }
  /** generates column label ("A") from column index (0-based) */
  ColumnLabel(column) {
    if (column === Infinity) {
      return "";
    }
    let s = String.fromCharCode(65 + column % 26);
    while (column > 25) {
      column = Math.floor(column / 26) - 1;
      s = String.fromCharCode(65 + column % 26) + s;
    }
    return s;
  }
  /** generates address label ("C3") from address (0-based) */
  AddressLabel(address, offset) {
    let column = address.column;
    if (!address.absolute_column && address.column !== Infinity)
      column += offset.columns;
    let row = address.row;
    if (!address.absolute_row && address.row !== Infinity)
      row += offset.rows;
    if (row < 0 || column < 0 || row === Infinity && column === Infinity)
      return "#REF";
    let label = "";
    if (address.sheet) {
      label = (QuotedSheetNameRegex.test(address.sheet) ? "'" + address.sheet + "'" : address.sheet) + "!";
    }
    if (row === Infinity) {
      return label + (address.absolute_column ? "$" : "") + this.ColumnLabel(column);
    }
    if (column === Infinity) {
      return label + (address.absolute_row ? "$" : "") + (row + 1);
    }
    return label + (address.absolute_column ? "$" : "") + this.ColumnLabel(column) + (address.absolute_row ? "$" : "") + (row + 1);
  }
  /**
   * base parse routine; may recurse inside parens (either as grouped
   * operations or in function arguments).
   *
   * @param exit exit on specific characters
   */
  ParseGeneric(exit = [0]) {
    let stream = [];
    for (; this.index < this.length; ) {
      const unit = this.ParseNext(stream.length === 0);
      if (typeof unit === "number") {
        if (exit.some((test) => unit === test)) {
          break;
        } else if (unit === OPEN_PAREN) {
          this.index++;
          const group = this.ParseGeneric([CLOSE_PAREN]);
          this.index++;
          if (group) {
            stream.push({
              type: "group",
              id: this.id_counter++,
              elements: [group],
              explicit: true
            });
          }
        } else {
          const operator = this.ConsumeOperator();
          if (operator) {
            stream.push(operator);
          } else {
            this.error = `unexpected character [1]: ${String.fromCharCode(unit)}, 0x${unit.toString(16)}`;
            this.valid = false;
            this.index++;
          }
        }
      } else {
        stream.push(unit);
      }
    }
    if (stream.length) {
      stream = this.BinaryToRange2(stream);
      if (this.flags.fractions) {
        const rebuilt = [];
        const IsInteger = (test) => {
          return test.type === "literal" && typeof test.value === "number" && test.value % 1 === 0;
        };
        let i = 0;
        for (; i < stream.length - 3; i++) {
          if (IsInteger(stream[i]) && IsInteger(stream[i + 1]) && (stream[i + 2].type === "operator" && stream[i + 2].operator === "/") && IsInteger(stream[i + 3])) {
            const a = stream[i];
            const b = stream[i + 1];
            const c = stream[i + 3];
            const f = (a.value < 0 ? -1 : 1) * (b.value / c.value);
            i += 3;
            rebuilt.push({
              id: stream[i].id,
              type: "literal",
              text: this.expression.substring(a.position, c.position + 1),
              value: a.value + f,
              position: a.position
            });
          } else {
            rebuilt.push(stream[i]);
          }
        }
        for (; i < stream.length; i++) {
          rebuilt.push(stream[i]);
        }
        stream = rebuilt;
      }
      stream = stream.map((test) => {
        if (test.type === "identifier" && test.name === this.imaginary_number) {
          return {
            type: "complex",
            real: 0,
            imaginary: 1,
            position: test.position,
            text: test.name,
            id: this.id_counter++
          };
        }
        return test;
      });
      if (this.flags.dimensioned_quantities) {
        const rebuilt = [];
        let unit;
        for (let i = 0; i < stream.length; i++) {
          const entry = stream[i];
          if (!unit) {
            unit = entry;
          } else if (entry.type === "identifier" && (unit.type === "literal" || unit.type === "group" || unit.type === "call")) {
            const identifier = entry;
            while (stream[i + 1]?.type === "identifier") {
              identifier.name += " " + stream[++i].name;
            }
            rebuilt.push({
              type: "dimensioned",
              expression: unit,
              unit: entry,
              id: this.id_counter++
            });
            unit = void 0;
          } else {
            rebuilt.push(unit);
            unit = entry;
          }
        }
        if (unit) {
          rebuilt.push(unit);
        }
        stream = rebuilt;
      }
    }
    if (stream.length === 0)
      return null;
    if (stream.length === 1)
      return stream[0];
    return this.BinaryToComplex(this.ArrangeUnits(stream));
  }
  /**
   * helper function, @see BinaryToRange
   * @param unit 
   * @returns 
   */
  UnitToAddress(unit) {
    if (unit.type === "literal") {
      if (typeof unit.value === "number" && unit.value > 0 && !/\./.test(unit.text || "")) {
        return {
          type: "address",
          position: unit.position,
          label: unit.value.toString(),
          row: unit.value - 1,
          id: this.id_counter++,
          column: Infinity
        };
      }
    } else {
      let sheet;
      let name = unit.name;
      const tokens = name.split("!");
      if (tokens.length > 1) {
        sheet = tokens.slice(0, tokens.length - 1).join("!");
        name = name.substr(sheet.length + 1);
        if (sheet[0] === "'") {
          if (sheet.length > 1 && sheet[sheet.length - 1] === "'") {
            sheet = sheet.substr(1, sheet.length - 2);
          } else {
            return void 0;
          }
        }
      }
      const absolute = name[0] === "$";
      name = (absolute ? name.substr(1) : name).toUpperCase();
      const as_number = Number(name);
      if (!isNaN(as_number)) {
        if (as_number > 0 && as_number !== Infinity && !/\./.test(name)) {
          return {
            type: "address",
            position: unit.position,
            absolute_row: absolute,
            label: unit.name,
            row: as_number - 1,
            id: this.id_counter++,
            column: Infinity,
            sheet
          };
        }
      } else if (/[A-Z]{1,3}/.test(name)) {
        let column = -1;
        for (let i = 0; i < name.length; i++) {
          const char = name[i].charCodeAt(0);
          column = 26 * (1 + column) + (char - UC_A);
        }
        return {
          type: "address",
          position: unit.position,
          absolute_column: absolute,
          label: unit.name,
          column,
          id: this.id_counter++,
          row: Infinity,
          sheet
        };
      }
    }
    return void 0;
  }
  /**
   * rewrite of binary to range. this version operates on the initial stream,
   * which should be OK because range has the highest precedence so we would
   * never reorder a range.
   * 
   * ACTUALLY this will break in the case of 
   * 
   * -15:16 
   * 
   * (I think that's the only case). we can fix that though. this should
   * not impact the case of `2-15:16`, because in that case the - will look
   * like an operator and not part of the number. the same goes for a leading
   * `+` which will get dropped implicitly but has no effect (we might want
   * to preserve it for consistency though).
   * 
   * NOTE: that error existed in the old version, too, and this way is perhaps
   * better for fixing it. we should merge this into main.
   * 
   * 
   * old version comments:
   * ---
   * 
   * converts binary operations with a colon operator to ranges. this also
   * validates that there are no colon operations with non-address operands
   * (which is why it's called after precendence reordering; colon has the
   * highest preference). recursive only over binary ops AND unary ops.
   * 
   * NOTE: there are other legal arguments to a colon operator. specifically:
   * 
   * (1) two numbers, in either order
   *
   * 15:16
   * 16:16
   * 16:15
   *
   * (2) with one or both optionally having a $
   *
   * 15:$16
   * $16:$16
   *
   * (3) two column identifiers, in either order
   * 
   * A:F
   * B:A
   *
   * (4) and the same with $
   *
   * $A:F
   * $A:$F
   * 
   * because none of these are legal in any other context, we leave the 
   * default treatment of them UNLESS they are arguments to the colon 
   * operator, in which case we will grab them. that does mean we parse
   * them twice, but (...)
   * 
   * FIXME: will need some updated to rendering these, we don't have any
   * handler for rendering infinity
   */
  BinaryToRange2(stream) {
    const result = [];
    for (let i = 0; i < stream.length; i++) {
      const a = stream[i];
      const b = stream[i + 1];
      const c = stream[i + 2];
      let range;
      let label = "";
      let negative;
      if (a && b && c && b.type === "operator" && b.operator === ":") {
        if (a.type === "address" && c.type === "address") {
          const start_index = a.position + a.label.length;
          const end_index = c.position;
          range = {
            type: "range",
            id: this.id_counter++,
            position: a.position,
            start: a,
            end: c,
            label: a.label + this.expression.substring(start_index, end_index) + c.label
          };
          label = range.start.label + ":" + range.end.label;
          this.address_refcount[range.start.label]--;
          this.address_refcount[range.end.label]--;
          const positions = [a.position, c.position];
          this.full_reference_list = this.full_reference_list.filter((test) => {
            return test.position !== positions[0] && test.position !== positions[1];
          });
        } else if ((a.type === "literal" || a.type === "identifier") && (c.type === "literal" || c.type === "identifier")) {
          let left = this.UnitToAddress(a);
          if (!left && a.type === "literal" && typeof a.value === "number" && a.value < 0) {
            const test = {
              ...a,
              text: (a.text || "").replace(/^-/, ""),
              // <- ...sign always in position 0
              position: a.position + 1,
              // <- ...advance 1
              value: -a.value
              // <- ...invert value
            };
            left = this.UnitToAddress(test);
            if (left) {
              negative = {
                type: "operator",
                operator: "-",
                position: a.position,
                id: this.id_counter++
              };
            }
          }
          const right = this.UnitToAddress(c);
          if (left && right && (left.column === Infinity && right.column === Infinity || left.row === Infinity && right.row === Infinity)) {
            label = left.label + ":" + right.label;
            range = {
              type: "range",
              id: this.id_counter++,
              position: left.position,
              start: left,
              end: right,
              label
            };
          }
        }
      }
      if (range) {
        if (negative) {
          result.push(negative);
        }
        result.push(range);
        this.dependencies.ranges[label] = range;
        this.full_reference_list.push(range);
        i += 2;
      } else {
        result.push(a);
      }
    }
    return result;
  }
  /**
   * we've now come full circle. we started with handling ranges as 
   * binary operators; then we added complex composition as a first-pass
   * function; then we moved ranges to a first-pass function; and now we're
   * moving complex composition to a lower-level restructuring of binary
   * operations.
   * 
   * that allows better precedence handling for (potentially) ambiguous
   * constructions like =B3 * 2 + 3i. we do have parens, so.
   * 
   * @param unit 
   * @returns 
   */
  BinaryToComplex(unit) {
    if (unit.type === "binary") {
      if ((unit.operator === "+" || unit.operator === "-") && unit.left.type === "literal" && typeof unit.left.value === "number" && unit.right.type === "complex" && !unit.right.composited) {
        let text = "";
        text = this.expression.substring(unit.left.position, unit.right.position + (unit.right.text?.length || 0));
        let imaginary_value = unit.right.imaginary;
        if (unit.operator === "-") {
          imaginary_value = -imaginary_value;
        }
        return {
          type: "complex",
          position: unit.left.position,
          text,
          id: this.id_counter++,
          imaginary: imaginary_value,
          real: unit.left.value,
          composited: true
        };
      } else {
        unit.left = this.BinaryToComplex(unit.left);
        unit.right = this.BinaryToComplex(unit.right);
      }
    } else if (unit.type === "unary" && (unit.operator === "-" || unit.operator === "+") && unit.operand.type === "complex" && unit.operand.text === this.imaginary_number) {
      return {
        ...unit.operand,
        position: unit.position,
        text: this.expression.substring(unit.position, unit.operand.position + (unit.operand.text || "").length),
        imaginary: unit.operand.imaginary * (unit.operator === "-" ? -1 : 1)
      };
    }
    return unit;
  }
  /**
   * converts binary operations with a colon operator to ranges. this also
   * validates that there are no colon operations with non-address operands
   * (which is why it's called after precendence reordering; colon has the
   * highest preference). recursive only over binary ops AND unary ops.
   * 
   * NOTE: there are other legal arguments to a colon operator. specifically:
   * 
   * (1) two numbers, in either order
   *
   * 15:16
   * 16:16
   * 16:15
   *
   * (2) with one or both optionally having a $
   *
   * 15:$16
   * $16:$16
   *
   * (3) two column identifiers, in either order
   * 
   * A:F
   * B:A
   *
   * (4) and the same with $
   *
   * $A:F
   * $A:$F
   * 
   * because none of these are legal in any other context, we leave the 
   * default treatment of them UNLESS they are arguments to the colon 
   * operator, in which case we will grab them. that does mean we parse
   * them twice, but (...)
   * 
   * FIXME: will need some updated to rendering these, we don't have any
   * handler for rendering infinity
   */
  BinaryToRangeX(unit) {
    if (unit.type === "binary") {
      if (unit.operator === ":") {
        let range;
        let label = "";
        if (unit.left.type === "address" && unit.right.type === "address") {
          const start_index = unit.left.position + unit.left.label.length;
          const end_index = unit.right.position;
          range = {
            type: "range",
            id: this.id_counter++,
            position: unit.left.position,
            start: unit.left,
            end: unit.right,
            label: unit.left.label + this.expression.substring(start_index, end_index) + unit.right.label
          };
          label = range.start.label + ":" + range.end.label;
          this.address_refcount[range.start.label]--;
          this.address_refcount[range.end.label]--;
          const positions = [unit.left.position, unit.right.position];
          this.full_reference_list = this.full_reference_list.filter((test) => {
            return test.position !== positions[0] && test.position !== positions[1];
          });
        } else if ((unit.left.type === "literal" || unit.left.type === "identifier") && (unit.right.type === "literal" || unit.right.type === "identifier")) {
          const left = this.UnitToAddress(unit.left);
          const right = this.UnitToAddress(unit.right);
          if (left && right && (left.column === Infinity && right.column === Infinity || left.row === Infinity && right.row === Infinity)) {
            label = left.label + ":" + right.label;
            range = {
              type: "range",
              id: this.id_counter++,
              position: unit.left.position,
              start: left,
              end: right,
              label
            };
          }
        }
        if (range) {
          this.dependencies.ranges[label] = range;
          this.full_reference_list.push(range);
          return range;
        } else {
          this.error = `unexpected character: :`;
          this.valid = false;
        }
      }
      unit.left = this.BinaryToRangeX(unit.left);
      unit.right = this.BinaryToRangeX(unit.right);
    }
    return unit;
  }
  /**
   * reorders operations for precendence
   */
  ArrangeUnits(stream) {
    if (stream.length === 0)
      return { type: "missing", id: this.id_counter++ };
    if (stream.length === 1)
      return stream[0];
    const stack = [];
    for (let index = 0; index < stream.length; index++) {
      let element = stream[index];
      if (element.type === "operator") {
        if (stack.length === 0 || stack[stack.length - 1].type === "operator") {
          if (unary_operators[element.operator]) {
            const right = this.BinaryToComplex(this.ArrangeUnits(stream.slice(index + 1)));
            if (!this.valid) {
              return {
                type: "group",
                id: this.id_counter++,
                elements: stream,
                explicit: false
              };
            }
            if (right.type === "binary") {
              right.left = {
                type: "unary",
                id: this.id_counter++,
                operator: element.operator,
                operand: right.left,
                position: element.position
              };
              element = right;
            } else {
              element = {
                type: "unary",
                id: this.id_counter++,
                operator: element.operator,
                operand: right,
                position: element.position
              };
            }
            index = stream.length;
          } else {
            this.error = `unexpected character [2]: ${element.operator}`;
            this.error_position = element.position;
            this.valid = false;
            return {
              type: "group",
              id: this.id_counter++,
              elements: stream,
              explicit: false
            };
          }
        } else {
          stack.push(element);
          continue;
        }
      }
      if (stack.length < 2) {
        stack.push(element);
      } else if (stack[stack.length - 1].type === "operator") {
        const left = stack[stack.length - 2];
        const operator_unit = stack[stack.length - 1];
        const operator = operator_unit.operator;
        const operation = {
          type: "binary",
          id: this.id_counter++,
          left,
          operator,
          position: operator_unit.position,
          right: element
        };
        if (left.type === "binary" && binary_operators_precendence[operator] > binary_operators_precendence[left.operator]) {
          operation.left = left.left;
          operation.operator = left.operator;
          operation.position = left.position;
          operation.right = {
            type: "binary",
            id: this.id_counter++,
            left: left.right,
            // <- B
            right: element,
            // <- C
            operator,
            // <- op2
            position: operator_unit.position
          };
        }
        stack.splice(-2, 2, operation);
      } else {
        this.error = `multiple expressions`;
        this.error_position = element.position;
        this.valid = false;
        return {
          type: "group",
          id: this.id_counter++,
          elements: stream,
          explicit: false
        };
      }
    }
    return stack[0];
  }
  /**
   * parses literals and tokens from the stream, ignoring whitespace,
   * and stopping on unexpected tokens (generally operators or parens).
   *
   * @param naked treat -/+ as signs (part of numbers) rather than operators.
   */
  ParseNext(naked = true) {
    this.ConsumeWhiteSpace();
    const char = this.data[this.index];
    if (char === DOUBLE_QUOTE) {
      return {
        type: "literal",
        id: this.id_counter++,
        position: this.index,
        value: this.ConsumeString()
      };
    } else if (char >= ZERO && char <= NINE || char === this.decimal_mark_char) {
      return this.ConsumeNumber();
    } else if (char === OPEN_BRACE) {
      return this.ConsumeArray();
    } else if (naked && (char === MINUS || char === PLUS)) {
      const check = this.data[this.index + 1];
      if (check >= ZERO && check <= NINE || check === this.decimal_mark_char) {
        return this.ConsumeNumber();
      }
    } else if (char >= UC_A && char <= UC_Z || char >= LC_A && char <= LC_Z || char === UNDERSCORE || char === HASH || // new: only allowed in position 1, always an error
    char === SINGLE_QUOTE || char === DOLLAR_SIGN || // we used to not allow square brackets to start tokens, because
    // we only supported them for relative R1C1 references -- hence you'd
    // need the R first. but we now allow them for "structured references".
    char === OPEN_SQUARE_BRACKET || char >= ACCENTED_RANGE_START && char <= ACCENTED_RANGE_END) {
      return this.ConsumeToken(char);
    }
    return char;
  }
  ConsumeArray() {
    const expression = {
      type: "array",
      id: this.id_counter++,
      values: [],
      position: this.index
    };
    this.index++;
    let row = 0;
    let column = 0;
    while (this.index < this.length) {
      const item = this.ParseNext();
      const start_position = this.index;
      if (typeof item === "number") {
        this.index++;
        switch (item) {
          case SEMICOLON:
            column++;
            row = 0;
            break;
          case COMMA:
            row++;
            break;
          case CLOSE_BRACE:
            return expression;
          default:
            if (this.valid) {
              this.error = `invalid character in array literal`;
              this.error_position = start_position;
              this.valid = false;
            }
            break;
        }
      } else {
        switch (item.type) {
          case "literal":
            if (!expression.values[row]) {
              expression.values[row] = [];
            }
            expression.values[row][column] = item.value;
            break;
          default:
            if (this.valid) {
              this.error = `invalid value in array literal`;
              this.error_position = start_position;
              this.valid = false;
            }
            break;
        }
      }
    }
    return expression;
  }
  ConsumeOperator() {
    for (const operator of binary_operators) {
      if (this.expression.substr(this.index, operator.length) === operator) {
        const position = this.index;
        this.index += operator.length;
        return {
          type: "operator",
          id: this.id_counter++,
          operator,
          position
        };
      }
    }
    return null;
  }
  /** consume function arguments, which can be of any type */
  ConsumeArguments() {
    this.index++;
    let argument_index = 0;
    const args = [];
    for (; this.index < this.length; ) {
      const unit = this.ParseGeneric([
        this.argument_separator_char,
        CLOSE_PAREN
      ]);
      if (null !== unit)
        args.push(unit);
      const char = this.data[this.index];
      if (char === this.argument_separator_char) {
        this.index++;
        argument_index++;
        for (let i = args.length; i < argument_index; i++) {
          args.push({ type: "missing", id: this.id_counter++ });
        }
      } else if (char === CLOSE_PAREN) {
        this.index++;
        return args;
      }
    }
    return args;
  }
  /**
   * consume token. also checks for function call, because parens
   * have a different meaning (grouping/precedence) when they appear
   * not immediately after a token.
   *
   * regarding periods: as long as there's no intervening whitespace
   * or operator, period should be a valid token character. tokens
   * cannot start with a period.
   *
   * NOTE: that's true irrespective of decimal mark type.
   *
   * you can have tokens (addresses) with single quotes; these are used
   * to escape sheet names with spaces (which is a bad idea, but hey). this
   * should only be legal if the token starts with a single quote, and only
   * for one (closing) quote.
   * 
   * R1C1 relative notation uses square brackets, like =R2C[-1] or =R[-1]C[-2].
   * that's pretty easy to see. there's also regular R1C1, like =R1C1.
   * 
   * "structured references" use square brackets. they can start with 
   * square brackets -- in that case the table source is implicit (has to
   * be in the table). otherwise they look like =TableName[@ColumnName]. that
   * @ is optional and (I think) means don't spill.
   * 
   */
  ConsumeToken(initial_char) {
    const token = [initial_char];
    const position = this.index;
    let single_quote = initial_char === SINGLE_QUOTE;
    let square_bracket = 0;
    let braces = false;
    if (initial_char === OPEN_SQUARE_BRACKET) {
      square_bracket = 1;
      braces = true;
    }
    for (++this.index; this.index < this.length; this.index++) {
      const char = this.data[this.index];
      if (char >= UC_A && char <= UC_Z || char >= LC_A && char <= LC_Z || char >= ACCENTED_RANGE_START && char <= ACCENTED_RANGE_END || char === UNDERSCORE || char === DOLLAR_SIGN || char === PERIOD || char === EXCLAMATION_MARK || single_quote || // ((char === SINGLE_QUOTE || char === SPACE) && single_quote) ||
      char >= ZERO && char <= NINE || char === OPEN_SQUARE_BRACKET || square_bracket > 0 && char === CLOSE_SQUARE_BRACKET || char === MINUS && this.flags.r1c1 && square_bracket === 1 || square_bracket > 0 && char === AT && this.data[this.index - 1] === OPEN_SQUARE_BRACKET || square_bracket === 1 && (char === COMMA || char === SPACE) || square_bracket > 1) {
        token.push(char);
        if (char === OPEN_SQUARE_BRACKET) {
          square_bracket++;
          braces = true;
        }
        if (char === CLOSE_SQUARE_BRACKET) {
          square_bracket--;
        }
        if (char === SINGLE_QUOTE) {
          single_quote = false;
        }
      } else
        break;
    }
    const str = token.map((num) => String.fromCharCode(num)).join("");
    if (single_quote) {
      this.error = `unbalanced single quote`;
      this.error_position = position;
      this.valid = false;
      return {
        type: "identifier",
        id: this.id_counter++,
        name: str,
        position
      };
    }
    if (square_bracket) {
      this.error = `unbalanced square bracket`;
      this.error_position = position;
      this.valid = false;
      return {
        type: "identifier",
        id: this.id_counter++,
        name: str,
        position
      };
    }
    if (str.toLowerCase() === "true") {
      return {
        type: "literal",
        id: this.id_counter++,
        value: true,
        position
      };
    }
    if (str.toLowerCase() === "false") {
      return {
        type: "literal",
        id: this.id_counter++,
        value: false,
        position
      };
    }
    this.ConsumeWhiteSpace();
    const next_char = this.data[this.index];
    if (next_char === OPEN_PAREN) {
      const args = this.ConsumeArguments();
      return {
        type: "call",
        id: this.id_counter++,
        name: str,
        args,
        position
      };
    }
    if (this.flags.spreadsheet_semantics) {
      const address = this.ConsumeAddress(str, position);
      if (address)
        return address;
      if (braces) {
        const structured = this.ConsumeStructuredReference(str, position);
        if (structured) {
          return structured;
        }
      }
    }
    const identifier = {
      type: "identifier",
      id: this.id_counter++,
      name: str,
      position
    };
    this.full_reference_list.push(identifier);
    return identifier;
  }
  /**
   * like ConsumeAddress, look for a structured reference.
   */
  ConsumeStructuredReference(token, position) {
    const index = position;
    const token_length = token.length;
    const label = token;
    let table = "";
    let i = 0;
    for (; i < token_length; i++) {
      if (token[i] === "[") {
        token = token.substring(i);
        break;
      }
      table += token[i];
    }
    if (token[0] !== "[" || token[token.length - 1] !== "]") {
      return void 0;
    }
    token = token.substring(1, token.length - 1);
    const parts = token.split(",").map((part) => part.trim());
    let scope = "column";
    let column = "";
    if (parts.length > 2) {
      return void 0;
    } else if (parts.length === 2) {
      if (/\[#this row\]/i.test(parts[0])) {
        scope = "row";
      } else if (/\[#all\]/i.test(parts[0])) {
        scope = "all";
      }
      column = parts[1];
    } else {
      column = parts[0];
      if (column[0] === "@") {
        scope = "row";
        column = column.substring(1, column.length);
      }
    }
    if (column[0] === "[" && column[column.length - 1] === "]") {
      column = column.substring(1, column.length - 1);
    }
    const reference = {
      type: "structured-reference",
      id: this.id_counter++,
      label,
      position,
      scope,
      column,
      table
    };
    this.full_reference_list.push(reference);
    return reference;
  }
  /**
   * consumes address. this is outside of the normal parse flow;
   * we already have a token, here we're checking if it's an address.
   *
   * this used to check for ranges as well, but we now treat ranges as
   * an operation on two addresses; that supports whitespace between the
   * tokens.
   *
   * FIXME: that means we can now inline the column/row routines, since
   * they are not called more than once
   */
  ConsumeAddress(token, position) {
    const index = position;
    const token_length = token.length;
    let sheet;
    const tokens = token.split("!");
    if (tokens.length > 1) {
      sheet = tokens.slice(0, tokens.length - 1).join("!");
      position += sheet.length + 1;
    }
    if (this.flags.r1c1) {
      const match = tokens[tokens.length - 1].match(this.r1c1_regex);
      if (match) {
        const r1c1 = {
          type: "address",
          id: this.id_counter++,
          label: token,
          // TODO
          row: 0,
          column: 0,
          // absolute_row: false, // TODO: is this supported?
          // absolute_column: false, // TODO: is this supported?
          position: index,
          sheet,
          r1c1: true
        };
        if (match[1][0] === "[") {
          r1c1.offset_row = true;
          r1c1.row = Number(match[1].substring(1, match[1].length - 1));
        } else {
          r1c1.row = Number(match[1]) - 1;
        }
        if (match[2][0] === "[") {
          r1c1.offset_column = true;
          r1c1.column = Number(match[2].substring(1, match[2].length - 1));
        } else {
          r1c1.column = Number(match[2]) - 1;
        }
        return r1c1;
      }
    }
    const c = this.ConsumeAddressColumn(position);
    if (!c)
      return null;
    position = c.position;
    const r = this.ConsumeAddressRow(position);
    if (!r)
      return null;
    position = r.position;
    const label = sheet ? sheet + token.substr(sheet.length, position - index).toUpperCase() : token.substr(0, position - index).toUpperCase();
    if (sheet && sheet[0] === "'") {
      sheet = sheet.substr(1, sheet.length - 2);
    }
    const addr = {
      type: "address",
      id: this.id_counter++,
      label,
      // : token.substr(0, position - index).toUpperCase(),
      row: r.row,
      column: c.column,
      absolute_row: r.absolute,
      absolute_column: c.absolute,
      position: index,
      sheet
    };
    if (token_length !== position - index)
      return null;
    this.dependencies.addresses[addr.label] = addr;
    this.address_refcount[addr.label] = (this.address_refcount[addr.label] || 0) + 1;
    this.full_reference_list.push(addr);
    return addr;
  }
  /**
   * consumes a row, possibly absolute ($). returns the numeric row
   * (0-based) and metadata
   */
  ConsumeAddressRow(position) {
    const absolute = this.data[position] === DOLLAR_SIGN;
    if (absolute)
      position++;
    const start = position;
    let value = 0;
    for (; ; position++) {
      const char = this.data[position];
      if (char >= ZERO && char <= NINE) {
        value *= 10;
        value += char - ZERO;
      } else
        break;
    }
    if (start === position)
      return false;
    return { absolute, row: value - 1, position };
  }
  /**
   * consumes a column, possibly absolute ($). returns the numeric
   * column (0-based) and metadata
   */
  ConsumeAddressColumn(position) {
    let column = -1;
    let length = 0;
    const absolute = this.data[position] === DOLLAR_SIGN;
    if (absolute)
      position++;
    for (; ; position++, length++) {
      if (length >= 4)
        return false;
      const char = this.data[position];
      if (char >= UC_A && char <= UC_Z) {
        column = 26 * (1 + column) + (char - UC_A);
      } else if (char >= LC_A && char <= LC_Z) {
        column = 26 * (1 + column) + (char - LC_A);
      } else
        break;
    }
    if (column < 0)
      return false;
    return { absolute, column, position };
  }
  /**
   * consumes number. supported formats (WIP):
   *
   * -3
   * +3
   * 100.9
   * 10.0%
   * 1e-2.2
   *
   * ~1,333,123.22~
   *
   * UPDATE: commas (separators) are not acceptable in numbers passed
   * in formulae, can't distinguish between them and function argument
   * separators.
   *
   * regarding the above, a couple of rules:
   *
   * 1. +/- is only legal in position 0 or immediately after e/E
   * 2. only one decimal point is allowed.
   * 3. any number of separators, in any position, are legal, but
   *    only before the decimal point.
   * 4. only one % is allowed, and only in the last position
   *
   * NOTE: this is probably going to break on unfinished strings that
   * end in - or +... if they're not treated as operators...
   *
   * FIXME: find test cases for that so we can fix it
   *
   * UPDATE: exporting original text string for preservation/insertion.
   * this function now returns a tuple of [value, text].
   *
   * UPDATE: we now (at least in a branch) consume complex numbers. the last 
   * element of the return array is a boolean which is set if the value is an 
   * imaginary number. when parsing, we will only see the imaginary part; 
   * we'll use a separate step to put complex numbers together.
   * 
   * 
   */
  ConsumeNumber() {
    const starting_position = this.index;
    let exponent = 0;
    let negative_exponent = false;
    let negative = false;
    let integer = 0;
    let decimal = 0;
    let fraction = 0;
    let state = "integer";
    let position = 0;
    let imaginary = false;
    const start_index = this.index;
    for (; this.index < this.length; this.index++, position++) {
      const char = this.data[this.index];
      if (char === this.decimal_mark_char) {
        if (state === "integer")
          state = "fraction";
        else
          break;
      } else if (char === PERCENT) {
        integer /= 100;
        fraction /= 100;
        this.index++;
        break;
      } else if (char === PLUS || char === MINUS) {
        if (position === 0) {
          if (char === MINUS)
            negative = true;
        } else
          break;
      } else if (char === UC_E || char === LC_E) {
        if (state === "integer" || state === "fraction") {
          state = "exponent";
          if (this.index < this.length - 1) {
            if (this.data[this.index + 1] === PLUS)
              this.index++;
            else if (this.data[this.index + 1] === MINUS) {
              this.index++;
              negative_exponent = true;
            }
          }
        } else
          break;
      } else if (char === this.imaginary_char) {
        const peek = this.data[this.index + 1];
        if (peek >= UC_A && peek <= UC_Z || peek >= LC_A && peek <= LC_Z || peek >= ACCENTED_RANGE_START && peek <= ACCENTED_RANGE_END || peek === UNDERSCORE) {
          break;
        }
        if (state === "integer" || state === "fraction") {
          this.index++;
          imaginary = true;
          break;
        }
      } else if (char >= ZERO && char <= NINE) {
        switch (state) {
          case "integer":
            integer = integer * 10 + (char - ZERO);
            break;
          case "fraction":
            fraction = fraction * 10 + (char - ZERO);
            decimal++;
            break;
          case "exponent":
            exponent = exponent * 10 + (char - ZERO);
            break;
        }
      } else
        break;
    }
    let value = integer + fraction / Math.pow(10, decimal);
    if (state === "exponent") {
      value = value * Math.pow(10, (negative_exponent ? -1 : 1) * exponent);
    }
    if (imaginary) {
      return {
        type: "complex",
        id: this.id_counter++,
        position: starting_position,
        imaginary: negative ? -value : value,
        real: 0,
        text: this.expression.substring(start_index, this.index) || ""
      };
    } else {
      return {
        type: "literal",
        id: this.id_counter++,
        position: starting_position,
        value: negative ? -value : value,
        text: this.expression.substring(start_index, this.index) || ""
      };
    }
  }
  /**
   * in spreadsheet language ONLY double-quoted strings are legal. there
   * are no escape characters, and a backslash is a legal character. to
   * embed a quotation mark, use "" (double-double quote); that's an escaped
   * double-quote.
   */
  ConsumeString() {
    this.index++;
    const str = [];
    for (; this.index < this.length; this.index++) {
      const char = this.data[this.index];
      if (char === DOUBLE_QUOTE) {
        this.index++;
        if (this.index >= this.length || this.data[this.index] !== DOUBLE_QUOTE) {
          break;
        }
      }
      str.push(char);
    }
    return str.map((char) => String.fromCharCode(char)).join("");
  }
  /** run through any intervening whitespace */
  ConsumeWhiteSpace() {
    for (; this.index < this.length; ) {
      const char = this.data[this.index];
      if (char === SPACE || char === TAB || char === CR || char === LF || char === NON_BREAKING_SPACE) {
        this.index++;
      } else
        return;
    }
  }
};

// treb-parser/src/csv-parser.ts
var ParseCSV = (text, delimiter = ",") => {
  let state = 0 /* default */;
  let record = [];
  let field = "";
  const records = [];
  const length = text.length;
  if (/[\r\n"]/.test(delimiter)) {
    throw new Error("invalid delimiter");
  }
  for (let i = 0; i < length; i++) {
    const char = text[i];
    if (i === 0 && char.charCodeAt(0) === 65279) {
      continue;
    }
    if (state === 0 /* default */) {
      switch (char) {
        case delimiter:
          record.push(field);
          field = "";
          break;
        case "\r":
          break;
        case "\n":
          record.push(field);
          field = "";
          records.push(record);
          record = [];
          break;
        case '"':
          if (field.length === 0) {
            state = 1 /* quoted */;
          } else {
            field += char;
          }
          break;
        default:
          field += char;
          break;
      }
    } else {
      if (char === '"') {
        if (i + 1 < length && text[i + 1] === '"') {
          field += '"';
          i++;
        } else {
          state = 0 /* default */;
        }
      } else
        field += char;
    }
  }
  if (record.length || field.length) {
    record.push(field);
    records.push(record);
  }
  return records;
};

// treb-parser/src/md-parser.ts
var MDParser = class _MDParser {
  static _instance = new _MDParser();
  constructor() {
  }
  static get instance() {
    return this._instance;
  }
  /**
   * given some formatted text (output of the `Parse` method), return HTML.
   * FIXME: is this used outside of testing? seems like we're wasting bytes.
   * 
   * also the way this works adds extra tags if you have nested styles. not
   * an issue if it's just for testing though.
   */
  HTML(formatted) {
    const lines = [];
    for (const line of formatted) {
      const text = [];
      for (const element of line) {
        if (element.pre) {
          text.push("<pre>");
        }
        if (element.emphasis) {
          text.push("<em>");
        }
        if (element.strong) {
          text.push("<strong>");
        }
        if (element.strike) {
          text.push("<strike>");
        }
        text.push(element.text);
        if (element.strike) {
          text.push("</strike>");
        }
        if (element.strong) {
          text.push("</strong>");
        }
        if (element.emphasis) {
          text.push("</em>");
        }
        if (element.pre) {
          text.push("</pre>");
        }
      }
      lines.push(text.join(""));
    }
    return lines.join("<br/>\n");
  }
  /**
   * this is a replacement for the Parse() method, if you don't actually
   * want to parse markdown. the aim is to have a unified result format,
   * even if we're not handling md. 
   */
  Dummy(text = "") {
    return text.split(/\n/).map((text2) => [{ text: text2 }]);
  }
  /**
   * given some input text, creates a set of text tokens with 
   * emphasis/strong emphasis applied. splits into lines (the 
   * outer array). whitespace (other than newlines) is preserved.
   */
  Parse(text = "") {
    const tokens = this.Tokenize(text);
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (token.type === "delimeter") {
        const preceding = tokens[i - 1];
        const following = tokens[i + 1];
        const preceded_by_whitespace = !preceding || preceding.type === "whitespace" || preceding.type === "newline";
        const preceded_by_punctuation = preceding && preceding.type === "text" && /[^\w\d]$/.test(preceding.text);
        const followed_by_whitespace = !following || following.type === "whitespace" || following.type === "newline";
        const followed_by_punctuation = following && following.type === "text" && /^[^\w\d]/.test(following.text);
        token.left_flanking = !followed_by_whitespace && (!followed_by_punctuation || preceded_by_whitespace);
        token.right_flanking = !preceded_by_whitespace && (!preceded_by_punctuation || (followed_by_whitespace || followed_by_punctuation));
      }
    }
    this.ApplyFormatting(tokens);
    return this.Consolidate(tokens);
  }
  /** is this worth a function call? will it get inlined? */
  IsWhitespace(char) {
    return char === " " || char === "	";
  }
  /** is this worth a function call? will it get inlined? */
  IsNewline(char) {
    return char === "\r" || char === "\n";
  }
  /** is this worth a function call? will it get inlined? */
  IsDelimeter(char) {
    return char === "*" || char === "_" || char === "~";
  }
  /**
   * consolidate text with common formatting. splits into lines (newlines are not rendered).
   */
  Consolidate(tokens) {
    const result = [];
    const format = {};
    let line = [];
    let current_token = { type: "text", text: "" };
    for (const token of tokens) {
      if (token.type === "newline") {
        if (current_token.text.length) {
          line.push(current_token);
        }
        current_token = { ...format, text: "", type: "text" };
        result.push(line);
        line = [];
      } else {
        if (!!format.strong !== !!token.strong || !!format.emphasis !== !!token.emphasis || !!format.strike !== !!token.strike) {
          format.strong = !!token.strong;
          format.emphasis = !!token.emphasis;
          format.strike = !!token.strike;
          if (current_token.text.length) {
            line.push(current_token);
          }
          current_token = { ...format, text: "", type: "text" };
        }
        switch (token.type) {
          case "text":
          case "whitespace":
            current_token.text += token.text;
            break;
          case "delimeter":
            for (let i = 0; i < token.length; i++) {
              current_token.text += token.char;
            }
            break;
        }
      }
    }
    if (current_token.text.length) {
      line.push(current_token);
    }
    if (line.length) {
      result.push(line);
    }
    return result;
  }
  /**
   *
   */
  ApplyFormatting(tokens, open) {
    let index = 0;
    const length = tokens.length;
    for (index = 0; index < length; index++) {
      const token = tokens[index];
      if (token.type === "delimeter") {
        if (open && token.right_flanking && open.char === token.char && token.length > 0) {
          return { index, token };
        }
        if (token.left_flanking) {
          const result = this.ApplyFormatting(tokens.slice(index + 1), token);
          if (result.token) {
            const format = Math.min(result.token.length, token.length);
            const strike = token.char === "~";
            const emphasis = !strike && !!(format % 2);
            const strong = !strike && format >= 2;
            for (let i = index + 1; i <= index + result.index; i++) {
              tokens[i].strong = !!tokens[i].strong || strong;
              tokens[i].emphasis = !!tokens[i].emphasis || emphasis;
              tokens[i].strike = !!tokens[i].strike || strike;
            }
            result.token.length -= format;
            token.length -= format;
            if (token.length > 0) {
              index--;
            } else {
              index += result.index;
            }
          }
        }
      }
    }
    return { index };
  }
  /**
   * 
   */
  Tokenize(text = "") {
    const tokens = [];
    const length = text.length;
    let index = 0;
    let escape = false;
    let current_token = "";
    for (index = 0; index < length; index++) {
      const char = text[index];
      if (this.IsWhitespace(char)) {
        if (current_token) {
          tokens.push({ type: "text", text: current_token });
        }
        let tmp = char;
        for (; ; ) {
          const next_char = text[index + 1];
          if (this.IsWhitespace(next_char)) {
            tmp += next_char;
            index++;
          } else {
            break;
          }
        }
        tokens.push({
          type: "whitespace",
          text: tmp
        });
        escape = false;
        current_token = "";
      } else if (this.IsNewline(char)) {
        if (current_token) {
          tokens.push({ type: "text", text: current_token });
        }
        let tmp = char;
        for (; ; ) {
          const next_char = text[index + 1];
          if (this.IsNewline(next_char)) {
            tmp += next_char;
            index++;
          } else {
            break;
          }
        }
        tokens.push({
          type: "newline",
          text: tmp
        });
        escape = false;
        current_token = "";
      } else if (escape) {
        current_token += char;
        escape = false;
      } else if (this.IsDelimeter(char)) {
        if (current_token) {
          tokens.push({ type: "text", text: current_token });
        }
        let tmp = char;
        for (; ; ) {
          const next_char = text[index + 1];
          if (next_char === char) {
            tmp += next_char;
            index++;
          } else {
            break;
          }
        }
        tokens.push({
          type: "delimeter",
          text: tmp,
          char,
          length: tmp.length
        });
        escape = false;
        current_token = "";
      } else if (char === "\\") {
        escape = true;
      } else {
        current_token += char;
      }
    }
    if (current_token) {
      tokens.push({ type: "text", text: current_token });
    }
    return tokens;
  }
};

// treb-format/src/number_format_section.ts
var NumberFormatSection = class {
  /** flag: this is a date format */
  date_format = false;
  /** flag: this is the string section, don't format numbers */
  string_format = false;
  /** flag: this is a fractional format */
  fraction_format = false;
  /** flag: time in 12-hour format  */
  twelve_hour = false;
  /** fraction: fixed denominator */
  fraction_denominator = 0;
  /** fraction includes integer */
  fraction_integer = true;
  /** align fraction digits (using ???) [TODO] */
  fraction_align = 0;
  /** 
   * fraction denominator digits. we will limit to [1,4] but this can
   * be zero if there's an explicit denominator.
   */
  fraction_denominator_digits = 0;
  /** prepend zeros */
  integer_min_digits = 0;
  /** append zeros */
  decimal_min_digits = 0;
  /** append decimal digits, but not trailing zeros */
  decimal_max_digits = 0;
  /** use grouping (only supports groups of 3, no matter where you put the ,) */
  grouping = false;
  /** this is a flag for switching whether we append strings to prefix or suffix */
  has_number_format = false;
  /** leading string(s) */
  prefix = [{ text: "" }];
  /** trailing string(s) */
  suffix = [{ text: "" }];
  /**
   * thousands scaling (trailing commas in the number format section). we set
   * to zero for a faster flag if no scaling.
   */
  scaling = 0;
  /** flag indicating percent -- will multiply value by 100 */
  percent = false;
  /** flag indicating exponential -- turns numbers in to exp format */
  exponential = false;
  /** this is a flag for testing -- we don't support multiple * in a format */
  has_asterisk = false;
};

// treb-format/src/format_parser.ts
var ASTERISK = 42;
var UNDERSCORE2 = 95;
var QUESTION_MARK = 63;
var ZERO2 = 48;
var PERIOD2 = 46;
var COMMA2 = 44;
var PERCENT2 = 37;
var DOUBLE_QUOTE2 = 34;
var NUMBER_SIGN = 35;
var SEMICOLON2 = 59;
var BACKSLASH = 92;
var AT2 = 64;
var LEFT_BRACE = 91;
var RIGHT_BRACE = 93;
var UPPERCASE_E = 69;
var LOWERCASE_E = 101;
var UPPERCASE_H = 72;
var LOWERCASE_H = 104;
var UPPERCASE_M = 77;
var LOWERCASE_M = 109;
var UPPERCASE_S = 83;
var LOWERCASE_S = 115;
var UPPERCASE_D = 68;
var LOWERCASE_D = 100;
var UPPERCASE_Y = 89;
var LOWERCASE_Y = 121;
var UPPERCASE_A = 65;
var LOWERCASE_A = 97;
var FormatParser = class {
  static date_pattern = false;
  static pattern = "";
  static char_index = 0;
  static characters = [];
  static sections = [];
  static current_section = new NumberFormatSection();
  static preserve_formatting_characters = false;
  // true;
  // FIXME: localization
  static decimal_mark = PERIOD2;
  static group_separator = COMMA2;
  /**
   * parser is static (essentially a singleton). state is ephemeral.
   *
   * it's a little hard to unify parsing for dates and numbers.
   * luckily we don't have to parse that often; only when a format
   * is created. so we will do some extra work here.
   */
  static Parse(pattern) {
    this.pattern = pattern;
    this.characters = pattern.split("").map((char) => char.charCodeAt(0));
    this.char_index = 0;
    this.current_section = new NumberFormatSection();
    this.sections = [this.current_section];
    if (this.ParseDatePattern()) {
      return this.sections;
    }
    this.char_index = 0;
    this.current_section = new NumberFormatSection();
    this.sections = [this.current_section];
    while (this.char_index < this.characters.length) {
      this.ConsumeChar();
    }
    return this.sections;
  }
  static ConsumeString() {
    let text = "";
    if (this.preserve_formatting_characters) {
      text += this.pattern[this.char_index];
    }
    for (++this.char_index; this.char_index < this.characters.length; this.char_index++) {
      const char = this.characters[this.char_index];
      switch (char) {
        case BACKSLASH:
          if (this.preserve_formatting_characters) {
            text += this.pattern[this.char_index];
          }
          if (this.char_index + 1 < this.characters.length) {
            text += this.pattern[++this.char_index];
          }
          break;
        case DOUBLE_QUOTE2:
          if (this.preserve_formatting_characters) {
            text += this.pattern[this.char_index];
          }
          this.char_index++;
          return text;
        default:
          text += this.pattern[this.char_index];
          break;
      }
    }
    throw new Error("unterminated string");
  }
  static ConsumeFormatting() {
    let text = "";
    for (++this.char_index; this.char_index < this.characters.length; this.char_index++) {
      const char = this.characters[this.char_index];
      switch (char) {
        case BACKSLASH:
          throw new Error("invalid escape character in formatting block");
        case RIGHT_BRACE:
          this.char_index++;
          return text;
        default:
          text += this.pattern[this.char_index];
          break;
      }
    }
    throw new Error("unterminated format");
  }
  /** 
   * pre-scan for fractional format, check for legal/illegal chars.
   * fraction format has an optional integer, spaces, then the fractional
   * part. 
   * 
   * except for the denominator, all characters are represented as # or ?, 
   * but formats seem to be a little forgiving (not sure we have to be). 
   * essentially, should look something like
   * ```
   * # ##/##
   * ? ??/??
   * #/32
   * #/64
   * # #/16
   * ```
   */
  static ScanFractionFormat() {
    const fraction_regex = /^([#?]+ +){0,1}([#?]+)\/([#?0-9]+)(?:$|[^#?0-9])/;
    const text = this.pattern.substr(this.char_index);
    const match = text.match(fraction_regex);
    if (!match) {
      return false;
    }
    const len = (match[1] || "").length + match[2].length + match[3].length + 1;
    this.current_section.fraction_format = true;
    this.current_section.fraction_integer = !!match[1];
    const fixed_denominator = Number(match[3]);
    if (!isNaN(fixed_denominator)) {
      this.current_section.fraction_denominator = fixed_denominator;
    }
    this.current_section.decimal_max_digits = this.current_section.fraction_denominator_digits = match[3].length;
    this.char_index += len;
    this.current_section.has_number_format = true;
    return true;
  }
  /**
   * number format proper contains only the following characters:
   * +-0#.,
   * anything else will be ignored
   * 
   * [UPDATE] fractional number formats can contain spaces and 
   * the / character (in fact they would have to contain that).
   * 
   */
  static ConsumeNumberFormat() {
    let number_part = 0 /* Integer */;
    for (this.char_index; this.char_index < this.characters.length; this.char_index++) {
      const char = this.characters[this.char_index];
      switch (char) {
        case this.group_separator:
          {
            let lookahead_digit = false;
            for (let i = this.char_index + 1; !lookahead_digit && i < this.characters.length; i++) {
              const next_char = this.characters[i];
              if (next_char === this.decimal_mark || next_char === NUMBER_SIGN || next_char === ZERO2) {
                lookahead_digit = true;
              } else if (next_char !== COMMA2) {
                break;
              }
            }
            if (lookahead_digit) {
              if (number_part === 1 /* Decimal */) {
                throw new Error("invalid grouping in decimal part");
              }
              this.current_section.grouping = true;
            } else {
              this.current_section.scaling = (this.current_section.scaling || 1) * 1e3;
            }
          }
          break;
        case this.decimal_mark:
          if (number_part === 1 /* Decimal */) {
            throw new Error("too many decimal marks");
          }
          number_part = 1 /* Decimal */;
          break;
        case NUMBER_SIGN:
          if (number_part === 1 /* Decimal */) {
            this.current_section.decimal_max_digits++;
          } else if (this.current_section.integer_min_digits) {
            this.current_section.integer_min_digits++;
          }
          break;
        case ZERO2:
          if (number_part === 1 /* Decimal */) {
            this.current_section.decimal_max_digits++;
            this.current_section.decimal_min_digits = this.current_section.decimal_max_digits;
          } else {
            this.current_section.integer_min_digits++;
          }
          break;
        default:
          return;
      }
    }
  }
  static AppendCharAsText(advance_pointer = true) {
    if (this.current_section.has_number_format) {
      this.current_section.suffix[this.current_section.suffix.length - 1].text += this.pattern[this.char_index];
    } else {
      this.current_section.prefix[this.current_section.prefix.length - 1].text += this.pattern[this.char_index];
    }
    if (advance_pointer) {
      this.char_index++;
    }
  }
  static AppendString(text) {
    if (this.current_section.has_number_format) {
      this.current_section.suffix[this.current_section.suffix.length - 1].text += text;
    } else {
      this.current_section.prefix[this.current_section.prefix.length - 1].text += text;
    }
  }
  static AppendTextPart(part) {
    if (this.current_section.has_number_format) {
      this.current_section.suffix.push(part);
      this.current_section.suffix.push({ text: "" });
    } else {
      this.current_section.prefix.push(part);
      this.current_section.prefix.push({ text: "" });
    }
  }
  static ConsumeChar() {
    const char = this.characters[this.char_index];
    if (char === QUESTION_MARK || char === NUMBER_SIGN) {
      if (!this.current_section.has_number_format && !this.current_section.string_format && this.ScanFractionFormat()) {
        return;
      }
    }
    switch (char) {
      case SEMICOLON2:
        this.char_index++;
        this.current_section = new NumberFormatSection();
        if (this.sections.length === 3)
          this.current_section.string_format = true;
        this.sections.push(this.current_section);
        break;
      case AT2:
        this.char_index++;
        this.AppendTextPart({
          text: "@",
          flag: 5 /* literal */
        });
        this.current_section.string_format = true;
        break;
      case ZERO2:
      case NUMBER_SIGN:
      case PERIOD2:
      case COMMA2:
        if (!this.current_section.has_number_format && !this.current_section.string_format) {
          this.ConsumeNumberFormat();
          this.current_section.has_number_format = true;
        } else {
          this.AppendCharAsText();
        }
        break;
      case LEFT_BRACE:
        this.AppendTextPart({ text: this.ConsumeFormatting(), flag: 6 /* formatting */ });
        break;
      case DOUBLE_QUOTE2:
        this.AppendString(this.ConsumeString());
        break;
      case QUESTION_MARK:
        if (this.preserve_formatting_characters) {
          this.AppendCharAsText();
        } else {
          this.AppendTextPart({
            text: "0",
            flag: 1 /* hidden */
          });
          this.char_index++;
        }
        break;
      case UNDERSCORE2:
        if (this.preserve_formatting_characters) {
          this.AppendCharAsText();
        } else {
          if (++this.char_index >= this.characters.length) {
            throw new Error("invalid pad character at end");
          }
          this.AppendTextPart({
            text: this.pattern[this.char_index++],
            flag: 1 /* hidden */
          });
        }
        break;
      case ASTERISK:
        if (this.current_section.has_asterisk) {
          throw new Error(`we don't support multiple asterisks`);
        }
        if (this.preserve_formatting_characters) {
          this.AppendCharAsText();
        } else {
          if (++this.char_index >= this.characters.length) {
            throw new Error("invalid pad character at end");
          }
          this.AppendTextPart({
            text: this.pattern[this.char_index++],
            flag: 2 /* padded */
          });
          this.current_section.has_asterisk = true;
        }
        break;
      case LOWERCASE_E:
      case UPPERCASE_E:
        if (this.current_section.percent || this.current_section.exponential || this.current_section.string_format) {
          this.AppendCharAsText();
        } else {
          this.current_section.exponential = true;
          this.char_index++;
        }
        break;
      case PERCENT2:
        if (!this.current_section.exponential && !this.current_section.string_format) {
          this.current_section.percent = true;
        }
        this.AppendCharAsText();
        break;
      case BACKSLASH:
        if (this.preserve_formatting_characters) {
          this.AppendCharAsText(false);
        }
        if (++this.char_index >= this.characters.length) {
          throw new Error("invalid escape character at end");
        }
        this.AppendCharAsText();
        break;
      default:
        this.AppendCharAsText();
    }
  }
  /**
   * we treat it as a date pattern if there's an unquoted date/time letter
   * (one of [hmsdyHMSDY]). technically mixing date formats and number
   * formats (#0) is illegal. we will just drop into number formats for those.
   */
  static ParseDatePattern() {
    this.date_pattern = true;
    while (this.date_pattern && this.char_index < this.pattern.length) {
      this.DatePatternConsumeChar();
    }
    if (this.date_pattern) {
      this.date_pattern = false;
      for (const section of this.sections) {
        for (const part of section.prefix) {
          if (part.flag && part.flag & (3 /* date_component */ | 4 /* date_component_minutes */)) {
            this.date_pattern = true;
          }
        }
      }
    }
    if (this.date_pattern) {
      this.sections[0].date_format = true;
      this.sections[0].prefix.forEach((item, index) => {
        if (item.flag === 3 /* date_component */ && (item.text === "mm" || item.text === "m")) {
          if (index) {
            for (let i = index - 1; i; i--) {
              const test = this.sections[0].prefix[i];
              if (test.flag === 3 /* date_component */) {
                if (/h/i.test(test.text)) {
                  item.flag = 4 /* date_component_minutes */;
                  item.text = item.text.toLowerCase();
                }
                break;
              }
            }
          }
          if (index < this.sections[0].prefix.length - 1) {
            for (let i = index + 1; i < this.sections[0].prefix.length; i++) {
              const test = this.sections[0].prefix[i];
              if (test.flag === 3 /* date_component */) {
                if (/s/i.test(test.text)) {
                  item.flag = 4 /* date_component_minutes */;
                  item.text = item.text.toLowerCase();
                }
                break;
              }
            }
          }
        }
      });
    }
    return this.date_pattern;
  }
  /**
   * date parts are repeated sequences (e.g. ddd). we allow
   * fractional seconds with ss.00.
   */
  static ConsumeDatePart() {
    const initial_char = this.pattern[this.char_index++];
    const normalized = initial_char.toLowerCase();
    const part = {
      text: initial_char,
      flag: 3 /* date_component */
    };
    while (this.pattern[this.char_index] && this.pattern[this.char_index].toLowerCase() === normalized) {
      part.text += this.pattern[this.char_index++];
    }
    if (normalized === "s" && this.pattern[this.char_index] === ".") {
      part.text += this.pattern[this.char_index++];
      while (this.pattern[this.char_index] === "0") {
        part.text += this.pattern[this.char_index++];
      }
    }
    return part;
  }
  /**
   * special patterns for am/pm in date formats
   */
  static ConsumeAMPM() {
    let test = this.pattern.substr(this.char_index, 5);
    if (test === "am/pm" || test === "AM/PM") {
      this.char_index += 5;
      this.sections[0].twelve_hour = true;
      return { text: test, flag: 3 /* date_component */ };
    }
    test = this.pattern.substr(this.char_index, 3);
    if (test === "a/p" || test === "A/P") {
      this.char_index += 3;
      this.sections[0].twelve_hour = true;
      return { text: test, flag: 3 /* date_component */ };
    }
    return void 0;
  }
  static DatePatternConsumeChar() {
    const char = this.characters[this.char_index];
    switch (char) {
      case SEMICOLON2:
        this.char_index = this.characters.length;
        break;
      case ZERO2:
      case NUMBER_SIGN:
      case LOWERCASE_E:
      case UPPERCASE_E:
      case PERCENT2:
      case AT2:
        this.date_pattern = false;
        break;
      case UPPERCASE_H:
      case LOWERCASE_H:
      case UPPERCASE_M:
      case LOWERCASE_M:
      case UPPERCASE_S:
      case LOWERCASE_S:
      case UPPERCASE_D:
      case LOWERCASE_D:
      case UPPERCASE_Y:
      case LOWERCASE_Y:
        this.AppendTextPart(this.ConsumeDatePart());
        break;
      case UPPERCASE_A:
      case LOWERCASE_A:
        {
          const ampm = this.ConsumeAMPM();
          if (ampm)
            this.AppendTextPart(ampm);
          else
            this.AppendCharAsText();
        }
        break;
      case DOUBLE_QUOTE2:
        this.AppendString(this.ConsumeString());
        break;
      case QUESTION_MARK:
        if (this.preserve_formatting_characters) {
          this.AppendCharAsText();
        } else {
          this.AppendTextPart({
            text: "0",
            flag: 1 /* hidden */
          });
          this.char_index++;
        }
        break;
      case UNDERSCORE2:
        if (this.preserve_formatting_characters) {
          this.AppendCharAsText();
        } else {
          if (++this.char_index >= this.characters.length) {
            throw new Error("invalid pad character at end");
          }
          this.AppendTextPart({
            text: this.pattern[this.char_index++],
            flag: 1 /* hidden */
          });
        }
        break;
      case ASTERISK:
        if (this.current_section.has_asterisk) {
          throw new Error(`we don't support multiple asterisks`);
        }
        if (this.preserve_formatting_characters) {
          this.AppendCharAsText();
        } else {
          if (++this.char_index >= this.characters.length) {
            throw new Error("invalid pad character at end");
          }
          this.AppendTextPart({
            text: this.pattern[this.char_index++],
            flag: 2 /* padded */
          });
          this.current_section.has_asterisk = true;
        }
        break;
      case BACKSLASH:
        if (this.preserve_formatting_characters) {
          this.AppendCharAsText(false);
        }
        if (++this.char_index >= this.characters.length) {
          throw new Error("invalid escape character at end");
        }
        this.AppendCharAsText();
        break;
      default:
        this.AppendCharAsText();
    }
  }
};

// treb-format/src/format.ts
var LotusDate = (value) => {
  if (value >= 60)
    value--;
  return new Date(-22090752e5 + 864e5 * value);
};
var UnlotusDate = (value, local = true) => {
  if (local) {
    const local_date = new Date(value);
    const utc_date = /* @__PURE__ */ new Date();
    utc_date.setUTCMilliseconds(local_date.getUTCMilliseconds());
    utc_date.setUTCSeconds(local_date.getUTCSeconds());
    utc_date.setUTCMinutes(local_date.getUTCMinutes());
    utc_date.setUTCHours(local_date.getHours());
    utc_date.setUTCDate(local_date.getDate());
    utc_date.setUTCMonth(local_date.getMonth());
    utc_date.setUTCFullYear(local_date.getFullYear());
    value = utc_date.getTime();
  }
  value = (value + 22090752e5) / 864e5;
  if (value >= 60) {
    value++;
  }
  return value;
};
var NumberFormat = class _NumberFormat {
  static grouping_regexp = /\d{1,3}(?=(\d{3})+(?!\d))/g;
  static fraction_limits = [9, 99, 999, 9999];
  /**
   * this is now exposed so it can be changed, for rendering; some options are 
   * 
   * "i" - regular i, and the default
   * "" - mathematical italic small i", U+1D456
   * "" - the same, with a leading hair space (U+200A)
   */
  static imaginary_character = "\u{1D456}";
  //  'i';
  /**
   * also for complex rendering, the minus sign. there's a unicode 
   * symbol U+2212 which (at least in calibri) is wider than the regular minus 
   * sign/hyphen. I like this but it looks a bit odd if negative numbers are 
   * rendered using the other one.
   * 
   * "-" - hyphen
   * "" - minus
   */
  static minus_character = "-";
  // hyphen
  // public static minus_character = ''; // minus
  /** for the "General" format, a magic decimal point */
  magic_decimal = false;
  /**
   * (testing) transformer. this is not rendered or persisted, like magic
   * decimal it needs to be applied in code. ATM this is only applied in
   * formatting DQ, but it might turn out to be more universal...
   * 
   * NOTE that atm this transforms value back into the same type; we don't
   * cross types (at least for now). perhaps we should support that? that
   * might mean switching in here and removing the "special" format calls
   * for complex and DQ.
   */
  transform_value;
  // tslint:disable-next-line:variable-name
  _pattern = "";
  sections;
  decimal_zero_regexp = [];
  // this is a flag for string representation
  cloned = [];
  //  NumberFormat.decimal_mark = Localization.decimal_separator;
  //  if (NumberFormat.decimal_mark === ',') NumberFormat.grouping_separator = ' ';
  //  public static decimal_mark: '.'|',' = Localization.decimal_separator;
  //  public static grouping_separator = (Localization.decimal_separator === '.') ? ',' : ' ';
  get pattern() {
    return this._pattern;
  }
  /** flag indicates if this is a date format */
  get date_format() {
    return this.sections[0] && this.sections[0].date_format;
  }
  constructor(pattern) {
    this._pattern = pattern;
    this.sections = FormatParser.Parse(pattern);
    if (!this.sections.length)
      this.sections = [];
    if (!this.sections[0]) {
      this.sections[0] = new NumberFormatSection();
    }
    if (!this.sections[1]) {
      this.sections[1] = { ...this.sections[0] };
      this.sections[1].prefix = JSON.parse(JSON.stringify(this.sections[1].prefix));
      this.sections[1].suffix = JSON.parse(JSON.stringify(this.sections[1].suffix));
      this.sections[1].prefix.push({ text: "-" });
      this.cloned[1] = true;
    }
    if (!this.sections[2]) {
      this.sections[2] = { ...this.sections[0] };
      this.cloned[2] = true;
    }
    if (!this.sections[3]) {
      for (const part of this.sections[0].prefix) {
        if (part.flag === 5 /* literal */) {
          this.sections[3] = { ...this.sections[0] };
          this.sections[3].string_format = true;
          this.cloned[3] = true;
          break;
        }
      }
    }
    this.decimal_zero_regexp = this.sections.map((section) => {
      if (section.decimal_max_digits > section.decimal_min_digits) {
        return new RegExp(`0{1,${section.decimal_max_digits - section.decimal_min_digits}}(?:$|e)`);
      }
      return void 0;
    });
  }
  /**
   * render text parts to string
   * FIXME: move
   */
  static FormatPartsAsText(parts, text_width = 0) {
    let padded = -1;
    const formatted = parts.map((part, index) => {
      switch (part.flag) {
        case 2 /* padded */:
          padded = index;
          return part.text;
        case 1 /* hidden */:
          return part.text.replace(/./g, " ");
        case 6 /* formatting */:
          return "";
        default:
          return part.text;
      }
    });
    if (padded >= 0 && text_width) {
      const total_length = formatted.reduce((a, str, index) => index === padded ? a : a + str.length, 0);
      let tmp = "";
      for (let i = 0; i < text_width - total_length; i++) {
        tmp += formatted[padded];
      }
      formatted[padded] = tmp;
    }
    return formatted.join("");
  }
  /** for decimal only, set an explicit number of digits */
  SetDecimal(digits) {
    for (const section of this.sections) {
      if (!section.fraction_format) {
        section.decimal_min_digits = digits;
        section.decimal_max_digits = digits;
      }
    }
  }
  /** 
   * mutate 
   * UPDATE: for fractional formats, increase the denominator digits
   *         (doing something weird with fixed denominators...)
   */
  IncreaseDecimal() {
    this.sections.forEach((section) => {
      if (section.fraction_format) {
        if (!section.fraction_denominator) {
          section.fraction_denominator_digits = Math.min(section.fraction_denominator_digits + 1, 4);
        }
      } else {
        section.decimal_min_digits++;
        section.decimal_max_digits = section.decimal_min_digits;
      }
    });
  }
  /** 
   * mutate 
   * UPDATE: for fractional formats, decrease the denominator digits
   *         (doing something weird with fixed denominators...)
   */
  DecreaseDecimal() {
    this.sections.forEach((section) => {
      if (section.fraction_format) {
        if (!section.fraction_denominator) {
          section.fraction_denominator_digits = Math.max(section.fraction_denominator_digits - 1, 1);
        }
      } else {
        section.decimal_min_digits = Math.max(0, section.decimal_min_digits - 1);
        section.decimal_max_digits = section.decimal_min_digits;
      }
    });
  }
  /** mutate */
  AddGrouping() {
    this.sections.forEach((section) => {
      section.grouping = true;
    });
  }
  /** mutate */
  RemoveGrouping() {
    this.sections.forEach((section) => {
      section.grouping = false;
    });
  }
  /** mutate */
  ToggleGrouping() {
    const grouping = !this.sections[0].grouping;
    this.sections.forEach((section) => {
      section.grouping = grouping;
    });
  }
  /**
   * generates a string representation. we use this because we are (now)
   * allowing mutation of formats; therefore we need to serialize them back
   * to the basic format.
   */
  toString() {
    if (this.sections[0].date_format) {
      return this._pattern;
    }
    return this.sections.filter((section, i) => {
      return !this.cloned[i];
    }).map((section) => {
      let nf = "";
      let i = 0;
      if (section.fraction_format) {
        if (section.fraction_integer) {
          nf += "? ";
        }
        let pattern = "";
        for (let j = 0; j < section.fraction_denominator_digits; j++) {
          pattern += "#";
        }
        nf += pattern;
        nf += "/";
        if (section.fraction_denominator) {
          nf += section.fraction_denominator;
        } else {
          nf += pattern;
        }
      } else if (section.has_number_format) {
        for (i = 0; i < section.integer_min_digits; i++) {
          nf += "0";
        }
        if (section.grouping) {
          if (nf.length < 4)
            nf = ("####" + nf).slice(-4);
          nf = nf.replace(/[\d#]{1,3}(?=([\d#]{3})+(?![\d#]))/g, "$&,");
        }
        if (section.decimal_max_digits || section.decimal_min_digits) {
          nf += ".";
          for (i = 0; i < section.decimal_min_digits; i++) {
            nf += "0";
          }
          for (; i < section.decimal_max_digits; i++) {
            nf += "#";
          }
        }
        if (section.scaling) {
          const count = Math.log10(section.scaling) / 3;
          for (i = 0; i < count; i++) {
            nf += ",";
          }
        }
        if (section.exponential) {
          nf += "e";
        }
      }
      return section.prefix.map((part) => {
        if (part.flag === 1 /* hidden */) {
          return part.text === "0" ? "?" : "_" + part.text;
        } else if (part.flag === 2 /* padded */) {
          return "*" + part.text;
        } else if (part.flag === 6 /* formatting */) {
          return "[" + part.text + "]";
        }
        return part.text;
      }).join("") + nf + section.suffix.map((part) => {
        if (part.flag === 1 /* hidden */) {
          return part.text === "0" ? "?" : "_" + part.text;
        } else if (part.flag === 2 /* padded */) {
          return "*" + part.text;
        }
        return part.text;
      }).join("");
    }).join(";");
  }
  /** also temporary? why not switch in here? */
  FormatDimensionedQuantity(value) {
    if (this.transform_value) {
      const result = this.transform_value(value);
      if (IsDimensionedQuantity(result)) {
        value = result;
      } else if (typeof result === "string") {
        return result;
      } else {
        return this.FormatParts(result);
      }
    }
    const parts = this.FormatParts(value.value || 0);
    if (value.unit) {
      parts.push({ text: " " }, {
        text: value.unit
      });
    }
    return parts;
  }
  /** 
   * temporary 
   * 
   * FIXME: merge with FormatParts, use a test to check if it's complex?
   * OTOH that adds a test to every format which is probably wasteful...
   * although we can check for 'number' first
   * 
   */
  FormatComplex(value) {
    let imaginary_format = [];
    let real_format = [];
    let drop_imaginary_coefficient = false;
    let has_imaginary_value = !!value.imaginary;
    if (has_imaginary_value) {
      imaginary_format = this.FormatParts(value.imaginary);
      has_imaginary_value = imaginary_format.some((element) => /[1-9]/.test(element.text));
      if (imaginary_format.length === 1 && this.sections[0].integer_min_digits <= 1 && imaginary_format[0].text === "1") {
        imaginary_format[0].text = "";
        drop_imaginary_coefficient = true;
      } else if (imaginary_format.length === 1 && this.sections[1].integer_min_digits <= 1 && imaginary_format[0].text === "-1") {
        imaginary_format[0].text = "-";
        drop_imaginary_coefficient = true;
      }
    }
    let has_real_value = !!value.real;
    if (has_real_value) {
      real_format = this.FormatParts(value.real);
      has_real_value = real_format.some((element) => /[1-9]/.test(element.text));
    }
    const parts = [];
    if (has_real_value || !has_real_value && !has_imaginary_value) {
      parts.push(...real_format);
      if (has_imaginary_value) {
        const i = Math.abs(value.imaginary);
        parts.push({ text: value.imaginary < 0 ? ` ${_NumberFormat.minus_character} ` : " + " });
        const reformatted_imaginary = drop_imaginary_coefficient ? [] : this.FormatParts(Math.abs(value.imaginary));
        parts.push(...reformatted_imaginary, { text: _NumberFormat.imaginary_character });
      }
    } else if (has_imaginary_value) {
      parts.push(...imaginary_format, { text: _NumberFormat.imaginary_character });
    }
    return parts;
  }
  /**
   * this method composes the format as a set of parts with various
   * states. it's intended for graphical representation where things
   * like hidden characters and padding require multiple passes or measurement.
   */
  FormatParts(value) {
    if (typeof value !== "number" && !this.sections[3]) {
      return [{ text: value.toString() }];
    }
    const { parts, section } = this.BaseFormat(value);
    let text_parts = [];
    if (section.date_format || section.string_format) {
      for (const part of parts) {
        if (typeof part === "string") {
          text_parts.push({ text: part });
        } else
          text_parts.push(part);
      }
    } else {
      if (this.magic_decimal && parts[1] === "") {
        parts.splice(1, 1);
      }
      text_parts = [
        ...section.prefix.map((text_part) => {
          return { ...text_part };
        }),
        { text: section.has_number_format ? parts.join(Localization.decimal_separator) : "" },
        ...section.suffix.map((text_part) => {
          return { ...text_part };
        })
      ];
    }
    for (let i = 1; i < text_parts.length; i++) {
      if (text_parts[i].flag === text_parts[i - 1].flag) {
        text_parts[i].text = text_parts[i - 1].text + text_parts[i].text;
        text_parts[i - 1].text = "";
      }
    }
    return text_parts.filter((text_part) => text_part.text);
  }
  /**
   * formats a number as text.
   *
   * this method will use a single space to replace hidden (leading-underscore)
   * characters. if a text width is provided, it will use that for padding;
   * otherwise the padding character (we only allow a single padding character)
   * is rendered once.
   *
   * FIXME: date, string (this is lagging)
   * UPDATE: unifying, basing this on the text part functionality
   */
  Format(value, text_width = 0) {
    return _NumberFormat.FormatPartsAsText(this.FormatParts(value), text_width);
  }
  ZeroPad(text, length) {
    while (text.length < length)
      text = "0" + text;
    return text;
  }
  DateFormat(value) {
    const date = LotusDate(value);
    const section = this.sections[0];
    let hours = date.getUTCHours();
    if (section.twelve_hour) {
      if (hours > 12)
        hours -= 12;
      if (hours === 0)
        hours = 12;
    }
    const parts = section.prefix.map((part) => {
      if (part.flag === 4 /* date_component_minutes */) {
        if (part.text === "mm") {
          return { text: this.ZeroPad(date.getUTCMinutes().toString(), 2) };
        }
        return { text: this.ZeroPad(date.getUTCMinutes().toString(), 1) };
      } else if (part.flag === 3 /* date_component */) {
        switch (part.text.toLowerCase()) {
          case "am/pm":
          case "a/p": {
            const elements = part.text.split("/");
            return { text: date.getUTCHours() > 12 ? elements[1] : elements[0] };
          }
          case "mmmmm":
            return { text: Localization.date_components.long_months[date.getUTCMonth()][0] };
          case "mmmm":
            if (part.text === "MMMM") {
              return { text: Localization.date_components.long_months[date.getUTCMonth()].toUpperCase() };
            }
            return { text: Localization.date_components.long_months[date.getUTCMonth()] };
          case "mmm":
            if (part.text === "MMM") {
              return { text: Localization.date_components.short_months[date.getUTCMonth()].toUpperCase() };
            }
            return { text: Localization.date_components.short_months[date.getUTCMonth()] };
          case "mm":
            return { text: this.ZeroPad((date.getUTCMonth() + 1).toString(), 2) };
          case "m":
            return { text: this.ZeroPad((date.getUTCMonth() + 1).toString(), 1) };
          case "ddddd":
          case "dddd":
            if (part.text === "DDDDD" || part.text === "DDDD") {
              return { text: Localization.date_components.long_days[date.getUTCDay()].toUpperCase() };
            }
            return { text: Localization.date_components.long_days[date.getUTCDay()] };
          case "ddd":
            if (part.text === "DDD") {
              return { text: Localization.date_components.short_days[date.getUTCDay()].toUpperCase() };
            }
            return { text: Localization.date_components.short_days[date.getUTCDay()] };
          case "dd":
            return { text: this.ZeroPad(date.getUTCDate().toString(), 2) };
          case "d":
            return { text: this.ZeroPad(date.getUTCDate().toString(), 1) };
          case "yyyy":
          case "yyy":
            return { text: date.getUTCFullYear().toString() };
          case "yy":
          case "y":
            return { text: this.ZeroPad((date.getUTCFullYear() % 100).toString(), 2) };
          case "hh":
            return { text: this.ZeroPad(hours.toString(), 2) };
          case "h":
            return { text: this.ZeroPad(hours.toString(), 1) };
          case "ss":
            return { text: this.ZeroPad(date.getUTCSeconds().toString(), 2) };
          case "s":
            return { text: this.ZeroPad(date.getUTCSeconds().toString(), 1) };
        }
        const match = part.text.match(/^(s+)\.(0+)$/);
        if (match) {
          return {
            text: this.ZeroPad(date.getUTCSeconds().toString(), match[1].length) + Localization.decimal_separator + (date.getUTCMilliseconds() / 1e3).toFixed(match[2].length).substr(2)
          };
        }
      }
      return { ...part };
    });
    return { parts, section };
  }
  StringFormat(value, section) {
    const parts = [];
    for (const part of section.prefix) {
      if (part.flag === 5 /* literal */) {
        parts.push({ text: value });
      } else
        parts.push({ ...part });
    }
    return {
      parts,
      section
    };
  }
  /*
    public DecimalAdjustRound(value: number, exp: number) {
  
      if (!exp) { return Math.round(value); }
  
      value = +value;
      // exp = +exp;
  
      // Shift
      let values = value.toString().split('e');
      value = Math.round(+(values[0] + 'e' + (values[1] ? (+values[1] - exp) : -exp)));
  
      // Shift back
      values = value.toString().split('e');
      return +(values[0] + 'e' + (values[1] ? (+values[1] + exp) : exp));
  
    }
    */
  Round2(value, digits) {
    const m = Math.pow(10, digits);
    return Math.round(m * value) / m;
  }
  FormatFraction(value, section) {
    if (section.percent) {
      value *= 100;
    }
    let candidate = {
      denominator: 1,
      numerator: Math.round(value),
      error: Math.abs(Math.round(value) - value)
    };
    if (section.fraction_denominator) {
      candidate.denominator = section.fraction_denominator;
      candidate.numerator = Math.round(value * candidate.denominator);
    } else {
      if (candidate.error) {
        const limit = _NumberFormat.fraction_limits[section.fraction_denominator_digits - 1] || _NumberFormat.fraction_limits[0];
        for (let denominator = 2; denominator <= limit; denominator++) {
          const numerator = Math.round(value * denominator);
          const error = Math.abs(numerator / denominator - value);
          if (error < candidate.error) {
            candidate = {
              numerator,
              denominator,
              error
            };
            if (!error) {
              break;
            }
          }
        }
      }
    }
    const text = [];
    if (section.fraction_integer) {
      const integer = Math.floor(candidate.numerator / candidate.denominator);
      candidate.numerator %= candidate.denominator;
      if (integer || !candidate.numerator) {
        text.push(integer.toString());
        if (candidate.numerator) {
          text.push(" ");
        }
      }
    } else if (!candidate.numerator) {
      text.push("0");
    }
    if (candidate.numerator) {
      text.push(candidate.numerator.toString());
      text.push("/");
      text.push(candidate.denominator.toString());
    }
    return text.join("");
  }
  BaseFormat(value) {
    if (this.sections[0].date_format) {
      return this.DateFormat(Number(value));
    }
    if (typeof value !== "number") {
      return this.StringFormat(value.toString(), this.sections[3]);
    }
    let section = this.sections[0];
    let zero_regexp = this.decimal_zero_regexp[0];
    if (value < 0) {
      section = this.sections[1];
    }
    const max_digits = section.percent ? section.decimal_max_digits + 2 : section.decimal_max_digits;
    const epsilon = Math.pow(10, -max_digits) / 2;
    let abs_value = Math.abs(value);
    if (abs_value < epsilon) {
      section = this.sections[2];
      zero_regexp = this.decimal_zero_regexp[2];
    }
    if (section.scaling) {
      abs_value /= section.scaling;
      if (abs_value < epsilon) {
        section = this.sections[2];
        zero_regexp = this.decimal_zero_regexp[2];
      }
    }
    if (section.string_format) {
      return this.StringFormat(value.toString(), section);
    }
    let representation = "";
    if (section.fraction_format) {
      return { parts: [this.FormatFraction(abs_value, section)], section };
    }
    if (section.exponential) {
      representation = abs_value.toExponential(section.decimal_max_digits);
    } else {
      if (section.percent) {
        abs_value *= 100;
      }
      representation = this.Round2(abs_value, section.decimal_max_digits).toFixed(section.decimal_max_digits);
    }
    if (zero_regexp) {
      representation = representation.replace(zero_regexp, "");
    }
    const parts = representation.split(".");
    while (parts[0].length < section.integer_min_digits) {
      parts[0] = ("0000000000000000" + parts[0]).slice(-section.integer_min_digits);
    }
    if (section.integer_min_digits === 0 && parts[0] === "0") {
      parts[0] = "";
    }
    if (section.grouping) {
      parts[0] = parts[0].replace(_NumberFormat.grouping_regexp, "$&" + Localization.grouping_separator);
    }
    return { parts, section };
  }
};

// treb-format/src/format_cache.ts
var NumberFormatCache = class {
  /** cache instance */
  static cache = {};
  /** special case for the "general" formatter for complex numbers only */
  static complex_general;
  /** 
   * this map is for case-insensitive mapping symbolic names to formats. we
   * want symbolic names with casing, primarily for interop, but we also want
   * to support icase matching.
   * 
   * FIXME: is there a better way to do this, with a pattern or something in
   * the cache?
   */
  static symbolc_name_map = {};
  /** base types, with default names */
  static base_formats = {
    Accounting: "_(#,##0.00_);(#,##0.00);-???",
    Number: "0.00",
    Integer: "0",
    Percent: "0.00%",
    General: "0.######",
    // for complex we will reduce the number of optional digits
    Fraction: "# ?/?",
    Dollar: "$* _(#,##0.00_);$* (#,##0.00);$* -???",
    Exponential: "0.000e",
    "Short Date": "mm/dd/yy",
    "Long Date": "dddd, mmm d yyyy",
    Timestamp: "mm-dd-yy hh:mm:ss"
  };
  /** alias types */
  static aliases = {
    Scientific: "Exponential",
    Percentage: "Percent",
    Currency: "Dollar"
    /*
        // we switched to Uppercase symbolic names to better
        // match imported files, but we have legacy stuff using
        // lowercase, so add aliases.
    
        accounting: 'Accounting',
        number: 'Number',
        integer: 'Integer',
        percent: 'Percent',
        general: 'General',
        dollar: 'Dollar',
        exponential: 'Exponential',
    
        'short date': 'Short Date',
        'long date': 'Long Date',
        timestamp: 'Timestamp',
        */
  };
  /**
   * we now have (some) overlay styles for complex. if the flag is set
   * we will check the complex cache first, and 
   * @param format 
   * @param complex 
   * @returns 
   */
  static Get(format, complex = false) {
    if (complex && format === "General") {
      return this.complex_general;
    }
    const canonical_name = this.symbolc_name_map[format.toLowerCase()];
    let formatter = this.cache[canonical_name || format];
    if (!formatter) {
      formatter = new NumberFormat(format);
      this.cache[format] = formatter;
    }
    return formatter;
  }
  /** 
   * does anyone use this? (...)
   */
  static Equals(a, b) {
    if (a === b)
      return true;
    const fa = this.Get(a);
    const fb = this.Get(b);
    return fa.pattern === fb.pattern;
  }
  /**
   * this method is used to translate symbolic formats,
   * without actually creating a formatter. it's a shortcut
   * we need for exporting to xlsx.
   *
   * if the passed format matches a symbolic format, we return
   * the string representation. if it doesn't match any symbolic format,
   * the string is returned as-is.
   */
  static Translate(format) {
    const mapped = this.symbolc_name_map[format.toLowerCase()];
    return mapped ? this.cache[mapped].toString() : format;
  }
  /**
   * check if the format (as a number format) matches a local 
   * symbolic name and if so, return that.
   */
  static SymbolicName(format) {
    for (const key of Object.keys(this.base_formats)) {
      if (format === this.base_formats[key])
        return key;
    }
    return null;
  }
  static InitCache() {
    for (const key of Object.keys(this.base_formats)) {
      this.cache[key] = new NumberFormat(this.base_formats[key]);
      this.symbolc_name_map[key.toLowerCase()] = key;
    }
    this.cache["General"].magic_decimal = true;
    this.complex_general = new NumberFormat("0.###");
    this.complex_general.magic_decimal = true;
    for (const key of Object.keys(this.aliases)) {
      this.cache[key] = this.cache[this.aliases[key]];
      this.symbolc_name_map[key.toLowerCase()] = key;
    }
  }
};
NumberFormatCache.InitCache();

// treb-format/src/value_parser.ts
var this_year = (/* @__PURE__ */ new Date()).getUTCFullYear();
var ValueParserType = class {
  compare_day;
  compare_month;
  TestDate(text) {
    const date_value = Date.parse(text);
    if (isNaN(date_value)) {
      return false;
    }
    const date = new Date(date_value);
    const tmp = text.replace(/[\d\-\\/,.\s]+/g, " ").toLocaleLowerCase();
    const components = tmp.split(/\s+/).map((component) => component.trim()).filter((component) => !!component);
    if (!components.length) {
      return date_value;
    }
    if (!this.compare_month) {
      this.compare_month = {};
      for (let i = 0; i < 12; i++) {
        this.compare_month[Localization.date_components.long_months[i].toLocaleLowerCase().replace(/\./, "")] = i;
        this.compare_month[Localization.date_components.short_months[i].toLocaleLowerCase().replace(/\./, "")] = i;
      }
    }
    if (!this.compare_day) {
      this.compare_day = {};
      for (let i = 0; i < 7; i++) {
        this.compare_day[Localization.date_components.long_days[i].toLocaleLowerCase().replace(/\./, "")] = i;
        this.compare_day[Localization.date_components.short_days[i].toLocaleLowerCase().replace(/\./, "")] = i;
      }
    }
    let found_month = false;
    let found_day = false;
    for (const component of components) {
      let found = false;
      for (const [month, value] of Object.entries(this.compare_month)) {
        if (component === month) {
          if (found_month) {
            return false;
          }
          if (date.getUTCMonth() !== value) {
            return false;
          }
          found = true;
          found_month = true;
        }
      }
      if (!found) {
        for (const [day, value] of Object.entries(this.compare_day)) {
          if (component === day) {
            if (found_day) {
              return false;
            }
            if (date.getUTCDay() !== value) {
              return false;
            }
            found = true;
            found_day = true;
          }
        }
      }
      if (!found) {
        return false;
      }
    }
    if (found_day && !found_month) {
      return false;
    }
    return date_value;
  }
  /**
   * parse a string. if it can reasonably be converted to a number,
   * do that and return the number; otherwise return the original
   * string. we also return hints as to formatting, which the caller
   * may use to select a number format.
   *
   * remind me why this is better than just using a parser? (...)
   */
  TryParse(text = "") {
    let hints = {};
    if (text[0] === "'")
      return { value: text, type: 2 /* string */ };
    if (text === "")
      return { value: text, type: 2 /* string */ };
    if (text === "NaN")
      return {
        value: NaN,
        type: 3 /* number */,
        hints: { Nan: true }
      };
    let x = text.trim();
    const currency = x.match(/^[$](.*?)$/);
    if (currency) {
      x = currency[1];
      hints.Currency = true;
    }
    const parens = x.match(/^\((.*?)\)$/);
    if (parens) {
      x = parens[1];
      hints.Parens = true;
    }
    const pct = x.match(/^(.*?)%\s*$/);
    if (pct) {
      x = pct[1];
      hints.Percent = true;
    }
    if (Localization.decimal_separator === ".") {
      if (/,/.test(x)) {
        x = x.replace(/,/g, "");
        hints.Grouping = true;
      }
    } else {
      x = x.replace(/(\d)\s+/g, "$1");
      x = x.replace(/\./g, "");
      x = x.replace(/,/, ".");
    }
    let num = Number(x);
    if (null === num || isNaN(num)) {
      const lc = text.toLowerCase();
      if (lc === "false")
        return { value: false, type: 4 /* boolean */ };
      if (lc === "true")
        return { value: true, type: 4 /* boolean */ };
      const date = this.TestDate(text);
      if (false !== date && !isNaN(date)) {
        const check = new Date(date);
        const year = check.getUTCFullYear();
        if (year >= this_year - 200 && year <= this_year + 200) {
          hints = { Date: true };
          if (check.getHours() || check.getMinutes() || check.getSeconds()) {
            hints.Time = true;
          }
          return {
            value: UnlotusDate(date),
            type: 3 /* number */,
            hints
          };
        }
      }
      return { value: text, type: 2 /* string */ };
    }
    if (parens) {
      num = -num;
    }
    if (pct) {
      const sign = num < 0 ? -1 : 1;
      const split = (sign * num).toString().split(".");
      split[0] = ("00" + split[0]).replace(/(\d\d)$/, ".$1");
      num = Number(split.join("")) * sign;
    }
    if (/e/.test(text))
      hints.Exponential = true;
    return { value: num, type: 3 /* number */, hints };
  }
};
var ValueParser = new ValueParserType();

// treb-grid/src/render/svg_selection_block.ts
var SVGSelectionBlock = class {
  constructor(primary, theme, offset = { x: 0, y: 0 }, node) {
    this.theme = theme;
    this.offset = offset;
    const DOM = DOMContext.GetInstance(node.ownerDocument);
    this.g = DOM.SVG("g");
    this.g.setAttribute("transform", `translate(${offset.x}, ${offset.y})`);
    this.outline = DOM.SVG("rect", "outline");
    if (primary) {
      this.g.setAttribute("class", "selection primary-selection");
      this.fill = DOM.SVG("path", "fill");
      this.nub = DOM.SVG("rect", "nub");
      this.g.appendChild(this.fill);
      this.g.appendChild(this.outline);
      this.g.appendChild(this.nub);
    } else {
      this.g.setAttribute("class", "selection alternate-selection");
      this.fill = DOM.SVG("rect", "fill");
      this.g.appendChild(this.fill);
      this.g.appendChild(this.outline);
    }
  }
  g;
  outline;
  fill;
  // SVGPathElement;
  nub;
  Offset(offset) {
    this.g.setAttribute("transform", `translate(${offset.x}, ${offset.y})`);
  }
  /*
    public SetThemeColor(index = 0) {
  
      if (Array.isArray(this.theme.additional_selection_color)) {
        if (index >= this.theme.additional_selection_color.length) {
          index = index % this.theme.additional_selection_color.length;
        }
      }
  
      if (this.theme.additional_selection_overlay_color) {
        if (typeof this.theme.additional_selection_overlay_color === 'string') {
          this.outline.setAttribute('fill', this.theme.additional_selection_overlay_color);
        }
        else {
          this.outline.setAttribute('fill', this.theme.additional_selection_overlay_color[index] || '');
        }
      }
      else {
        this.outline.setAttribute('fill', '');
      }
  
      if (this.theme.additional_selection_color) {
        if (typeof this.theme.additional_selection_color === 'string') {
          this.outline.setAttribute('stroke', this.theme.additional_selection_color);
        }
        else {
          this.outline.setAttribute('stroke', this.theme.additional_selection_color[index] || '');
        }
      }
      else {
        this.outline.setAttribute('stroke', '');
      }
  
    }
    */
  Show(show = true) {
    this.g.style.display = show ? "block" : "none";
  }
  SetOutline(rect, fill = false) {
    this.outline.setAttribute("x", (rect.left - 1).toString());
    this.outline.setAttribute("y", (rect.top - 1).toString());
    this.outline.setAttribute("width", (rect.width + 1).toString());
    this.outline.setAttribute("height", (rect.height + 1).toString());
    if (fill && this.fill) {
      this.fill.setAttribute("x", rect.left.toString());
      this.fill.setAttribute("y", rect.top.toString());
      this.fill.setAttribute("width", rect.width.toString());
      this.fill.setAttribute("height", rect.height.toString());
    }
  }
  SetFill(inside, outside) {
    if (!this.fill)
      return;
    const d = [];
    d.push("M" + inside.left + " " + inside.top);
    d.push("L" + inside.left + " " + inside.bottom);
    d.push("L" + inside.right + " " + inside.bottom);
    d.push("L" + inside.right + " " + inside.top);
    d.push("Z");
    d.push("M" + outside.left + " " + outside.top);
    d.push("L" + outside.right + " " + outside.top);
    d.push("L" + outside.right + " " + outside.bottom);
    d.push("L" + outside.left + " " + outside.bottom);
    d.push("Z");
    this.fill.setAttribute("d", d.join(" "));
  }
  SetNub(rect) {
    if (!this.nub)
      return;
    this.nub.setAttribute("x", (rect.left + rect.width - 4).toString());
    this.nub.setAttribute("y", (rect.top + rect.height - 4).toString());
    this.nub.setAttribute("width", "7");
    this.nub.setAttribute("height", "7");
  }
};

// treb-grid/src/render/svg_header_overlay.ts
var HeaderOverlay = class {
  constructor(theme, container, orientation) {
    this.theme = theme;
    this.container = container;
    this.orientation = orientation;
    const DOM = DOMContext.GetInstance(container.ownerDocument);
    this.g = DOM.SVG("g", "treb-header-overlay");
    this.overlay = DOM.SVG("rect", "treb-overlay");
    this.highlight = DOM.SVG("rect", "treb-highlight");
    this.g.style.display = "none";
    this.g.appendChild(this.highlight);
    this.g.appendChild(this.overlay);
    container.appendChild(this.g);
  }
  g;
  overlay;
  highlight;
  /**
   * remove from DOM, prior to cleanup
   */
  Remove() {
    this.container.removeChild(this.g);
  }
  Hide() {
    this.g.style.display = "none";
  }
  Show(x, y, width, height) {
    this.overlay.setAttribute("x", x.toString());
    this.overlay.setAttribute("y", y.toString());
    this.overlay.setAttribute("width", width.toString());
    this.overlay.setAttribute("height", height.toString());
    if (this.orientation === 0 /* Horizontal */) {
      this.highlight.setAttribute("x", x.toString());
      this.highlight.setAttribute("y", (y + height - 2).toString());
      this.highlight.setAttribute("width", width.toString());
      this.highlight.setAttribute("height", "2");
    } else {
      this.highlight.setAttribute("x", (x + width - 2).toString());
      this.highlight.setAttribute("y", y.toString());
      this.highlight.setAttribute("width", "2");
      this.highlight.setAttribute("height", height.toString());
    }
    this.g.style.display = "block";
  }
};

// treb-grid/src/render/selection-renderer.ts
var SelectionRenderer = class {
  constructor(theme, layout, model, view, primary_selection, additional_selections) {
    this.theme = theme;
    this.layout = layout;
    this.model = model;
    this.view = view;
    this.primary_selection = primary_selection;
    this.additional_selections = additional_selections;
  }
  nub_rectangle = new Rectangle(-1, -1, 0, 0);
  // tmp
  cached_additional_selections = "";
  grid_selections = [];
  row_header_selections = [];
  column_header_selections = [];
  corner_selections = [];
  row_overlay;
  column_overlay;
  corner_row_overlay;
  corner_column_overlay;
  Initialize() {
    this.row_overlay = new HeaderOverlay(this.theme, this.layout.row_header_selection, 0 /* Horizontal */);
    this.column_overlay = new HeaderOverlay(this.theme, this.layout.column_header_selection, 1 /* Vertical */);
    this.corner_row_overlay = new HeaderOverlay(this.theme, this.layout.corner_selection, 0 /* Horizontal */);
    this.corner_column_overlay = new HeaderOverlay(this.theme, this.layout.corner_selection, 1 /* Vertical */);
  }
  /**
     * we cache blocks that have inline style information. if style
     * information updates we will have to flush the cache and rebuild.
     * /
    public Flush() {
  
      // clean up, then call initialize to reconstruct
  
      for (const overlay of [
          this.row_overlay,
          this.column_overlay,
          this.corner_row_overlay,
          this.corner_column_overlay,
        ]) {
        overlay.Remove();
      }
  
      this.Initialize();
  
      // selections: remove nodes from DOM, if connected, before cleaning up
  
      for (const group of [
          this.grid_selections,
          this.row_header_selections,
          this.column_header_selections,
          this.corner_selections,
        ]) {
        for (const block of group) {
  
          // IE11 requires parentNode; seems to work in chrome/ffx,
          // so unify (was originally using parentElement)
  
          if (block.g.parentNode) {
            block.g.parentNode.removeChild(block.g);
          }
        }
      }
  
      this.grid_selections = [];
      this.row_header_selections = [];
      this.column_header_selections = [];
      this.corner_selections = [];
  
    }
    */
  /**
   * renders all (primary and additional) selections. selections are painted
   * on a separate canvas which overlays the grid. unlike grid/header layers,
   * the selection canvas is transparent (alpha = true, which is default, so
   * omitted).
   *
   * updated for svg selections. erase is now required, so parameter is removed.
   * update: add an optional (default true) parameter to re-render additional
   * selections; this will support cache for selections that don't change.
   */
  RenderSelections(show_primary_selection = true, rerender = true) {
    const cache_primary_empty = this.primary_selection.empty;
    if (!show_primary_selection) {
      this.primary_selection.empty = true;
    }
    const aggregate = [this.primary_selection].concat(this.additional_selections);
    this.RenderSelectionGroup(aggregate, this.layout.grid_selection, void 0, void 0, this.grid_selections, void 0, rerender);
    let header_selection_rect = new Rectangle(-1, -1, 0, 0);
    if (!this.primary_selection.empty) {
      const area = this.view.active_sheet.RealArea(this.primary_selection.area);
      header_selection_rect = this.layout.CellAddressToRectangle(area.start).Combine(
        this.layout.CellAddressToRectangle(area.end)
      );
    }
    if (!this.primary_selection.empty && this.layout.header_offset.y > 2) {
      this.row_overlay.Show(
        header_selection_rect.left,
        0,
        header_selection_rect.width,
        this.layout.header_offset.y
      );
      this.corner_row_overlay.Show(
        header_selection_rect.left + this.layout.header_offset.x,
        0,
        header_selection_rect.width,
        this.layout.header_offset.y
      );
    } else {
      this.row_overlay.Hide();
      this.corner_row_overlay.Hide();
    }
    if (!this.primary_selection.empty && this.layout.header_offset.x > 2) {
      this.column_overlay.Show(
        0,
        header_selection_rect.top,
        this.layout.header_offset.x,
        header_selection_rect.height
      );
      this.corner_column_overlay.Show(
        0,
        header_selection_rect.top + this.layout.header_offset.y,
        this.layout.header_offset.x,
        header_selection_rect.height
      );
    } else {
      this.column_overlay.Hide();
      this.corner_column_overlay.Hide();
    }
    if (!this.view.active_sheet.freeze.columns && !this.view.active_sheet.freeze.rows) {
      this.primary_selection.empty = cache_primary_empty;
      return;
    }
    const visible_row = [];
    const visible_column = [];
    if (this.primary_selection.empty) {
      visible_row.push(false);
      visible_column.push(false);
    } else {
      const start = this.primary_selection.area.start;
      visible_row.push(
        start.row <= this.view.active_sheet.freeze.rows || start.row === Infinity
      );
      visible_column.push(
        start.column <= this.view.active_sheet.freeze.columns || start.column === Infinity
      );
    }
    for (const { area } of this.additional_selections) {
      visible_row.push(
        area.start.row <= this.view.active_sheet.freeze.rows || area.start.row === Infinity
      );
      visible_column.push(
        area.start.column <= this.view.active_sheet.freeze.columns || area.start.column === Infinity
      );
    }
    if (this.view.active_sheet.freeze.rows) {
      this.RenderSelectionGroup(
        aggregate,
        this.layout.row_header_selection,
        visible_row,
        void 0,
        this.row_header_selections,
        { x: 0, y: this.layout.header_offset.y }
      );
    }
    if (this.view.active_sheet.freeze.columns) {
      this.RenderSelectionGroup(
        aggregate,
        this.layout.column_header_selection,
        visible_column,
        void 0,
        this.column_header_selections,
        { x: this.layout.header_offset.x, y: 0 }
      );
    }
    if (this.view.active_sheet.freeze.rows && this.view.active_sheet.freeze.columns) {
      this.RenderSelectionGroup(
        aggregate,
        this.layout.corner_selection,
        visible_column,
        visible_row,
        this.corner_selections,
        { ...this.layout.header_offset }
      );
    }
    this.primary_selection.empty = cache_primary_empty;
  }
  /**
   * render a group of selections, optionally gated on one or two boolean
   * arrays (used to check if the selection is within some bounds)
   */
  RenderSelectionGroup(aggregate, node, visible_a, visible_b, group, offset, rerender = true) {
    for (let i = 0; i < aggregate.length; i++) {
      const sheet_match = !aggregate[i].area.start.sheet_id || aggregate[i].area.start.sheet_id === this.view.active_sheet.id;
      if (sheet_match && !aggregate[i].empty && (!visible_a || visible_a[i]) && (!visible_b || visible_b[i])) {
        if (rerender || !aggregate[i].rendered) {
          const block = this.EnsureGridSelectionBlock(node, group, i, offset);
          this.RenderSVGSelection(aggregate[i], block, i);
        }
      } else {
        if (group[i])
          group[i].Show(false);
      }
    }
    for (let i = aggregate.length; i < group.length; i++) {
      if (group[i])
        group[i].Show(false);
    }
  }
  /**
   * create or return existing node. supports changing the offset,
   * as that may be variable.
   *
   * FIXME: now that this is in a single method, could inline?
   */
  EnsureGridSelectionBlock(node, node_set, index, offset) {
    let selection_block = node_set[index];
    if (!selection_block) {
      selection_block = new SVGSelectionBlock(!index, this.theme, void 0, node);
      node_set[index] = selection_block;
      if (index) {
        let group = node.querySelector(".alternate-selections");
        if (!group) {
          group = this.layout.DOM.SVG("g", "alternate-selections");
          node.appendChild(group);
        }
        group?.appendChild(selection_block.g);
      } else {
        node.appendChild(selection_block.g);
      }
    }
    if (offset)
      selection_block.Offset(offset);
    return selection_block;
  }
  ClampEnd(address) {
    return {
      row: Math.min(address.row, this.view.active_sheet.rows - 1),
      column: Math.min(address.column, this.view.active_sheet.columns - 1)
    };
  }
  /**
   * testing an SVG selection. index replaces primary; primary is always index 0.
   */
  RenderSVGSelection(selection, block, index = 0) {
    const area = this.view.active_sheet.RealArea(selection.area, true);
    let rect = this.layout.CellAddressToRectangle(area.start);
    if (area.count > 1) {
      rect = rect.Combine(this.layout.CellAddressToRectangle(area.end));
    } else if (index) {
      const data = this.view.active_sheet.CellData(selection.target);
      if (data.merge_area) {
        rect = this.layout.CellAddressToRectangle(data.merge_area.start);
        rect = rect.Combine(this.layout.CellAddressToRectangle(data.merge_area.end));
      }
    }
    if (!index) {
      this.nub_rectangle = new Rectangle(
        rect.left + rect.width - 6,
        rect.top + rect.height - 6,
        11,
        11
      );
    } else {
    }
    if (rect.top === 0 && this.layout.header_offset.y <= 1) {
      rect.top = 1;
      rect.height -= 1;
    }
    if (rect.left === 0 && this.layout.header_offset.x <= 1) {
      rect.left = 1;
      rect.width -= 1;
    }
    if (rect.height <= 0 || rect.height <= 0) {
      block.Show(false);
      return;
    }
    block.SetOutline(rect, !!index);
    if (!index) {
      let target_rect = this.layout.CellAddressToRectangle(selection.target);
      const data = this.view.active_sheet.CellData(selection.target);
      if (data.merge_area) {
        target_rect = this.layout.CellAddressToRectangle(data.merge_area.start);
        target_rect = target_rect.Combine(this.layout.CellAddressToRectangle(data.merge_area.end));
      }
      block.SetFill(target_rect, rect);
      block.SetNub(rect);
    } else {
      selection.rendered = true;
    }
    block.Show();
  }
};

// treb-grid/src/types/drag_mask.ts
function MouseDrag(mask_node, classes = [], move, end) {
  if (typeof classes === "string") {
    classes = [classes];
  }
  let cleanup;
  const handle_up = (event) => {
    event.stopPropagation();
    event.preventDefault();
    cleanup();
    if (end) {
      end(event);
    }
  };
  const handle_move = (event) => {
    event.stopPropagation();
    event.preventDefault();
    if (!event.buttons) {
      cleanup();
      if (end) {
        end(event);
      }
      return;
    }
    if (move) {
      move(event);
    }
  };
  cleanup = () => {
    mask_node.style.display = "none";
    mask_node.removeEventListener("mousemove", handle_move);
    mask_node.removeEventListener("mouseup", handle_up);
    for (const class_entry of classes)
      mask_node.classList.remove(class_entry);
  };
  for (const class_entry of classes)
    mask_node.classList.add(class_entry);
  mask_node.style.display = "block";
  if (move)
    mask_node.addEventListener("mousemove", handle_move);
  if (end)
    mask_node.addEventListener("mouseup", handle_up);
}

// treb-grid/src/types/scale-control.ts
var ScaleControl = class extends EventSource {
  constructor(container) {
    super();
    this.container = container;
    this.format = NumberFormatCache.Get("0.0");
    const DOM = DOMContext.GetInstance(container.ownerDocument);
    this.input = DOM.Create("input", "treb-scale-input", container, {
      events: {
        // is this for some x-browser issue? or did we just not 
        // know which event to use and this is old junk?
        keypress: (event) => {
          switch (event.key) {
            case "ArrowUp":
            case "ArrowDown":
              event.stopPropagation();
              event.preventDefault();
              console.info("mark?");
              break;
          }
        },
        keydown: (event) => {
          switch (event.key) {
            case "Enter":
              this.input.blur();
              break;
            case "ArrowUp":
              this.Tick(-1);
              break;
            case "ArrowDown":
              this.Tick(1);
              break;
            case "Escape":
              this.input.value = this.format.Format(this.scale) + "%";
              this.input.blur();
              break;
            default:
              return;
          }
          event.stopPropagation();
          event.preventDefault();
        },
        // select text on click
        focusin: () => this.input.select(),
        change: () => {
          let text = this.input.value;
          text = text.replace(/%/g, "");
          const value = ValueParser.TryParse(text);
          if (value.type === 3 /* number */) {
            this.UpdateScale(Number(value.value), true);
          } else {
            this.input.value = this.format.Format(this.scale) + "%";
          }
        }
      }
    });
    const popup = DOM.Div("treb-slider-container", container);
    this.slider = DOM.Create("input", void 0, popup, {
      attrs: {
        type: "range",
        min: "50",
        max: "200",
        value: "100",
        step: "2.5"
      },
      events: {
        input: () => this.UpdateScale(Number(this.slider.value), true)
      }
    });
    container.addEventListener("wheel", (event) => {
      event.stopPropagation();
      event.preventDefault();
      this.Tick(event.deltaY);
    });
  }
  input;
  slider;
  scale = 0;
  format;
  timeout = 0;
  Tick(value) {
    const scale = Math.round(this.scale / 2.5) * 2.5;
    if (value > 0) {
      this.UpdateScale(scale - 2.5, true, true);
    } else if (value < 0) {
      this.UpdateScale(scale + 2.5, true, true);
    }
  }
  UpdateScale(scale, notify = false, keep_focus = false) {
    scale = Math.max(50, Math.min(200, scale));
    if (scale !== this.scale) {
      this.scale = scale;
      this.input.value = this.format.Format(scale) + "%";
      this.slider.value = scale.toFixed(1);
      if (notify) {
        if (!this.timeout) {
          this.timeout = requestAnimationFrame(() => {
            this.timeout = 0;
            this.Publish({
              type: "scale",
              value: this.scale / 100,
              keep_focus
            });
          });
        }
      }
    }
  }
};

// treb-grid/src/types/tab_bar.ts
var TabBar = class extends EventSource {
  constructor(layout, model, view, options, view_node) {
    super();
    this.layout = layout;
    this.model = model;
    this.view = view;
    this.options = options;
    this.DOM = DOMContext.GetInstance(view_node.ownerDocument);
    this.container = view_node.querySelector(".treb-spreadsheet-footer");
    if (!this.container) {
      throw new Error("missing container for tab bar");
    }
    if (options.tab_bar !== "auto") {
      this.container.removeAttribute("hidden");
    }
    this.tab_container = this.container.querySelector(".treb-spreadsheet-tabs");
    this.container.addEventListener("click", (event) => {
      const command = event.target?.dataset.command;
      if (command) {
        event.stopPropagation();
        event.preventDefault();
        switch (command) {
          case "add-tab":
            this.Publish({ type: "add-sheet" });
            break;
          case "delete-tab":
            this.Publish({ type: "delete-sheet" });
            break;
          default:
            console.info("unhandled command", command);
        }
      }
    });
    if (this.options.stats) {
      this.stats_panel = this.container.querySelector(".treb-stats-panel");
    }
    if (this.options.scale_control) {
      const div = this.container.querySelector(".treb-scale-control");
      this.scale_control = new ScaleControl(div);
      this.scale_control.Subscribe((event) => {
        this.Publish(event);
      });
      this.UpdateScale(this.options.initial_scale || 1);
    }
  }
  // private container?: HTMLElement;
  tab_container;
  scale_control;
  stats_panel;
  dragging = false;
  double_click_data = {};
  // tslint:disable-next-line: variable-name
  _visible = false;
  get visible() {
    return this._visible;
  }
  set stats_data(value) {
    if (this.stats_panel) {
      this.stats_panel.innerText = "";
      for (const entry of value) {
        this.DOM.Create("span", "treb-stats-label", this.stats_panel, {
          text: entry.label
        });
        this.DOM.Create("span", "treb-stats-value", this.stats_panel, {
          text: entry.value
        });
      }
    }
  }
  container;
  DOM;
  IsDoubleClick(index, timeout = 300) {
    if (this.double_click_data.index === index) {
      clearTimeout(this.double_click_data.timeout);
      this.double_click_data.index = void 0;
      this.double_click_data.timeout = void 0;
      return true;
    }
    if (this.double_click_data.timeout) {
      clearTimeout(this.double_click_data.timeout);
    }
    this.double_click_data.index = index;
    this.double_click_data.timeout = window.setTimeout(() => {
      this.double_click_data.index = void 0;
      this.double_click_data.timeout = void 0;
    }, timeout);
    return false;
  }
  Hide() {
    this.Show(false);
  }
  Show(show = true) {
    if (!this.container) {
      return;
    }
    this._visible = show;
    if (show) {
      this.container.removeAttribute("hidden");
    } else {
      this.container.setAttribute("hidden", "");
    }
  }
  SetActive(tab, active) {
    if (active) {
      tab.setAttribute("selected", "");
    } else {
      tab.removeAttribute("selected");
    }
  }
  /** change scale if we have a scale label */
  UpdateScale(scale) {
    this.scale_control?.UpdateScale(scale * 100);
  }
  DoubleClickTab(event, tab, sheet) {
    tab.contentEditable = "true";
    if (this.DOM.doc) {
      const selection = this.DOM.GetSelection();
      if (selection) {
        selection.removeAllRanges();
        const range = this.DOM.doc.createRange();
        range.selectNodeContents(tab);
        selection.addRange(range);
      }
    }
    tab.addEventListener("keydown", (inner_event) => {
      switch (inner_event.key) {
        case "Enter":
          this.Publish({
            type: "rename-sheet",
            name: tab.innerText.trim(),
            sheet
          });
          break;
        case "Escape":
          tab.innerText = sheet.name;
          this.Publish({ type: "cancel" });
          this.Update();
          break;
        default:
          return;
      }
      inner_event.stopPropagation();
      inner_event.preventDefault();
    });
    tab.addEventListener("focusout", () => {
      const name = tab.innerText.trim();
      if (name !== sheet.name) {
        this.Publish({ type: "rename-sheet", name, sheet });
      } else {
        this.Update();
      }
    });
    tab.focus();
  }
  MouseDownTab(event, tab, sheet, index, tabs) {
    event.stopPropagation();
    event.preventDefault();
    if (this.IsDoubleClick(index)) {
      return;
    }
    this.Publish({ type: "activate-sheet", sheet });
    let rectangles = tabs.map((element) => element.getBoundingClientRect());
    let order = index * 2 - 1;
    const left = rectangles[0].left;
    const right = rectangles[rectangles.length - 1].right;
    const top = rectangles[0].top;
    const bottom = rectangles[0].bottom;
    const min = -1;
    const max = (rectangles.length - 1) * 2 + 1;
    for (const candidate of tabs) {
      this.SetActive(candidate, candidate === tab);
    }
    this.dragging = true;
    MouseDrag(this.layout.mask, [], (move_event) => {
      const [x, y] = [move_event.clientX, move_event.clientY];
      if (y > top && y < bottom) {
        let new_order = order;
        if (x < left) {
          new_order = min;
        } else if (x > right) {
          new_order = max;
        } else {
          for (let i = 0; i < rectangles.length; i++) {
            const rectangle = rectangles[i];
            if (x >= rectangle.left && x <= rectangle.right) {
              if (i !== index) {
                if (x >= rectangle.left + rectangle.width / 2) {
                  new_order = i * 2 + 1;
                } else {
                  new_order = i * 2 - 1;
                }
              }
              break;
            }
          }
        }
        if (new_order !== order) {
          order = new_order;
          tab.style.order = order.toString();
          rectangles = tabs.map((element) => element.getBoundingClientRect());
        }
      }
    }, () => {
      let current = index;
      let move_before = (order + 1) / 2;
      this.dragging = false;
      for (let i = 0; i < this.model.sheets.length; i++) {
        if (!this.model.sheets.list[i].visible) {
          if (current >= i) {
            current++;
          }
          if (move_before >= i) {
            move_before++;
          }
        }
      }
      if (current === move_before || current === 0 && move_before <= 0 || current === tabs.length - 1 && move_before >= tabs.length - 1) {
      } else {
        this.Publish({ type: "reorder-sheet", index: current, move_before });
      }
    });
  }
  /**
   * update tabs from model.
   */
  Update() {
    if (this.dragging) {
      return;
    }
    if (this.options.tab_bar === "auto") {
      const visible_count = this.model.sheets.list.reduce((count, test) => test.visible ? count + 1 : count, 0);
      if (visible_count <= 1) {
        this.Show(false);
        return;
      }
      this.Show(true);
    }
    if (!this.tab_container) {
      return;
    }
    this.tab_container.innerText = "";
    const tabs = [];
    for (const sheet of this.model.sheets.list) {
      if (!sheet.visible) {
        continue;
      }
      const index = tabs.length;
      const tab = this.DOM.Create("li");
      tab.setAttribute("tabindex", "0");
      tab.style.order = (index * 2).toString();
      tab.role = "tab";
      this.SetActive(tab, sheet === this.view.active_sheet);
      const mousedown = (event) => this.MouseDownTab(event, tab, sheet, index, tabs);
      const doubleclick = (event) => {
        tab.removeEventListener("mousedown", mousedown);
        tab.removeEventListener("dblclick", doubleclick);
        this.DoubleClickTab(event, tab, sheet);
      };
      tab.textContent = sheet.name;
      tab.addEventListener("dblclick", doubleclick);
      tab.addEventListener("mousedown", mousedown);
      this.tab_container.appendChild(tab);
      tabs.push(tab);
    }
  }
};

// treb-grid/src/types/grid_selection.ts
var CreateSelection = () => {
  return {
    target: { row: 0, column: 0 },
    area: new Area({ row: 0, column: 0 }),
    empty: true
  };
};

// treb-grid/src/types/annotation.ts
var key_generator = 100;
var default_annotation_data = {
  move_with_cells: true,
  resize_with_cells: true,
  movable: true,
  resizable: true,
  removable: true,
  selectable: true
};
var Annotation = class {
  data = {
    ...default_annotation_data
  };
  /** 
   * the key field is used to identify and coordinate annotations when we 
   * have freeze panes. when an annotation crosses a freeze pane, we need
   * two copies of the rendered node so that we can scroll. we use the key
   * to match the frozen/unfrozen instances.
   */
  get key() {
    return this.key_;
  }
  /** coordinates, in sheet space */
  rect;
  // public get rect(): Rectangle|undefined { return this.rect_; }
  /** display coordinates, possibly scaled. not persisted. */
  scaled_rect;
  /** also opaque data, but not serialized. */
  temp = {};
  view = [];
  /**
   * advisory, meaning we probably need an update if there's an opportunity.
   * only advisory and not persisted.
   */
  dirty;
  key_ = key_generator++;
  /**
   * constructor takes persisted data
   */
  constructor(opts = {}) {
    this.data = {
      ...default_annotation_data,
      ...JSON.parse(JSON.stringify(opts))
    };
    if (opts.rect) {
      this.rect = Rectangle.Create(opts.rect);
    }
  }
  /**
   * serialization just returns persisted data, plus we update the 
   * rectangle. 
   * 
   * anyone serializing annotations should just be fetching the data
   * object, but we're leaving this in place because we can't trace 
   * it back using tooling. that's a real drawback of toJSON, we 
   * should stop using it.
   * 
   * although as long as we need to support `rect` here, it's not bad
   * that we do it this way. perhaps change the function name, and 
   * call it directly?
   * 
   */
  toJSON() {
    return {
      ...this.data,
      rect: this.rect
    };
  }
};

// treb-grid/src/types/sheet.ts
var DEFAULT_COLUMN_WIDTH = 100;
var DEFAULT_ROW_HEADER_WIDTH = 60;
var Sheet = class _Sheet {
  // --- static members -------------------------------------------------------
  static base_id = 100;
  static default_sheet_name = "Sheet1";
  // FIXME: use the external measurement object (from utils)
  // private static measurement_canvas?: HTMLCanvasElement;
  /**
   * adding verbose flag so we can figure out who is publishing
   * (and stop -- part of the ExecCommand switchover)
   */
  // public static readonly sheet_events = new EventSource<SheetEvent>(true, 'sheet-events');
  // --- instance members -----------------------------------------------------
  /**
   * in the old model, we had a concept of "default" style properties. we then
   * used that object for theming: we would set default properties when the theme
   * changed.
   *
   * the problem is that if there are multiple instances on a single page, with
   * different themes, they would clash.
   *
   * so the new concept is to have a default property set per instance, managed
   * by the grid instance. any sheets that are loaded in/created by grid will
   * get a reference to that property set, and grid can update it as desired.
   *
   * because it's a reference, it should be constant.
   * FIXME: move to model...
   */
  default_style_properties;
  /* moved from grid */
  annotations = [];
  // moved from layout
  freeze = {
    rows: 0,
    columns: 0
  };
  /** testing */
  // public scale = 1.0;
  visible = true;
  /** standard width (FIXME: static?) */
  default_column_width = 100;
  /** standard height (FIXME: static?) */
  default_row_height = 25;
  /** cells data */
  cells = new Cells();
  /**
   * selection. moved to sheet to preserve selections in multiple sheets.
   * this instance should just be used to populate the actual selection,
   * not used as a reference.
   */
  selection = CreateSelection();
  /**
   * cache scroll offset for flipping between sheets. should this be
   * persisted? (...)
   */
  scroll_offset = { x: 0, y: 0 };
  /**
   * named ranges: name -> area
   * FIXME: this needs to move to an outer container, otherwise we
   * may get conflicts w/ multiple sheets. unless we want to allow that...
   */
  // public named_ranges = new NamedRangeCollection();
  name = _Sheet.default_sheet_name;
  background_image;
  _image = void 0;
  /**
   * set this flag when we need to update conditional formats even
   * if they are not dirty (generally when one is deleted)
   */
  flush_conditional_formats = false;
  get image() {
    return this._image;
  }
  /**
   * @internal
   */
  conditional_formats = [];
  /**
   * @internal
   * 
   * testing, not serialized atm
   */
  outline;
  /** internal ID */
  // tslint:disable-next-line: variable-name
  id_;
  // tslint:disable-next-line:variable-name
  row_height_ = [];
  // tslint:disable-next-line:variable-name
  column_width_ = [];
  /**
   * optionally, custom row headers (instead of 1...2...3...)
   * FIXME: should maybe be a function instead?
   * FIXME: why is this any type? just sloppiness?
   */
  row_headers = [];
  /**
   * optionally, custom column headers (instead of A...B...C...)
   * FIXME: should maybe be a function instead?
   * FIXME: why is this any type? just sloppiness?
   */
  column_headers = [];
  /** size of header */
  row_header_width = 100;
  /** size of header */
  column_header_height = 25;
  // we cache composite styles so we don't wind up with objects
  // for every cell, when all we need is a single reference.
  style_map = [];
  // we use json for comparison. it should be faster than the alternative
  // (even if that doesn't make sense).
  style_json_map = [];
  // style now uses overlays, but we want to precalculate the
  // overlaid values. we need to hold on to the originals, in
  // the event something changes, so we can redo the calculation.
  // there's a default at the bottom that gets applied to everything.
  // (in Style). above that, we have the sheet style
  sheet_style = {};
  // then individual (applied) row and column styles (indexed by row/column)
  row_styles = {};
  column_styles = {};
  /* 
   we used to have "alternate row" styles. it's clumsy, but it is a nice
   effect. we will add that back via a "pattern". not sure how the UI would
   work for this, but programatically it works.
  
   just rows atm, not columns.
   */
  row_pattern = [];
  // and finally any cell-specific styles. [FIXME: this is sparse]
  // [why FIXME? sparse is OK in js]
  cell_style = [];
  /**
   * applied conditional formats are stored them in this array;
   * they will be stacked on top of cell style when rendering.
   * conditional formats have top priority. [FIXME: what about tables?]
   */
  conditional_format_cache = [];
  /**
   * this is a list of cells we formatted on the last pass, so we can 
   * compare when applying conditional formats .
   * 
   * update: using areas
   */
  conditional_format_checklist = [];
  // --- accessors ------------------------------------------------------------
  // public get column_header_count() { return this.column_header_count_; }
  get header_offset() {
    return { x: this.row_header_width, y: this.column_header_height };
  }
  /** accessor: now just a wrapper for the call on cells */
  get rows() {
    return this.cells.rows;
  }
  /** accessor: now just a wrapper for the call on cells */
  get columns() {
    return this.cells.columns;
  }
  get id() {
    return this.id_;
  }
  set id(id) {
    this.id_ = id;
    if (this.id >= _Sheet.base_id) {
      _Sheet.base_id = this.id + 1;
    }
  }
  /**
   * constructor is now protected. use a factory method (Blank or FromJSON).
   */
  constructor(theme_style_properties) {
    this.default_style_properties = theme_style_properties;
    this.default_column_width = DEFAULT_COLUMN_WIDTH;
    this.row_header_width = DEFAULT_ROW_HEADER_WIDTH;
    this.UpdateDefaultRowHeight();
    this.id_ = _Sheet.base_id++;
  }
  // --- class methods --------------------------------------------------------
  static Reset() {
    this.base_id = 100;
  }
  /**
   * factory method creates a new sheet
   */
  static Blank(style_defaults, name, rows = 30, columns = 20) {
    const sheet = new _Sheet(style_defaults);
    if (name) {
      sheet.name = name;
    }
    rows = Math.max(rows, 1);
    columns = Math.max(columns, 1);
    sheet.cells.EnsureCell({ row: rows - 1, column: columns - 1 });
    return sheet;
  }
  /**
   * update old-style alignment constants to the new symbolic values.
   * updates in place.
   */
  static UpdateStyle(properties) {
    if (typeof properties.horizontal_align === "number") {
      const members = [
        "",
        // Style.HorizontalAlign.None,
        "left",
        // Style.HorizontalAlign.Left,
        "center",
        // Style.HorizontalAlign.Center,
        "right"
        // Style.HorizontalAlign.Right,
      ];
      properties.horizontal_align = members[properties.horizontal_align] || void 0;
    }
    if (typeof properties.vertical_align === "number") {
      const members = [
        "",
        // Style.VerticalAlign.None,
        "top",
        // Style.VerticalAlign.Top,
        "bottom",
        // Style.VerticalAlign.Bottom,
        "middle"
        // Style.VerticalAlign.Middle,
      ];
      properties.vertical_align = members[properties.vertical_align] || void 0;
    }
  }
  /**
   * deserialize json representation. returns new instance or updates
   * passed instance.
   *
   * FIXME: why not make this an instance method, always call on new instance?
   *
   * @param hints UpdateHints supports partial deserialization/replacement
   * if we know there are only minor changes (as part of undo/redo, probably)
   */
  static FromJSON(json, style_defaults, sheet) {
    const source = typeof json === "string" ? JSON.parse(json) : json;
    const unflatten_numeric_array = (target, data) => {
      Object.keys(data).forEach((key) => {
        const index = Number(key) || 0;
        target[index] = data[key];
      });
    };
    if (!sheet) {
      sheet = new _Sheet(style_defaults);
    }
    if (source.default_column_width) {
      sheet.default_column_width = source.default_column_width;
    }
    if (source.default_row_height) {
      sheet.default_row_height = source.default_row_height;
    }
    if (source.conditional_formats) {
      sheet.conditional_formats = source.conditional_formats;
    }
    if (source.id) {
      sheet.id = source.id;
    }
    if (source.name) {
      sheet.name = source.name;
    }
    if (source.background_image) {
      sheet.background_image = source.background_image;
    }
    const patch_style = (style) => {
      const ref = style;
      this.UpdateStyle(ref);
      if (ref.font_size_value || ref.font_size_unit) {
        ref.font_size = {
          unit: ref.font_size_unit || "pt",
          value: ref.font_size_value || 10
        };
        ref.font_size_unit = void 0;
        ref.font_size_value = void 0;
      }
      if (ref.font_bold) {
        ref.bold = true;
        ref.font_bold = void 0;
      }
      if (ref.font_italic) {
        ref.italic = true;
        ref.font_italic = void 0;
      }
      if (ref.font_underline) {
        ref.underline = true;
        ref.font_underline = void 0;
      }
      if (ref.font_strike) {
        ref.strike = true;
        ref.font_strike = void 0;
      }
      if (ref.text_color) {
        if (ref.text_color !== "none") {
          ref.text = { text: ref.text_color };
        }
        ref.text_color = void 0;
      }
      if (ref.background) {
        if (ref.background !== "none") {
          ref.fill = { text: ref.background };
        }
        ref.background = void 0;
      }
      if (ref.border_top_color) {
        if (ref.border_top_color !== "none") {
          ref.border_top_fill = { text: ref.border_top_color };
        }
        ref.border_top_color = void 0;
      }
      if (ref.border_left_color) {
        if (ref.border_left_color !== "none") {
          ref.border_left_fill = { text: ref.border_left_color };
        }
        ref.border_left_color = void 0;
      }
      if (ref.border_bottom_color) {
        if (ref.border_bottom_color !== "none") {
          ref.border_bottom_fill = { text: ref.border_bottom_color };
        }
        ref.border_bottom_color = void 0;
      }
      if (ref.border_right_color) {
        if (ref.border_right_color !== "none") {
          ref.border_right_fill = { text: ref.border_right_color };
        }
        ref.border_right_color = void 0;
      }
    };
    const cell_style_refs = source.styles || source.cell_style_refs || [];
    for (const entry of cell_style_refs) {
      patch_style(entry);
    }
    sheet.cell_style = [];
    if (cell_style_refs) {
      (source.cell_styles || []).forEach((cell_style) => {
        if (typeof cell_style.ref === "number") {
          cell_style.style = JSON.parse(JSON.stringify(cell_style_refs[cell_style.ref]));
        }
      });
    }
    sheet.cells.FromJSON(source.data);
    if (source.rows)
      sheet.cells.EnsureRow(source.rows - 1);
    if (source.columns)
      sheet.cells.EnsureColumn(source.columns - 1);
    if (source.data) {
      if (IsFlatDataArray(source.data)) {
        for (const entry of source.data) {
          if (entry.style_ref) {
            if (!sheet.cell_style[entry.column])
              sheet.cell_style[entry.column] = [];
            sheet.cell_style[entry.column][entry.row] = // entry.style;
            JSON.parse(JSON.stringify(cell_style_refs[entry.style_ref]));
          }
        }
      } else {
        if (IsNestedRowArray(source.data)) {
          for (const block of source.data) {
            const row = block.row;
            for (const entry of block.cells) {
              const column = entry.column;
              if (entry.style_ref) {
                if (!sheet.cell_style[column])
                  sheet.cell_style[column] = [];
                sheet.cell_style[column][row] = // entry.style;
                JSON.parse(JSON.stringify(cell_style_refs[entry.style_ref]));
              }
            }
          }
        } else {
          for (const block of source.data) {
            const column = block.column;
            for (const entry of block.cells) {
              const row = entry.row;
              if (entry.style_ref) {
                if (!sheet.cell_style[column])
                  sheet.cell_style[column] = [];
                sheet.cell_style[column][row] = // entry.style;
                JSON.parse(JSON.stringify(cell_style_refs[entry.style_ref]));
              }
            }
          }
        }
      }
    }
    sheet.freeze.rows = 0;
    sheet.freeze.columns = 0;
    if (source.freeze) {
      sheet.freeze.rows = source.freeze.rows || 0;
      sheet.freeze.columns = source.freeze.columns || 0;
    }
    sheet.scroll_offset = source.scroll ? { ...source.scroll } : { x: 0, y: 0 };
    for (const cell_style of source.cell_styles || []) {
      if (cell_style.style) {
        if (!sheet.cell_style[cell_style.column])
          sheet.cell_style[cell_style.column] = [];
        sheet.cell_style[cell_style.column][cell_style.row] = cell_style.style;
        if (cell_style.rows) {
          for (let r = 1; r < cell_style.rows; r++) {
            sheet.cell_style[cell_style.column][cell_style.row + r] = JSON.parse(JSON.stringify(cell_style.style));
          }
        }
      }
    }
    sheet.sheet_style = source.sheet_style || {};
    sheet.column_styles = {};
    sheet.row_styles = {};
    const MapStyles = (source_list, target_list) => {
      for (const key of Object.keys(source_list)) {
        const index = Number(key);
        const value = source_list[index];
        if (typeof value === "number") {
          const properties = cell_style_refs[value];
          if (properties) {
            target_list[index] = JSON.parse(JSON.stringify(properties));
            patch_style(target_list[index]);
          }
        } else if (value) {
          target_list[index] = value;
          patch_style(target_list[index]);
        }
      }
    };
    MapStyles(source.row_style, sheet.row_styles);
    MapStyles(source.column_style, sheet.column_styles);
    sheet.row_pattern = source.row_pattern || [];
    patch_style(sheet.sheet_style || {});
    for (const entry of sheet.row_pattern) {
      patch_style(entry);
    }
    sheet.row_height_ = [];
    unflatten_numeric_array(
      sheet.row_height_,
      source.row_height || {}
    );
    if (sheet.row_height_.length) {
      sheet.cells.EnsureRow(sheet.row_height_.length - 1);
    }
    sheet.column_width_ = [];
    unflatten_numeric_array(
      sheet.column_width_,
      source.column_width || {}
    );
    if (sheet.column_width_.length) {
      sheet.cells.EnsureColumn(sheet.column_width_.length - 1);
    }
    sheet.annotations = (source.annotations || []).map((entry) => new Annotation(entry));
    if (source.selection) {
      sheet.selection = JSON.parse(JSON.stringify(source.selection));
    }
    sheet.visible = true;
    if (typeof source.visible !== "undefined") {
      sheet.visible = !!source.visible;
    }
    return sheet;
  }
  Activate(DOM) {
    if (this.background_image) {
      const resource = ValidateURI(this.background_image);
      if (resource) {
        this._image = DOM.Create("img");
        this._image.src = resource;
      }
    }
  }
  /* *
     * factory method creates a sheet from a 2D array.
     *
     * /
    public static FromArray(data: any[] = [], transpose = false): Sheet {
      const sheet = new Sheet();
      sheet.cells.FromArray(data, transpose);
  
      return sheet;
    }
    */
  // --- public methods -------------------------------------------------------
  MergeCells(area) {
    area = area.Clone();
    this.cells.Apply(area, (cell, c, r) => {
      cell.merge_area = area;
      cell.render_clean = [];
      if (c !== area.start.column || r !== area.start.row)
        cell.Reset();
    }, true);
  }
  UnmergeCells(area) {
    let match = true;
    this.cells.Apply(area, (cell) => {
      match = match && !!cell.merge_area && area.Equals(cell.merge_area);
    }, false);
    if (!match) {
      console.warn("area mismatch");
      return;
    }
    this.cells.Apply(area, (cell) => {
      cell.merge_area = void 0;
      cell.render_clean = [];
    }, false);
  }
  /**
   * FIXME: measure the font.
   * 
   * Can we use the same metrics as renderer? That uses a canvas. Obviously
   * canvas won't work if there's no DOM but it's OK if this method fails in
   * that case; the only question is will it break if it's running headless?
   */
  StyleFontSize(style, default_properties2 = {}) {
    let font_height = style.font_size?.value || 0;
    let scale = 0;
    switch (style.font_size?.unit) {
      case "px":
        font_height *= 75 / 100;
        break;
      case "em":
        scale = style.font_size.value || 1;
        break;
      case "%":
        scale = (style.font_size.value || 100) / 100;
        break;
    }
    if (scale) {
      font_height = scale * (default_properties2.font_size?.value || 10);
      if (default_properties2.font_size?.unit === "px") {
        font_height *= 75 / 100;
      }
    }
    return font_height || 10;
  }
  /**
   * FIXME: this is called in the ctor, which made sense when sheets
   * were more ephemeral. now that we update a single instance, rather
   * than create new instances, we lose this behavior. we should call
   * this when we change sheet style.
   * 
   * removing parameter, event
   */
  UpdateDefaultRowHeight() {
    const composite = Style.Composite([this.default_style_properties, this.sheet_style]);
    if (typeof window !== "undefined") {
      const measurement = Measurement.MeasureText(Style.Font(composite), "M");
      const height = Math.round(measurement.height * 1.4);
      if (this.default_row_height < height) {
        this.default_row_height = height;
      }
    }
  }
  /**
   * deprecated (or give me a reason to keep it)
   * KEEP IT: just maintain flexibility, it has very low cost
   */
  SetRowHeaders(headers) {
    this.row_headers = headers.map((value) => value === void 0 ? "" : value.toString());
    if (this.row_headers) {
      this.cells.EnsureRow(this.row_headers.length - 1);
    }
  }
  /**
   * deprecated (or give me a reason to keep it)
   * KEEP IT: just maintain flexibility, it has very low cost
   */
  SetColumnHeaders(headers) {
    this.column_headers = headers.map((value) => value === void 0 ? "" : value.toString());
    if (headers) {
      this.cells.EnsureColumn(headers.length - 1);
    }
  }
  /**
   * deprecated
   * KEEP IT: just maintain flexibility, it has very low cost
   */
  RowHeader(row) {
    if (this.row_headers) {
      if (this.row_headers.length > row)
        return this.row_headers[row];
      return "";
    }
    return row + 1;
  }
  /**
   * deprecated
   * KEEP IT: just maintain flexibility, it has very low cost
   * (we did drop the multiple rows, though)
   */
  ColumnHeader(column) {
    let s = "";
    if (this.column_headers) {
      if (this.column_headers.length > column)
        return this.column_headers[column];
      return "";
    }
    for (; ; ) {
      const c = column % 26;
      s = String.fromCharCode(65 + c) + s;
      column = Math.floor(column / 26);
      if (column)
        column--;
      else
        break;
    }
    return s;
  }
  GetRowHeight(row) {
    const height = this.row_height_[row];
    if (typeof height === "undefined")
      return this.default_row_height;
    return height;
  }
  SetRowHeight(row, height) {
    this.row_height_[row] = height;
    this.cells.EnsureRow(row);
    return height;
  }
  GetColumnWidth(column) {
    const width = this.column_width_[column];
    if (typeof width === "undefined")
      return this.default_column_width;
    return width;
  }
  SetColumnWidth(column, width) {
    this.column_width_[column] = width;
    this.cells.EnsureColumn(column);
    return width;
  }
  /**
   * returns set of properties in B that differ from A. returns 
   * property values from B.
   * 
   * this is the function I could never get to work inline for 
   * CellStyle -- not sure why it works better with a generic 
   * function (although the partial here is new, so maybe it's that?)
   *
   * seems to be related to
   * https://github.com/microsoft/TypeScript/pull/30769
   * 
   */
  Delta(A, B) {
    const result = {};
    const keys = [...Object.keys(A), ...Object.keys(B)];
    for (const key of keys) {
      const a = A[key];
      const b = B[key];
      if (typeof a === "object" && typeof b === "object") {
        if (JSON.stringify(a) !== JSON.stringify(b)) {
          result[key] = b;
        }
      } else if (a !== b) {
        result[key] = b;
      }
    }
    return result;
  }
  /**
   * updates cell styles. flushes cached style.
   *
   * @param delta merge with existing properties (we will win conflicts)
   * @param inline this is part of another operation, don't do any undo/state updates
   */
  UpdateCellStyle(address, properties, delta = true) {
    const { row, column } = address;
    if (!this.cell_style[column])
      this.cell_style[column] = [];
    const underlying = this.CompositeStyleForCell(address, false, false, void 0, false);
    const merged = Style.Composite([
      this.default_style_properties,
      underlying,
      Style.Merge(this.cell_style[column][row] || {}, properties, delta)
    ]);
    const composite = this.Delta(underlying, merged);
    this.cell_style[column][row] = composite;
    this.BleedFlush({ start: address, end: address });
  }
  /**
   * invalidate sets the "render dirty" flag on cells, whether there
   * is any change or not. we are currently using it to force rendering
   * when border/background changes, and we need to handle bleed into
   * neighboring cells.
   */
  Invalidate(area) {
    this.cells.Apply(this.RealArea(area), (cell) => cell.render_clean = []);
  }
  /**
   *
   * @param area
   * @param style
   * @param delta
   * @param render LEGACY PARAMETER NOT USED
   */
  UpdateAreaStyle(area, style = {}, delta = true) {
    if (!area)
      return;
    if (area.entire_sheet) {
      this.UpdateSheetStyle(style, delta);
    } else if (area.entire_column) {
      for (let column = area.start.column; column <= area.end.column; column++) {
        this.UpdateColumnStyle(column, style, delta);
      }
    } else if (area.entire_row) {
      for (let row = area.start.row; row <= area.end.row; row++) {
        this.UpdateRowStyle(row, style, delta);
      }
    } else
      area.Array().forEach((address) => this.UpdateCellStyle(address, style, delta));
  }
  /**
   * checks if the given cell has been assigned a specific style, either for
   * the cell itself, or for row and column.
   */
  HasCellStyle(address) {
    return !!(this.cell_style[address.column] && this.cell_style[address.column][address.row] || this.row_styles[address.row] || this.column_styles[address.column] || this.row_pattern.length);
  }
  /**
   * returns the next non-hidden column. so if you are column C (2) and columns
   * D, E, and F are hidden, then it will return 6 (G).
   */
  NextVisibleColumn(column) {
    for (++column; this.column_width_[column] === 0; column++) {
    }
    return column;
  }
  /** 
   * @see NextVisibleColumn 
   * because this one goes left, it may return -1 meaning you are at the left edge 
   */
  PreviousVisibleColumn(column) {
    for (--column; column >= 0 && this.column_width_[column] === 0; column--) {
    }
    return column;
  }
  /**
   * @see NextVisibleColumn
   */
  NextVisibleRow(row) {
    for (++row; this.row_height_[row] === 0; row++) {
    }
    return row;
  }
  /**
   * @see PreviousVisibleColumn
   */
  PreviousVisibleRow(row) {
    for (--row; row >= 0 && this.row_height_[row] === 0; row--) {
    }
    return row;
  }
  /**
   * if this cell is part of a table, get row information -- is this
   * an alternate row, is it the header, is it the last (visible) row
   * 
   * @param table 
   * @param row 
   * @returns 
   */
  TableRow(table, row) {
    const result = {
      alternate: false,
      header: row === table.area.start.row,
      last: false,
      totals: table.totals_row && row === table.area.end.row
    };
    if (result.header || result.totals) {
      return result;
    }
    const totals_visible = table.totals_row && this.GetRowHeight(table.area.end.row) > 0;
    if (!totals_visible) {
      let last = table.area.end.row;
      for (; last >= table.area.start.row; last--) {
        if (this.GetRowHeight(last)) {
          result.last = last === row;
          break;
        }
      }
    }
    let start = table.area.start.row + 1;
    for (; start <= table.area.end.row; start++) {
      if (!this.GetRowHeight(start)) {
        continue;
      }
      result.alternate = !result.alternate;
      if (start === row) {
        break;
      }
    }
    return result;
  }
  /**
   * returns style properties for cells surrounding this cell, 
   * mapped like a number pad:
   * 
   * +---+---+---+
   * | 7 | 8 | 9 |
   * +---+---+---+
   * | 4 | X | 6 |
   * +---+---+---+
   * | 1 | 2 | 3 |
   * +---+---+---+
   * 
   * presuming you already have X (5). this is called by renderer, we 
   * move it here so we can inline the next/previous loops.
   * 
   */
  SurroundingStyle(address, table) {
    const map = [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}];
    let column_right = address.column + 1;
    let column_left = address.column - 1;
    let row_below = address.row + 1;
    let row_above = address.row - 1;
    for (; this.column_width_[column_right] === 0; column_right++) {
    }
    for (; this.row_height_[row_below] === 0; row_below++) {
    }
    for (; column_left >= 0 && this.column_width_[column_left] === 0; column_left--) {
    }
    for (; row_above >= 0 && this.row_height_[row_above] === 0; row_above--) {
    }
    if (column_left >= 0 && row_above >= 0) {
      map[7] = this.CellStyleData({ row: row_above, column: column_left }, table) || {};
    }
    if (column_left >= 0) {
      map[4] = this.CellStyleData({ row: address.row, column: column_left }, table) || {};
      map[1] = this.CellStyleData({ row: row_below, column: column_left }, table) || {};
    }
    if (row_above >= 0) {
      map[8] = this.CellStyleData({ row: row_above, column: address.column }, table) || {};
      map[9] = this.CellStyleData({ row: row_above, column: column_right }, table) || {};
    }
    map[6] = this.CellStyleData({ row: address.row, column: column_right }, table) || {};
    map[2] = this.CellStyleData({ row: row_below, column: address.column }, table) || {};
    map[3] = this.CellStyleData({ row: row_below, column: column_right }, table) || {};
    return map;
  }
  /**
   * get style only. as noted in the comment to `CellData` there used to be
   * no case where this was useful without calculated value as well; but we
   * now have a case: fixing borders by checking neighboring cells. (testing).
   * 
   * switching from null to undefined as "missing" type
   * 
   * UPDATE: this is a convenient place to do table formatting. table 
   * formatting is complicated because it's variable; it depends on row
   * visibility so we can't cache it. this is a good spot because we're 
   * already calling this function when doing border rendering; we can call 
   * it separately, if necessary, when rendering cells.
   * 
   * table formats are applied on top of cell formats, after compositing,
   * and we don't preserve the style.
   * 
   */
  CellStyleData(address, default_table_theme) {
    const cell = this.cells.GetCell(address);
    if (!cell) {
      return void 0;
    }
    if (!cell.style) {
      const index = this.GetStyleIndex(this.CompositeStyleForCell(address));
      cell.style = this.style_map[index];
    }
    if (cell.table) {
      const table_theme = cell.table.theme || default_table_theme;
      if (table_theme) {
        let style = JSON.parse(JSON.stringify(cell.style));
        const data = this.TableRow(cell.table, address.row);
        if (data.header) {
          if (table_theme.header) {
            style = Style.Composite([style, table_theme.header]);
          }
        } else if (data.totals) {
          if (table_theme.total) {
            style = Style.Composite([style, table_theme.total]);
          }
        } else {
          if (data.alternate) {
            if (table_theme.odd) {
              style = Style.Composite([style, table_theme.odd]);
            }
          } else {
            if (table_theme.even) {
              style = Style.Composite([style, table_theme.even]);
            }
          }
        }
        return style;
      }
    }
    return cell.style;
  }
  /**
   * accessor to get cell style without row pattern -- for cut/copy
   * @param address 
   */
  GetCopyStyle(address) {
    return this.CompositeStyleForCell(address, true, false, void 0, false);
  }
  /**
   * wrapper for getting all relevant render data.
   * TODO: merge in "FormattedValue". restructure data so we don't have
   * two caches (formatted and calculated).
   *
   * NOTE: we removed "GetCellStyle" in favor of this function. the rationale
   * is that there are no reasonable cases where someone looks up the style
   * without that being a next step to (or in reasonable proximity to)
   * rendering. so it's reasonable to call this function even if it's in
   * advance of rendering.
   *
   * NOTE: that applies to the "GetCellFormula" and "GetCellValue" functions
   * as well -- so remove those too.
   *
   * NOTE: actually GetCellFormula resolves array formulae, so maybe not --
   * or the caller needs to check.
   * 
   */
  CellData(address) {
    const cell = this.cells.EnsureCell(address);
    if (cell.rendered_type)
      return cell;
    let type;
    let value;
    if (cell.calculated_type) {
      value = cell.calculated;
      type = cell.calculated_type;
    } else {
      value = cell.value;
      type = cell.type;
    }
    if (!cell.style) {
      const index = this.GetStyleIndex(this.CompositeStyleForCell(address));
      cell.style = this.style_map[index];
    }
    if (!type || value === null || typeof value === "undefined") {
      cell.formatted = "";
      cell.rendered_type = 2 /* string */;
    } else if (type === 3 /* number */) {
      if (isNaN(value)) {
        cell.formatted = // Style.Format(cell.style, value); // formats NaN
        typeof cell.style.nan === "undefined" ? "NaN" : cell.style.nan;
      } else {
        cell.formatted = // Style.Format(cell.style, value);
        this.FormatNumber(value, cell.style.number_format);
      }
      cell.rendered_type = 3 /* number */;
    } else if (type === 6 /* error */) {
      cell.formatted = "#" + (value || "ERR?");
      cell.rendered_type = 6 /* error */;
    } else if (type === 4 /* boolean */) {
      cell.formatted = value.toString().toUpperCase();
      cell.rendered_type = 4 /* boolean */;
    } else if (type === 1 /* formula */ && cell.calculated === void 0) {
      cell.formatted = "";
      cell.rendered_type = 2 /* string */;
    } else if (type === 7 /* complex */) {
      const complex = value;
      if (isNaN(complex.real) || isNaN(complex.imaginary)) {
        cell.formatted = // Style.Format(cell.style, value); // formats NaN
        typeof cell.style.nan === "undefined" ? "NaN" : cell.style.nan;
      } else {
        const format = NumberFormatCache.Get(cell.style.number_format || "", true);
        cell.formatted = format.FormatComplex(complex);
      }
      cell.rendered_type = 7 /* complex */;
    } else if (type === 9 /* dimensioned_quantity */) {
      if (isNaN(value.value)) {
        cell.formatted = // Style.Format(cell.style, value); // formats NaN
        typeof cell.style.nan === "undefined" ? "NaN" : cell.style.nan;
        cell.formatted += ` ` + value.unit;
      } else {
        const format = NumberFormatCache.Get(cell.style.number_format || "", true);
        cell.formatted = // Style.Format(cell.style, value);
        // this.FormatNumber((value as DimensionedQuantity).value, cell.style.number_format);
        // this.FormatNumber(value, cell.style.number_format);
        format.FormatDimensionedQuantity(value);
      }
      cell.rendered_type = 9 /* dimensioned_quantity */;
    } else {
      cell.formatted = this.FormatNumber(value, cell.style.number_format);
      cell.rendered_type = 2 /* string */;
    }
    return cell;
  }
  /**
   * format number using passed format; gets the actual format object
   * and calls method. returns a string or array of text parts
   * (@see treb-format).
   */
  FormatNumber(value, format = "") {
    const formatted = NumberFormatCache.Get(format).FormatParts(value);
    if (!formatted.length)
      return "";
    if (formatted.length === 1 && !formatted[0].flag) {
      return formatted[0].text || "";
    }
    return formatted;
  }
  // no references... removing
  //public ColumnHeaderHeight(): number {
  //  return this.column_header_height || this.default_row_height_x;
  //}
  /**
   * the only place this is called is in a method that shows/hides headers;
   * it sets the size either to 1 (hidden) or undefined, which uses the 
   * defaults here. that suggests we should have a show/hide method instead.
   * 
   * @param row_header_width 
   * @param column_header_height 
   */
  SetHeaderSize(row_header_width = DEFAULT_ROW_HEADER_WIDTH, column_header_height = this.default_row_height) {
    this.row_header_width = row_header_width;
    this.column_header_height = column_header_height;
  }
  /**
   * resize row to match character hight, taking into
   * account multi-line values.
   * 
   * UPDATE: since the only caller calls with inline = true, removing 
   * parameter, test, and extra behavior.
   */
  AutoSizeRow(row, default_properties2 = {}, allow_shrink = true) {
    let height = this.default_row_height;
    const padding = 9;
    for (let column = 0; column < this.cells.columns; column++) {
      const cell = this.CellData({ row, column });
      const style = cell.style;
      let text = cell.formatted || "";
      if (typeof text !== "string") {
        text = text.map((part) => part.text).join("");
      }
      if (style && text && text.length) {
        const lines = text.split(/\n/);
        const font_height = Math.round(this.StyleFontSize(style, default_properties2) * 1.5);
        height = Math.max(height, ((font_height || 10) + padding) * lines.length);
      }
    }
    if (!allow_shrink) {
      const test = this.GetRowHeight(row);
      if (test >= height) {
        return;
      }
    }
    this.SetRowHeight(row, height);
  }
  /** returns the style properties for a given style index */
  GetStyle(index) {
    return this.style_map[index];
  }
  /* *
   * if the cell is in an array, returns the array as an Area.
   * if not, returns falsy (null or undefined).
   *
   * FIXME: is this used? seems like the caller could do this
   * calculation.
   * 
   * Answer was no, so removed
   * /
  public ContainingArray(address: ICellAddress): Area | undefined {
    const cell = this.cells.GetCell(address);
    if (cell) return cell.area;
    return undefined;
  }
  */
  /**
   *
   * @param before_row insert before
   * @param count number to insert
   */
  InsertRows(before_row = 0, count = 1) {
    if (before_row) {
      for (let column = 0; column < this.cells.columns; column++) {
        const cell1 = this.cells.GetCell({ row: before_row - 1, column }, false);
        if (cell1 && cell1.area) {
          const cell2 = this.cells.GetCell({ row: before_row, column }, false);
          if (cell2 && cell2.area && cell2.area.Equals(cell1.area)) {
            return false;
          }
        }
      }
    }
    if (count < 0) {
      this.cells.DeleteRows(before_row, -count);
    } else {
      this.cells.InsertRows(before_row, count);
    }
    const merge_heads = {};
    const array_heads = {};
    for (let row = before_row; row < this.cells.rows; row++) {
      for (let column = 0; column < this.cells.columns; column++) {
        const cell = this.cells.GetCell({ row, column }, false);
        if (cell) {
          if (cell.area && !array_heads[cell.area.spreadsheet_label]) {
            array_heads[cell.area.spreadsheet_label] = cell.area;
          }
          if (cell.merge_area && !merge_heads[cell.merge_area.spreadsheet_label]) {
            merge_heads[cell.merge_area.spreadsheet_label] = cell.merge_area;
          }
        }
      }
    }
    for (const key of Object.keys(array_heads)) {
      const head = array_heads[key];
      const patched = new Area(
        { row: head.start.row + count, column: head.start.column },
        { row: head.end.row + count, column: head.end.column }
      );
      patched.Iterate((address) => {
        const cell = this.cells.GetCell(address, true);
        cell.area = patched;
      });
    }
    for (const key of Object.keys(merge_heads)) {
      const head = merge_heads[key];
      const patched_start = { row: head.start.row, column: head.start.column };
      if (head.start.row >= before_row)
        patched_start.row += count;
      const patched = new Area(
        patched_start,
        { row: head.end.row + count, column: head.end.column }
      );
      patched.Iterate((address) => {
        const cell = this.cells.GetCell(address, true);
        cell.merge_area = patched;
      });
    }
    const row_keys = Object.keys(this.row_styles);
    const new_row_style = {};
    row_keys.forEach((key) => {
      const index = Number(key);
      if (index < before_row)
        new_row_style[index] = this.row_styles[index];
      else if (count < 0 && index < before_row - count) {
      } else
        new_row_style[index + count] = this.row_styles[index];
    });
    this.row_styles = new_row_style;
    let args = [];
    if (count < 0) {
      args = [before_row, -count];
    } else {
      args = [before_row, 0];
      for (let i = 0; i < count; i++)
        args.push(void 0);
    }
    this.cell_style.forEach((column) => {
      if (column && column.length >= before_row) {
        column.splice.apply(column, args);
      }
    });
    this.row_height_.splice.apply(this.row_height_, args);
    this.FlushCellStyles();
    return true;
  }
  /**
   * see InsertRow for details
   */
  InsertColumns(before_column = 0, count = 1) {
    if (before_column) {
      for (let row = 0; row < this.cells.rows; row++) {
        const cell1 = this.cells.GetCell({ row, column: before_column - 1 }, false);
        if (cell1 && cell1.area) {
          const cell2 = this.cells.GetCell({ row, column: before_column }, false);
          if (cell2 && cell2.area && cell2.area.Equals(cell1.area))
            return false;
        }
      }
    }
    if (count < 0) {
      this.cells.DeleteColumns(before_column, -count);
    } else {
      this.cells.InsertColumns(before_column, count);
    }
    const merge_heads = {};
    const array_heads = {};
    for (let column = before_column; column < this.cells.columns; column++) {
      for (let row = 0; row < this.cells.rows; row++) {
        const cell = this.cells.GetCell({ row, column }, false);
        if (cell) {
          if (cell.area && !array_heads[cell.area.spreadsheet_label]) {
            array_heads[cell.area.spreadsheet_label] = cell.area;
          }
          if (cell.merge_area && !merge_heads[cell.merge_area.spreadsheet_label]) {
            merge_heads[cell.merge_area.spreadsheet_label] = cell.merge_area;
          }
        }
      }
    }
    for (const key of Object.keys(array_heads)) {
      const head = array_heads[key];
      const patched = new Area(
        { row: head.start.row, column: head.start.column + count },
        { row: head.end.row, column: head.end.column + count }
      );
      patched.Iterate((address) => {
        const cell = this.cells.GetCell(address, true);
        cell.area = patched;
      });
    }
    for (const key of Object.keys(merge_heads)) {
      const head = merge_heads[key];
      const patched_start = { row: head.start.row, column: head.start.column };
      if (head.start.column >= before_column)
        patched_start.column += count;
      const patched = new Area(
        patched_start,
        { row: head.end.row, column: head.end.column + count }
      );
      patched.Iterate((address) => {
        const cell = this.cells.GetCell(address, true);
        cell.merge_area = patched;
      });
    }
    const column_keys = Object.keys(this.column_styles);
    const new_column_style = {};
    column_keys.forEach((key) => {
      const index = Number(key);
      if (index < before_column)
        new_column_style[index] = this.column_styles[index];
      else if (count < 0 && index < before_column - count) {
      } else
        new_column_style[index + count] = this.column_styles[index];
    });
    this.column_styles = new_column_style;
    let args = [];
    if (count < 0) {
      args = [before_column, -count];
    } else {
      args = [before_column, 0];
      for (let i = 0; i < count; i++)
        args.push(void 0);
    }
    this.cell_style.splice.apply(this.cell_style, args);
    this.column_width_.splice.apply(this.column_width_, args);
    this.FlushCellStyles();
    return true;
  }
  /** clear cells in area */
  ClearArea(area) {
    area = this.RealArea(area);
    this.cells.Apply(area, (cell) => cell.Reset());
  }
  // ATM we have 4 methods to set value/values. we need a distinction for
  // arrays, but that could be a parameter. the single-value/multi-value
  // area functions could probably be consolidated, also the single-cell-
  // single-value function... you need logic either on the outside or the
  // inside, put that logic where it makes the most sense.
  // also some of this could be moved to the Cells class... if for no
  // other reason than to remove the iteration overhead
  SetAreaValues2(area, values) {
    area = this.RealArea(area);
    this.cells.SetArea(area, values);
  }
  /**
   * set the area as an array formula, based in the top-left cell
   */
  SetArrayValue(area, value) {
    area = this.RealArea(area);
    this.cells.Apply(area, (element) => element.SetArray(area), true);
    const cell = this.cells.GetCell(area.start, true);
    cell.SetArrayHead(area, value);
  }
  /**
   * set a single value in a single cell
   */
  SetCellValue(address, value) {
    const cell = this.cells.GetCell(address, true);
    cell.Set(value);
  }
  /** 
   * FIXME: does not need to be in sheet 
   *
   * @param headers_only - only return tables if the cell is in the 
   * header (first) row. useful if you only want to worry about headers. 
   */
  TablesFromArea(area, headers_only = false) {
    if (IsCellAddress(area)) {
      const cell = this.cells.GetCell(area, false);
      if (cell?.table) {
        if (!headers_only || area.row === cell.table.area.start.row) {
          return [cell.table];
        }
      }
      return [];
    }
    const set = /* @__PURE__ */ new Set();
    for (let row = area.start.row; row <= area.end.row; row++) {
      for (let column = area.start.column; column <= area.end.column; column++) {
        const cell = this.cells.GetCell({ row, column }, false);
        if (cell?.table && !set.has(cell.table)) {
          if (!headers_only || row === cell.table.area.start.row) {
            set.add(cell.table);
          }
        }
      }
    }
    return Array.from(set.values());
  }
  /**
   * returns the area bounding actual content
   * (i.e. flattening "entire row/column/sheet")
   *
   * FIXME: this does not clamp to actual cells... why not?
   * FIXME: so now we are (optionally) clamping end; should clamp start, too
   *
   * @param clamp -- new parameter will optionally clamp to actual sheet size
   */
  RealArea(area, clamp = false) {
    const start = area.start;
    const end = area.end;
    if (area.entire_row) {
      start.column = 0;
      start.absolute_column = false;
      end.column = this.cells.columns - 1;
      end.absolute_column = false;
    }
    if (area.entire_column) {
      start.row = 0;
      start.absolute_row = false;
      end.row = this.cells.rows - 1;
      end.absolute_row = false;
    }
    if (clamp) {
      if (end.row >= this.rows) {
        end.row = this.rows - 1;
        end.absolute_row = false;
      }
      if (end.column >= this.columns) {
        end.column = this.columns - 1;
        end.absolute_column = false;
      }
    }
    return new Area(start, end);
  }
  /**
   * this is a new GetCellStyle function, used for external access
   * to style (for API access). there was an old GetCellStyle function
   * for rendering, but that's been removed (control+F for info).
   * 
   * Q: does this include conditional formatting? (...)
   */
  GetCellStyle(area, apply_theme = false) {
    if (IsCellAddress(area)) {
      return this.CompositeStyleForCell(area, true, false, apply_theme);
    }
    if (area.start.row === area.end.row && area.start.column === area.end.column) {
      return this.CompositeStyleForCell(area.start, true, false, apply_theme);
    }
    const result = [];
    for (let r = area.start.row; r <= area.end.row; r++) {
      const row = [];
      for (let c = area.start.column; c <= area.end.column; c++) {
        row.push(this.CompositeStyleForCell({ row: r, column: c }, true, false, apply_theme));
      }
      result.push(row);
    }
    return result;
  }
  ///
  FormattedCellValue(address) {
    const cell = this.CellData(address);
    if (!cell) {
      return void 0;
    }
    if (typeof cell.formatted === "string")
      return cell.formatted;
    if (cell.formatted) {
      return cell.formatted.map((part) => {
        switch (part.flag) {
          case 1:
            return " ";
          case 2:
            return " ";
          default:
            return part.text;
        }
      }).join("");
    }
    return cell.value;
  }
  GetFormattedRange(from, to = from) {
    if (from.row === to.row && from.column === to.column) {
      return this.FormattedCellValue(from);
    }
    const result = [];
    for (let row = from.row; row <= to.row; row++) {
      const target = [];
      for (let column = from.column; column <= to.column; column++) {
        target.push(this.FormattedCellValue({ row, column }));
      }
      result.push(target);
    }
    return result;
  }
  /**
   * get all styles used in the sheet. this is used to populate color
   * and number format lists in the toolbar. we used to just serialize
   * the document and use that, but that's absurdly wasteful. for this
   * application we don't even need composites.
   * 
   * although, this is a bit dangerous because you could (in theory)
   * modify the results in place. so maybe we should either duplicate or
   * just return the requested data...
   */
  NumberFormatsAndColors(color_map, number_format_map) {
    const parse = (style) => {
      if (style.number_format) {
        number_format_map[style.number_format] = 1;
      }
      if (style.text?.text && style.text.text !== "none") {
        color_map[style.text.text] = 1;
      }
      if (style.fill?.text) {
        color_map[style.fill.text] = 1;
      }
      if (style.border_top_fill?.text) {
        color_map[style.border_top_fill.text] = 1;
      }
      if (style.border_left_fill?.text) {
        color_map[style.border_left_fill.text] = 1;
      }
      if (style.border_right_fill?.text) {
        color_map[style.border_right_fill.text] = 1;
      }
      if (style.border_bottom_fill?.text) {
        color_map[style.border_bottom_fill.text] = 1;
      }
    };
    parse(this.sheet_style);
    for (const key in this.row_styles) {
      parse(this.row_styles[key]);
    }
    for (const key in this.column_styles) {
      parse(this.column_styles[key]);
    }
    for (const style of this.row_pattern) {
      parse(style);
    }
    for (const row of this.cell_style) {
      if (row) {
        for (const style of row) {
          if (style) {
            parse(style);
          }
        }
      }
    }
  }
  CompressCellStyles(data) {
    const list = [];
    for (let c = 0; c < data.length; c++) {
      const column = data[c];
      if (column) {
        for (let r = 0; r < column.length; r++) {
          const style = column[r];
          if (style) {
            let k = r + 1;
            for (; k < column.length; k++) {
              if (column[k] !== style) {
                break;
              }
            }
            if (k > r + 1) {
              list.push({ row: r, column: c, ref: style, rows: k - r });
            } else {
              list.push({ row: r, column: c, ref: style });
            }
            r = k - 1;
          }
        }
      }
    }
    return list;
  }
  /**
   * generates serializable object. given the new data semantics this
   * has to change a bit. here is what we are storing:
   *
   * all style data (sheet, row/column, alternate and cell)
   * raw value for cell
   * array head for arrays
   * row height and column width arrays
   *
   * because we have sparse arrays, we convert them to flat objects first.
   */
  toJSON(options = {}) {
    const flatten_numeric_array = (arr, default_value) => {
      const obj = {};
      for (let i = 0; i < arr.length; i++) {
        if (typeof arr[i] !== "undefined" && arr[i] !== default_value)
          obj[i] = arr[i];
      }
      if (Object.keys(obj).length)
        return obj;
      return void 0;
    };
    let cell_style_refs = [{}];
    const cell_style_map = {};
    const cell_reference_map = [];
    const empty_json2 = JSON.stringify({});
    for (let c = 0; c < this.cell_style.length; c++) {
      const column = this.cell_style[c];
      if (column) {
        cell_reference_map[c] = [];
        for (let r = 0; r < column.length; r++) {
          if (column[r]) {
            const style_as_json = JSON.stringify(column[r]);
            if (style_as_json !== empty_json2) {
              let reference_index = cell_style_map[style_as_json];
              if (typeof reference_index !== "number") {
                cell_style_map[style_as_json] = reference_index = cell_style_refs.length;
                cell_style_refs.push(column[r]);
              }
              cell_reference_map[c][r] = reference_index;
            }
          }
        }
      }
    }
    const StyleToRef = (style) => {
      const style_as_json = JSON.stringify(style);
      if (style_as_json === empty_json2) {
        return 0;
      }
      let reference_index = cell_style_map[style_as_json];
      if (typeof reference_index !== "number") {
        cell_style_map[style_as_json] = reference_index = cell_style_refs.length;
        cell_style_refs.push(style);
      }
      return reference_index;
    };
    cell_style_refs = JSON.parse(JSON.stringify(cell_style_refs));
    const sheet_style = JSON.parse(JSON.stringify(this.sheet_style));
    const row_pattern = JSON.parse(JSON.stringify(this.row_pattern));
    const column_style = {};
    const row_style = {};
    for (const key of Object.keys(this.column_styles)) {
      const index = Number(key);
      const style = this.column_styles[index];
      if (style) {
        const reference = StyleToRef(style);
        if (reference) {
          column_style[index] = reference;
        }
      }
    }
    for (const key of Object.keys(this.row_styles)) {
      const index = Number(key);
      const style = this.row_styles[index];
      if (style) {
        const reference = StyleToRef(style);
        if (reference) {
          row_style[index] = reference;
        }
      }
    }
    const translate_border_color = (color, default_color) => {
      if (typeof color !== "undefined" && color !== "none") {
        if (color === default_color) {
          return void 0;
        } else {
          return Measurement.MeasureColorARGB(color);
        }
      }
      return void 0;
    };
    const translate_border_fill = (color = {}, default_color = {}) => {
      const result2 = {
        ...default_color,
        ...color
      };
      if (result2.text) {
        result2.text = Measurement.MeasureColorARGB(result2.text);
        return result2;
      } else if (typeof result2.theme === "number") {
        return result2;
      }
      return void 0;
    };
    if (options.export_colors) {
      const style_list = [];
      for (const group of [
        //row_style, column_style, // these are moved -> csr (which should be renamed)
        cell_style_refs,
        [sheet_style],
        row_pattern
      ]) {
        if (Array.isArray(group)) {
          for (const entry of group)
            style_list.push(entry);
        } else {
          for (const key of Object.keys(group))
            style_list.push(group[key]);
        }
      }
      for (const style of style_list) {
        let fill = translate_border_fill(style.border_top_fill, Style.DefaultProperties.border_top_fill);
        if (fill !== void 0) {
          style.border_top_fill = fill;
        }
        fill = translate_border_fill(style.border_left_fill, Style.DefaultProperties.border_left_fill);
        if (fill !== void 0) {
          style.border_left_fill = fill;
        }
        fill = translate_border_fill(style.border_right_fill, Style.DefaultProperties.border_right_fill);
        if (fill !== void 0) {
          style.border_right_fill = fill;
        }
        fill = translate_border_fill(style.border_bottom_fill, Style.DefaultProperties.border_bottom_fill);
        if (fill !== void 0) {
          style.border_bottom_fill = fill;
        }
        if (style.fill?.text) {
          style.fill.text = Measurement.MeasureColorARGB(style.fill.text);
        }
        if (style.text) {
          if (style.text.text && style.text.text !== "none") {
            style.text.text = Measurement.MeasureColorARGB(style.text.text);
          }
        }
      }
    }
    const serialization_options = {
      calculated_value: !!options.rendered_values,
      preserve_type: !!options.preserve_type,
      expand_arrays: !!options.expand_arrays,
      decorated_cells: !!options.decorated_cells,
      nested: true,
      cell_style_refs: cell_reference_map,
      tables: !!options.tables
    };
    const serialized_data = this.cells.toJSON(serialization_options);
    const data = serialized_data.data;
    let { rows, columns } = serialized_data;
    if (!options.shrink) {
      rows = this.rows;
      columns = this.columns;
    } else {
      rows += 2;
      columns += 1;
    }
    for (const annotation of this.annotations) {
      if (!annotation.data.extent) {
        this.CalculateAnnotationExtent(annotation);
      }
      if (annotation.data.extent) {
        rows = Math.max(rows, annotation.data.extent.row + 1);
        columns = Math.max(columns, annotation.data.extent.column + 1);
      }
    }
    const cell_styles = this.CompressCellStyles(cell_reference_map);
    const conditional_formats = this.conditional_formats.length ? JSON.parse(JSON.stringify(this.conditional_formats.map((format) => ({ ...format, internal: void 0 })))) : void 0;
    const result = {
      // not used atm, but in the event we need to gate
      // or swap importers on versions in the future
      // FIXME: drop, in favor of container versioning. there's no point
      // in this submodule versioning (is there? ...)
      // version: (ModuleInfo as any).version,
      id: this.id,
      name: this.name,
      data,
      sheet_style,
      rows,
      columns,
      cell_styles,
      styles: cell_style_refs,
      row_style,
      column_style,
      conditional_formats,
      row_pattern: row_pattern.length ? row_pattern : void 0,
      // why are these serialized? (...) export!
      default_row_height: this.default_row_height,
      default_column_width: this.default_column_width,
      row_height: flatten_numeric_array(this.row_height_, this.default_row_height),
      column_width: flatten_numeric_array(this.column_width_, this.default_column_width),
      selection: JSON.parse(JSON.stringify(this.selection)),
      annotations: JSON.parse(JSON.stringify(this.annotations))
    };
    if (!this.visible) {
      result.visible = this.visible;
    }
    if (this.scroll_offset.x || this.scroll_offset.y) {
      result.scroll = this.scroll_offset;
    }
    if (this.background_image) {
      result.background_image = this.background_image;
    }
    if (this.freeze.rows || this.freeze.columns) {
      result.freeze = this.freeze;
    }
    return result;
  }
  /*
     * export values and calcualted values; as for csv export (which is what it's for) * /
    public ExportValueData(transpose = false, dates_as_strings = false, export_functions = false): CellValue[][] {
  
      const arr: CellValue[][] = [];
      const data = this.cells.data;
  
      if (transpose) {
        const rowcount = data[0].length; // assuming it's a rectangle
        for (let r = 0; r < rowcount; r++) {
          const row: CellValue[] = [];
          for (const column of data) {
            const ref = column[r];
            let value: CellValue;
            if (!export_functions && typeof ref.calculated !== 'undefined') value = ref.calculated;
            else if (typeof ref.value === 'undefined') value = '';
            else value = ref.value;
  
            if (dates_as_strings && ref.style && typeof value === 'number') {
              const format = NumberFormatCache.Get(ref.style.number_format || '');
              if (format.date_format) value = format.Format(value);
            }
  
            // if (dates_as_strings && ref.style && ref.style.date && typeof value === 'number') {
            //  value = Style.Format(ref.style, value);
            // }
            row.push(value);
          }
          arr.push(row);
        }
      }
      else {
        for (const column_ref of data) {
          const column: CellValue[] = [];
          for (const ref of column_ref) {
            let value: CellValue;
            if (!export_functions && typeof ref.calculated !== 'undefined') value = ref.calculated;
            else if (typeof ref.value === 'undefined') value = '';
            else value = ref.value;
  
            if (dates_as_strings && ref.style && typeof value === 'number') {
              const format = NumberFormatCache.Get(ref.style.number_format || '');
              if (format.date_format) value = format.Format(value);
            }
  
            // if (dates_as_strings && ref.style && ref.style.date && typeof value === 'number') {
            //   value = Style.Format(ref.style, value);
            // }
            column.push(value);
          }
          arr.push(column);
        }
      }
  
      return arr;
    }
    */
  /** flushes ALL rendered styles and caches. made public for theme API */
  FlushCellStyles() {
    this.style_map = [];
    this.style_json_map = [];
    this.cells.FlushCellStyles();
  }
  ImportData(data) {
    const styles = data.styles;
    if (data.outline) {
      this.outline = data.outline;
    }
    const sheet_style = data.sheet_style;
    if (sheet_style) {
      this.UpdateAreaStyle(
        new Area({ row: Infinity, column: Infinity }, { row: Infinity, column: Infinity }),
        styles[sheet_style]
      );
    }
    const column_styles = data.column_styles;
    if (column_styles) {
      for (let i = 0; i < column_styles.length; i++) {
        if (column_styles[i]) {
          this.UpdateAreaStyle(new Area({ row: Infinity, column: i }, { row: Infinity, column: i }), styles[column_styles[i]]);
        }
      }
    }
    this.cells.FromJSON(data.cells);
    if (data.name) {
      this.name = data.name || "";
    }
    const cs = this.cell_style;
    for (const info of data.cells) {
      if (info.style_ref) {
        if (!cs[info.column])
          cs[info.column] = [];
        cs[info.column][info.row] = styles[info.style_ref];
      }
    }
    for (let i = 0; i < data.column_widths.length; i++) {
      if (typeof data.column_widths[i] !== "undefined") {
        this.SetColumnWidth(i, data.column_widths[i]);
      }
    }
    for (let i = 0; i < data.row_heights.length; i++) {
      if (typeof data.row_heights[i] !== "undefined") {
        this.SetRowHeight(i, data.row_heights[i]);
      }
    }
    for (const annotation of data.annotations || []) {
      this.annotations.push(new Annotation(annotation));
    }
    for (const format of data.conditional_formats || []) {
      this.conditional_formats.push(format);
    }
    if (data.hidden) {
      this.visible = false;
    }
  }
  // --- protected ------------------------------------------------------------
  /** 
   * figure out the last row/column of the annotation. this
   * might set it to 0/0 if there's no rect, just make sure
   * that it gets cleared on layout changes.
   */
  CalculateAnnotationExtent(annotation) {
    if (annotation.data.layout) {
      annotation.data.extent = { ...annotation.data.layout.br.address };
      return;
    }
    const sanity = 1e3;
    annotation.data.extent = { row: 0, column: 0 };
    let right = annotation.rect?.right;
    if (right && this.default_column_width) {
      for (let i = 0; right >= 0 && i < sanity; i++) {
        right -= this.GetColumnWidth(i);
        if (right < 0) {
          annotation.data.extent.column = i;
          break;
        }
      }
    }
    let bottom = annotation.rect?.bottom;
    if (bottom && this.default_row_height) {
      for (let i = 0; bottom >= 0 && i < sanity; i++) {
        bottom -= this.GetRowHeight(i);
        if (bottom < 0) {
          annotation.data.extent.row = i;
          break;
        }
      }
    }
  }
  /* *
   * when checking style properties, check falsy but not '' or 0
   * (also strict equivalence)
   * /
  protected StyleEquals(a: any, b: any): boolean {
    return a === b ||
      ((a === false || a === null || a === undefined)
        && (b === false || b === null || b === undefined));
  }
  */
  /*
  protected Serialize() {
    return JSON.stringify(this);
  }
  */
  /*
    protected Deserialize(data: SerializedSheet) {
      Sheet.FromJSON(data, this.default_style_properties, this);
  
      // some overlap here... consolidate? actually, doesn't
      // fromJSON call flush styles? [A: sometimes...]
  
      this.cells.FlushCachedValues();
      this.FlushCellStyles();
    }
    */
  // --- private methods ------------------------------------------------------
  /**
   * update style properties. merge by default.
   *
   * this method will reverse-override properties, meaning if you have set (for
   * example) a cell style to bold, then you set the whole sheet to unbold, we
   * expect that the unbold style will control. instead of explicitly setting
   * the cell style, we go up the chain and remove any matching properties.
   */
  UpdateSheetStyle(properties, delta = true) {
    this.sheet_style = Style.Merge(this.sheet_style, properties, delta);
    const keys = Object.keys(properties);
    for (const style_column of this.cell_style) {
      if (style_column) {
        for (const style_ref of style_column) {
          if (style_ref) {
            keys.forEach((key) => delete style_ref[key]);
          }
        }
      }
    }
    for (const index of Object.keys(this.row_styles)) {
      keys.forEach((key) => delete this.row_styles[index][key]);
    }
    for (const index of Object.keys(this.column_styles)) {
      keys.forEach((key) => delete this.column_styles[index][key]);
    }
    this.FlushCellStyles();
  }
  /**
   * updates row properties. reverse-overrides cells (@see UpdateSheetStyle).
   *
   * we also need to ensure that the desired effect takes hold, meaning if
   * there's an overriding column property (columns have priority), we will
   * need to update the cell property to match the desired output.
   */
  UpdateRowStyle(row, properties, delta = true) {
    this.row_styles[row] = Style.Merge(this.row_styles[row] || {}, properties, delta);
    const keys = Object.keys(properties);
    for (const column of this.cell_style) {
      if (column && column[row]) {
        keys.forEach((key) => delete column[row][key]);
      }
    }
    for (let i = 0; i < this.cells.columns; i++) {
      if (this.column_styles[i]) {
        const column_style = this.column_styles[i];
        const overrides = this.cell_style[i] ? this.cell_style[i][row] || {} : {};
        for (const key of keys) {
          if (typeof column_style[key] !== "undefined") {
            overrides[key] = properties[key];
          }
        }
        if (Object.keys(overrides).length) {
          if (!this.cell_style[i])
            this.cell_style[i] = [];
          this.cell_style[i][row] = JSON.parse(JSON.stringify(overrides));
        }
      }
    }
    this.cells.Apply(this.RealArea(Area.FromRow(row)), (cell) => cell.FlushStyle());
  }
  /**
   * updates column properties. reverse-overrides cells (@see UpdateSheetStyle).
   */
  UpdateColumnStyle(column, properties, delta = true) {
    this.column_styles[column] = Style.Merge(this.column_styles[column] || {}, properties, delta);
    const keys = Object.keys(properties);
    if (this.cell_style[column]) {
      for (const ref of this.cell_style[column]) {
        if (ref) {
          keys.forEach((key) => delete ref[key]);
        }
      }
    }
    this.cells.Apply(this.RealArea(Area.FromColumn(column)), (cell) => cell.FlushStyle());
  }
  /* *
     * flush the cache and the checklist. flush cell styles at the same
     * time. this should be called when adding/removing a conditional format.
     * optionally apply active formats again.
     * 
     * is this actually necessary? what's the use case? (...)
     * 
     * /
    public FlushConditionalFormats(reapply = false) {
  
      for (const [row, column] of this.conditional_format_checklist) {
        this.CellData({row, column}).FlushStyle();
      }
  
      this.conditional_format_checklist = [];
      this.conditional_format_cache = [];
  
      if (reapply) {
        this.ApplyConditionalFormats();
      }
  
    }
    */
  BleedFlush(area) {
    let rows = [Math.max(0, area.start.row - 1), area.end.row + 1];
    let cols = [Math.max(0, area.start.column - 1), area.end.column + 1];
    for (let row = rows[0]; row <= rows[1]; row++) {
      for (let column = cols[0]; column <= cols[1]; column++) {
        this.cells.GetCell({ row, column }, false)?.FlushStyle();
      }
    }
  }
  FlushConditionalFormats() {
    this.flush_conditional_formats = true;
  }
  /**
   * this version combines flushing the cache with building it, using
   * the application flag in the format objects. 
   * 
   * this function was set up to support comparing the two lists and
   * only flushing style if necessary; but that turns out to be so 
   * much additional work that I'm not sure it's preferable to just 
   * repaint. need to test.
   * 
   * ...we're also probably looping unecessarily. since we're using
   * those leaf nodes we can probably check if the state changed, and
   * it not, skip the loop pass. I think we'd need to identify or map
   * the applications though (meaning use a stack that matches the list
   * of formats). or you could even recheck everything if one of them 
   * changed, you'd still probably save a lot in cases where nothing
   * changed.
   * 
   */
  ApplyConditionalFormats() {
    let updated = this.flush_conditional_formats;
    for (const format of this.conditional_formats) {
      if (format.internal?.vertex?.updated) {
        updated = true;
        break;
      }
    }
    if (!updated) {
      return;
    }
    this.flush_conditional_formats = false;
    const temp = [];
    const checklist = [...this.conditional_format_checklist];
    this.conditional_format_checklist = [];
    for (const format of this.conditional_formats) {
      if (format.internal?.vertex?.updated) {
        format.internal.vertex.updated = false;
      }
      if (format.type === "gradient") {
        const area = JSON.parse(JSON.stringify(format.area));
        const result = format.internal?.vertex?.result;
        if (result && format.internal?.gradient) {
          const property = format.property ?? "fill";
          if (result.type === 8 /* array */) {
            for (let row = area.start.row; row <= area.end.row; row++) {
              for (let column = area.start.column; column <= area.end.column; column++) {
                const value = result.value[column - area.start.column][row - area.start.row];
                if (value.type === 3 /* number */) {
                  if (!temp[row]) {
                    temp[row] = [];
                  }
                  if (!temp[row][column]) {
                    temp[row][column] = [];
                  }
                  const color = format.internal.gradient.Interpolate(value.value);
                  temp[row][column].push({ [property]: color });
                }
              }
            }
          } else if (result.type === 3 /* number */) {
            const color = format.internal.gradient.Interpolate(result.value);
            for (let row = area.start.row; row <= area.end.row; row++) {
              if (!temp[row]) {
                temp[row] = [];
              }
              for (let column = area.start.column; column <= area.end.column; column++) {
                if (!temp[row][column]) {
                  temp[row][column] = [];
                }
                temp[row][column].push({ [property]: color });
              }
            }
          }
          checklist.push(area);
          this.conditional_format_checklist.push(area);
        }
      } else {
        const area = JSON.parse(JSON.stringify(format.area));
        const result = format.internal?.vertex?.result;
        if (result) {
          if (result.type === 8 /* array */) {
            for (let row = area.start.row; row <= area.end.row; row++) {
              for (let column = area.start.column; column <= area.end.column; column++) {
                const value = result.value[column - area.start.column][row - area.start.row];
                if ((value.type === 4 /* boolean */ || value.type === 3 /* number */) && !!value.value) {
                  if (!temp[row]) {
                    temp[row] = [];
                  }
                  if (!temp[row][column]) {
                    temp[row][column] = [];
                  }
                  temp[row][column].push(format.style);
                }
              }
            }
          } else {
            if (result.type === 4 /* boolean */ || result.type === 3 /* number */) {
              if (!!result.value) {
                for (let row = area.start.row; row <= area.end.row; row++) {
                  if (!temp[row]) {
                    temp[row] = [];
                  }
                  for (let column = area.start.column; column <= area.end.column; column++) {
                    if (!temp[row][column]) {
                      temp[row][column] = [];
                    }
                    temp[row][column].push(format.style);
                  }
                }
              }
            }
          }
          checklist.push(area);
          this.conditional_format_checklist.push(area);
        }
      }
    }
    for (const area of checklist) {
      this.BleedFlush(area);
    }
    this.conditional_format_cache = temp;
  }
  ConditionalFormatForCell(address) {
    if (this.conditional_format_cache[address.row]) {
      return this.conditional_format_cache[address.row][address.column] || [];
    }
    return [];
  }
  /**
   * generates the composite style for the given cell. this
   * should only be used to generate a cache of styles (Q: really? PERF?)
   *
   * the "apply_cell_style" parameter is used for testing when pruning. we
   * want to check what happens if the cell style is not applied; if nothing 
   * happens, then we can drop the cell style (or the property in the style).
   */
  CompositeStyleForCell(address, apply_cell_style = true, apply_row_pattern = true, apply_default = true, apply_conditional = true) {
    const { row, column } = address;
    const stack = [];
    if (apply_default) {
      stack.push(this.default_style_properties);
    }
    stack.push(this.sheet_style);
    if (apply_row_pattern && this.row_pattern.length) {
      stack.push(this.row_pattern[row % this.row_pattern.length]);
    }
    if (this.row_styles[row]) {
      stack.push(this.row_styles[row]);
    }
    if (this.column_styles[column]) {
      stack.push(this.column_styles[column]);
    }
    if (apply_cell_style && this.cell_style[column] && this.cell_style[column][row]) {
      stack.push(this.cell_style[column][row]);
    }
    if (apply_conditional) {
      stack.push(...this.ConditionalFormatForCell(address));
    }
    return Style.Composite(stack);
  }
  /**
   * can we use the rendered JSON as a key, instead? 
   */
  GetStyleIndex(style) {
    const json = JSON.stringify(style);
    for (let i = 0; i < this.style_json_map.length; i++) {
      if (json === this.style_json_map[i])
        return i;
    }
    const new_index = this.style_map.length;
    this.style_map.push(JSON.parse(json));
    this.style_json_map.push(json);
    return new_index;
  }
};

// treb-grid/src/layout/base_layout.ts
var BaseLayout = class {
  constructor(model, view, mock = false, DOM = DOMContext.GetInstance()) {
    this.model = model;
    this.view = view;
    this.DOM = DOM;
    if (mock) {
      return;
    }
    if (!DOM) {
      throw new Error("missing DOM context");
    }
    this.dpr = Math.max(1, self.devicePixelRatio || 1);
    this.mask = DOM.Div("treb-mouse-mask");
    this.tooltip = DOM.Div("treb-tooltip");
    this.dropdown_caret = DOM.SVG("svg", "treb-dropdown-caret");
    this.dropdown_caret.setAttribute("viewBox", "0 0 24 24");
    this.dropdown_caret.tabIndex = -1;
    const caret = DOM.SVG("path");
    caret.setAttribute("d", "M5,7 L12,17 L19,7");
    this.dropdown_caret.appendChild(caret);
    this.dropdown_caret.addEventListener("click", (event) => {
      event.stopPropagation();
      event.preventDefault();
      this.grid_cover.classList.remove("nub-select");
      const class_name = this.dropdown_caret.getAttribute("class") || "";
      if (/active/i.test(class_name)) {
        this.dropdown_caret.setAttribute("class", "treb-dropdown-caret");
      } else {
        this.dropdown_caret.setAttribute("class", "treb-dropdown-caret active");
        this.dropdown_list.focus();
      }
    });
    this.dropdown_list = DOM.Div("treb-dropdown-list", void 0, {
      attrs: { tabindex: "-1" }
    });
    this.dropdown_list.addEventListener("keydown", (event) => {
      let delta = 0;
      switch (event.key) {
        case "ArrowDown":
          delta = 1;
          break;
        case "ArrowUp":
          delta = -1;
          break;
        case "Escape":
          break;
        case "Enter":
          break;
        default:
          console.info(event.key);
          return;
      }
      event.stopPropagation();
      event.preventDefault();
      if (event.key === "Escape" || event.key === "Enter") {
        this.container?.focus();
        this.dropdown_caret.setAttribute("class", "treb-dropdown-caret");
        if (event.key === "Enter" && this.dropdown_callback) {
          if (this.dropdown_selected) {
            this.dropdown_callback.call(0, this.dropdown_selected.dropdown_value);
          }
        }
      } else if (delta) {
        if (this.dropdown_selected) {
          if (delta > 0 && this.dropdown_selected.nextSibling) {
            this.dropdown_selected.nextSibling.classList.add("selected");
            this.dropdown_selected.classList.remove("selected");
            this.dropdown_selected = this.dropdown_selected.nextSibling;
            const bottom = this.dropdown_selected.offsetTop + this.dropdown_selected.offsetHeight;
            if (bottom > this.dropdown_list.offsetHeight + this.dropdown_list.scrollTop) {
              this.dropdown_list.scrollTop = bottom - this.dropdown_list.offsetHeight;
            }
          } else if (delta < 0 && this.dropdown_selected.previousSibling) {
            this.dropdown_selected.previousSibling.classList.add("selected");
            this.dropdown_selected.classList.remove("selected");
            this.dropdown_selected = this.dropdown_selected.previousSibling;
            if (this.dropdown_selected.offsetTop < this.dropdown_list.scrollTop) {
              this.dropdown_list.scrollTop = this.dropdown_selected.offsetTop;
            }
          }
        }
      }
    });
    this.dropdown_list.addEventListener("mousedown", (event) => {
      const target = event.target;
      if (event.target === this.dropdown_list) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      this.container?.focus();
      this.dropdown_caret.setAttribute("class", "treb-dropdown-caret");
      if (this.dropdown_callback) {
        this.dropdown_callback.call(0, target.dropdown_value);
      }
    });
    this.dropdown_list.addEventListener("mousemove", (event) => {
      const target = event.target;
      if (target === this.dropdown_selected) {
        return;
      }
      this.grid_cover.classList.remove("nub-select");
      if (this.dropdown_selected) {
        this.dropdown_selected.classList.remove("selected");
      }
      target.classList.add("selected");
      this.dropdown_selected = target;
    });
    this.mock_selection = DOM.Div("mock-selection-node", void 0, {
      html: "&nbsp;"
    });
    this.note_node = DOM.Div("treb-note");
    this.title_node = DOM.Div("treb-hover-title");
    this.sort_button = DOM.Create(
      "button",
      "treb-sort-button",
      void 0,
      { attrs: { title: "Sort table", tabindex: "-1" } }
    );
    this.HideNote();
  }
  column_header;
  row_header;
  contents;
  buffer_canvas;
  corner;
  corner_canvas;
  // HTMLDivElement;
  grid_selection;
  grid_cover;
  column_header_cover;
  row_header_cover;
  annotation_container;
  mask;
  mock_selection;
  container;
  // reference to container
  grid_tiles = [];
  column_header_tiles = [];
  row_header_tiles = [];
  corner_selection;
  row_header_selection;
  column_header_selection;
  corner_annotations;
  row_header_annotations;
  column_header_annotations;
  frozen_row_tiles = [];
  frozen_column_tiles = [];
  header_size = { width: 0, height: 0 };
  /**
   * last rendered column. this is used to calculate the limits of
   * cell overflows, which may exceed actual data in the sheet.
   */
  last_column = 0;
  total_height = 0;
  total_width = 0;
  default_row_height = 0;
  default_column_width = 0;
  header_offset = {
    x: 0,
    y: 0
  };
  /** freeze rows/columns */
  // public freeze = { rows: 0, columns: 0 };
  /**
   * NOTE: dpr can probably change, on zoom; but I'm not sure there's
   * an event we can trap for that. it might be necessary to test this
   * periodically.
   */
  dpr = 1;
  // Math.max(1, self.devicePixelRatio || 1);
  /** separate scale, user-controlled (testing...) */
  scale = 1;
  /**
   * this is a reference to the node that handles scrolling. it needs
   * to be different for legacy renderer.
   */
  scroll_reference_node;
  get scroll_offset() {
    if (!this.scroll_reference_node) {
      return { x: 0, y: 0 };
    }
    return {
      x: this.scroll_reference_node.scrollLeft,
      y: this.scroll_reference_node.scrollTop
    };
  }
  set scroll_offset(offset) {
    if (!this.scroll_reference_node) {
      return;
    }
    this.scroll_reference_node.scrollLeft = offset.x;
    this.scroll_reference_node.scrollTop = offset.y;
  }
  dropdown_caret;
  /** we have to disable mock selection for IE or it breaks key handling */
  trident = typeof navigator !== "undefined" && navigator.userAgent && /trident/i.test(navigator.userAgent);
  // private default_tile_size: Size = { width: 600, height: 400 };
  default_tile_size = { width: 1200, height: 800 };
  tooltip_state;
  tooltip;
  dropdown_list;
  dropdown_caret_visible = false;
  dropdown_callback;
  dropdown_selected;
  // private selection_layout_token?: any;
  // private error_highlight: HTMLDivElement;
  // private error_highlight_timeout?: any;
  note_node;
  sort_button;
  title_node;
  row_cache = [];
  column_cache = [];
  /**
   * flag so we don't try to paint before we have tiles
   */
  initialized = false;
  /**
   * if the DPR has changed, update it and return true. otherwise return
   * false. this is used on resize events: if the scale has changed, we 
   * probably want to repaint (and we need to update scale).
   */
  UpdateDPR() {
    const dpr = Math.max(1, self.devicePixelRatio || 1);
    if (dpr === this.dpr) {
      return false;
    }
    this.dpr = dpr;
    return true;
  }
  /** wrapper around sheet method, incorporating scale */
  ColumnWidth(column) {
    return Math.round(this.view.active_sheet.GetColumnWidth(column) * this.scale);
  }
  /** wrapper around sheet method, incorporating scale */
  RowHeight(row) {
    return Math.round(this.view.active_sheet.GetRowHeight(row) * this.scale);
  }
  /** 
   * wrapper around sheet method, incorporating scale
   * 
   * NOTE: this does not update total size, so unless there's a subsequent call
   * to a layout update, total size will be out of sync 
   */
  SetRowHeight(row, height) {
    this.view.active_sheet.SetRowHeight(row, Math.round(height / this.scale));
  }
  /** 
   * wrapper around sheet method, incorporating scale 
   * 
   * NOTE: this does not update total size, so unless there's a subsequent call
   * to a layout update, total size will be out of sync 
   */
  SetColumnWidth(column, width) {
    this.view.active_sheet.SetColumnWidth(column, Math.round(width / this.scale));
  }
  /**
   * show/hide grid selections. used when selecting annotations.
   */
  ShowSelections(show = true) {
    this.grid_selection.style.display = show ? "block" : "none";
  }
  HideTitle() {
    this.title_node.style.opacity = "0";
  }
  ShowTitle(text, address) {
    this.title_node.textContent = text;
    if (!this.title_node.parentElement)
      return;
    const container = this.title_node.parentElement.getBoundingClientRect();
    const rect = this.OffsetCellAddressToRectangle(address).Shift(
      this.header_size.width,
      this.header_size.height
    );
    this.title_node.style.left = container.left + rect.left - this.scroll_reference_node.scrollLeft + 0 + "px";
    this.title_node.style.top = container.top + rect.bottom - this.scroll_reference_node.scrollTop + 8 + "px";
    this.title_node.style.opacity = "1";
  }
  HideNote() {
    this.note_node.style.opacity = "0";
    this.note_node.style.pointerEvents = "none";
  }
  HideTableSortButton() {
    this.sort_button.style.opacity = "0";
    this.sort_button.style.pointerEvents = "none";
    this.sort_button.setAttribute("tabindex", "-1");
  }
  ShowTableSortButton(table, column, address) {
    if (!this.sort_button.parentElement) {
      return;
    }
    let asc = true;
    let initial = false;
    if (table.sort) {
      if (table.sort.column === column) {
        asc = !table.sort.asc;
        initial = true;
      }
    }
    this.sort_button.setAttribute("tabindex", "0  ");
    this.sort_button.style.opacity = "1";
    this.sort_button.style.pointerEvents = "initial";
    this.sort_button.classList.remove("asc", "desc");
    if (initial) {
      this.sort_button.classList.add(asc ? "asc" : "desc");
    }
    this.sort_button.dataset.asc = asc.toString();
    this.sort_button.dataset.table = table.name;
    this.sort_button.dataset.column = column.toString();
    const rect = this.OffsetCellAddressToRectangle(address).Shift(
      this.header_size.width,
      this.header_size.height
    );
    const button_size = this.sort_button.getBoundingClientRect();
    this.sort_button.style.left = rect.right - button_size.width - button_size.width / 2 + "px";
    this.sort_button.style.top = rect.top + (rect.height - button_size.height) / 2 + "px";
  }
  /**
   * adding html parameter at the end, so we can keep the function 
   * signature otherwise the same. this is for markdown formatting.
   */
  ShowNote(note, address, event, markdown) {
    if (markdown) {
      this.note_node.innerHTML = markdown;
    } else {
      this.note_node.textContent = note;
    }
    if (!this.note_node.parentElement)
      return;
    const note_size = this.note_node.getBoundingClientRect();
    const container = this.note_node.parentElement.getBoundingClientRect();
    const offset = { x: 8, y: 2 };
    const rect = this.OffsetCellAddressToRectangle(address).Shift(
      this.header_size.width,
      this.header_size.height
    );
    this.note_node.style.left = container.left + rect.right - this.scroll_reference_node.scrollLeft + offset.x + "px";
    this.note_node.style.top = container.top + rect.top - this.scroll_reference_node.scrollTop - note_size.height / 5 - offset.y + "px";
    this.note_node.style.opacity = "1";
    this.note_node.style.pointerEvents = "auto";
  }
  /* * needed for IE11, legacy only * /
  public FixBrokenSelection() {
    // ...
  }
  */
  /**
   * raise or lower annotation in z-order (implicit)
   *
   * returns true if we've made changes, so you can trigger any necessary
   * events or side-effects
   */
  AnnotationLayoutOrder(annotation, delta) {
    let index = -1;
    for (let i = 0; i < this.view.active_sheet.annotations.length; i++) {
      if (this.view.active_sheet.annotations[i] === annotation) {
        index = i;
        break;
      }
    }
    if (index < 0) {
      return false;
    }
    const target = Math.min(Math.max(0, index + delta), this.view.active_sheet.annotations.length - 1);
    if (target === index) {
      return false;
    }
    this.view.active_sheet.annotations.splice(index, 1);
    this.view.active_sheet.annotations.splice(target, 0, annotation);
    for (let i = 0; i < this.view.active_sheet.annotations.length; i++) {
      const key = this.view.active_sheet.annotations[i].key;
      const elements = this.container?.querySelectorAll(`.annotation[data-key="${key}"]`);
      if (elements) {
        for (let j = 0; j < elements?.length; j++) {
          elements[j].style.zIndex = (i + 1).toString();
        }
      }
    }
    return true;
  }
  /**
   * 
   */
  PointToAnnotationCorner(point) {
    const address = this.PointToAddress_Grid(point, void 0, false);
    const cell_rect = this.CellAddressToRectangle(address);
    return {
      address,
      offset: {
        x: (point.x - cell_rect.left) / cell_rect.width,
        y: (point.y - cell_rect.top) / cell_rect.height
      }
    };
  }
  /**
   * utility for managing (new) annotation layout. we offset the {top, left}
   * by {1, 1} pixel so that the alignment snaps to cell boundaries.
   */
  RectToAnnotationLayout(rect) {
    return {
      tl: this.PointToAnnotationCorner({ x: (rect.left || 0) + 1, y: (rect.top || 0) + 1 }),
      br: this.PointToAnnotationCorner({ x: rect.right || rect.left || 100, y: rect.bottom || rect.top || 100 })
    };
  }
  AddressToAnnotationLayout(tl, br) {
    const rects = {
      tl: this.CellAddressToRectangle(tl),
      br: this.CellAddressToRectangle(br)
    };
    return {
      tl: this.PointToAnnotationCorner({ x: rects.tl.left || 0, y: rects.tl.top || 0 }),
      br: this.PointToAnnotationCorner({ x: rects.br.right || rects.tl.left || 100, y: rects.br.bottom || rects.tl.left || 100 })
    };
  }
  /**
   * @see RectToAnnotationLayout regarding the 1 pixel shift
   */
  AnnotationLayoutToRect(layout) {
    const tl = this.CellAddressToRectangle(layout.tl.address);
    const br = this.CellAddressToRectangle(layout.br.address);
    const left = tl.left + tl.width * layout.tl.offset.x - 1;
    const top = tl.top + tl.height * layout.tl.offset.y - 1;
    return new Rectangle(
      left,
      top,
      br.left + br.width * layout.br.offset.x - left,
      br.top + br.height * layout.br.offset.y - top
    );
  }
  UpdateAnnotation(elements) {
    if (!Array.isArray(elements))
      elements = [elements];
    for (const annotation of elements) {
      const view = annotation.view[this.view.view_index] || {};
      if (view.node) {
        view.node.dataset.scale = this.scale.toString();
        view.node.style.fontSize = `${10 * this.scale}pt`;
        if (annotation.rect && !annotation.data.layout) {
          annotation.scaled_rect = annotation.rect.Scale(this.scale);
          annotation.data.layout = this.RectToAnnotationLayout(annotation.scaled_rect);
        }
        if (annotation.data.layout) {
          const rect = this.AnnotationLayoutToRect(annotation.data.layout);
          rect.ApplyStyle(view.node);
          annotation.scaled_rect = rect;
        }
        view.node.dataset.key = annotation.key.toString();
        if (this.view.active_sheet.freeze.rows || this.view.active_sheet.freeze.columns) {
          this.CloneFrozenAnnotation(annotation);
        }
      }
    }
  }
  /** returns a list of copies painted to frozen panes, for move/size */
  GetFrozenAnnotations(annotation) {
    const containers = [this.row_header_annotations, this.column_header_annotations, this.corner_annotations];
    return containers.map((container) => container.querySelector(`.annotation[data-key="${annotation.key}"]`)).filter((test) => test !== null);
  }
  /**
   * clone all annotations into freeze panes
   */
  CloneFrozenAnnotations() {
    for (const annotation of this.view.active_sheet.annotations) {
      const view = annotation.view[this.view.view_index];
      if (view?.node && annotation.key) {
        this.CloneFrozenAnnotation(annotation);
      }
    }
  }
  /**
   * remove all annotations from freeze panes
   * 
   */
  ClearFrozenAnnotations() {
    for (const container of [this.row_header_annotations, this.column_header_annotations, this.corner_annotations]) {
      const elements = container.querySelectorAll(".annotation");
      for (let i = 0; i < elements.length; i++) {
        elements[i].parentElement?.removeChild(elements[i]);
      }
    }
  }
  /**
   * remove a frozen annotation
   * @param annotation 
   */
  RemoveFrozenAnnotation(annotation) {
    for (const container of [this.row_header_annotations, this.column_header_annotations, this.corner_annotations]) {
      const element = container.querySelector(`.annotation[data-key="${annotation.key}"]`);
      if (element) {
        element.parentElement?.removeChild(element);
      }
    }
  }
  /**
   * clone a single annotation. usually this will be used on create, but
   * we batch them when we freeze panes (from unfrozen)
   */
  CloneFrozenAnnotation(annotation) {
    for (const container of [this.row_header_annotations, this.column_header_annotations, this.corner_annotations]) {
      let element = container.querySelector(`.annotation[data-key="${annotation.key}"]`);
      if (element) {
        element.parentElement?.removeChild(element);
      }
      const view = annotation.view[this.view.view_index];
      element = view?.node?.cloneNode(true);
      if (element) {
        const move_target = element.querySelector(".annotation-move-target");
        const resize_target = element.querySelector(".annotation-resize-target");
        element.addEventListener("mousedown", (event) => {
          const node = view.node;
          requestAnimationFrame(() => {
            node?.focus();
          });
          this.AnnotationMouseDown(annotation, view.node, event, move_target, resize_target);
        });
        container.appendChild(element);
      }
    }
  }
  RemoveAnnotation(annotation) {
    const view = annotation.view[this.view.view_index] || {};
    if (view.node) {
      view.node.parentElement?.removeChild(view.node);
    }
    this.RemoveFrozenAnnotation(annotation);
  }
  /**
   * remove annotation nodes from the container, without impacting
   * the underlying data. annotations will still retain nodes, they
   * just won't be attached to anything.
   *
   * NOTE: IE destroys nodes if you do this? (...)
   * patch in legacy... actually we'll do it here
   */
  RemoveAnnotationNodes() {
    const children = Array.prototype.map.call(
      this.annotation_container.children,
      (node) => node
    );
    for (const child of children) {
      this.annotation_container.removeChild(child);
    }
    if (this.view.active_sheet.freeze.rows || this.view.active_sheet.freeze.columns) {
      this.ClearFrozenAnnotations();
    }
  }
  AddAnnotation(annotation) {
    const view = annotation.view[this.view.view_index] || {};
    if (!view.node) {
      throw new Error("annotation view/node missing");
    }
    this.annotation_container.appendChild(view.node);
    this.UpdateAnnotation(annotation);
  }
  // testing moving this here...
  AnnotationMouseDown(annotation, node, event, move_target, resize_target) {
    const rect = annotation.scaled_rect;
    if (!rect) {
      console.info("missing scaled rect!");
      return Promise.reject();
    }
    return new Promise((resolve) => {
      const origin = {
        left: rect.left,
        top: rect.top,
        width: rect.width,
        height: rect.height
      };
      const scroll_node = this.scroll_reference_node;
      const scroll_rect = scroll_node.getBoundingClientRect();
      const bounding_rect = node.getBoundingClientRect();
      if (event.target === move_target || event.target !== resize_target && event.altKey) {
        event.stopPropagation();
        event.preventDefault();
        node.focus();
        const offset = {
          x: bounding_rect.left + event.offsetX - rect.left,
          y: bounding_rect.top + event.offsetY - rect.top
        };
        const elements = [node, ...this.GetFrozenAnnotations(annotation)];
        const scroll_delta = 25;
        const grid_rect = this.CellAddressToRectangle({ row: 0, column: 0 }).Combine(
          this.CellAddressToRectangle({
            row: this.view.active_sheet.rows - 1,
            column: this.view.active_sheet.columns - 1
          })
        ).Expand(-1, -1);
        MouseDrag(this.mask, "move", (move_event) => {
          if (move_event.offsetY - scroll_rect.top < this.header_offset.y) {
            const delta = Math.min(scroll_delta, scroll_node.scrollTop);
            scroll_node.scrollTop -= delta;
            offset.y += delta;
          } else if (move_event.offsetY - scroll_rect.top >= scroll_rect.height) {
            if (scroll_node.scrollTop + scroll_rect.height < grid_rect.height) {
              const delta = scroll_delta;
              scroll_node.scrollTop += delta;
              offset.y -= delta;
            }
          }
          if (move_event.offsetX - scroll_rect.left < this.header_offset.x) {
            const delta = Math.min(scroll_delta, scroll_node.scrollLeft);
            scroll_node.scrollLeft -= delta;
            offset.x += delta;
          } else if (move_event.offsetX - scroll_rect.left >= scroll_rect.width) {
            if (scroll_node.scrollLeft + scroll_rect.width < grid_rect.width) {
              const delta = scroll_delta;
              scroll_node.scrollLeft += delta;
              offset.x -= delta;
            }
          }
          rect.top = move_event.offsetY - offset.y;
          rect.left = move_event.offsetX - offset.x;
          if (move_event.shiftKey) {
            const dx = Math.abs(rect.left - origin.left);
            const dy = Math.abs(rect.top - origin.top);
            if (dx <= dy) {
              rect.left = origin.left;
            } else {
              rect.top = origin.top;
            }
          }
          if (move_event.ctrlKey) {
            const point = this.ClampToGrid({
              x: rect.left,
              y: rect.top
            });
            rect.left = point.x;
            rect.top = point.y;
          }
          for (const element of elements) {
            element.style.top = rect.top + "px";
            element.style.left = rect.left + "px";
          }
        }, () => {
          annotation.data.extent = void 0;
          annotation.data.layout = this.RectToAnnotationLayout(rect);
          resolve({ type: "annotation", annotation, event: "move" });
        });
        return;
      } else if (event.target === resize_target) {
        event.stopPropagation();
        event.preventDefault();
        node.focus();
        let aspect = 0;
        if (annotation.data.type === "image") {
          if (annotation.data.data && annotation.data.data.original_size && annotation.data.data.original_size.width && annotation.data.data.original_size.height) {
            aspect = annotation.data.data.original_size.width / annotation.data.data.original_size.height;
          }
        }
        const bounds = node.getBoundingClientRect();
        const offset = {
          x: bounds.left + event.offsetX - rect.width + resize_target.offsetLeft,
          y: bounds.top + event.offsetY - rect.height + resize_target.offsetTop
        };
        MouseDrag(this.mask, "nw-resize", (move_event) => {
          const elements = [node, ...this.GetFrozenAnnotations(annotation)];
          rect.height = move_event.offsetY - offset.y;
          rect.width = move_event.offsetX - offset.x;
          if (move_event.shiftKey && move_event.ctrlKey) {
            if (aspect) {
              const dx = Math.abs(rect.width - origin.width);
              const dy = Math.abs(rect.height - origin.height);
              if (dx < dy) {
                rect.width = aspect * rect.height;
              } else {
                rect.height = rect.width / aspect;
              }
            }
          } else if (move_event.shiftKey) {
            const dx = Math.abs(rect.height - origin.height);
            const dy = Math.abs(rect.width - origin.width);
            if (dx > dy) {
              rect.width = origin.width;
            } else {
              rect.height = origin.height;
            }
          } else if (move_event.ctrlKey) {
            const point = this.ClampToGrid({
              x: rect.right,
              y: rect.bottom
            });
            rect.width = point.x - rect.left + 1;
            rect.height = point.y - rect.top + 1;
          }
          for (const element of elements) {
            element.style.height = rect.height + "px";
            element.style.width = rect.width + "px";
          }
        }, () => {
          annotation.data.extent = void 0;
          annotation.data.layout = this.RectToAnnotationLayout(rect);
          resolve({ type: "annotation", annotation, event: "resize" });
        });
        return;
      } else {
        resolve();
      }
    });
  }
  /**
   * this used to be an abstract method for initializing. we're taking it
   * over to do some additional work post init, and renaming the subclass-specific
   * method (@see InitializeInternal).
   */
  Initialize(container, callbacks, scroll = true) {
    if (!this.mask.parentElement) {
      container.parentElement?.parentElement?.appendChild(this.mask);
    }
    if (!this.tooltip.parentElement) {
      container.appendChild(this.tooltip);
    }
    if (!this.dropdown_caret.parentElement) {
      container.appendChild(this.dropdown_caret);
    }
    if (!this.dropdown_list.parentElement) {
      container.appendChild(this.dropdown_list);
    }
    if (!this.note_node.parentElement) {
      container.appendChild(this.note_node);
    }
    if (!this.sort_button.parentElement) {
      container.appendChild(this.sort_button);
      this.sort_button.addEventListener("click", () => {
        callbacks.sort(
          this.sort_button.dataset.table || "",
          Number(this.sort_button.dataset.column || "0") || 0,
          /true/i.test(this.sort_button.dataset.asc || "")
        );
        this.sort_button.classList.remove("asc", "desc");
        if (this.sort_button.dataset.asc === "true") {
          this.sort_button.dataset.asc = "false";
          this.sort_button.classList.add("desc");
        } else {
          this.sort_button.dataset.asc = "true";
          this.sort_button.classList.add("asc");
        }
        callbacks.focus();
      });
    }
    if (!this.title_node.parentElement) {
      container.appendChild(this.title_node);
    }
    this.InitializeInternal(container, callbacks.scroll);
    if (!scroll && this.scroll_reference_node) {
      this.scroll_reference_node.style.overflow = "hidden";
    }
    this.dropdown_callback = callbacks.dropdown;
    this.initialized = true;
  }
  /**
   * create a selection so that this node (and parents) receive
   * a copy event on ctrl+c (or any other system copy event).
   * seems to break IE, so split.
   */
  MockSelection() {
    if (!this.container) {
      return;
    }
    if (this.trident) {
      return;
    }
    if (this.DOM.doc) {
      const selection = this.DOM.GetSelection();
      if (selection) {
        const range = this.DOM.doc.createRange();
        range.selectNodeContents(this.mock_selection);
        selection.removeAllRanges();
        selection.addRange(range);
      }
    }
  }
  /**
   * FIXME: this is public for now but tiles should move into
   * this class, then this method can become private
   */
  CreateTile(classes, size, position, first_cell, cell_extent, pixel_start, parent, mark_dirty = true) {
    const tile = this.DOM.Create("canvas");
    tile.setAttribute("class", classes);
    tile.logical_size = size;
    tile.width = size.width * this.dpr;
    tile.height = size.height * this.dpr;
    tile.style.width = `${size.width}px`;
    tile.style.height = `${size.height}px`;
    tile.tile_position = position;
    tile.first_cell = first_cell;
    this.UpdateTileGridPosition(tile);
    tile.last_cell = {
      row: first_cell.row + cell_extent.rows - 1,
      column: first_cell.column + cell_extent.columns - 1
    };
    tile.pixel_start = pixel_start;
    tile.pixel_end = {
      x: pixel_start.x + size.width,
      y: pixel_start.y + size.height
    };
    tile.dirty = !!mark_dirty;
    tile.needs_full_repaint = true;
    parent.appendChild(tile);
    return tile;
  }
  /**
   * applies theme to nodes, as necessary
   */
  ApplyTheme(theme) {
    this.row_header.style.backgroundColor = this.column_header.style.backgroundColor = this.corner.style.backgroundColor = theme.headers?.fill ? ThemeColor(theme, theme.headers.fill) : "";
    this.corner.style.borderColor = theme.grid_color || "";
    for (const row of this.grid_tiles) {
      for (const tile of row) {
        tile.style.backgroundColor = ThemeColor(theme, theme.grid_cell?.fill) || "#fff";
      }
    }
    this.dropdown_list.style.font = Style.Font(theme.grid_cell || {});
  }
  UpdateTotalSize() {
    this.total_height = 0;
    const rows = this.view.active_sheet.rows;
    for (let i = 0; i < rows; i++) {
      this.total_height += this.RowHeight(i);
    }
    this.total_width = 0;
    const columns = this.view.active_sheet.columns;
    for (let i = 0; i < columns; i++) {
      this.total_width += this.ColumnWidth(i);
    }
  }
  UpdateContentsSize() {
    const height = this.row_header_tiles.reduce((a, tile) => a + tile.logical_size.height, 0);
    const width = this.column_header_tiles.reduce((a, tile) => a + tile.logical_size.width, 0);
    this.column_header.style.width = this.contents.style.width = `${width}px`;
    this.row_header.style.height = this.contents.style.height = `${height}px`;
  }
  /** hides column/row resize tooltip and removes any specific classes */
  HideTooltip() {
    this.tooltip.style.display = "none";
    this.tooltip_state = void 0;
    this.tooltip.classList.remove("arrow-up");
    this.tooltip.classList.remove("arrow-left");
  }
  /*
  
    highlight error removed in favor of container errors, event reporting
    
    * briefly flash red, to indicate an error * /
    public HighlightError(address: ICellAddress): void {
  
      const target_rect = this.OffsetCellAddressToRectangle(address).Shift(
        this.header_size.width, this.header_size.height);
  
      target_rect.ApplyStyle(this.error_highlight);
      this.error_highlight.style.opacity = '1';
  
      // we don't like to rely on transitionend events. the concern is that
      // if they overlap eventually one will get lost... because this can be
      // triggered faster than the transition, we can almost always make that
      // happen
  
      if (this.error_highlight_timeout) {
        clearTimeout(this.error_highlight_timeout);
      }
  
      this.error_highlight_timeout = setTimeout(() => {
        this.error_highlight.style.opacity = '0';
        this.error_highlight_timeout = undefined;
      }, 250)
  
    }
    */
  /** show column/row resize tooltip */
  ShowTooltip(options = {}) {
    if (options.up) {
      this.tooltip.classList.add("arrow-up");
      this.tooltip_state = "up";
    } else if (options.left) {
      this.tooltip.classList.add("arrow-left");
      this.tooltip_state = "left";
    }
    this.tooltip.style.display = "block";
    this.UpdateTooltip(options);
  }
  ShowDropdownCaret(area, list, current) {
    let target_rect = this.OffsetCellAddressToRectangle(area.start);
    if (area.count > 1) {
      target_rect = target_rect.Combine(this.OffsetCellAddressToRectangle(area.end));
    }
    target_rect = target_rect.Shift(
      this.header_size.width,
      this.header_size.height
    );
    const height = Math.round(this.scale * Math.max(8, Math.min(20, target_rect.height)));
    this.dropdown_caret.style.height = `${height}px`;
    this.dropdown_caret.style.width = `${height}px`;
    this.dropdown_caret.style.left = `${target_rect.right + 1}px`;
    this.dropdown_caret.style.top = `${target_rect.bottom - height}px`;
    this.dropdown_list.style.top = `${target_rect.bottom + 2}px`;
    this.dropdown_list.style.left = `${target_rect.left + 2}px`;
    this.dropdown_list.style.minWidth = `${target_rect.width}px`;
    this.dropdown_list.textContent = "";
    for (const value of list) {
      const entry = this.DOM.Div(void 0, this.dropdown_list);
      if (current === value) {
        this.dropdown_selected = entry;
        entry.classList.add("selected");
      }
      entry.dropdown_value = value;
      entry.textContent = value?.toString() || "";
    }
    this.dropdown_caret.setAttribute("class", "treb-dropdown-caret");
    this.dropdown_caret.style.display = "block";
    this.dropdown_caret_visible = true;
  }
  HideDropdownCaret() {
    if (this.dropdown_caret_visible) {
      this.dropdown_caret.setAttribute("class", "treb-dropdown-caret");
      this.dropdown_caret_visible = false;
      this.dropdown_caret.style.display = "none";
    }
  }
  /**
   * this method returns the scroll offset adjusted for headers.
   * if you just want the raw scroll offset, use the accessor.
   * 
   * @param offset_headers 
   * @returns 
   */
  GetScrollOffset() {
    return {
      x: this.scroll_reference_node.scrollLeft + this.header_offset.x,
      y: this.scroll_reference_node.scrollTop + this.header_offset.y
    };
  }
  ScrollTo(address, x = true, y = true, smooth = false) {
    const target_rect = this.CellAddressToRectangle(address);
    if (smooth && !!this.scroll_reference_node.scrollTo) {
      const current = {
        left: this.scroll_reference_node.scrollLeft,
        top: this.scroll_reference_node.scrollTop
      };
      const options = {
        left: x ? target_rect.left : current.left,
        top: y ? target_rect.top : current.top,
        behavior: "smooth"
      };
      this.scroll_reference_node.scrollTo(options);
    } else {
      if (y) {
        this.scroll_reference_node.scrollTop = target_rect.top;
      }
      if (x) {
        this.scroll_reference_node.scrollLeft = target_rect.left;
      }
    }
  }
  /**
   * scroll address into view, at top-left or bottom-right depending on
   * target and current position. also offsets for frozen rows, columns.
   */
  ScrollIntoView(address, smooth = false) {
    const target_rect = this.CellAddressToRectangle(address);
    const width = this.scroll_reference_node.clientWidth - this.row_header.offsetWidth;
    const height = this.scroll_reference_node.clientHeight - this.column_header.offsetHeight;
    const offset = { x: 0, y: 0 };
    const lock = { x: false, y: false };
    const viewport = new Rectangle(
      this.scroll_reference_node.scrollLeft,
      this.scroll_reference_node.scrollTop,
      width,
      height
    );
    if (this.view.active_sheet.freeze.rows || this.view.active_sheet.freeze.columns) {
      if (this.view.active_sheet.freeze.rows && address.row >= this.view.active_sheet.freeze.rows) {
        offset.y = this.frozen_row_tiles[0].logical_size.height;
      } else if (this.view.active_sheet.freeze.rows)
        lock.y = true;
      if (this.view.active_sheet.freeze.columns && address.column >= this.view.active_sheet.freeze.columns) {
        offset.x = this.frozen_column_tiles[0].logical_size.width;
      } else if (this.view.active_sheet.freeze.columns)
        lock.x = true;
    }
    let options = {
      behavior: smooth ? "smooth" : "auto"
    };
    if (address.row !== Infinity) {
      if (target_rect.top < viewport.top + offset.y && !lock.y) {
        options.top = target_rect.top - offset.y;
      } else if (target_rect.bottom > viewport.bottom) {
        options.top = target_rect.bottom - height;
      }
    }
    if (address.column !== Infinity) {
      if (target_rect.left < viewport.left + offset.x && !lock.x) {
        options.left = target_rect.left - offset.x;
      } else if (target_rect.right > viewport.right) {
        options.left = target_rect.right - width;
      }
    }
    this.scroll_reference_node.scrollTo(options);
  }
  UpdateTooltip(options = {}) {
    if (typeof options.text !== "undefined") {
      this.tooltip.textContent = options.text;
    }
    if (typeof options.x !== "undefined") {
      let x = options.x || 0;
      if (this.tooltip_state === "up") {
        x -= this.tooltip.offsetWidth / 2;
      }
      this.tooltip.style.left = Math.round(x) + "px";
    }
    if (typeof options.y !== "undefined") {
      let y = options.y || 0;
      if (this.tooltip_state === "left") {
        y -= this.tooltip.offsetHeight / 2;
      }
      this.tooltip.style.top = Math.round(y) + "px";
    }
  }
  /**
   * y coordinate to row header. for consistency we return an address.
   */
  CoordinateToRowHeader(y) {
    const result = { column: Infinity, row: 0 };
    if (this.view.active_sheet.freeze.rows && this.frozen_row_tiles[0].pixel_end.y >= y - this.scroll_reference_node.scrollTop) {
      let height = 0;
      y -= this.scroll_reference_node.scrollTop;
      for (let i = 0; i < this.view.active_sheet.freeze.rows; i++) {
        height += this.RowHeight(i);
        if (height >= y) {
          result.row = i;
          return result;
        }
      }
    }
    for (const tile of this.row_header_tiles) {
      if (tile.pixel_end.y >= y) {
        let top = y - tile.pixel_start.y;
        let height = 0;
        result.row = tile.first_cell.row;
        for (; result.row <= tile.last_cell.row; result.row++, top -= height) {
          height = this.RowHeight(result.row);
          if (height > top) {
            return result;
          }
        }
        return result;
      }
    }
    return result;
  }
  /**
   * x coordinate to colum header. for consistency we return an address.
   */
  CoordinateToColumnHeader(x) {
    const result = { row: Infinity, column: 0 };
    if (this.view.active_sheet.freeze.columns && this.frozen_column_tiles[0].pixel_end.x >= x - this.scroll_reference_node.scrollLeft) {
      let width = 0;
      x -= this.scroll_reference_node.scrollLeft;
      for (let i = 0; i < this.view.active_sheet.freeze.columns; i++) {
        width += this.ColumnWidth(i);
        if (width >= x) {
          result.column = i;
          return result;
        }
      }
    }
    for (const tile of this.column_header_tiles) {
      if (tile.pixel_end.x >= x) {
        let left = x - tile.pixel_start.x;
        let width = 0;
        result.column = tile.first_cell.column;
        for (; result.column <= tile.last_cell.column; result.column++, left -= width) {
          width = this.ColumnWidth(result.column);
          if (width > left)
            return result;
        }
        return result;
      }
    }
    return result;
  }
  /**
   * point to cell address (grid only)
   * 
   * FIXME: implement cap_maximum parameter (not sure where we would need it)
   */
  PointToAddress_Grid(point, cap_maximum = false, offset_freeze = true) {
    if (offset_freeze) {
      if (this.view.active_sheet.freeze.rows) {
        const frozen_height = this.frozen_row_tiles[0].logical_size.height;
        if (point.y - this.scroll_reference_node.scrollTop < frozen_height) {
          point.y -= this.scroll_reference_node.scrollTop;
        }
      }
      if (this.view.active_sheet.freeze.columns) {
        const frozen_width = this.frozen_column_tiles[0].logical_size.width;
        if (point.x - this.scroll_reference_node.scrollLeft < frozen_width) {
          point.x -= this.scroll_reference_node.scrollLeft;
        }
      }
    }
    const result = {
      row: 0,
      column: 0
    };
    const last_column = this.grid_tiles[this.grid_tiles.length - 1];
    const last_tile = last_column[last_column.length - 1];
    if (point.y > last_tile.pixel_end.y) {
      let top = point.y - last_tile.pixel_end.y;
      result.row = last_tile.last_cell.row;
      while (top > 0) {
        result.row++;
        top -= this.default_row_height;
      }
    } else {
      for (const cell of last_column) {
        if (cell.pixel_start.y <= point.y && cell.pixel_end.y >= point.y) {
          let top = point.y - cell.pixel_start.y;
          let height = 0;
          result.row = cell.first_cell.row;
          for (; result.row <= cell.last_cell.row; result.row++, top -= height) {
            height = this.RowHeight(result.row);
            if (height > top) {
              break;
            }
          }
          break;
        }
      }
    }
    if (point.x > last_tile.pixel_end.x) {
      let left = point.x - last_tile.pixel_end.x;
      result.column = last_tile.last_cell.column;
      while (left > 0) {
        result.column++;
        left -= this.default_column_width;
      }
    } else {
      for (const column of this.grid_tiles) {
        if (column[0].pixel_start.x <= point.x && column[0].pixel_end.x >= point.x) {
          const cell = column[0];
          let left = point.x - cell.pixel_start.x;
          let width = 0;
          result.column = cell.first_cell.column;
          for (; result.column <= cell.last_cell.column; result.column++, left -= width) {
            width = this.ColumnWidth(result.column);
            if (width > left) {
              break;
            }
          }
          break;
        }
      }
    }
    return result;
  }
  /**
   * get an adjacent tile. this is used by the renderer when a merge or
   * overflow runs out of the painted tile, and we need to paint it.
   */
  AdjacentTile(tile, row_offset = 0, column_offset = 0) {
    if (!row_offset && !column_offset) {
      return tile;
    }
    const position = tile.tile_position;
    const row = tile.tile_position.row + row_offset;
    const column = tile.tile_position.column + column_offset;
    if (row < 0 || column < 0)
      return void 0;
    if (this.grid_tiles[position.column] && this.grid_tiles[position.column][position.row] === tile) {
      if (this.grid_tiles[column])
        return this.grid_tiles[column][row];
    }
    if (!position.column && this.frozen_column_tiles[position.row] === tile) {
      return this.frozen_column_tiles[row];
    }
    if (!position.row && this.frozen_row_tiles[position.column] === tile) {
      return this.frozen_row_tiles[column];
    }
    return void 0;
  }
  UpdateTiles() {
    if (!this.container)
      throw new Error("invalid container");
    this.grid_tiles.forEach((arr) => {
      arr.forEach((tile) => {
        if (tile.parentElement) {
          tile.parentElement.removeChild(tile);
        }
      });
    });
    for (const tileset of [
      this.column_header_tiles,
      this.row_header_tiles,
      this.frozen_row_tiles,
      this.frozen_column_tiles
    ]) {
      for (const tile of tileset) {
        if (tile.parentElement) {
          tile.parentElement.removeChild(tile);
        }
      }
    }
    this.frozen_row_tiles = [];
    this.frozen_column_tiles = [];
    this.row_header_tiles = [];
    this.column_header_tiles = [];
    this.grid_tiles = [];
    const sheet = this.view.active_sheet;
    this.default_row_height = Math.round(sheet.default_row_height * this.scale);
    this.default_column_width = Math.round(sheet.default_column_width * this.scale);
    this.header_offset = {
      x: Math.round(sheet.header_offset.x * this.scale),
      y: Math.round(sheet.header_offset.y * this.scale)
    };
    this.UpdateContainingGrid();
    let rows = this.view.active_sheet.rows;
    let columns = this.view.active_sheet.columns;
    if (!rows)
      rows = 100;
    if (!columns)
      columns = 40;
    let total_height = 0;
    let total_width = 0;
    for (let i = 0; i < rows; i++) {
      total_height += this.RowHeight(i);
    }
    for (let i = 0; i < columns; i++) {
      total_width += this.ColumnWidth(i);
    }
    if (!total_width || !total_height) {
      throw "unexpected missing total size";
    }
    if (!total_height)
      total_height = this.default_row_height * rows;
    if (!total_width)
      total_width = this.default_column_width * columns;
    if (this.container.clientWidth > total_width + this.header_size.width) {
      const add_columns = Math.ceil((this.container.offsetWidth - total_width) / this.default_column_width);
      total_width += add_columns * this.default_column_width;
      columns += add_columns;
    }
    this.last_column = columns;
    if (this.container.clientHeight > total_height + this.header_size.height) {
      const add_rows = Math.ceil((this.container.offsetHeight - total_height) / this.default_row_height);
      total_height += add_rows * this.default_row_height;
      rows += add_rows;
    }
    this.column_header.style.width = this.contents.style.width = `${total_width}px`;
    this.row_header.style.height = this.contents.style.height = `${total_height}px`;
    const tile_widths = [];
    const tile_columns = [];
    let tile_width = 0;
    let tile_column = 0;
    for (let c = 0; c < columns; c++) {
      const column_width = this.ColumnWidth(c);
      if (tile_width && tile_width + column_width > this.default_tile_size.width) {
        tile_widths.push(tile_width);
        tile_columns.push(tile_column);
        tile_column = c;
        tile_width = 0;
      }
      tile_width += column_width;
    }
    tile_widths.push(tile_width);
    tile_columns.push(tile_column);
    const tile_heights = [];
    const tile_rows = [];
    let tile_height = 0;
    let tile_row = 0;
    for (let r = 0; r < rows; r++) {
      const row_height = this.RowHeight(r);
      if (tile_height && tile_height + row_height > this.default_tile_size.height) {
        tile_heights.push(tile_height);
        tile_rows.push(tile_row);
        tile_height = 0;
        tile_row = r;
      }
      tile_height += row_height;
    }
    tile_heights.push(tile_height);
    tile_rows.push(tile_row);
    const column_tile_count = tile_widths.length;
    const row_tile_count = tile_heights.length;
    let pixel_y = 0;
    let pixel_x = 0;
    let header_height = 0;
    let header_width = 0;
    for (let i = 0; i < this.view.active_sheet.freeze.rows; i++) {
      header_height += this.RowHeight(i);
    }
    for (let i = 0; i < this.view.active_sheet.freeze.columns; i++) {
      header_width += this.ColumnWidth(i);
    }
    for (let c = 0; c < column_tile_count; c++) {
      const column = [];
      pixel_y = 0;
      const column_extent = c === column_tile_count - 1 ? columns - tile_columns[c] : tile_columns[c + 1] - tile_columns[c];
      this.column_header_tiles.push(this.CreateTile(
        "column-header-tile",
        { height: this.header_offset.y, width: tile_widths[c] },
        { row: 0, column: c },
        { row: 0, column: tile_columns[c] },
        { rows: 0, columns: column_extent },
        { x: pixel_x, y: 0 },
        this.column_header
      ));
      if (this.view.active_sheet.freeze.rows) {
        this.frozen_row_tiles.push(this.CreateTile(
          "frozen-row-tile",
          { height: header_height, width: tile_widths[c] },
          { row: 1, column: c },
          { row: 0, column: tile_columns[c] },
          { rows: 0, columns: column_extent },
          { x: pixel_x, y: 0 },
          this.column_header
        ));
      }
      for (let r = 0; r < row_tile_count; r++) {
        const row_extent = r === row_tile_count - 1 ? rows - tile_rows[r] : tile_rows[r + 1] - tile_rows[r];
        if (!c) {
          this.row_header_tiles.push(this.CreateTile(
            "row-header-tile",
            { height: tile_heights[r], width: this.header_offset.x },
            { row: r, column: 0 },
            { row: tile_rows[r], column: 0 },
            // first cell
            { rows: row_extent, columns: 1 },
            { x: 0, y: pixel_y },
            this.row_header
          ));
          if (this.view.active_sheet.freeze.columns) {
            this.frozen_column_tiles.push(this.CreateTile(
              "frozen-column-tile",
              { height: tile_heights[r], width: header_width },
              { row: r, column: 1 },
              { row: tile_rows[r], column: 0 },
              { rows: row_extent, columns: 1 },
              { x: 0, y: pixel_y },
              this.row_header
            ));
          }
        }
        column.push(this.CreateTile(
          "grid-tile",
          { height: tile_heights[r], width: tile_widths[c] },
          // tile size in pixels
          { row: r, column: c },
          // grid position
          { row: tile_rows[r], column: tile_columns[c] },
          // first cell
          { rows: row_extent, columns: column_extent },
          // extent
          { x: pixel_x, y: pixel_y },
          this.contents
        ));
        pixel_y += tile_heights[r];
      }
      this.grid_tiles.push(column);
      pixel_x += tile_widths[c];
    }
    this.total_height = total_height;
    this.total_width = total_width;
    this.ClearLayoutCaches();
    this.UpdateGridTemplates(true, true);
  }
  ClearLayoutCaches() {
    this.row_cache = [];
    this.column_cache = [];
  }
  /**
   * returns the tile index for a given column. this is used to map
   * a column to a tile in either the header or the grid.
   * FIXME: speed up w/ lookup cache
   */
  TileIndexForColumn(column) {
    for (const tile of this.column_header_tiles) {
      if (tile.first_cell.column <= column && tile.last_cell.column >= column) {
        return tile.tile_position.column;
      }
    }
    return -1;
  }
  /**
   * returns the tile index for a given row. this is used to map
   * a column to a tile in either the header or the grid.
   * FIXME: speed up w/ lookup cache
   */
  TileIndexForRow(row) {
    for (const tile of this.row_header_tiles) {
      if (tile.first_cell.row <= row && tile.last_cell.row >= row) {
        return tile.tile_position.row;
      }
    }
    return -1;
  }
  /**
   * marks header tiles as dirty, for next repaint call
   *
   * UPDATE fix for entire column/row/sheet (the Intersects() method
   * doesn't support infinities, for some reason: FIX THAT)
   */
  DirtyHeaders(area) {
    if (!area)
      return;
    for (const tile of this.column_header_tiles) {
      if (tile.dirty)
        continue;
      const test = new Area(
        { row: area.start.row, column: tile.first_cell.column },
        { row: area.start.row, column: tile.last_cell.column }
      );
      if (area.entire_row || test.Intersects(area)) {
        tile.dirty = true;
      }
    }
    for (const tile of this.row_header_tiles) {
      if (tile.dirty)
        continue;
      const test = new Area(
        { column: area.start.column, row: tile.first_cell.row },
        { column: area.start.column, row: tile.last_cell.row }
      );
      if (area.entire_column || test.Intersects(area)) {
        tile.dirty = true;
      }
    }
  }
  DirtyAll() {
    for (const column of this.grid_tiles) {
      for (const tile of column) {
        tile.dirty = true;
      }
    }
  }
  DirtyArea(areas) {
    if (!this.initialized)
      return;
    if (!Array.isArray(areas)) {
      areas = [areas];
    }
    for (const area of areas) {
      const start = { row: 0, column: 0 };
      const end = { row: this.grid_tiles[0].length - 1, column: this.grid_tiles.length - 1 };
      if (area.start.column !== Infinity) {
        start.column = end.column = this.TileIndexForColumn(area.start.column);
        if (area.end.column !== area.start.column)
          end.column = this.TileIndexForColumn(area.end.column);
      }
      if (area.start.row !== Infinity) {
        start.row = end.row = this.TileIndexForRow(area.start.row);
        if (area.end.row !== area.start.row)
          end.row = this.TileIndexForRow(area.end.row);
      }
      for (let column = start.column; column <= end.column; column++) {
        for (let row = start.row; row <= end.row; row++) {
          this.grid_tiles[column][row].dirty = true;
        }
      }
    }
  }
  /** calculate first visible tile based on scroll position */
  VisibleTiles() {
    const tiles = [{ row: 0, column: 0 }, { row: 0, column: 0 }];
    if (!this.container || !this.grid_tiles.length || !this.grid_tiles[0].length) {
      return new Area(tiles[0], tiles[1]);
    }
    const left = this.scroll_reference_node.scrollLeft;
    const right = left + this.scroll_reference_node.offsetWidth;
    const top = this.scroll_reference_node.scrollTop;
    const bottom = top + this.scroll_reference_node.offsetHeight;
    for (const column of this.grid_tiles) {
      let cell = column[0];
      if (cell.pixel_start.x <= left && cell.pixel_end.x >= left) {
        for (cell of column) {
          if (cell.pixel_start.y <= top && cell.pixel_end.y >= top) {
            tiles[0] = cell.tile_position;
            break;
          }
        }
      }
      if (column === this.grid_tiles[this.grid_tiles.length - 1] || cell.pixel_start.x <= right && cell.pixel_end.x >= right) {
        for (cell of column) {
          if (cell === column[column.length - 1] || cell.pixel_start.y <= bottom && cell.pixel_end.y >= bottom) {
            tiles[1] = cell.tile_position;
            return new Area(tiles[0], tiles[1]);
          }
        }
      }
    }
    return new Area(tiles[0], tiles[1]);
  }
  UpdateTileHeights(mark_dirty = true, start_row = -1) {
    let y = 0;
    for (let i = 0; i < this.row_header_tiles.length; i++) {
      const tile = this.row_header_tiles[i];
      if (start_row > tile.last_cell.row) {
        y += tile.logical_size.height;
        continue;
      }
      let height = 0;
      for (let r = tile.first_cell.row; r <= tile.last_cell.row; r++) {
        height += this.RowHeight(r);
      }
      const height_match = tile.logical_size.height === height;
      tile.pixel_start.y = y;
      y += height;
      tile.pixel_end.y = y;
      if (!height_match) {
        tile.logical_size.height = height;
        tile.style.height = `${height}px`;
        tile.height = this.dpr * height;
        if (this.view.active_sheet.freeze.columns) {
          const frozen_tile = this.frozen_column_tiles[i];
          frozen_tile.logical_size.height = height;
          frozen_tile.style.height = `${height}px`;
          frozen_tile.height = this.dpr * height;
        }
        if (mark_dirty) {
          tile.dirty = true;
          tile.needs_full_repaint = true;
        }
      }
      for (const column of this.grid_tiles) {
        const grid_tile = column[i];
        grid_tile.pixel_start.y = tile.pixel_start.y;
        grid_tile.pixel_end.y = tile.pixel_end.y;
        if (!height_match) {
          grid_tile.logical_size.height = height;
          grid_tile.style.height = `${height}px`;
          grid_tile.height = this.dpr * height;
          if (mark_dirty) {
            grid_tile.dirty = true;
            grid_tile.needs_full_repaint = true;
          }
        }
      }
    }
    if (this.view.active_sheet.freeze.rows) {
      let freeze_height = 0;
      for (let i = 0; i < this.view.active_sheet.freeze.rows; i++)
        freeze_height += this.RowHeight(i);
      for (const tile of this.frozen_row_tiles) {
        tile.style.height = `${freeze_height}px`;
        tile.height = freeze_height * this.dpr;
      }
      freeze_height += this.header_offset.y;
      this.corner_canvas.style.height = `${freeze_height}px`;
      this.corner_canvas.height = freeze_height * this.dpr;
      for (const column of this.grid_tiles) {
        column[0].dirty = true;
      }
    }
    this.UpdateGridTemplates(false, true);
    this.row_header.style.height = this.contents.style.height = `${y}px`;
    this.ClearLayoutCaches();
  }
  /**
   * update all widths. start_column is a hint that can save some work
   * by skipping unaffected tiles
   */
  UpdateTileWidths(mark_dirty = true, start_column = -1) {
    let x = 0;
    for (let i = 0; i < this.column_header_tiles.length; i++) {
      const tile = this.column_header_tiles[i];
      const column = this.grid_tiles[i];
      if (start_column > tile.last_cell.column) {
        x += tile.logical_size.width;
        continue;
      }
      let width = 0;
      for (let c = tile.first_cell.column; c <= tile.last_cell.column; c++) {
        width += this.ColumnWidth(c);
      }
      const width_match = tile.logical_size.width === width;
      tile.pixel_start.x = x;
      x += width;
      tile.pixel_end.x = x;
      if (!width_match) {
        tile.logical_size.width = width;
        tile.style.width = `${width}px`;
        tile.width = this.dpr * width;
        if (this.view.active_sheet.freeze.rows) {
          const frozen_tile = this.frozen_row_tiles[i];
          frozen_tile.logical_size.width = width;
          frozen_tile.style.width = `${width}px`;
          frozen_tile.width = this.dpr * width;
        }
        if (mark_dirty) {
          tile.dirty = true;
          tile.needs_full_repaint = true;
        }
      }
      for (const grid_tile of column) {
        grid_tile.pixel_start.x = tile.pixel_start.x;
        grid_tile.pixel_end.x = tile.pixel_end.x;
        if (!width_match) {
          grid_tile.logical_size.width = width;
          grid_tile.style.width = `${width}px`;
          grid_tile.width = this.dpr * width;
          if (mark_dirty) {
            grid_tile.dirty = true;
            grid_tile.needs_full_repaint = true;
          }
        }
      }
    }
    if (this.view.active_sheet.freeze.columns) {
      let freeze_width = 0;
      for (let i = 0; i < this.view.active_sheet.freeze.columns; i++)
        freeze_width += this.ColumnWidth(i);
      for (const tile of this.frozen_column_tiles) {
        tile.style.width = `${freeze_width}px`;
        tile.width = freeze_width * this.dpr;
      }
      freeze_width += this.header_offset.x;
      this.corner_canvas.style.width = `${freeze_width}px`;
      this.corner_canvas.width = freeze_width * this.dpr;
      for (const tile of this.grid_tiles[0]) {
        tile.dirty = true;
      }
    }
    this.UpdateGridTemplates(true, false);
    this.column_header.style.width = this.contents.style.width = `${x}px`;
    this.ClearLayoutCaches();
  }
  ClampToGrid(point) {
    const address = this.PointToAddress_Grid(point);
    const rect = this.OffsetCellAddressToRectangle(address);
    if (point.x > rect.left + rect.width / 2) {
      point.x = rect.left + rect.width - 1;
    } else {
      point.x = rect.left - 1;
    }
    if (point.y > rect.top + rect.height / 2) {
      point.y = rect.top + rect.height - 1;
    } else {
      point.y = rect.top - 1;
    }
    return point;
  }
  /**
   * wrapper method for CellAddressToRectangle allows us to offset for
   * frozen rows/columns. in some cases we may not want to do this, so
   * the underlying method is still visible (and cache contains the raw
   * rectangles, not offset).
   */
  OffsetCellAddressToRectangle(address) {
    let rect = this.CellAddressToRectangle(address);
    if (address.column >= 0 && address.column < this.view.active_sheet.freeze.columns) {
      rect = rect.Shift(this.scroll_reference_node.scrollLeft, 0);
    }
    if (address.row >= 0 && address.row < this.view.active_sheet.freeze.rows) {
      rect = rect.Shift(0, this.scroll_reference_node.scrollTop);
    }
    return rect;
  }
  /**
   * finds the rectangle, in the coordinate space of the grid node,
   * of the cell with the given address. uses a cache since we wind
   * up looking up the same rectangles a lot.
   * 
   * UPDATE dropping rectangle cache in favor of holding row and 
   * column edges. I realized we were holding a lot of redundant 
   * information, and this should be resonably fast.
   * 
   * TODO could probably be slightly more efficient by holding the
   * left edge of the column/row at the index; then we don't have to
   * have special behavior for column/row 0.
   */
  CellAddressToRectangle(address) {
    const row = address.row === Infinity || address.row < 0 ? 0 : address.row;
    const column = address.column === Infinity || address.column < 0 ? 0 : address.column;
    if (this.column_cache.length <= column + 1) {
      if (!this.column_cache.length) {
        this.column_cache[0] = 0;
      }
      for (let i = this.column_cache.length - 1; i <= column; i++) {
        this.column_cache[i + 1] = this.column_cache[i] + this.ColumnWidth(i);
      }
    }
    if (this.row_cache.length <= row + 1) {
      if (!this.row_cache.length) {
        this.row_cache[0] = 0;
      }
      for (let i = this.row_cache.length - 1; i <= row; i++) {
        this.row_cache[i + 1] = this.row_cache[i] + this.RowHeight(i);
      }
    }
    const left = this.column_cache[column];
    const top = this.row_cache[row];
    return new Rectangle(
      left,
      top,
      this.column_cache[column + 1] - left,
      this.row_cache[row + 1] - top
    );
  }
  /**
   * resizes the tile at this index, rebuilds structure of subsequent tiles.
   * this is necessary because tiles keep track of pixel position: so if a
   * tile is resized, subsequent tiles have to change.
   */
  ResizeTileWidth(index, width, mark_dirty = true) {
    let tile = this.column_header_tiles[index];
    const delta = width - tile.logical_size.width;
    tile.logical_size.width = width;
    tile.style.width = `${width}px`;
    tile.width = this.dpr * width;
    tile.pixel_end.x += delta;
    if (mark_dirty) {
      tile.dirty = true;
      tile.needs_full_repaint = true;
    }
    for (let i = index + 1; i < this.column_header_tiles.length; i++) {
      this.column_header_tiles[i].pixel_start.x += delta;
      this.column_header_tiles[i].pixel_end.x += delta;
      for (const cell of this.grid_tiles[i]) {
        cell.pixel_start.x += delta;
        cell.pixel_end.x += delta;
      }
    }
    const column = this.grid_tiles[index];
    for (tile of column) {
      tile.logical_size.width = width;
      tile.style.width = `${width}px`;
      tile.width = this.dpr * width;
      tile.pixel_end.x += delta;
      if (mark_dirty) {
        tile.dirty = true;
        tile.needs_full_repaint = true;
      }
    }
    this.UpdateTotalSize();
    this.UpdateGridTemplates(true, false);
    this.UpdateContentsSize();
  }
  /**
   * resizes the tile at this index, rebuilds structure of subsequent tiles
   */
  ResizeTileHeight(index, height, mark_dirty = true) {
    let tile = this.row_header_tiles[index];
    const delta = height - tile.logical_size.height;
    tile.logical_size.height = height;
    tile.style.height = `${height}px`;
    tile.height = this.dpr * height;
    tile.pixel_end.y += delta;
    if (mark_dirty) {
      tile.dirty = true;
      tile.needs_full_repaint = true;
    }
    for (let r = index + 1; r < this.row_header_tiles.length; r++) {
      tile = this.row_header_tiles[r];
      tile.pixel_start.y += delta;
      tile.pixel_end.y += delta;
    }
    for (const column of this.grid_tiles) {
      tile = column[index];
      tile.logical_size.height = height;
      tile.style.height = `${height}px`;
      tile.height = this.dpr * height;
      tile.pixel_end.y += delta;
      if (mark_dirty) {
        tile.dirty = true;
        tile.needs_full_repaint = true;
      }
      for (let i = index + 1; i < column.length; i++) {
        column[i].pixel_start.y += delta;
        column[i].pixel_end.y += delta;
      }
    }
    this.UpdateTotalSize();
    this.UpdateGridTemplates(false, true);
    this.UpdateContentsSize();
  }
};

// treb-grid/src/layout/mock-layout.ts
var MockLayout = class extends BaseLayout {
  constructor(model, view) {
    super(model, view, true);
  }
  InitializeInternal(container, scroll_callback) {
  }
  UpdateGridTemplates(columns, rows) {
  }
  UpdateTileGridPosition(tile) {
  }
  UpdateContainingGrid() {
  }
  ResizeCursor(resize) {
  }
};

// treb-grid/src/layout/grid_layout.ts
var GridLayout = class extends BaseLayout {
  constructor(model, view, DOM) {
    super(model, view, false, DOM);
    this.column_header = DOM.Div("treb-top-header");
    this.row_header = DOM.Div("treb-left-header");
    this.corner = DOM.Div("treb-corner");
    this.corner_canvas = DOM.Create("canvas");
    this.corner.appendChild(this.corner_canvas);
    this.contents = DOM.Div("treb-contents");
    this.buffer_canvas = DOM.Create("canvas", "treb-buffer-canvas", this.contents);
    this.grid_selection = DOM.SVG("svg", "treb-grid-selection", this.contents);
    this.row_header_selection = DOM.SVG("svg", ["frozen-selection", "frozen-selection-rows"], this.column_header);
    this.row_header_annotations = DOM.Div("frozen-annotation-container frozen-annotation-container-rows", this.column_header);
    this.column_header_selection = DOM.SVG("svg", ["frozen-selection", "frozen-selection-columns"], this.row_header);
    this.column_header_annotations = DOM.Div("frozen-annotation-container frozen-annotation-container-columns", this.row_header);
    this.corner_selection = DOM.SVG("svg", "frozen-selection", this.corner);
    this.corner_annotations = DOM.Div("frozen-annotation-container frozen-annotation-container-corner", this.corner);
    this.annotation_container = DOM.Div("treb-annotation-container");
    this.grid_cover = DOM.Div("tile-cover grid-cover");
    this.column_header_cover = DOM.Div("tile-cover column-header-cover");
    this.row_header_cover = DOM.Div("tile-cover row-header-cover");
  }
  /** attach node structure to container */
  InitializeInternal(container, scroll_callback) {
    this.container = container;
    this.scroll_reference_node = this.container;
    container.appendChild(this.column_header);
    container.appendChild(this.row_header);
    container.appendChild(this.corner);
    container.appendChild(this.contents);
    container.appendChild(this.annotation_container);
    container.appendChild(this.grid_cover);
    container.appendChild(this.column_header_cover);
    container.appendChild(this.row_header_cover);
    container.appendChild(this.mock_selection);
    this.container.addEventListener("scroll", () => scroll_callback());
  }
  ResizeCursor(resize) {
    switch (resize) {
      case "row":
        this.row_header_cover.classList.add("resize");
        break;
      case "column":
        this.column_header_cover.classList.add("resize");
        break;
      default:
        this.row_header_cover.classList.remove("resize");
        this.column_header_cover.classList.remove("resize");
        break;
    }
  }
  UpdateTileGridPosition(tile) {
    tile.style.gridColumn = `${tile.tile_position.column + 1} / ${tile.tile_position.column + 2}`;
    tile.style.gridRow = `${tile.tile_position.row + 1} / ${tile.tile_position.row + 2}`;
  }
  UpdateContainingGrid() {
    if (!this.container)
      throw new Error("missing container");
    this.header_size.width = this.header_offset.x;
    this.header_size.height = this.header_offset.y;
    let x = this.header_offset.x;
    let y = this.header_offset.y;
    if (this.view.active_sheet.freeze.columns) {
      for (let i = 0; i < this.view.active_sheet.freeze.columns; i++)
        x += this.ColumnWidth(i);
    }
    if (this.view.active_sheet.freeze.rows) {
      for (let i = 0; i < this.view.active_sheet.freeze.rows; i++)
        y += this.RowHeight(i);
    }
    this.container.style.gridTemplateColumns = `${this.header_offset.x}px auto`;
    this.container.style.gridTemplateRows = `${this.header_offset.y}px auto`;
    this.corner_canvas.setAttribute("width", `${this.dpr * x}`);
    this.corner_canvas.setAttribute("height", `${this.dpr * y}`);
    this.column_header.style.height = `${y}px`;
    this.corner_canvas.style.width = `${x}px`;
    this.corner_canvas.style.height = `${y}px`;
  }
  UpdateGridTemplates(columns = true, rows = true) {
    let width = 0;
    let height = 0;
    this.column_header.style.gridTemplateColumns = this.contents.style.gridTemplateColumns = this.column_header_tiles.map((tile) => {
      width += tile.logical_size.width;
      return `${tile.logical_size.width}px`;
    }).join(" ");
    this.column_header.style.gridTemplateRows = `${this.header_offset.y}px auto`;
    this.row_header.style.gridTemplateRows = this.contents.style.gridTemplateRows = this.row_header_tiles.map((tile) => {
      height += tile.logical_size.height;
      return `${tile.logical_size.height}px`;
    }).join(" ");
    let y = this.header_offset.y;
    if (this.view.active_sheet.freeze.rows) {
      for (let i = 0; i < this.view.active_sheet.freeze.rows; i++) {
        y += this.RowHeight(i);
      }
    }
    this.column_header.style.height = `${y}px`;
    this.row_header_selection.style.display = "block";
    this.row_header_selection.style.width = `${width}px`;
    this.corner_selection.style.height = this.row_header_selection.style.height = `${y}px`;
    this.corner_selection.style.top = this.row_header_selection.style.top = "0px";
    this.row_header_selection.style.left = `0px`;
    let x = this.header_offset.x;
    if (this.view.active_sheet.freeze.columns) {
      for (let i = 0; i < this.view.active_sheet.freeze.columns; i++) {
        x += this.ColumnWidth(i);
      }
    }
    this.column_header_selection.style.display = "block";
    this.corner_selection.style.width = this.column_header_selection.style.width = `${x}px`;
    this.column_header_selection.style.height = `${height}px`;
    this.column_header_selection.style.top = `0px`;
    this.corner_selection.style.left = this.column_header_selection.style.left = "0px";
    const scaled_header = {
      x: this.view.active_sheet.header_offset.x * this.scale,
      y: this.view.active_sheet.header_offset.y * this.scale
    };
    const freeze = this.view.active_sheet.freeze;
    if (freeze.rows && freeze.columns) {
      this.row_header_annotations.style.display = "block";
      this.column_header_annotations.style.display = "block";
      this.corner_annotations.style.display = "block";
    } else if (freeze.rows) {
      this.row_header_annotations.style.display = "block";
      this.column_header_annotations.style.display = "none";
      this.corner_annotations.style.display = "none";
    } else if (freeze.columns) {
      this.row_header_annotations.style.display = "none";
      this.column_header_annotations.style.display = "block";
      this.corner_annotations.style.display = "none";
    } else {
      this.row_header_annotations.style.display = "none";
      this.column_header_annotations.style.display = "none";
      this.corner_annotations.style.display = "none";
    }
    this.row_header_annotations.style.width = `${width}px`;
    this.corner_annotations.style.height = this.row_header_annotations.style.height = `${y - scaled_header.y}px`;
    this.corner_annotations.style.top = this.row_header_annotations.style.top = `${scaled_header.y}px`;
    this.column_header_annotations.style.width = this.corner_annotations.style.width = `${x - scaled_header.x}px`;
    this.column_header_annotations.style.height = `${height}px`;
    this.corner_annotations.style.left = this.column_header_annotations.style.left = `${scaled_header.x}px`;
    this.corner_selection.style.display = "block";
    this.grid_selection.style.width = `${width}px`;
    this.grid_selection.style.height = `${height}px`;
    this.grid_selection.style.top = `${this.header_offset.y}px`;
    this.grid_selection.style.left = `${this.header_offset.x}px`;
    this.annotation_container.style.width = `${width}px`;
    this.annotation_container.style.height = `${height}px`;
    this.annotation_container.style.top = `${this.header_offset.y}px`;
    this.annotation_container.style.left = `${this.header_offset.x}px`;
  }
};

// treb-grid/src/editors/autocomplete_matcher.ts
var AutocompleteMatcher = class {
  function_names = [];
  //private function_map: {[index: string]: FunctionDescriptor} = {};
  argument_separator = Localization.argument_separator.charCodeAt(0);
  /**
   * making this public (and scrubbing the type). we need it public so we 
   * can check collisions. I'm not sure why it was originally private...
   */
  function_map = {};
  RemoveFunctions(functions) {
    if (!Array.isArray(functions)) {
      functions = [functions];
    }
    let list = Object.keys(this.function_map).map((key) => this.function_map[key]);
    for (const func of functions) {
      list = list.filter((test) => test.name !== func.name);
    }
    this.SetFunctions(list);
  }
  AddFunctions(functions) {
    if (!Array.isArray(functions)) {
      functions = [functions];
    }
    const list = Object.keys(this.function_map).map((key) => this.function_map[key]).concat(...functions);
    this.SetFunctions(list);
  }
  SetFunctions(functions) {
    this.function_map = {};
    this.function_names = functions.map((fn) => {
      this.function_map[fn.name.toLowerCase()] = fn;
      return fn.name;
    }).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
  }
  NormalizeIdentifier(name) {
    const identifier = this.function_map[name.toLowerCase()];
    return identifier ? identifier.name : void 0;
  }
  Exec(data) {
    if (data.text[0] !== "=") {
      return {};
    }
    let match;
    let result = {};
    if (data.cursor === data.text.length) {
      match = data.text.match(/(?:^|[^A-Za-z_\d])([A-Za-z_][\w\d_.]*)\s*$/);
      if (match) {
        const token = match[1];
        const rex = new RegExp("^" + token.replace(".", "\\."), "i");
        const list = this.function_names.filter((name) => rex.test(name)).map((name) => this.function_map[name.toLowerCase()]);
        result = {
          completions: list,
          token,
          position: data.cursor - token.length
        };
      }
    }
    const parsed = this.ParseTooltip(data.text.substr(0, data.cursor));
    if (parsed.function) {
      const func = this.function_map[parsed.function.toLowerCase()];
      if (func) {
        result.tooltip = '<span class="notranslate">' + func.name + "</span>";
        result.arguments = "(" + (func.arguments || []).map((desc, index) => {
          const argument = desc.name || "argument";
          return index === parsed.argument ? `<span class="active-argument">${argument}</span>` : argument;
        }).join(Localization.argument_separator + " ") + ")";
        result.description = func.description ? `<span class="function-description">${func.description}</span>` : "";
        result.function_position = parsed.position || 0;
      }
    }
    return result;
  }
  /**
   * baby parser for generating tooltips. we want the name of the 
   * current function, and the index of the current argument.
   * 
   * not handled: escaped quotes (not even sure what the syntax for that is)
   */
  ParseTooltip(expression) {
    const stack = [];
    let argument = 0;
    let buffer = "";
    let quote = false;
    let position = 0;
    for (const letter of expression) {
      const char = letter.charCodeAt(0);
      if (quote) {
        if (char === 34) {
          quote = false;
        }
      } else {
        switch (char) {
          case 40:
            stack.push({
              buffer: buffer.trim(),
              // there is no case where spaces get in this buffer
              argument,
              position: position - buffer.length
            });
            buffer = "";
            argument = 0;
            break;
          case this.argument_separator:
            argument++;
            break;
          case 41:
            argument = stack.pop()?.argument || 0;
            break;
          case 34:
            buffer = "";
            quote = true;
            break;
          default:
            if (char >= 97 && char <= 122 || char >= 65 && char <= 90 || char >= 48 && char <= 57 || char === 95 || char === 46) {
              buffer += letter;
            } else {
              buffer = "";
            }
        }
      }
      position++;
    }
    const last_func = stack.pop();
    return {
      function: last_func?.buffer || void 0,
      position: last_func?.position || 0,
      argument
    };
  }
};

// treb-grid/src/editors/editor.ts
var Editor = class _Editor extends EventSource {
  constructor(model, view, autocomplete) {
    super();
    this.model = model;
    this.view = view;
    this.autocomplete = autocomplete;
    this.parser = model.parser;
  }
  static FormulaChars = ("$^&*(-+={[<>/~%" + Localization.argument_separator).split("");
  // FIXME: i18n
  /**
   * the current edit cell. in the event we're editing a merged or
   * array cell, this might be different than the actual target address.
   */
  active_cell;
  /** matcher. passed in by owner. should move to constructor arguments */
  autocomplete_matcher;
  /** the containing node, used for layout */
  container_node;
  /** 
   * this is the node we are currently editing. it's possible we are not 
   * editing any cell, but just formatting. this one sends events and is 
   * the target for inserting addresses.
   */
  active_editor;
  /**
   * all nodes that are involved with this editor. we format all of them,
   * and if you edit one we might switch the colors in the others as 
   * references change.
   */
  nodes = [];
  /** 
   * address of cell we're editing, if we're editing a cell
   */
  target_address;
  /**
   * assume we're editing a formula. this is for the external editor.
   * if we switch the formula bar to inherit from this class, it should
   * be false.
   */
  assume_formula = false;
  /**
   * this flag indicates we're editing a formula, which starts with `=`.
   */
  text_formula = false;
  /**
   * this has changed -- we don't have an internal field. instead we'll 
   * check when called. it's slightly more expensive but should be 
   * relatively rare.
   */
  get selecting() {
    if (this.assume_formula) {
      return true;
    }
    if (!this.text_formula) {
      return false;
    }
    if (this.active_editor && this.active_editor.node === this.active_editor.node.ownerDocument.activeElement) {
      const view = this.active_editor.node.ownerDocument.defaultView;
      const selection = view.getSelection();
      const count = selection?.rangeCount;
      if (count) {
        const range = selection?.getRangeAt(0);
        const element = range?.endContainer instanceof view.HTMLElement ? range.endContainer : range.endContainer?.parentElement;
        if (element?.dataset.reference !== void 0) {
          return true;
        }
        if (range?.startContainer instanceof view.Text) {
          const str = (range.startContainer.textContent?.substring(0, range.startOffset) || "").trim();
          if (str.length && _Editor.FormulaChars.includes(str[str.length - 1])) {
            return true;
          }
        } else {
          console.info("mark 21", range);
        }
      }
      const text = this.SubstringToCaret2(this.active_editor.node)[1].trim();
      if (text.length) {
        const char = text[text.length - 1];
        return _Editor.FormulaChars.includes(char);
      }
    }
    return false;
  }
  /** internal. not sure why we have a shadow property. */
  composite_dependencies = [];
  /** accessor */
  get dependencies() {
    return this.composite_dependencies;
  }
  /** reference to model parser */
  parser;
  FocusEditor() {
    if (this.active_editor) {
      this.active_editor.node.focus();
    }
  }
  /**
   * add an event listener to the node. these are stored so we can remove
   * them later if the node is disconnected. 
   * 
   * listeners moved to node descriptors so we can have multiple sets.
   */
  RegisterListener(descriptor, key, handler) {
    descriptor.node.addEventListener(key, handler);
    if (!descriptor.listeners) {
      descriptor.listeners = /* @__PURE__ */ new Map();
    }
    descriptor.listeners.set(key, handler);
  }
  SelectAll(node) {
    const view = node.ownerDocument.defaultView;
    const selection = view.getSelection();
    const range = node.ownerDocument.createRange();
    range.selectNode(node);
    selection?.removeAllRanges();
    selection?.addRange(range);
  }
  SetCaret(start, end) {
    const doc = start.node.ownerDocument;
    const view = doc?.defaultView;
    const selection = view.getSelection();
    const range = doc?.createRange();
    const FirstTextNode = (node) => {
      let target = node;
      while (target && !(target instanceof view.Text) && !!target.firstChild) {
        target = target.firstChild;
      }
      return target;
    };
    const start_node = FirstTextNode(start.node);
    if (end) {
      const end_node = FirstTextNode(end.node);
      if (selection && range) {
        range.setStart(start_node, start.offset);
        range.setEnd(end_node, end.offset);
        selection.removeAllRanges();
        selection.addRange(range);
      }
    } else {
      if (selection && range) {
        range.setStart(start_node, start.offset);
        range.setEnd(start_node, start.offset);
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
      }
    }
  }
  /**
   * not sure what the ID was, we don't use it atm
   */
  InsertReference(reference, id) {
    if (!this.active_editor) {
      return;
    }
    const view = this.active_editor.node.ownerDocument.defaultView;
    const selection = view.getSelection();
    if (!selection) {
      throw new Error("error getting selection");
    }
    if (selection.rangeCount === 0) {
      return "";
    }
    let range = selection.getRangeAt(0);
    const text = this.active_editor.node.textContent || "";
    if (range.startContainer instanceof view.Text) {
      if (!range.collapsed && range.startOffset < range.endOffset) {
        const substrings = this.SubstringToCaret2(this.active_editor.node);
        this.active_editor.node.textContent = substrings[0] + reference + text.substring(substrings[1].length);
        this.SetCaret({
          node: this.active_editor.node,
          offset: substrings[0].length
        }, {
          node: this.active_editor.node,
          offset: substrings[0].length + reference.length
        });
      } else {
        const parent = range.startContainer.parentElement;
        if (parent instanceof view.HTMLElement && parent.dataset.reference) {
          parent.textContent = reference;
          this.SetCaret({
            node: parent,
            offset: reference.length
          });
        } else {
          const substring = this.SubstringToCaret2(this.active_editor.node)[1];
          let leader = "";
          let trailer = "";
          let trimmed = substring.trim();
          if (trimmed.length) {
            const char = trimmed[trimmed.length - 1];
            if (!_Editor.FormulaChars.includes(char)) {
              if (substring.length === trimmed.length) {
                leader = " +";
              } else {
                leader = "+";
              }
            }
          }
          this.active_editor.node.textContent = substring + leader + reference + text.substring(substring.length);
          this.SetCaret({
            node: this.active_editor.node,
            offset: substring.length + reference.length + leader.length
          });
        }
      }
    } else {
      if (range.startContainer instanceof view.HTMLElement) {
        range.startContainer.textContent = reference;
        this.SetCaret({
          node: range.startContainer,
          offset: reference.length
        });
      } else {
        console.warn("unexpected range start container", range.startContainer);
      }
    }
    this.UpdateText(this.active_editor);
    this.UpdateColors();
    this.active_editor.node.dispatchEvent(new Event("input", {
      bubbles: true,
      cancelable: true
    }));
  }
  /**
   * this method does three things:
   * 
   * (1) builds a flat list of references across all nodes
   * (2) applies colors to formatted references
   * (3) sends an event (if necessary, or forced)
   * 
   * that's fine, but it needs a new name.
   * 
   */
  UpdateColors(force_event = false) {
    const map = /* @__PURE__ */ new Map();
    const indexes = /* @__PURE__ */ new Map();
    for (const support of this.nodes) {
      for (const area of support.references || []) {
        const label = this.model.AddressToLabel(area);
        if (!map.has(label)) {
          map.set(label, area);
          indexes.set(label, indexes.size);
        }
      }
    }
    for (const entry of this.nodes) {
      for (const node of Array.from(entry.node.childNodes)) {
        const view = node.ownerDocument?.defaultView;
        if (view && node instanceof view.HTMLElement && node.dataset.reference) {
          const index = indexes.get(node.dataset.reference);
          node.dataset.highlightIndex = typeof index === "number" ? (index % 5 + 1).toString() : "?";
        }
      }
      entry.check = entry.node.innerHTML.length;
    }
    const list = Array.from(map.values());
    if (!force_event) {
      if (JSON.stringify(this.composite_dependencies) === JSON.stringify(list)) {
        return;
      }
    }
    this.composite_dependencies = list;
    this.Publish({ type: "update", dependencies: this.composite_dependencies });
  }
  /**
   * get a list of all references in the text (actually in the parse result, 
   * since we have that). stores the list in the node descriptor (and in 
   * the node dataset).
   * 
   * returns a list of the references in parse result mapped to normalized
   * address labels. those can be used to identify identical references when 
   * we highlight later.
   * 
   * @param parse_result 
   * @returns 
   */
  UpdateDependencies(descriptor, parse_result) {
    const reference_list = [];
    for (const unit of parse_result.full_reference_list || []) {
      switch (unit.type) {
        case "address":
        case "range": {
          const start = unit.type === "range" ? unit.start : unit;
          if (!start.sheet_id) {
            if (start.sheet) {
              start.sheet_id = this.model.sheets.Find(start.sheet)?.id || 0;
            } else {
              start.sheet_id = this.view.active_sheet.id;
            }
          }
          reference_list.push(unit);
          break;
        }
        case "structured-reference":
          if (this.target_address) {
            const reference = this.model.ResolveStructuredReference(unit, this.target_address);
            if (reference) {
              reference_list.push(reference);
            }
          } else {
            console.info("target address not set");
          }
          break;
        case "identifier": {
          const named_range = this.model.named_ranges.Get(unit.name);
          if (named_range) {
            if (named_range.count === 1) {
              reference_list.push({
                type: "address",
                ...named_range.start,
                label: unit.name,
                position: unit.position,
                id: unit.id
              });
            } else {
              reference_list.push({
                type: "range",
                start: {
                  type: "address",
                  position: unit.position,
                  id: unit.id,
                  label: unit.name,
                  ...named_range.start
                },
                end: {
                  type: "address",
                  position: unit.position,
                  label: unit.name,
                  id: unit.id,
                  ...named_range.end
                },
                label: unit.name,
                position: unit.position,
                id: unit.id
              });
            }
          }
          break;
        }
      }
    }
    reference_list.sort((a, b) => a.position - b.position);
    const references = [];
    const list = /* @__PURE__ */ new Set();
    const map = /* @__PURE__ */ new Map();
    for (const entry of reference_list) {
      const label = this.model.AddressToLabel(entry, this.view.active_sheet);
      const area = IsCellAddress(entry) ? new Area(entry) : new Area(entry.start, entry.end);
      if (!list.has(label)) {
        references.push(area);
        list.add(label);
      }
      map.set(entry, label);
    }
    this.UpdateReferences(descriptor, references);
    return map;
  }
  /**
   * store the set of references, and store in the node dataset for 
   * external clients.
   * 
   * @param descriptor 
   * @param references 
   * @param options 
   */
  UpdateReferences(descriptor, references = []) {
    descriptor.node.dataset.references = JSON.stringify(references.map((entry) => this.model.AddressToLabel(entry)));
    descriptor.references = references;
  }
  /**
   * reformat text to highlight, which involves tinkering with
   * node structure. we're probably doing this more than necessary;
   * we might consider editing the existing structure, rather than
   * throwing it away every time.
   * 
   */
  UpdateText(descriptor, options = {}) {
    const node = descriptor.node;
    const text = node.textContent || "";
    const DOM = DOMContext.GetInstance(node.ownerDocument);
    this.text_formula = text[0] === "=";
    if (this.active_editor && !this.assume_formula) {
      this.active_editor.node.spellcheck = !this.text_formula;
    }
    if (text === descriptor.formatted_text) {
      return;
    }
    const [substring_start, substring_end] = this.SubstringToCaret2(node);
    let caret_start = substring_start.length;
    let caret_end = substring_end.length;
    if (caret_start === 0 && caret_end === 0) {
      caret_end = text.length;
    }
    if (!text) {
      this.UpdateReferences(descriptor);
    } else {
      const parse_result = this.parser.Parse(text);
      if (parse_result.expression) {
        const normalized_labels = this.UpdateDependencies(descriptor, parse_result);
        const offset = text[0] === "=" ? 1 : 0;
        let start = 0;
        let selection_start;
        let selection_end;
        let text_index = 0;
        let last_text_node;
        const fragment = DOM.Fragment();
        const AddNode = (text2, type = "text", reference = "", force_selection = false) => {
          const text_node = DOM.Text(text2);
          if (force_selection || (caret_start > text_index || caret_start === 0 && text_index === 0) && caret_start <= text_index + text2.length) {
            selection_start = {
              offset: caret_start - text_index,
              node: text_node
            };
          }
          if (caret_end > text_index && caret_end <= text_index + text2.length) {
            selection_end = {
              offset: caret_end - text_index,
              node: text_node
            };
          }
          if (type !== "text") {
            const span = DOM.Create("span", type);
            if (reference) {
              span.dataset.reference = reference;
            }
            span.appendChild(text_node);
            fragment.appendChild(span);
          } else {
            fragment.appendChild(text_node);
          }
          last_text_node = text_node;
          text_index += text2.length;
        };
        this.parser.Walk(parse_result.expression, (unit) => {
          if (unit.type === "missing" || unit.type === "group" || unit.type === "dimensioned") {
            return true;
          }
          const pos = unit.position + offset;
          const part = text.substring(start, pos);
          let label = "";
          let type = unit.type;
          let reference = "";
          switch (unit.type) {
            case "identifier":
            case "call":
              label = text.substring(pos, pos + unit.name.length);
              break;
            case "literal":
              if (typeof unit.value === "string") {
                label = text.substring(pos, pos + unit.value.length + 2);
                type = "string";
              } else {
                return false;
              }
              break;
            case "address":
            case "range":
            case "structured-reference":
              reference = normalized_labels.get(unit) || "???";
              label = options.rewrite_addresses ? unit.label : text.substring(pos, pos + unit.label.length);
              break;
            default:
              return true;
          }
          AddNode(part);
          AddNode(label, type, reference);
          start = pos + label.length;
          return unit.type !== "range";
        });
        if (start < text.length) {
          AddNode(text.substring(start));
        }
        if (!selection_start) {
          if (last_text_node) {
            selection_start = {
              node: last_text_node,
              offset: (last_text_node.data || "").length
            };
          } else {
            AddNode("", void 0, "", true);
          }
        }
        node.textContent = "";
        node.appendChild(fragment);
        if (selection_start && !options.format_only && node === this.active_editor?.node) {
          this.SetCaret(selection_start, selection_end);
        }
      } else {
      }
    }
    descriptor.formatted_text = text;
    const matcher = this.autocomplete_matcher;
    if (matcher) {
      Promise.resolve().then(() => {
        const exec_result = matcher.Exec({ text, cursor: substring_end.length });
        const node2 = this.NodeAtIndex(exec_result.completions?.length ? exec_result.position || 0 : exec_result.function_position || 0);
        this.Autocomplete(exec_result, node2);
      });
    }
  }
  NodeAtIndex(index) {
    const children = this.active_editor?.node.childNodes || [];
    for (let i = 0; i < children.length; i++) {
      const len = children[i].textContent?.length || 0;
      if (len > index) {
        return children[i];
      }
      index -= len;
    }
    return void 0;
  }
  AcceptAutocomplete(ac_result) {
    if (!this.active_editor)
      return;
    let type = 0 /* Function */;
    if (ac_result.data && ac_result.data.completions) {
      for (const completion of ac_result.data.completions) {
        if (completion.name.toLowerCase() === ac_result.value?.toLowerCase()) {
          type = completion.type || 0 /* Function */;
          break;
        }
      }
    }
    const start = ac_result.data?.position || 0;
    const end = start + (ac_result.data?.token?.length || 0);
    const insertion = type === 1 /* Token */ ? ac_result.value : ac_result.value + "(";
    const text = this.active_editor.node.textContent || "";
    let adjusted = text.substring(0, start) + insertion;
    let caret = adjusted.length;
    adjusted += text.substring(end);
    this.active_editor.node.textContent = adjusted;
    this.SetCaret({ node: this.active_editor.node, offset: caret });
    this.autocomplete?.Hide();
    this.UpdateText(this.active_editor);
    this.UpdateColors();
  }
  /** called when there's AC data to display (or tooltip) */
  Autocomplete(data, target_node) {
    if (!this.container_node || !this.autocomplete) {
      return;
    }
    let client_rect;
    if (target_node?.nodeType === Node.ELEMENT_NODE) {
      client_rect = target_node.getBoundingClientRect();
    } else {
      client_rect = this.container_node.getBoundingClientRect();
    }
    const rect = new Rectangle(
      Math.round(client_rect.left),
      Math.round(client_rect.top),
      client_rect.width,
      client_rect.height
    );
    this.autocomplete.Show(this.AcceptAutocomplete.bind(this), data, rect);
  }
  /**
   * this version gets substrings to both selection points.
   * 
   * @param node 
   * @returns [substring to start of selection, substring to end of selection]
   */
  SubstringToCaret2(node) {
    const result = ["", ""];
    if (node !== node.ownerDocument.activeElement || node !== this.active_editor?.node) {
      return result;
    }
    const doc = node.ownerDocument;
    const view = doc.defaultView;
    let complete = [false, false];
    const Consume = (element, range) => {
      if (element === range.startContainer && element === range.endContainer && !(element instanceof view.Text)) {
        complete[0] = complete[1] = true;
        result[0] += element.textContent;
        result[1] += element.textContent;
        return;
      }
      if (element === range.startContainer) {
        result[0] += (element.textContent || "").substring(0, range.startOffset);
        complete[0] = true;
      }
      if (element === range.endContainer) {
        result[1] += (element.textContent || "").substring(0, range.endOffset);
        complete[1] = true;
      }
      if (complete[0] && complete[1]) {
        return;
      }
      if (element instanceof view.Text) {
        const text = element.textContent || "";
        if (!complete[0]) {
          result[0] += text;
        }
        if (!complete[1]) {
          result[1] += text;
        }
      } else if (element.hasChildNodes()) {
        for (const child of Array.from(element.childNodes)) {
          Consume(child, range);
          if (complete[0] && complete[1]) {
            return;
          }
        }
      }
    };
    const selection = view.getSelection();
    if (selection?.rangeCount ?? 0 > 0) {
      const range = selection?.getRangeAt(0);
      if (range) {
        Consume(node, range);
      }
    }
    return result;
  }
};

// treb-grid/src/util/ua.ts
var app_version = typeof navigator === "undefined" ? "" : navigator.appVersion;
var user_agent = typeof navigator === "undefined" ? "" : navigator.userAgent;
var UAType = class {
  /** we need this for some edge-specific weirdness */
  is_edge = /Edge/.test(app_version);
  /** more testing. ios safari doesn't support grid+sticky (apparently) */
  is_ipad = /iPad|iPhone/.test(user_agent);
  /** more testing. firefox android doesn't support grid+sticky (apparently) */
  is_android = /android|samsung/i.test(user_agent);
  /** mobile we want slightly different keyboard behavior */
  is_mobile = this.is_ipad || this.is_android;
  /** more testing. firefox android doesn't support grid+sticky (apparently) */
  is_firefox = /firefox/i.test(user_agent);
  /** ... */
  is_safari = /safari/i.test(user_agent) && !/edg/i.test(user_agent);
  /** ... */
  is_mac = /macintosh/i.test(user_agent);
  /** ... */
  is_chrome = /Chrome/i.test(user_agent);
  /* * this is for events (IE11 does't support event constructor) * /
  public trident = ((typeof navigator !== 'undefined') &&
    user_agent && /trident/i.test(user_agent));
  */
  /** ... */
  is_windows = /win64|win32|windows\s+nt/i.test(user_agent);
  // safari doesn't seem to hold the sticky elements in place. not
  // sure why not, though, need to do some more testing. legacy
  // renderer on safari has no scrollbars...
  // position: -webkit-sticky fixes the sticky issue, behavior seems
  // consistent with cr/ffx. also fixes on ios, but we lost the scrollbars.
  // blinking on safari handled with -webkit-tap-highlight-color: transparent;
  // but we still have no scrollbars. it may be that we never have them...
  /** temp only: need a more robust check */
  is_modern = !this.is_edge && // (!this.is_ipad) &&
  // (!this.is_mac || (this.is_chrome || this.is_firefox)) &&
  !(this.is_firefox && this.is_android) && /webkit|firefox/i.test(user_agent);
};
var null_ua = {
  is_edge: false,
  is_ipad: false,
  is_android: false,
  is_firefox: false,
  is_safari: false,
  is_mac: false,
  is_chrome: false,
  trident: false,
  is_windows: false,
  is_modern: true,
  is_node: true,
  is_mobile: false
};
var UA = typeof navigator === "undefined" ? null_ua : new UAType();

// treb-grid/src/editors/overlay_editor.ts
var OverlayEditor = class extends Editor {
  constructor(container, theme, model, view, autocomplete) {
    super(model, view, autocomplete);
    this.container = container;
    this.theme = theme;
    this.container_node = container.querySelector(".treb-overlay-container");
    this.edit_node = this.container_node.querySelector(".treb-overlay-editor");
    if (UA.is_firefox) {
      this.edit_node.classList.add("firefox");
    }
    this.edit_node.inputMode = "none";
    const descriptor = { node: this.edit_node };
    this.nodes = [descriptor];
    this.active_editor = descriptor;
    this.RegisterListener(descriptor, "input", (event) => {
      if (event instanceof InputEvent && event.isComposing) {
        return;
      }
      if (!event.isTrusted) {
        this.reset_selection = true;
        return;
      }
      if (this.reset_selection) {
        this.Publish({
          type: "reset-selection"
        });
      }
      const first_child = this.edit_node.firstChild;
      if (first_child && first_child.tagName === "BR") {
        this.edit_node.removeChild(first_child);
      }
      if (!this.editing) {
        return;
      }
      this.UpdateText(descriptor);
      this.UpdateColors();
    });
    this.RegisterListener(descriptor, "keyup", (event) => {
      if (event.isComposing || !this.editing) {
        return;
      }
      if (this.autocomplete && this.autocomplete.HandleKey("keyup", event).handled) {
        return;
      }
    });
    this.edit_inset = this.container_node.querySelector(".treb-overlay-inset");
    this.ClearContents();
  }
  // --- do we actually need this? ---------------------------------------------
  /**
   * selection being edited. note that this is private rather than protected
   * in an effort to prevent subclasses from accidentally using shallow copies
   */
  internal_selection = {
    target: { row: 0, column: 0 },
    area: new Area({ row: 0, column: 0 })
  };
  /** accessor for selection */
  get selection() {
    return this.internal_selection;
  }
  /** set selection, deep copy */
  set selection(rhs) {
    if (!rhs) {
      const zero = { row: 0, column: 0 };
      this.internal_selection = { target: zero, area: new Area(zero) };
    } else {
      const target = rhs.target || rhs.area.start;
      this.internal_selection = {
        target: { row: target.row, column: target.column },
        area: new Area(rhs.area.start, rhs.area.end)
      };
    }
  }
  // ---------------------------------------------------------------------------
  /**
   * this is a flag used to indicate when we need to reset the selection.
   * the issue has to do with selecting cells via arrow keys; if you do
   * that twice, the second time the selection starts on the cell you 
   * selected the first time. so we want to fix that.
   * 
   * I guess that used to work with an 'end-selection' event (although it
   * didn't change the sheet) but that doesn't happen anymore because 
   * selecting state is determined dynamically now.
   */
  reset_selection = false;
  /** we could use the descriptor reference */
  edit_node;
  /** narrowing from superclass */
  container_node;
  /** special node for ICE */
  edit_inset;
  scale = 1;
  // this should go into theme, since it tends to follow it
  /** shadow property */
  internal_editing = false;
  /** accessor */
  get editing() {
    return this.internal_editing;
  }
  /**
   * this is only set one time for each state, so it would be more
   * efficient to inline it unless that's going to change
   */
  set editing(state) {
    if (this.internal_editing !== state) {
      this.internal_editing = state;
      if (state) {
        this.container_node.style.opacity = "1";
        this.container_node.style.pointerEvents = "initial";
      } else {
        this.container_node.style.opacity = "0";
        this.container_node.style.pointerEvents = "none";
      }
    }
  }
  UpdateCaption(text = "") {
    this.edit_node.setAttribute("aria-label", text);
  }
  Focus(text = "") {
    if (this.edit_node !== this.edit_node.ownerDocument.activeElement) {
      this.container_node.style.top = `${this.container.scrollTop + this.view.active_sheet.header_offset.y}px`;
      this.container_node.style.left = `${this.container.scrollLeft + this.view.active_sheet.header_offset.x}px`;
    }
    this.edit_node.focus();
    this.UpdateCaption(text);
  }
  /* TEMP (should be Hide() ?) */
  CloseEditor() {
    this.editing = false;
    this.reset_selection = false;
    this.ClearContents();
    this.edit_node.spellcheck = true;
    this.autocomplete?.Hide();
    this.active_cell = void 0;
  }
  /**
   * remove contents, plus add mozilla junk node
   */
  ClearContents() {
    if (UA.is_firefox) {
      this.edit_node.innerHTML = "<span></span>";
    } else {
      this.edit_node.textContent = "";
    }
  }
  // ---------------------------------------------------------------------------
  /**
   * start editing. I'm not sure why we're passing the selection around, 
   * but I don't want to take it out until I can answer that question.
   * 
   * something to do with keyboard selection? (which needs to be fixed)?
   */
  Edit(gridselection, rect, cell, value, event) {
    this.Publish({
      type: "start-editing",
      editor: "ice"
    });
    this.active_cell = cell;
    this.target_address = { ...gridselection.target };
    this.reset_selection = false;
    const style = cell.style || {};
    this.edit_node.style.font = Style.Font(style, this.scale);
    this.edit_node.style.color = ThemeColor2(this.theme, style.text, 1);
    this.edit_inset.style.backgroundColor = ThemeColor2(this.theme, style.fill, 0);
    switch (style.horizontal_align) {
      case "right":
        this.container_node.classList.remove("align-center", "align-left");
        this.container_node.classList.add("align-right");
        break;
      case "center":
        this.container_node.classList.remove("align-right", "align-left");
        this.container_node.classList.add("align-center");
        break;
      default:
        this.container_node.classList.remove("align-right", "align-center");
        this.container_node.classList.add("align-left");
        break;
    }
    this.edit_node.style.paddingBottom = `${Math.max(0, (self.devicePixelRatio || 1) - 1)}px`;
    const value_string = value?.toString() || "";
    if (value_string && value_string[0] === "=") {
      this.edit_node.spellcheck = false;
    }
    rect.ApplyStyle(this.container_node);
    this.autocomplete?.ResetBlock();
    this.selection = gridselection;
    if (typeof value !== "undefined") {
      const percent = value_string[0] !== "=" && value_string[value_string.length - 1] === "%";
      const value_length = value_string.length;
      this.edit_node.textContent = value_string;
      this.SetCaret({ node: this.edit_node, offset: value_length - (percent ? 1 : 0) });
    }
    this.editing = true;
    Promise.resolve().then(() => {
      if (this.active_editor) {
        this.active_editor.formatted_text = void 0;
        this.UpdateText(this.active_editor);
        this.UpdateColors();
      }
      if (!event && value !== void 0) {
        this.Publish({ type: "update", text: value.toString(), dependencies: this.composite_dependencies });
      }
    });
  }
  /**
   * check if we want to handle this key. we have some special cases (tab, 
   * enter, escape) where we do take some action but we also let the 
   * spreadsheet handle the key. for those we have some additional return
   * values.
   * 
   * NOTE this is *not* added as an event handler -- it's called by the grid
   * 
   * @param event 
   * @returns 
   */
  HandleKeyDown(event) {
    if (!this.editing) {
      return void 0;
    }
    if (this.autocomplete) {
      const ac = this.autocomplete.HandleKey("keydown", event);
      if (ac.accept) {
        this.AcceptAutocomplete(ac);
      }
      if (ac.handled) {
        return "handled";
      }
    }
    switch (event.key) {
      case "Enter":
      case "Tab":
        return "commit";
      case "Escape":
      case "Esc":
        return "discard";
      case "ArrowUp":
      case "ArrowDown":
      case "ArrowLeft":
      case "ArrowRight":
      case "Up":
      case "Down":
      case "Left":
      case "Right":
        return this.selecting ? void 0 : "handled";
    }
    return "handled";
  }
  UpdateScale(scale) {
    this.scale = scale;
  }
};

// treb-grid/src/util/fontmetrics2.ts
var FontMetricsFactory = class {
  canvas;
  cache = {};
  // public base_size_px = 10;
  constructor() {
    if (typeof document !== "undefined") {
      this.canvas = document.createElement("canvas");
    }
  }
  /* *
   * set base font size. the idea here is to have a base in case font sizes 
   * are relative (% or em), they need to be relative to something. HOWEVER,
   * canvas doesn't inherit -- 
   * 
   * (moved to base_size_points)
   * 
   * /
  public BaseSize(size: string): void {
    this.canvas.style.fontSize = size || '';
  }
  */
  Flush() {
    this.cache = {};
  }
  Get(font, base = 10) {
    const key = font + ";" + base;
    let metrics = this.cache[key];
    if (metrics) {
      return metrics;
    }
    metrics = this.Measure(font, base);
    this.cache[key] = metrics;
    return metrics;
  }
  Measure(font, base) {
    const match = font.match(/([\d.]+)((?:%|em))/);
    if (match) {
      const target = match[1] + match[2];
      let value = Number(match[1]) * base;
      if (match[2] === "%") {
        value /= 100;
      }
      font = font.replace(target, value + "px");
    }
    let context = this.canvas.getContext("2d", {
      willReadFrequently: true
    });
    if (!context) {
      throw new Error("invalid context");
    }
    context.font = font;
    const metrics = context.measureText("MMM");
    const size = Math.ceil(metrics.width);
    this.canvas.setAttribute("width", size.toString());
    this.canvas.setAttribute("height", size.toString());
    context = this.canvas.getContext("2d", {
      willReadFrequently: true
    });
    if (!context) {
      throw new Error("invalid context");
    }
    context.font = font;
    context.textAlign = "center";
    context.textBaseline = "alphabetic";
    context.fillStyle = "#000";
    const y = Math.round(size * 2 / 3);
    const x = Math.round(size / 2);
    context.clearRect(0, 0, size, size);
    for (let i = 32; i <= 126; i++) {
      const s = String.fromCharCode(i);
      context.fillText(s, x, y);
    }
    const data = context.getImageData(0, 0, this.canvas.width, this.canvas.height).data;
    const top = Math.floor(this.GetFirstIndex(data) / size);
    const bottom = Math.floor(this.GetLastIndex(data) / size);
    return {
      ascender: y - top,
      descender: bottom - y,
      block: bottom - top + 1,
      paren: context.measureText("(").width,
      hash: context.measureText("##").width - context.measureText("#").width
    };
  }
  GetFirstIndex(pixels) {
    for (let i = 3, n = pixels.length; i < n; i += 4) {
      if (pixels[i] > 0)
        return (i - 3) / 4;
    }
    return pixels.length;
  }
  GetLastIndex(pixels) {
    for (let i = pixels.length - 1; i >= 3; i -= 4) {
      if (pixels[i] > 0)
        return i / 4;
    }
    return 0;
  }
};
var FontMetricsCache = new FontMetricsFactory();

// treb-grid/src/render/tile_renderer.ts
var BASELINE = "bottom";
var WK = /webkit/i.test(typeof navigator === "undefined" ? "" : navigator?.userAgent || "") ? 1 : 0;
var TileRenderer = class {
  constructor(theme, layout, model, view, options) {
    this.theme = theme;
    this.layout = layout;
    this.model = model;
    this.view = view;
    this.options = options;
    this.buffer_canvas = layout.buffer_canvas;
    this.buffer_canvas.width = this.buffer_canvas_size.width;
    this.buffer_canvas.height = this.buffer_canvas_size.height;
    const context = this.buffer_canvas.getContext("2d", { alpha: false });
    if (context) {
      const scale = this.layout.dpr;
      this.buffer_context = context;
      this.buffer_context.setTransform(scale, 0, 0, scale, 0, 0);
      this.buffer_context.textAlign = "left";
      this.buffer_context.textBaseline = BASELINE;
    }
  }
  // removing last_font because we are doing more complex
  // font manipulation for MD text
  // protected last_font?: string;
  cell_edge_buffer = 4;
  /**
   * a record of cell overflows, also used for merges if they cross tile
   * boundaries. on render, we check if an overflow(ed) cell is dirty; if
   * so, this forces update of dependent cells.
   */
  overflow_areas = [];
  buffer_canvas;
  buffer_context;
  buffer_canvas_size = { width: 256, height: 256 };
  /**
   * we manage overflow blocks to simplify (more or less) rendering,
   * but they break in the event of insert/delete row/column. we need 
   * to adjust, or perhaps flush, when we insert/delete columns.
   * 
   */
  FlushOverflows() {
    const cells = this.view.active_sheet.cells;
    cells.IterateAll((cell) => {
      if (cell.renderer_data?.overflowed) {
        cell.renderer_data = void 0;
        cell.render_clean[this.view.view_index] = false;
      }
    });
    for (const overflow_area of this.overflow_areas) {
      overflow_area.tile.dirty = true;
    }
    this.overflow_areas = [];
  }
  /**
   * use one of the tile contexts to measure text. we are using the tile
   * context because it's attached to the DOM, and style is applied. we need
   * that for the root font size, in case font size in the style is relative
   * (which it should be).
   * 
   * we could use the buffer context, if that were attached to the DOM, but
   * at the moment it is not so this is a shortcut. since we're not actually
   * painting, it's not too bad, but we still fetch the context every time.
   * hopefully it's cached.
   * 
   * FIXME: if you're doing it this way, maybe pass in an array of strings/
   * fonts, to avoid getting the context every time?
   * 
   * @param text 
   * @param font 
   */
  MeasureText(text, font) {
    const context = this.layout.grid_tiles[0][0].getContext("2d", { alpha: false });
    if (!context) {
      throw new Error("invalid context");
    }
    if (font) {
      context.font = font;
    }
    return context.measureText(text);
  }
  /**
   * when drawing to the buffered canvas, (1) ensure it's large enough,
   * and (2) set transform as necessary (we may be overflowing to the left).
   */
  EnsureBuffer(width = 0, height = 0, offset = 0) {
    const scale = this.layout.dpr;
    width = width * scale;
    height = height * scale;
    offset = offset * scale;
    if (width > this.buffer_canvas_size.width || height > this.buffer_canvas_size.height) {
      this.buffer_canvas_size.width = Math.max(Math.ceil(width / 256) * 256, this.buffer_canvas_size.width);
      this.buffer_canvas_size.height = Math.max(Math.ceil(height / 256) * 256, this.buffer_canvas_size.height);
      this.buffer_canvas.width = this.buffer_canvas_size.width;
      this.buffer_canvas.height = this.buffer_canvas_size.height;
      const context = this.buffer_canvas.getContext("2d", { alpha: false });
      if (context) {
        this.buffer_context = context;
        this.buffer_context.textAlign = "left";
        this.buffer_context.textBaseline = BASELINE;
      }
    }
    this.buffer_context.setTransform(scale, 0, 0, scale, offset, 0);
  }
  /**
   * check all overflow areas. if any elements are dirty, mark all elements
   * as dirty (FIXME: and remove the list?)
   */
  OverflowDirty(full_tile = false) {
    const mutated = [];
    for (const overflow of this.overflow_areas) {
      const row = overflow.area.start.row;
      let dirty = full_tile;
      if (!dirty) {
        for (let column = overflow.area.start.column; !dirty && column <= overflow.area.end.column; column++) {
          const cell = this.view.active_sheet.cells.GetCell({ row, column }, false);
          dirty = !!(cell && !cell.render_clean[this.view.view_index]);
        }
      }
      if (dirty) {
        for (let column = overflow.area.start.column; column <= overflow.area.end.column; column++) {
          const cell = this.view.active_sheet.cells.GetCell({ row, column }, false);
          if (cell) {
            cell.render_clean[this.view.view_index] = false;
            if (cell.renderer_data && cell.renderer_data.overflowed) {
              cell.renderer_data = void 0;
            }
          }
        }
        overflow.tile.dirty = true;
      } else
        mutated.push(overflow);
    }
    this.overflow_areas = mutated;
  }
  /**
   * 
   */
  RenderCorner() {
    const corner = this.layout.corner_canvas;
    const context = corner.getContext("2d", { alpha: false });
    if (!context) {
      throw new Error("invalid context");
    }
    const m2 = FontMetricsCache.Get(Style.Font(this.theme.headers || {}, this.layout.scale));
    const scale = this.layout.dpr;
    const header_size = this.layout.header_offset;
    let x = header_size.x;
    for (let i = 0; i < this.view.active_sheet.freeze.columns; i++) {
      x += this.layout.ColumnWidth(i);
    }
    let y = header_size.y;
    for (let i = 0; i < this.view.active_sheet.freeze.rows; i++) {
      y += this.layout.RowHeight(i);
    }
    context.setTransform(scale, 0, 0, scale, 0, 0);
    context.fillStyle = this.theme.headers?.fill ? ThemeColor2(this.theme, this.theme.headers.fill) : "";
    context.fillRect(0, 0, x, header_size.y);
    context.fillRect(0, 0, header_size.x, y);
    context.strokeStyle = this.theme.headers_grid_color || "";
    context.beginPath();
    context.moveTo(header_size.x - 0.5, 0);
    context.lineTo(header_size.x - 0.5, header_size.y);
    context.moveTo(0, header_size.y - 0.5);
    context.lineTo(header_size.x, header_size.y - 0.5);
    context.stroke();
    if (!this.view.active_sheet.freeze.columns && !this.view.active_sheet.freeze.rows)
      return;
    context.strokeStyle = this.theme.grid_color || "";
    context.beginPath();
    if (y !== header_size.y) {
      context.moveTo(header_size.x - 0.5, header_size.y);
      context.lineTo(header_size.x - 0.5, y);
    }
    if (x !== header_size.x) {
      context.moveTo(header_size.x, header_size.y - 0.5);
      context.lineTo(x, header_size.y - 0.5);
    }
    context.stroke();
    context.strokeStyle = this.theme.headers_grid_color || "";
    context.textAlign = "center";
    context.textBaseline = "middle";
    context.font = Style.Font(this.theme.headers || {}, this.layout.scale);
    context.fillStyle = ThemeColor2(this.theme, this.theme.headers?.text);
    if (this.view.active_sheet.freeze.rows && this.layout.header_offset.x > 1) {
      context.setTransform(scale, 0, 0, scale, 0, 0);
      context.translate(0, header_size.y);
      context.beginPath();
      context.moveTo(0, 0 - 0.5);
      context.lineTo(header_size.x, 0 - 0.5);
      context.stroke();
      this.RenderRowLabels(context, 0, this.view.active_sheet.freeze.rows - 1, m2.block);
    }
    if (this.view.active_sheet.freeze.columns && this.layout.header_offset.y > 1) {
      context.setTransform(scale, 0, 0, scale, 0, 0);
      context.translate(header_size.x, 0);
      context.beginPath();
      context.moveTo(0 - 0.5, 0);
      context.lineTo(0 - 0.5, header_size.y);
      context.stroke();
      this.RenderColumnLabels(context, 0, this.view.active_sheet.freeze.columns - 1);
    }
  }
  /**
   * unifying because headers and corner both render labels.
   * 
   * @param context 
   * @param column 
   * @param end 
   */
  RenderColumnLabels(context, column, end) {
    const header_y = this.layout.header_offset.y;
    if (header_y <= 1) {
      return;
    }
    context.fillStyle = ThemeColor2(this.theme, this.theme.headers?.text, 0);
    context.beginPath();
    for (; column <= end; column++) {
      const width = this.layout.ColumnWidth(column);
      const text = Area.ColumnToLabel(column);
      const metrics = context.measureText(text);
      if (width > metrics.width) {
        context.fillText(text, width / 2, header_y / 2 + 1);
      }
      context.moveTo(width - 0.5, 0);
      context.lineTo(width - 0.5, header_y);
      context.translate(width, 0);
    }
    context.stroke();
  }
  RenderRowLabels(context, row, end, block) {
    const header_x = this.layout.header_offset.x;
    if (header_x <= 1) {
      return;
    }
    context.fillStyle = ThemeColor2(this.theme, this.theme.headers?.text, 0);
    context.beginPath();
    for (; row <= end; row++) {
      const height = this.layout.RowHeight(row);
      if (height >= block * 1.2) {
        context.fillText(`${row + 1}`, header_x / 2, height / 2 + 1);
      }
      context.moveTo(0, height - 0.5);
      context.lineTo(header_x, height - 0.5);
      context.translate(0, height);
    }
    context.stroke();
  }
  /**
   */
  RenderHeaders(tiles, force = false) {
    const scale = this.layout.dpr;
    const header_size = this.layout.header_offset;
    const m2 = FontMetricsCache.Get(Style.Font(this.theme.headers || {}, this.layout.scale));
    for (let column = tiles.start.column; column <= tiles.end.column; column++) {
      const tile = this.layout.column_header_tiles[column];
      if (tile.dirty || force) {
        const context = tile.getContext("2d", { alpha: false });
        if (!context)
          continue;
        context.setTransform(scale, 0, 0, scale, 0, 0);
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.font = Style.Font(this.theme.headers || {}, this.layout.scale);
        context.fillStyle = this.theme.headers?.fill ? ThemeColor2(this.theme, this.theme.headers.fill) : "";
        context.fillRect(0, 0, tile.logical_size.width, this.layout.header_offset.y);
        context.strokeStyle = this.theme.headers_grid_color || "";
        context.beginPath();
        context.moveTo(0, header_size.y - 0.5);
        context.lineTo(tile.logical_size.width, header_size.y - 0.5);
        context.stroke();
        context.strokeStyle = this.theme.headers_grid_color || "";
        this.RenderColumnLabels(context, tile.first_cell.column, tile.last_cell.column);
        tile.dirty = false;
      }
    }
    for (let row = tiles.start.row; row <= tiles.end.row; row++) {
      const tile = this.layout.row_header_tiles[row];
      if (tile.dirty || force) {
        const context = tile.getContext("2d", { alpha: false });
        if (!context)
          continue;
        context.fillStyle = this.theme.headers?.fill ? ThemeColor2(this.theme, this.theme.headers.fill) : "";
        context.setTransform(scale, 0, 0, scale, 0, 0);
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.font = Style.Font(this.theme.headers || {}, this.layout.scale);
        context.fillRect(0, 0, this.layout.header_offset.x, tile.logical_size.height);
        context.strokeStyle = this.theme.headers_grid_color || "";
        context.beginPath();
        context.moveTo(header_size.x - 0.5, 0);
        context.lineTo(header_size.x - 0.5, tile.logical_size.height);
        context.stroke();
        context.strokeStyle = this.theme.headers_grid_color || "";
        this.RenderRowLabels(context, tile.first_cell.row, tile.last_cell.row, m2.block);
        tile.dirty = false;
      }
    }
    if (this.view.active_sheet.freeze.rows || this.view.active_sheet.freeze.columns) {
      this.RenderCorner();
    }
  }
  /**
   * 
   * @param tile starting tile
   * @param scale scale
   * @param dx tile offset, in tiles
   * @param dy tile offset, in tiles
   * @param left (original) translation, in scaled pixels
   * @param top (original) translation, in scaled pixels
   * @param result buffer info
   */
  CopyToAdjacent(tile, scale, dx, dy, left, top, result) {
    const adjacent = this.layout.AdjacentTile(tile, dy, dx);
    if (!adjacent)
      return;
    let x = left;
    let y = top;
    if (dx > 0) {
      x = left - (tile.pixel_end.x - tile.pixel_start.x) * scale;
    } else if (dx < 0) {
      x = left + (adjacent.pixel_end.x - adjacent.pixel_start.x) * scale;
    }
    if (dy > 0) {
      y = top - (tile.pixel_end.y - tile.pixel_start.y) * scale;
    }
    const context = adjacent.getContext("2d", { alpha: false });
    if (context) {
      context.setTransform(scale, 0, 0, scale, x, y);
      context.drawImage(
        this.buffer_canvas,
        0,
        0,
        (result.width || 0) * scale,
        (result.height || 0) * scale,
        result.left || 0,
        0,
        result.width || 0,
        result.height || 0
      );
    }
  }
  /** render a tile */
  Render(tile) {
    const context = tile.getContext("2d", { alpha: false });
    if (!context) {
      return;
    }
    context.textBaseline = BASELINE;
    const scale = this.layout.dpr;
    context.setTransform(scale, 0, 0, scale, 0, 0);
    let left = 0;
    let top = 0;
    for (let column = tile.first_cell.column; column <= tile.last_cell.column; column++) {
      const width = this.layout.ColumnWidth(column);
      if (!width)
        continue;
      top = 0;
      for (let row = tile.first_cell.row; row <= tile.last_cell.row; row++) {
        const height = this.layout.RowHeight(row);
        if (height) {
          context.setTransform(scale, 0, 0, scale, left, top);
          const cell = this.view.active_sheet.CellData({ row, column });
          if (tile.needs_full_repaint || !cell.render_clean[this.view.view_index]) {
            const result = this.RenderCell(
              tile,
              cell,
              context,
              { row, column },
              width,
              height,
              tile.pixel_start.x + left,
              tile.pixel_start.y + top
            );
            if (result.tile_overflow_right) {
              this.CopyToAdjacent(tile, scale, 1, 0, left, top, result);
            }
            if (result.tile_overflow_left) {
              this.CopyToAdjacent(tile, scale, -1, 0, left, top, result);
            }
            if (result.tile_overflow_bottom) {
              this.CopyToAdjacent(tile, scale, 0, 1, left, top, result);
            }
          }
        }
        top += height * scale;
      }
      left += width * scale;
    }
    if (!this.view.active_sheet.freeze.rows && !this.view.active_sheet.freeze.columns)
      return;
    let copy_height = 0;
    let copy_width = 0;
    if (tile.first_cell.row <= this.view.active_sheet.freeze.rows - 1) {
      for (let i = tile.first_cell.row; i < this.view.active_sheet.freeze.rows && i <= tile.last_cell.row; i++) {
        copy_height += this.layout.RowHeight(i);
      }
    }
    if (tile.first_cell.column <= this.view.active_sheet.freeze.columns - 1) {
      for (let i = tile.first_cell.column; i < this.view.active_sheet.freeze.columns && i <= tile.last_cell.column; i++) {
        copy_width += this.layout.ColumnWidth(i);
      }
    }
    if (copy_height) {
      const header = this.layout.frozen_row_tiles[tile.tile_position.column];
      if (!header)
        throw new Error("can't find matching header tile");
      const header_context = header.getContext("2d", { alpha: true });
      if (!header_context)
        throw new Error("header context failed");
      header_context.setTransform(scale, 0, 0, scale, 0, 0);
      header_context.drawImage(
        tile,
        0,
        0,
        tile.logical_size.width * scale,
        copy_height * scale,
        0,
        0,
        tile.logical_size.width,
        copy_height
      );
    }
    if (copy_width) {
      const header = this.layout.frozen_column_tiles[tile.tile_position.row];
      if (!header)
        throw new Error("can't find matching header tile");
      const header_context = header.getContext("2d", { alpha: true });
      if (!header_context)
        throw new Error("header context failed");
      header_context.setTransform(scale, 0, 0, scale, 0, 0);
      header_context.drawImage(
        tile,
        0,
        0,
        copy_width * scale,
        tile.logical_size.height * scale,
        0,
        0,
        copy_width,
        tile.logical_size.height
      );
    }
    if (copy_width && copy_height) {
      const corner_context = this.layout.corner_canvas.getContext("2d", { alpha: "false" });
      if (!corner_context)
        throw new Error("corner context failed");
      corner_context.setTransform(
        scale,
        0,
        0,
        scale,
        this.layout.header_offset.x * scale,
        this.layout.header_offset.y * scale
      );
      corner_context.drawImage(
        tile,
        0,
        0,
        copy_width * scale,
        copy_height * scale,
        0,
        0,
        copy_width,
        copy_height
      );
    }
    return;
  }
  /**
   * split and measure text. can be cached. there are actually two completely
   * separate operations here, which we're consolidating for convenience (and
   * because they never overlap).
   *
   * UPDATED returning a 2d array, where the first dimension represents lines
   * and the second dimension represents components
   */
  PrepText(context, fonts, cell, cell_width) {
    const strings = [];
    const style = cell.style || {};
    let pad_entry;
    let composite_width = 0;
    let override_formatting;
    let formatted = cell.editing ? "" : cell.formatted;
    if (Array.isArray(formatted)) {
      for (const part of formatted) {
        if (part.flag === 6 /* formatting */) {
          override_formatting = part.text;
          continue;
        }
        const mt_width = context.measureText(part.text).width;
        const render_part = {
          width: mt_width,
          text: part.text,
          hidden: part.flag === 1 /* hidden */
        };
        strings.push(render_part);
        if (part.flag === 2 /* padded */) {
          pad_entry = render_part;
        } else {
          composite_width += mt_width;
        }
      }
      if (pad_entry) {
        const text = pad_entry.text;
        const text_width = pad_entry.width;
        const balance = cell_width - composite_width - 2 * this.cell_edge_buffer;
        pad_entry.width = Math.max(0, balance);
        if (balance > 0) {
          const count = Math.floor(balance / text_width);
          for (let i = 1; i < count; i++) {
            pad_entry.text += text;
          }
          composite_width = cell_width - 2 * this.cell_edge_buffer;
        } else {
          pad_entry.text = "";
        }
      }
      return { strings: [strings], format: override_formatting, width: composite_width };
    } else if (formatted) {
      if (cell.type === 2 /* string */ && formatted[0] === "'") {
        formatted = formatted.slice(1);
      }
      let md;
      if (this.options.markdown) {
        md = MDParser.instance.Parse(formatted);
      } else {
        md = MDParser.instance.Dummy(formatted);
        context.font = fonts.base;
      }
      let max_width = 0;
      const bound = cell_width - 2 * this.cell_edge_buffer;
      const strings2 = [];
      if (style.wrap) {
        for (const line of md) {
          for (let i = 1; i < line.length; i++) {
            const test = line[i].text.match(/^(\s+)/);
            if (test) {
              line[i - 1].text += test[1];
              line[i].text = line[i].text.replace(/^\s+/, "");
            }
          }
          const words = [];
          for (const element of line) {
            if (this.options.markdown) {
              if (element.strong && element.emphasis) {
                context.font = fonts.strong_emphasis;
              } else if (element.strong) {
                context.font = fonts.strong;
              } else if (element.emphasis) {
                context.font = fonts.emphasis;
              } else {
                context.font = fonts.base;
              }
            }
            const split = element.text.match(/\S+\s*/g);
            if (split && split.length) {
              for (const word of split) {
                const trimmed = context.measureText(word.trim()).width;
                const width = context.measureText(word).width;
                words.push({ part: element, text: word, trimmed, width });
              }
            }
          }
          while (words.length) {
            let last = words.shift();
            const line2 = [last];
            let line_width = last.trimmed;
            while (line_width < bound && words.length) {
              const word = words[0];
              const test = line_width - last.trimmed + last.width + word.trimmed;
              if (test >= bound) {
                break;
              }
              last = word;
              line2.push(word);
              line_width = test;
              words.shift();
              max_width = Math.max(max_width, line_width);
            }
            last.text = last.text.trim();
            last.width = last.trimmed;
            max_width = Math.max(max_width, last.width);
            strings2.push(line2.map((metric) => {
              return {
                ...metric.part,
                hidden: false,
                width: metric.width,
                text: metric.text
              };
            }));
          }
        }
      } else {
        for (const line of md) {
          const parts = [];
          let line_width = 0;
          for (const element of line) {
            if (this.options.markdown) {
              if (element.strong && element.emphasis) {
                context.font = fonts.strong_emphasis;
              } else if (element.strong) {
                context.font = fonts.strong;
              } else if (element.emphasis) {
                context.font = fonts.emphasis;
              } else {
                context.font = fonts.base;
              }
            }
            const width = context.measureText(element.text).width;
            line_width += width;
            parts.push({
              ...element,
              hidden: false,
              width
            });
          }
          max_width = Math.max(max_width, line_width);
          strings2.push(parts);
        }
      }
      return { strings: strings2, width: max_width };
    }
    return {
      strings: [[{ text: "", hidden: false, width: 0 }]],
      width: 0
    };
  }
  ResolveColors(style) {
    const resolved = { ...style };
    resolved.text = { text: ThemeColor2(this.theme, style.text, 1) };
    return resolved;
  }
  RenderCellBorders(address, context, style, left = 0, top = 0, width = 0, height = 0) {
    const numpad = this.view.active_sheet.SurroundingStyle(address, this.theme.table);
    let color = ThemeColor2(this.theme, numpad[8].fill);
    if (color) {
      context.fillStyle = color;
      context.fillRect(left + 0, top - 1, width, 1);
    }
    color = ThemeColor2(this.theme, numpad[4].fill);
    if (color) {
      context.fillStyle = color;
      context.fillRect(left - 1, top, 1, height);
    }
    color = ThemeColor2(this.theme, style.fill);
    if (color) {
      context.fillStyle = color;
      context.fillRect(left - 1, top - 1, width + 1, height + 1);
    }
    color = ThemeColor2(this.theme, numpad[6].fill);
    if (color) {
      context.fillStyle = color;
      context.fillRect(left + width - 1, top - 1, 1, height + 1);
    }
    color = ThemeColor2(this.theme, numpad[2].fill);
    if (color) {
      context.fillStyle = color;
      context.fillRect(left - 1, top + height - 1, width + 1, 1);
    }
    if (numpad[6].border_top && !numpad[6].border_left) {
      context.fillStyle = ThemeColor2(this.theme, numpad[6].border_top_fill, 1);
      context.fillRect(left + width - 1, top - 2 + numpad[6].border_top, 1, 1);
    }
    if (numpad[9].border_left) {
      context.fillStyle = ThemeColor2(this.theme, numpad[9].border_left_fill, 1);
      context.fillRect(left + width - 1, top - 1, 1, 1);
    }
    if (numpad[9].border_bottom) {
      context.fillStyle = ThemeColor2(this.theme, numpad[9].border_bottom_fill, 1);
      context.fillRect(left + width - 1, top - 2 + numpad[9].border_bottom, 1, 1);
    }
    if (numpad[4].border_top && !numpad[4].border_right) {
      context.fillStyle = ThemeColor2(this.theme, numpad[4].border_right_fill, 1);
      context.fillRect(left - 1, top - 2 + numpad[4].border_top, 1, 1);
    }
    if (numpad[7].border_right) {
      context.fillStyle = ThemeColor2(this.theme, numpad[7].border_right_fill, 1);
      context.fillRect(left - 1, top - 1, 1, 1);
    }
    if (numpad[7].border_bottom) {
      context.fillStyle = ThemeColor2(this.theme, numpad[7].border_bottom_fill, 1);
      context.fillRect(left - 1, top - 2 + numpad[7].border_bottom, 1, 1);
    }
    if (numpad[6].border_bottom && !numpad[6].border_left) {
      context.fillStyle = ThemeColor2(this.theme, numpad[6].border_bottom_fill, 1);
      context.fillRect(left + width - 1, top + height - numpad[6].border_bottom, 1, 1);
    }
    if (numpad[3].border_left) {
      context.fillStyle = ThemeColor2(this.theme, numpad[3].border_left_fill, 1);
      context.fillRect(left + width - 1, top + height - 1, 1, 1);
    }
    if (numpad[3].border_top) {
      context.fillStyle = ThemeColor2(this.theme, numpad[3].border_top_fill, 1);
      context.fillRect(left + width - 1, top + height - numpad[3].border_top, 1, 1);
    }
    if (numpad[4].border_bottom && !numpad[4].border_right) {
      context.fillStyle = ThemeColor2(this.theme, numpad[4].border_bottom_fill, 1);
      context.fillRect(left - 1, top + height - numpad[4].border_bottom, 1, 1);
    }
    if (numpad[1].border_right) {
      context.fillStyle = ThemeColor2(this.theme, numpad[1].border_right_fill, 1);
      context.fillRect(left - 1, top + height - 1, 1, 1);
    }
    if (numpad[1].border_top) {
      context.fillStyle = ThemeColor2(this.theme, numpad[1].border_top_fill, 1);
      context.fillRect(left - 1, top + height - numpad[1].border_top, 1, 1);
    }
    if (numpad[8].border_bottom) {
      context.fillStyle = ThemeColor2(this.theme, numpad[8].border_bottom_fill, 1);
      if (numpad[8].border_bottom === 2) {
        context.fillRect(left - 1, top - 2, width + 1, 1);
        context.fillRect(left - 1, top - 0, width + 1, 1);
        context.fillStyle = ThemeColor2(this.theme, numpad[8].fill) || ThemeColor(this.theme, this.theme.grid_cell?.fill) || "#fff";
        context.fillRect(left - 1, top - 1, width + 1, 1);
      } else {
        context.fillRect(left - 1, top - 1, width + 1, 1);
      }
    }
    if (numpad[4].border_right) {
      context.fillStyle = ThemeColor2(this.theme, numpad[4].border_right_fill, 1);
      context.fillRect(left - 1, top - 1, 1, height + 1);
    }
    if (numpad[6].border_left) {
      context.fillStyle = ThemeColor2(this.theme, numpad[4].border_left_fill, 1);
      context.fillRect(left + width - 1, top - 1, 1, height + 1);
    }
    if (numpad[2].border_top) {
      context.fillStyle = ThemeColor2(this.theme, numpad[2].border_top_fill, 1);
      if (numpad[2].border_top === 2) {
        context.fillRect(left - 1, top + height - 2, width + 1, 1);
        context.fillRect(left - 1, top + height - 0, width + 1, 1);
        context.fillStyle = ThemeColor2(this.theme, numpad[2].fill) || ThemeColor(this.theme, this.theme.grid_cell?.fill) || "#fff";
        context.fillRect(left - 1, top + height - 1, width + 1, 1);
      } else {
        context.fillRect(left - 1, top + height - 1, width + 1, 1);
      }
    }
    if (style.border_top) {
      context.fillStyle = ThemeColor2(this.theme, style.border_top_fill, 1);
      if (style.border_top === 2) {
        context.fillRect(left - 1, top - 2, width + 1, 1);
        context.fillRect(left - 1, top + 0, width + 1, 1);
        context.fillStyle = ThemeColor2(this.theme, style.fill) || ThemeColor(this.theme, this.theme.grid_cell?.fill) || "#fff";
        context.fillRect(left - 1, top - 1, width + 1, 1);
      } else {
        context.fillRect(left - 1, top - 1, width + 1, 1);
      }
    }
    if (style.border_left) {
      context.fillStyle = ThemeColor2(this.theme, style.border_left_fill, 1);
      context.fillRect(left - 1, top - 1, 1, height + 1);
    }
    if (style.border_right) {
      context.fillStyle = ThemeColor2(this.theme, style.border_right_fill, 1);
      context.fillRect(left + width - 1, top - 1, 1, height + 1);
    }
    if (style.border_bottom) {
      context.fillStyle = ThemeColor2(this.theme, style.border_bottom_fill, 1);
      if (style.border_bottom === 2) {
        context.fillRect(left - 1, top + height - 2, width + 1, 1);
        context.fillRect(left - 1, top + height + 0, width + 1, 1);
        context.fillStyle = ThemeColor2(this.theme, style.fill) || ThemeColor(this.theme, this.theme.grid_cell?.fill) || "#fff";
        context.fillRect(left - 1, top + height - 1, width + 1, 1);
      } else {
        context.fillRect(left - 1, top + height - 1, width + 1, 1);
      }
    }
  }
  /**
   * paint background image, offset and tiled.
   */
  PaintBackgroundImage(context, image, left, top, width, height, render_left = 0, render_top = 0, offset = 0) {
    if (!image.width || !image.height) {
      return;
    }
    const scale = (this.layout.scale || 1) * this.layout.dpr;
    const source_left = left / scale % image.width;
    const source_top = top / scale % image.height;
    const source_width = width / scale;
    const source_height = height / scale;
    const roll_x = source_left + source_width > image.width;
    const roll_y = source_top + source_height > image.height;
    if (roll_x) {
      context.drawImage(
        image,
        source_left - image.width,
        source_top,
        source_width,
        source_height,
        render_left,
        render_top,
        width - offset,
        height - offset
      );
    }
    if (roll_y) {
      context.drawImage(
        image,
        source_left,
        source_top - image.height,
        source_width,
        source_height,
        render_left,
        render_top,
        width - offset,
        height - offset
      );
    }
    if (roll_x && roll_y) {
      context.drawImage(
        image,
        source_left - image.width,
        source_top - image.height,
        source_width,
        source_height,
        render_left,
        render_top,
        width - offset,
        height - offset
      );
    }
    context.drawImage(
      image,
      source_left,
      source_top,
      source_width,
      source_height,
      render_left,
      render_top,
      width - offset,
      height - offset
    );
  }
  RenderCellBackground(note, address, context, style, width, height, cell_left = 0, cell_top = 0) {
    context.fillStyle = this.theme.grid_color;
    context.fillRect(0, 0, width, height);
    if (this.view.active_sheet.image) {
      this.PaintBackgroundImage(
        context,
        this.view.active_sheet.image,
        cell_left,
        cell_top,
        width,
        height,
        0,
        0,
        1
      );
    } else {
      const fill = ThemeColor2(this.theme, style.fill);
      if (fill) {
        context.fillStyle = fill;
        context.fillRect(0, 0, width - 1, height - 1);
      } else {
        context.fillStyle = ThemeColor(this.theme, this.theme.grid_cell?.fill) || "#fff";
        context.fillRect(0, 0, width - 1, height - 1);
      }
    }
    this.RenderCellBorders(address, context, style, 0, 0, width, height);
    if (note) {
      const offset_x = 2;
      const offset_y = 1;
      const length = 8;
      context.fillStyle = this.theme.note_marker_color;
      context.beginPath();
      context.moveTo(width - offset_x, offset_y);
      context.lineTo(width - offset_x - length, offset_y);
      context.lineTo(width - offset_x, offset_y + length);
      context.lineTo(width - offset_x, offset_y);
      context.fill();
    }
  }
  /**
   * refactoring render to allow rendering to buffered canvas, in the
   * case of tile overflow. this is problematic because as the code stands
   * now, it paints before determining if there's an overflow. so we need
   * to move some paint calls around.
   */
  RenderCell(tile, cell, context, address, width, height, cell_left = 0, cell_top = 0) {
    const result = {};
    const dirty = !cell.render_clean[this.view.view_index];
    cell.render_clean[this.view.view_index] = true;
    if (tile.needs_full_repaint && cell.renderer_data?.overflowed) {
      return {};
    }
    let style = cell.style ? { ...cell.style } : {};
    if (cell.table) {
      style = this.view.active_sheet.CellStyleData(address, cell.table.theme || this.theme.table) || {};
    }
    if (cell.merge_area) {
      if (address.row === cell.merge_area.start.row && address.column === cell.merge_area.start.column) {
        for (let column = cell.merge_area.start.column + 1; column <= cell.merge_area.end.column; column++) {
          width += this.layout.ColumnWidth(column);
        }
        for (let row = cell.merge_area.start.row + 1; row <= cell.merge_area.end.row; row++) {
          height += this.layout.RowHeight(row);
        }
        if (cell.merge_area.count > 1) {
          const end_cell_style = this.view.active_sheet.CellStyleData(cell.merge_area.end);
          if (end_cell_style) {
            style.border_bottom = end_cell_style.border_bottom;
            style.border_right = end_cell_style.border_right;
            style.border_bottom_fill = end_cell_style.border_bottom_fill;
            style.border_right_fill = end_cell_style.border_right_fill;
          }
        }
        if (cell.merge_area.end.column > tile.last_cell.column) {
          result.tile_overflow_right = true;
        }
        if (cell.merge_area.end.row > tile.last_cell.row) {
          result.tile_overflow_bottom = true;
        }
        if (result.tile_overflow_bottom || result.tile_overflow_right) {
          this.overflow_areas.push({
            tile,
            head: { ...address },
            area: new Area(cell.merge_area.start, cell.merge_area.end)
          });
        }
      } else {
        return {};
      }
    }
    const preserve_layout_info = !!cell.hyperlink;
    if (cell.render_function) {
      this.RenderCellBackground(
        !!cell.note,
        address,
        context,
        style,
        width,
        height
      );
      context.strokeStyle = context.fillStyle = ThemeColor2(this.theme, style.text, 1);
      const apply_style = this.ResolveColors(style);
      const render_result = cell.render_function.call(void 0, {
        width,
        height,
        context,
        cell,
        style: apply_style,
        scale: this.layout.scale || 1
      });
      if (render_result.handled) {
        return result;
      }
    }
    const fonts = {
      base: Style.Font(style, this.layout.scale),
      strong: Style.Font({ ...style, bold: true }, this.layout.scale),
      emphasis: Style.Font({ ...style, italic: true }, this.layout.scale),
      strong_emphasis: Style.Font({ ...style, bold: true, italic: true }, this.layout.scale)
    };
    context.font = fonts.base;
    if (dirty || !cell.renderer_data || cell.renderer_data.width !== width || cell.renderer_data.height !== height) {
      const text_data2 = this.PrepText(context, fonts, cell, width);
      cell.renderer_data = {
        text_data: text_data2,
        width,
        height
      };
    }
    const text_data = cell.renderer_data.text_data;
    const overflow = text_data.width > width - 2 * this.cell_edge_buffer;
    let paint_right = width;
    let paint_left = 0;
    let clip = false;
    const is_number = cell.type === 3 /* number */ || cell.calculated_type === 3 /* number */ || cell.type === 7 /* complex */ || cell.calculated_type === 7 /* complex */ || cell.type === 9 /* dimensioned_quantity */ || cell.calculated_type === 9 /* dimensioned_quantity */;
    let horizontal_align = style.horizontal_align;
    if (!horizontal_align) {
      horizontal_align = is_number ? "right" : "left";
    }
    const overflow_backgrounds = [];
    if (overflow) {
      const can_overflow = cell.type !== 3 /* number */ && cell.calculated_type !== 3 /* number */ && !style.wrap && !cell.merge_area;
      if (can_overflow) {
        const delta = text_data.width - width + this.cell_edge_buffer;
        let overflow_pixels_left = 0;
        let overflow_pixels_right = 0;
        if (horizontal_align === "center") {
          overflow_pixels_left = overflow_pixels_right = delta / 2;
        } else if (horizontal_align === "right") {
          overflow_pixels_left = delta;
        } else {
          overflow_pixels_right = delta;
        }
        let overflow_right_column = address.column;
        let overflow_left_column = address.column;
        while (overflow_pixels_right > 0 && overflow_right_column < this.layout.last_column) {
          overflow_right_column++;
          const target_address = { row: address.row, column: overflow_right_column };
          const target_cell = this.view.active_sheet.CellData(target_address);
          const target_width = this.layout.ColumnWidth(overflow_right_column);
          overflow_pixels_right -= target_width;
          if (target_cell && !target_cell.type && !target_cell.calculated_type) {
            overflow_backgrounds.push({
              address: target_address,
              cell: target_cell,
              grid: new Rectangle(paint_right, 0, target_width, height),
              background: new Rectangle(paint_right - 1, 0, target_width, height - 1),
              border: new Rectangle(paint_right, 0, target_width, height)
            });
            paint_right += target_width;
            target_cell.render_clean[this.view.view_index] = true;
            target_cell.renderer_data = {
              overflowed: true
            };
          } else {
            clip = true;
            break;
          }
        }
        if (overflow_right_column > tile.last_cell.column) {
          result.tile_overflow_right = true;
        }
        while (overflow_pixels_left > 0 && overflow_left_column >= 1) {
          overflow_left_column--;
          const target_address = { row: address.row, column: overflow_left_column };
          const target_cell = this.view.active_sheet.CellData(target_address);
          const target_width = this.layout.ColumnWidth(overflow_left_column);
          overflow_pixels_left -= target_width;
          if (target_cell && !target_cell.type && !target_cell.calculated_type) {
            paint_left -= target_width;
            overflow_backgrounds.push({
              address: target_address,
              cell: target_cell,
              grid: new Rectangle(paint_left, 0, target_width, height),
              background: new Rectangle(paint_left, 0, target_width, height - 1),
              border: new Rectangle(paint_left, 0, target_width, height)
            });
          } else {
            clip = true;
            break;
          }
        }
        if (overflow_left_column < tile.first_cell.column) {
          result.tile_overflow_left = true;
        }
        this.overflow_areas.push({
          head: { ...address },
          tile,
          area: new Area(
            { row: address.row, column: overflow_left_column },
            { row: address.row, column: overflow_right_column }
          )
        });
      } else {
        clip = !is_number;
      }
    }
    let buffering = false;
    const original_context = context;
    if (result.tile_overflow_bottom || result.tile_overflow_left || result.tile_overflow_right) {
      buffering = true;
      result.width = paint_right - paint_left;
      result.height = height;
      result.left = paint_left;
      this.EnsureBuffer(result.width + 1, height + 1, -paint_left);
      context = this.buffer_context;
      context.font = fonts.base;
    }
    this.RenderCellBackground(!!cell.note, address, context, style, width, height, cell_left, cell_top);
    for (const element of overflow_backgrounds) {
      if (element.cell.style?.fill && (element.cell.style.fill.text || element.cell.style.fill.theme || element.cell.style.fill.theme === 0) && !this.options.grid_over_background) {
        context.fillStyle = ThemeColor(this.theme, element.cell.style.fill);
        context.fillRect(element.grid.left, element.grid.top, element.grid.width, element.grid.height);
      } else {
        context.fillStyle = this.theme.grid_color || "";
        context.fillRect(element.grid.left, element.grid.top, element.grid.width, element.grid.height);
        if (this.view.active_sheet.image) {
          this.PaintBackgroundImage(
            context,
            this.view.active_sheet.image,
            cell_left + element.background.left,
            cell_top + element.background.top,
            element.background.width,
            element.background.height,
            element.background.left,
            element.background.top,
            0
          );
        } else {
          context.fillStyle = this.theme.grid_cell?.fill ? ThemeColor(this.theme, this.theme.grid_cell.fill) : "";
          context.fillRect(
            element.background.left,
            element.background.top,
            element.background.width,
            element.background.height
          );
        }
      }
      if (element.cell.style) {
        this.RenderCellBorders(
          element.address,
          context,
          element.cell.style,
          element.border.left,
          element.border.top,
          element.border.width,
          element.border.height
        );
      }
    }
    const m2 = FontMetricsCache.Get(fonts.base, this.theme.grid_cell?.font_size?.value);
    context.lineWidth = 1;
    context.strokeStyle = context.fillStyle = text_data.format ? text_data.format : ThemeColor2(this.theme, style.text, 1);
    context.beginPath();
    let left = this.cell_edge_buffer;
    const line_height = 1.25;
    const line_count = text_data.strings.length;
    const text_height = line_count * m2.block * line_height;
    clip = (clip || text_height >= height) && !buffering;
    if (clip) {
      context.save();
      context.beginPath();
      context.moveTo(paint_left + 1.5, 0);
      context.lineTo(paint_left + 1.5, height);
      context.lineTo(paint_right - 1.5, height);
      context.lineTo(paint_right - 1.5, 0);
      context.clip();
    }
    context.beginPath();
    let original_baseline = Math.round(height - 2 - m2.block * line_height * (line_count - 1) + WK);
    switch (style.vertical_align) {
      case "top":
        original_baseline = Math.round(m2.block * line_height) + 1;
        break;
      case "middle":
        original_baseline = Math.round((height - text_height) / 2 + m2.block * line_height);
        break;
    }
    if ((cell.type === 3 /* number */ || cell.calculated_type === 3 /* number */ || cell.type === 7 /* complex */ || cell.calculated_type === 7 /* complex */) && overflow) {
      const count = Math.floor((width - 2 * this.cell_edge_buffer) / m2.hash);
      let text = "";
      for (let i = 0; i < count; i++) {
        text += "#";
      }
      const text_width = context.measureText(text).width;
      if (horizontal_align === "center") {
        left = Math.round((width - text_width) / 2);
      } else if (horizontal_align === "right") {
        left = width - this.cell_edge_buffer - text_width;
      }
      context.fillText(text, left, original_baseline);
    } else {
      let baseline = original_baseline;
      let index = 0;
      for (const line of text_data.strings) {
        let line_width = 0;
        for (const part of line) {
          line_width += part.width;
        }
        if (horizontal_align === "center") {
          left = Math.round((width - line_width) / 2);
        } else if (horizontal_align === "right") {
          left = width - this.cell_edge_buffer - line_width;
        }
        const underline_y = Math.floor(baseline + 1.5 - m2.descender - WK) + 0.5;
        const strike_y = Math.floor(baseline - m2.descender - m2.ascender / 2) + 0.5;
        let x = left;
        for (const part of line) {
          if (part.strong && part.emphasis) {
            context.font = fonts.strong_emphasis;
          } else if (part.strong) {
            context.font = fonts.strong;
          } else if (part.emphasis) {
            context.font = fonts.emphasis;
          } else {
            context.font = fonts.base;
          }
          if (!part.hidden) {
            if (part.text) {
              context.fillText(part.text, x, baseline);
            }
            if (style.underline) {
              context.moveTo(x, underline_y);
              context.lineTo(x + part.width, underline_y);
            }
            if (style.strike || part.strike) {
              context.moveTo(x, strike_y);
              context.lineTo(x + part.width, strike_y);
            }
            if (preserve_layout_info) {
              part.left = x;
              part.top = baseline - m2.block;
              part.height = m2.block;
            }
          }
          x += part.width;
        }
        index++;
        baseline = Math.round(original_baseline + index * m2.block * line_height);
      }
    }
    context.stroke();
    if (clip) {
      context.restore();
    } else if (buffering) {
      const scale = this.layout.dpr;
      original_context.drawImage(
        this.buffer_canvas,
        0,
        0,
        (result.width || 0) * scale,
        height * scale,
        paint_left,
        0,
        result.width || 0,
        height
      );
    }
    return result;
  }
};

// treb-grid/src/editors/formula_bar.ts
var FormulaBar = class extends Editor {
  constructor(container, model, view, options, autocomplete) {
    super(model, view, autocomplete);
    this.options = options;
    const DOM = DOMContext.GetInstance(container.ownerDocument);
    const inner_node = container.querySelector(".treb-formula-bar");
    inner_node.removeAttribute("hidden");
    this.address_label_container = inner_node.querySelector(".treb-address-label");
    this.address_label = this.address_label_container.firstElementChild;
    this.InitAddressLabel();
    if (this.options.insert_function_button) {
      this.button = DOM.Create("button", "formula-button", inner_node);
      this.button.addEventListener("click", () => {
        const formula = this.active_editor ? this.active_editor.node.textContent || "" : "";
        this.Publish({ type: "formula-button", formula });
      });
    }
    this.container_node = container.querySelector(".treb-editor-container");
    const target = this.container_node.firstElementChild;
    const descriptor = {
      node: target
    };
    this.active_editor = descriptor;
    this.nodes = [descriptor];
    if (target) {
      this.RegisterListener(descriptor, "input", (event) => {
        if (event.isTrusted) {
          this.UpdateText(descriptor);
          this.UpdateColors();
        }
      });
    }
    this.active_editor.node.spellcheck = false;
    this.RegisterListener(descriptor, "focusin", () => {
      if (!this.active_editor) {
        return;
      }
      let text = this.active_editor.node.textContent || "";
      if (text[0] === "{" && text[text.length - 1] === "}") {
        text = text.substring(1, text.length - 1);
        this.active_editor.node.textContent = text;
        this.active_editor.formatted_text = void 0;
      }
      this.autocomplete?.ResetBlock();
      this.UpdateText(this.active_editor);
      this.UpdateColors();
      this.Publish([
        { type: "start-editing", editor: "formula-bar" },
        { type: "update", text, cell: this.active_cell, dependencies: this.composite_dependencies }
      ]);
      this.focused_ = true;
    });
    this.RegisterListener(descriptor, "focusout", (event) => {
      if (this.selecting) {
        console.info("focusout, but selecting...");
      }
      this.autocomplete?.Hide();
      this.Publish([
        { type: "stop-editing" }
      ]);
      this.focused_ = false;
      if (this.active_editor) {
        this.active_editor.node.spellcheck = false;
      }
    });
    this.RegisterListener(descriptor, "keydown", this.FormulaKeyDown.bind(this));
    this.RegisterListener(descriptor, "keyup", this.FormulaKeyUp.bind(this));
    if (this.options.expand_formula_button) {
      this.expand_button = DOM.Create("button", "expand-button", inner_node, {
        events: {
          click: (event) => {
            event.stopPropagation();
            event.preventDefault();
            if (this.active_editor) {
              this.active_editor.node.scrollTop = 0;
            }
            if (inner_node.hasAttribute("expanded")) {
              inner_node.removeAttribute("expanded");
            } else {
              inner_node.setAttribute("expanded", "");
            }
          }
        }
      });
    }
  }
  /** is the _editor_ currently focused */
  // tslint:disable-next-line:variable-name
  focused_ = false;
  /** accessor for focused field */
  get focused() {
    return this.focused_;
  }
  /** address label (may also show other things... ?) */
  address_label_container;
  /** address label (may also show other things... ?) */
  address_label;
  /** the function button (optional?) */
  button;
  /** */
  expand_button;
  /* * corner for resizing formula editor * /
    private drag_corner!: HTMLDivElement; 
  
    / * * for math * /
    private lines = 1;
  
    private last_formula = '';
    */
  label_update_timer = 0;
  /** get formula text */
  get formula() {
    return this.active_editor ? this.active_editor.node.textContent || "" : "";
  }
  /** set formula text */
  set formula(text) {
    if (this.active_editor) {
      this.active_editor.node.textContent = text;
      this.active_editor.formatted_text = void 0;
    }
  }
  /** get address label text */
  get label() {
    return this.address_label?.textContent || "";
  }
  /**
   * set address label text. if the label is too long for the box,
   * add a title attribute for a tooltip.
   */
  set label(text) {
    if (!text.trim().length) {
      this.address_label.innerHTML = "&nbsp;";
      this.address_label.removeAttribute("title");
    } else {
      this.address_label.textContent = text;
      if (!this.label_update_timer) {
        this.label_update_timer = requestAnimationFrame(() => {
          this.label_update_timer = 0;
          if (this.address_label.scrollWidth > this.address_label.offsetWidth) {
            this.address_label.setAttribute("title", text);
          } else {
            this.address_label.removeAttribute("title");
          }
        });
      }
    }
  }
  /** toggle editable property: supports locked cells */
  set editable(editable) {
    if (!this.active_editor || !this.container_node)
      return;
    if (editable) {
      this.active_editor.node.setAttribute("contenteditable", "true");
      this.container_node.removeAttribute("locked");
    } else {
      this.active_editor.node.removeAttribute("contenteditable");
      this.container_node.setAttribute("locked", "");
    }
  }
  IsElement(element) {
    return element === this.active_editor?.node;
  }
  InitAddressLabel() {
    this.address_label.contentEditable = "true";
    this.address_label.spellcheck = false;
    this.address_label.addEventListener("focusin", (event) => {
      const doc = this.address_label.ownerDocument;
      requestAnimationFrame(() => {
        const selection = doc.defaultView.getSelection();
        const range = doc.createRange();
        range.selectNodeContents(this.address_label);
        selection?.removeAllRanges();
        selection?.addRange(range);
      });
    });
    this.address_label.addEventListener("keydown", (event) => {
      if (event.isComposing) {
        return;
      }
      switch (event.key) {
        case "Enter":
          event.stopPropagation();
          event.preventDefault();
          this.Publish({
            type: "address-label-event",
            text: this.address_label.textContent || void 0
          });
          break;
        case "Esc":
        case "Escape":
          event.stopPropagation();
          event.preventDefault();
          this.Publish({ type: "address-label-event" });
          break;
      }
    });
  }
  GetTextContent(node) {
    const children = node.childNodes;
    const buffer = [];
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      switch (child.nodeType) {
        case Node.ELEMENT_NODE:
          buffer.push(...this.GetTextContent(child));
          if (child instanceof Element && child.tagName === "DIV") {
            buffer.push("\n");
          }
          break;
        case Node.TEXT_NODE:
          if (child.nodeValue) {
            buffer.push(child.nodeValue);
          }
          break;
      }
    }
    return buffer;
  }
  FormulaKeyUp(event) {
    if (event.isComposing) {
      return;
    }
    if (this.autocomplete) {
      const ac_result = this.autocomplete.HandleKey("keyup", event);
      if (ac_result.handled) {
        return;
      }
    }
  }
  FormulaKeyDown(event) {
    if (event.isComposing) {
      return;
    }
    if (this.autocomplete) {
      const ac_result = this.autocomplete.HandleKey("keydown", event);
      if (ac_result.accept)
        this.AcceptAutocomplete(ac_result);
      if (ac_result.handled)
        return;
    }
    switch (event.key) {
      case "Enter":
      case "Tab":
        {
          const array = event.key === "Enter" && event.ctrlKey && event.shiftKey;
          const text = (this.active_editor ? this.GetTextContent(this.active_editor.node).join("") : "").trim();
          this.Publish({
            type: "commit",
            // selection: this.selection,
            value: text,
            event,
            array
          });
        }
        break;
      case "Escape":
      case "Esc":
        this.Publish({ type: "discard" });
        break;
      default:
        return;
    }
    event.stopPropagation();
    event.preventDefault();
  }
};

// treb-grid/src/editors/autocomplete.ts
var Autocomplete = class {
  constructor(options = {}) {
    this.options = options;
    this.DOM = DOMContext.GetInstance(options.container?.ownerDocument);
    if (!this.DOM.doc) {
      throw new Error("invalid context");
    }
    this.completion_list = this.DOM.Div(
      "treb-cell-editor-ac-list treb-autocomplete",
      options.container || this.DOM.doc.body,
      {
        events: {
          mousedown: (event) => this.ListMouseDown(event),
          mousemove: (event) => this.ListMouseMove(event)
        }
      }
    );
    this.tooltip = this.DOM.Div(
      "treb-cell-editor-ac-tooltip treb-autocomplete-tooltip",
      options.container || this.DOM.doc.body
    );
  }
  completion_list_visible = false;
  tooltip_visible = false;
  last_completion;
  completion_list;
  tooltip;
  selected_index = 0;
  block = false;
  autocomplete_data = {};
  callback;
  // ALTHOUGH we are dropping scope from _this_ node, it might be 
  // useful to add it to the containing node... something to think 
  // about
  // private scope: string;
  active_element;
  DOM;
  /*
    public UpdateTheme(): void {
      if (this.options.theme) {
  
        // FIXME: no longer sharing, don't need scoped styling anymore
  
        // FIXME: split?
  
        this.completion_list.style.fontFamily =
          this.tooltip.style.fontFamily = this.options.theme.cell_font ?
          this.options.theme.cell_font : '';
  
        const font_size = (this.options.theme.cell_font_size_value || 0) +
          (this.options.theme.cell_font_size_unit || 'pt');
  
        / *
        let font_size: string|null = null;
        if (typeof this.options.theme.cell_font_size === 'string') {
          font_size = this.options.theme.cell_font_size;
        }
        else if (typeof this.options.theme.cell_font_size === 'number') {
          font_size = this.options.theme.cell_font_size + 'pt';
        }
        * /
  
        this.completion_list.style.fontSize =
          this.tooltip.style.fontSize =
          font_size || '';
  
        / *
        this.stylesheet.textContent = `
  
        .treb-ac-list[${this.scope}] {
          background: ${this.options.theme.autocomplete_background};
        }
  
        .treb-ac-list[${this.scope}] ul li {
          color: ${this.options.theme.autocomplete_color};
        }
  
        .treb-ac-list[${this.scope}] ul li a:hover, .treb-ac-list[${this.scope}] ul li a.selected,
            .treb-ac-list[${this.scope}] ul:hover li a.selected:hover {
          color: ${this.options.theme.autocomplete_highlight_color};
          background: ${this.options.theme.autocomplete_highlight_background};
        }
  
        `.replace(/\s+/g, ' ').trim();
        * /
  
       this.stylesheet.textContent = css`
  
       .treb-ac-list[${this.scope}] {
         background: ${this.options.theme.autocomplete_background};
       }
  
       .treb-ac-list[${this.scope}] > ul > li {
         color: ${this.options.theme.autocomplete_color};
       }
  
       .treb-ac-list[${this.scope}] > ul > li > a.selected {
         color: ${this.options.theme.autocomplete_highlight_color};
         background: ${this.options.theme.autocomplete_highlight_background};
       }
  
       `; // this is not needed because the template compressor will remove whitespace // .replace(/\s+/g, ' ').trim();
       
      }
    }
    */
  Hide() {
    this.tooltip.style.top = "-1000px";
    this.completion_list.style.top = "-1000px";
    this.completion_list_visible = false;
    this.tooltip_visible = false;
    this.active_element = void 0;
  }
  SetBlock() {
    this.block = true;
  }
  ResetBlock() {
    this.block = false;
  }
  ListMouseMove(event) {
    const target = event.target;
    if (target.tagName === "A") {
      if (target !== this.active_element) {
        if (this.active_element) {
          this.active_element.classList.remove("selected");
          this.active_element = target;
          this.active_element.classList.add("selected");
          this.selected_index = Number(target.dataset.index || "0");
          this.last_completion = target.textContent || "";
        }
      }
    }
  }
  ListMouseDown(event) {
    event.stopPropagation();
    event.preventDefault();
    let target = event.target;
    while (target) {
      if (target === this.completion_list)
        return;
      if (target.tagName === "A")
        break;
      target = target.parentElement;
    }
    if (!target)
      return;
    console.info(target);
    if (this.callback) {
      this.callback({
        handled: true,
        accept: true,
        value: target.textContent ? target.textContent : void 0,
        data: this.autocomplete_data,
        click: true
      });
    }
  }
  HandleKey(event_type, event) {
    if (!this.completion_list_visible)
      return { handled: false };
    let delta = 0;
    let block = false;
    let accept = false;
    switch (event.key) {
      case "Up":
      case "ArrowUp":
        delta = -1;
        break;
      case "Down":
      case "ArrowDown":
        delta = 1;
        break;
      case "Tab":
        accept = true;
        break;
      case "Escape":
      case "Esc":
        block = true;
        break;
      default:
        return { handled: false };
    }
    event.stopPropagation();
    event.preventDefault();
    if (event_type === "keyup")
      return { handled: true };
    if (delta) {
      const list_rect = this.completion_list.getBoundingClientRect();
      this.selected_index += delta;
      this.selected_index = Math.max(0, this.selected_index);
      const children = this.completion_list.querySelectorAll("a");
      this.selected_index = Math.min(this.selected_index, children.length - 1);
      for (let index = 0; index < children.length; index++) {
        const child = children[index];
        if (index === this.selected_index) {
          child.classList.add("selected");
          this.active_element = child;
          const child_rect = child.getBoundingClientRect();
          if (child_rect.top < list_rect.top) {
            this.completion_list.scrollBy(0, -child_rect.height);
          } else if (child_rect.bottom > list_rect.bottom) {
            this.completion_list.scrollBy(0, child_rect.height);
          }
          this.last_completion = child.textContent || void 0;
        } else
          child.classList.remove("selected");
      }
      return { handled: true };
    } else if (block) {
      this.block = true;
      this.Hide();
      return { handled: true };
    } else if (accept) {
      return {
        handled: true,
        accept: true,
        value: this.last_completion,
        data: this.autocomplete_data
      };
    }
    return { handled: false };
  }
  Show(callback, data = {}, position) {
    this.completion_list_visible = false;
    this.tooltip_visible = false;
    this.autocomplete_data = data;
    this.callback = callback;
    if (this.block)
      return;
    if (data.tooltip) {
      this.tooltip.innerHTML = data.tooltip + data.arguments + (data.description ? "\n" + data.description : "");
      this.tooltip.style.left = position.left + "px";
      if (this.options.tooltip_prefer_top) {
        this.tooltip.style.top = position.top - this.tooltip.offsetHeight - 5 + "px";
      } else {
        this.tooltip.style.top = position.bottom + 5 + "px";
      }
      this.tooltip_visible = true;
    } else
      this.tooltip.style.top = "-1000px";
    if (data.completions && data.completions.length) {
      this.tooltip.style.top = "-1000px";
      this.selected_index = 0;
      this.completion_list.innerHTML = `<ul class="notranslate">` + data.completions.map((descriptor, index) => {
        if (descriptor.name === this.last_completion)
          this.selected_index = index;
        return `<li><a data-index="${index}">${descriptor.name}</a></li>`;
      }).join("\n") + `<ul>`;
      const height = this.completion_list.offsetHeight;
      let layout_top = false;
      if (this.options.autocomplete_prefer_top) {
        layout_top = position.top >= 200;
      } else {
        if (this.DOM.doc?.documentElement) {
          const viewport_height = Math.max(this.DOM.doc.documentElement.clientHeight, this.DOM.view?.innerHeight || 0);
          if (viewport_height - position.bottom < 200) {
            layout_top = true;
          }
        }
      }
      if (layout_top) {
        this.completion_list.style.top = position.top - height - 5 + "px";
      } else {
        this.completion_list.style.top = position.bottom + 5 + "px";
      }
      this.completion_list.style.left = position.left + "px";
      const children = this.completion_list.querySelectorAll("a");
      this.active_element = children[this.selected_index];
      children[this.selected_index].classList.add("selected");
      this.last_completion = children[this.selected_index].textContent || void 0;
      this.completion_list.scrollTop = this.active_element.offsetTop;
      this.completion_list_visible = true;
    } else
      this.completion_list.style.top = "-1000px";
  }
};

// treb-grid/src/types/grid_command.ts
var CommandKey = /* @__PURE__ */ ((CommandKey2) => {
  CommandKey2[CommandKey2["Null"] = 0] = "Null";
  CommandKey2[CommandKey2["InsertRows"] = 1] = "InsertRows";
  CommandKey2[CommandKey2["InsertColumns"] = 2] = "InsertColumns";
  CommandKey2[CommandKey2["ResizeRows"] = 3] = "ResizeRows";
  CommandKey2[CommandKey2["ResizeColumns"] = 4] = "ResizeColumns";
  CommandKey2[CommandKey2["Select"] = 5] = "Select";
  CommandKey2[CommandKey2["SetRange"] = 6] = "SetRange";
  CommandKey2[CommandKey2["UpdateStyle"] = 7] = "UpdateStyle";
  CommandKey2[CommandKey2["UpdateBorders"] = 8] = "UpdateBorders";
  CommandKey2[CommandKey2["MergeCells"] = 9] = "MergeCells";
  CommandKey2[CommandKey2["UnmergeCells"] = 10] = "UnmergeCells";
  CommandKey2[CommandKey2["Clear"] = 11] = "Clear";
  CommandKey2[CommandKey2["UpdateTheme"] = 12] = "UpdateTheme";
  CommandKey2[CommandKey2["SetNote"] = 13] = "SetNote";
  CommandKey2[CommandKey2["SetLink"] = 14] = "SetLink";
  CommandKey2[CommandKey2["Freeze"] = 15] = "Freeze";
  CommandKey2[CommandKey2["SetName"] = 16] = "SetName";
  CommandKey2[CommandKey2["ShowHeaders"] = 17] = "ShowHeaders";
  CommandKey2[CommandKey2["AddSheet"] = 18] = "AddSheet";
  CommandKey2[CommandKey2["DuplicateSheet"] = 19] = "DuplicateSheet";
  CommandKey2[CommandKey2["DeleteSheet"] = 20] = "DeleteSheet";
  CommandKey2[CommandKey2["ActivateSheet"] = 21] = "ActivateSheet";
  CommandKey2[CommandKey2["RenameSheet"] = 22] = "RenameSheet";
  CommandKey2[CommandKey2["ReorderSheet"] = 23] = "ReorderSheet";
  CommandKey2[CommandKey2["ShowSheet"] = 24] = "ShowSheet";
  CommandKey2[CommandKey2["DataValidation"] = 25] = "DataValidation";
  CommandKey2[CommandKey2["Reset"] = 26] = "Reset";
  CommandKey2[CommandKey2["SortTable"] = 27] = "SortTable";
  CommandKey2[CommandKey2["InsertTable"] = 28] = "InsertTable";
  CommandKey2[CommandKey2["RemoveTable"] = 29] = "RemoveTable";
  CommandKey2[CommandKey2["AddConditionalFormat"] = 30] = "AddConditionalFormat";
  CommandKey2[CommandKey2["RemoveConditionalFormat"] = 31] = "RemoveConditionalFormat";
  return CommandKey2;
})(CommandKey || {});

// treb-grid/src/types/grid_options.ts
var DefaultGridOptions = {
  scrollbars: true,
  in_cell_editor: true,
  formula_bar: true,
  add_tab: false,
  tab_bar: "auto",
  insert_function_button: false,
  expand_formula_button: false,
  expand: true,
  repaint_on_cell_change: true,
  grid_over_background: false
  // true,
};

// treb-grid/src/types/grid_base.ts
var AssertNever = (value) => {
  console.error("invalid case");
};
var GridBase = class {
  // --- public members --------------------------------------------------------
  /** events */
  grid_events = new EventSource();
  /** for recording */
  command_log = new EventSource();
  model;
  view;
  // --- public accessors ------------------------------------------------------
  get active_sheet() {
    return this.view.active_sheet;
  }
  set active_sheet(sheet) {
    this.view.active_sheet = sheet;
  }
  /** access the view index, if needed */
  get view_index() {
    return this.view.view_index;
  }
  // --- protected members -----------------------------------------------------
  batch = false;
  batch_events = [];
  /**
   * single instance of AC. editors (function bar, ICE) have references.
   * this is in base, instead of subclass, because we use it to check
   * for valid names.
   */
  autocomplete_matcher = new AutocompleteMatcher();
  /**
   * flags/state (used for some recordkeeping -- not super important)
   */
  flags = {};
  /** */
  options;
  /**
   * spreadsheet language parser. used to pull out address
   * references from functions, for highlighting
   * 
   * ...
   * 
   * it's used for lots of stuff now, in addition to highlighting.
   * copy/paste with translation; csv; defines; and some other stuff.
   * still would like to share w/ parent though, if possible.
   * 
   * 
   * FIXME: need a way to share/pass parser flags
   * UPDATE: sharing parser w/ owner (embedded sheet)
   */
  parser;
  // --- constructor -----------------------------------------------------------
  constructor(options = {}, model) {
    this.model = model;
    this.view = {
      active_sheet: this.model.sheets.list[0],
      view_index: this.model.view_count++
    };
    this.parser = model.parser;
    this.options = { ...DefaultGridOptions, ...options };
  }
  // --- API methods -----------------------------------------------------------
  RemoveConditionalFormat(options) {
    this.ExecCommand({
      key: 31 /* RemoveConditionalFormat */,
      ...options
    });
  }
  AddConditionalFormat(format) {
    this.ExecCommand({
      key: 30 /* AddConditionalFormat */,
      format
    });
  }
  /** remove a table. doesn't remove any data, just removes the overlay. */
  RemoveTable(table) {
    this.ExecCommand({
      key: 29 /* RemoveTable */,
      table
    });
  }
  /**
   * create a table in the given area. the area cannot contain any 
   * merge cells, arrays, or be part of another table. if you add a table
   * with a totals row, we don't insert a new row -- allocate enough space
   * when you create it.
   * 
   * @param area - the total area for the table, including headers and totals
   * @param totals - set true to include a totals row. tables have different
   * formatting and slightly different behavior when there's a totals row.
   */
  InsertTable(area, totals = true, sortable = void 0, theme) {
    if (!area.start.sheet_id) {
      area.start.sheet_id = this.active_sheet.id;
    }
    const sheet = this.FindSheet(area);
    for (let row = area.start.row; row <= area.end.row; row++) {
      for (let column = area.start.column; column <= area.end.column; column++) {
        const cell = sheet.cells.GetCell({ row, column }, false);
        if (cell && (cell.area || cell.merge_area || cell.table)) {
          this.Error(4 /* invalid_area_for_table */);
          return;
        }
      }
    }
    this.ExecCommand({
      key: 28 /* InsertTable */,
      area: JSON.parse(JSON.stringify(area)),
      totals,
      sortable,
      theme
    });
  }
  /**
   * activate sheet, by name or index number
   * @param sheet number (index into the array) or string (name)
   */
  ActivateSheet(sheet) {
    const index = typeof sheet === "number" ? sheet : void 0;
    const name = typeof sheet === "string" ? sheet : void 0;
    this.ExecCommand({
      key: 21 /* ActivateSheet */,
      index,
      name
    });
  }
  /**
   * activate sheet, by ID
   */
  ActivateSheetID(id) {
    this.ExecCommand({
      key: 21 /* ActivateSheet */,
      id
    });
  }
  /**
   * duplicate sheet by index or (omitting index) the current active sheet
   */
  DuplicateSheet(index, name, insert_before) {
    const command = {
      key: 19 /* DuplicateSheet */,
      new_name: name,
      insert_before
    };
    if (typeof index === "undefined") {
      command.id = this.active_sheet.id;
    } else {
      command.index = index;
    }
    this.ExecCommand(command);
  }
  AddSheet(name) {
    this.ExecCommand({
      key: 18 /* AddSheet */,
      name,
      show: true
    });
  }
  /**
   * delete sheet, by index or (omitting index) the current active sheet
   */
  DeleteSheet(index) {
    if (typeof index === "undefined") {
      if (!this.model.sheets.list.some((sheet, i) => {
        if (sheet === this.active_sheet) {
          index = i;
          return true;
        }
        return false;
      })) {
        throw new Error("invalid index");
      }
    }
    this.ExecCommand({
      key: 20 /* DeleteSheet */,
      index
    });
  }
  /** insert sheet at the given index (or current index) */
  InsertSheet(index, name) {
    if (typeof index === "undefined") {
      if (!this.model.sheets.list.some((sheet, i) => {
        if (sheet === this.active_sheet) {
          index = i + 1;
          return true;
        }
        return false;
      })) {
        throw new Error("invalid index");
      }
    }
    this.ExecCommand({
      key: 18 /* AddSheet */,
      insert_index: index,
      name,
      show: true
    });
  }
  DeleteSheetID(id) {
    this.ExecCommand({
      key: 20 /* DeleteSheet */,
      id
    });
  }
  /**
   * clear sheet, reset all data
   */
  Reset() {
    this.ExecCommand({ key: 26 /* Reset */ });
  }
  /**
   * set hyperlink, like set note
   */
  SetLink(address, reference) {
    this.ExecCommand({
      key: 14 /* SetLink */,
      area: address,
      reference
    });
  }
  ShowAll() {
    const commands = [];
    for (let index = 0; index < this.model.sheets.length; index++) {
      commands.push({
        key: 24 /* ShowSheet */,
        index,
        show: true
      });
    }
    this.ExecCommand(commands);
  }
  ShowSheet(index = 0, show = true) {
    const command = {
      key: 24 /* ShowSheet */,
      show
    };
    if (typeof index === "string") {
      command.name = index;
    } else {
      command.index = index;
    }
    this.ExecCommand(command);
  }
  /**
   * sort table. column is absolute.
   */
  SortTable(table, options = {}) {
    this.ExecCommand({
      key: 27 /* SortTable */,
      table: JSON.parse(JSON.stringify(table)),
      ...DefaultTableSortOptions,
      ...options
    });
  }
  /** return freeze area */
  GetFreeze() {
    return { ...this.active_sheet.freeze };
  }
  /**
   * insert rows(s) at some specific point
   */
  InsertRows(before_row = 0, count = 1) {
    this.ExecCommand({
      key: 1 /* InsertRows */,
      before_row,
      count
    });
  }
  /**
   * return the table (if any) at the given address
   */
  GetTableReference(address) {
    const sheet = this.model.sheets.Find(address.sheet_id || this.active_sheet.id);
    return sheet?.CellData(address).table || void 0;
  }
  /**
   * reset sheet, set data from CSV
   *
   * FIXME: this is problematic, because it runs around the exec command
   * system. however it doesn't seem like a good candidate for a separate
   * command. it should maybe move to the import class? (...)
   *
   * one problem with that is that import is really, really heavy (jszip).
   * it seems wasteful to require all that just to import csv.
   */
  FromCSV(text) {
    const toggle_separator = this.parser.decimal_mark === "," /* Comma */;
    if (toggle_separator) {
      this.parser.argument_separator = "," /* Comma */;
      this.parser.decimal_mark = "." /* Period */;
    }
    const records = ParseCSV(text);
    const arr = records.map((record) => record.map((field) => {
      if (field) {
        const tmp = this.parser.Parse(field);
        if (tmp.expression?.type === "complex") {
          return tmp.expression;
        }
      }
      return ValueParser.TryParse(field).value;
    }));
    if (toggle_separator) {
      this.parser.argument_separator = ";" /* Semicolon */;
      this.parser.decimal_mark = "," /* Comma */;
    }
    const end = {
      row: Math.max(0, arr.length - 1),
      column: arr.reduce((max, row) => Math.max(max, Math.max(0, row.length - 1)), 0)
    };
    this.ExecCommand([
      { key: 26 /* Reset */ },
      {
        key: 6 /* SetRange */,
        area: { start: { row: 0, column: 0 }, end },
        value: arr
      }
      // we took this out because the data may require a layout update
      // (rebuilding tiles); in that case, this will be duplicative. maybe
      // should use setTimeout or some sort of queue...
      // { key: CommandKey.ResizeColumns }, // auto
    ]);
  }
  /**
   * insert column(s) at some specific point
   */
  InsertColumns(before_column = 0, count = 1) {
    this.ExecCommand({
      key: 2 /* InsertColumns */,
      before_column,
      count
    });
  }
  /** move sheet (X) before sheet (Y) */
  ReorderSheet(index, move_before) {
    this.ExecCommand({
      key: 23 /* ReorderSheet */,
      index,
      move_before
    });
  }
  /**
   * rename active sheet
   */
  RenameSheet(sheet, name) {
    this.ExecCommand({
      key: 22 /* RenameSheet */,
      new_name: name,
      id: sheet.id
    });
  }
  /**
   * freeze rows or columns. set to 0 (or call with no arguments) to un-freeze.
   *
   * highglight is shown by default, but we can hide it(mostly for document load)
   */
  Freeze(rows = 0, columns = 0, highlight_transition = true) {
    this.ExecCommand({
      key: 15 /* Freeze */,
      rows,
      columns,
      highlight_transition
    });
  }
  /**
   * API method
   */
  SetRowHeight(row, height, shrink = true) {
    this.ExecCommand({
      key: 3 /* ResizeRows */,
      row,
      height,
      shrink
    });
  }
  /**
   * API method
   *
   * @param column column, columns, or undefined means all columns
   * @param width target width, or undefined means auto-size
   */
  SetColumnWidth(column, width = 0) {
    this.ExecCommand({
      key: 4 /* ResizeColumns */,
      column,
      width
    });
  }
  /**
   * filter table. what this means is "show the rows that match the filter
   * and hide the other rows". it doesn't actually change data, but it does
   * show/hide rows which (now) has some data effects.
   * 
   * note that we don't pass the filter command through the command queue.
   * it uses a callback, so that would not work. rather we filter first,
   * then send hide/show row commands through the command queue. that will
   * propagate updates.
   */
  FilterTable(table, column, filter) {
    const command = [];
    if (!table.area.start.sheet_id) {
      throw new Error("invalid table area");
    }
    const sheet = this.model.sheets.Find(table.area.start.sheet_id);
    if (!sheet) {
      throw new Error("invalid table sheet");
    }
    const show_rows = [];
    const hide_rows = [];
    const end = table.totals_row ? table.area.end.row - 1 : table.area.end.row;
    column += table.area.start.column;
    for (let row = table.area.start.row + 1; row <= end; row++) {
      const cell = sheet.CellData({ row, column });
      const show = filter(cell);
      const current = sheet.GetRowHeight(row);
      if (show && !current) {
        show_rows.push(row);
      } else if (!show && current) {
        hide_rows.push(row);
      }
    }
    if (show_rows) {
      command.push({
        key: 3 /* ResizeRows */,
        sheet_id: sheet.id,
        row: show_rows,
        height: sheet.default_row_height
      });
    }
    if (hide_rows) {
      command.push({
        key: 3 /* ResizeRows */,
        sheet_id: sheet.id,
        row: hide_rows,
        height: 0
      });
    }
    if (command.length) {
      this.ExecCommand(command);
    }
  }
  /**
   * UpdateSheets means "set these as the sheets, drop any old stuff". there's 
   * an implicit reset (in fact we may do that twice in some cases).
   *
   * this is non-UI; specialization should handle the UI part
   */
  UpdateSheets(data, render = false, activate_sheet) {
    Sheet.Reset();
    const sheets = data.map((sheet) => Sheet.FromJSON(sheet, this.model.theme_style_properties));
    if (sheets.length === 0) {
      sheets.push(Sheet.Blank(this.model.theme_style_properties));
    }
    this.model.sheets.Assign(sheets);
    this.ResetMetadata();
    this.active_sheet = sheets[0];
    if (activate_sheet) {
      const sheet = this.model.sheets.Find(activate_sheet);
      if (sheet) {
        this.active_sheet = sheet;
      }
    }
  }
  /**
   * set functions for AC matcher. should be called by calculator on init,
   * or when any functions are added/removed.
   *
   * FIXME: we should use this to normalize function names, on insert and
   * on paste (if we're doing that).
   * 
   * FIXME: are named expressions included here? (this function predates
   * named expressions).
   * 
   * 
   * this moved to grid base because we use the list to check for conflicts
   * when setting names. 
   * 
   */
  SetAutocompleteFunctions(functions) {
    const expressions = [];
    for (const name of this.model.named_expressions.keys()) {
      expressions.push({
        name,
        type: 0 /* Function */
      });
    }
    const consolidated = functions.slice(0).concat(
      this.model.named_ranges.List().map((named_range) => {
        return { name: named_range.name, type: 1 /* Token */ };
      }),
      expressions
    );
    this.autocomplete_matcher.SetFunctions(consolidated);
  }
  ResetMetadata() {
    this.model.document_name = void 0;
    this.model.user_data = void 0;
  }
  /**
   * serialize data. this function used to (optionally) stringify
   * by typescript has a problem figuring this out, so we will simplify
   * the function.
   */
  Serialize(options = {}) {
    const sheet_data = this.model.sheets.list.map((sheet) => sheet.toJSON(options));
    let tables;
    if (this.model.tables.size > 0) {
      tables = Array.from(this.model.tables.values());
    }
    let macro_functions;
    if (this.model.macro_functions.size) {
      macro_functions = [];
      for (const macro of this.model.macro_functions.values()) {
        macro_functions.push({
          ...macro,
          expression: void 0
        });
      }
    }
    const named_expressions = [];
    if (this.model.named_expressions) {
      for (const [name, expr] of this.model.named_expressions) {
        this.parser.Walk(expr, (unit) => {
          if (unit.type === "address" || unit.type === "range") {
            const test = unit.type === "range" ? unit.start : unit;
            test.absolute_column = test.absolute_row = true;
            if (!test.sheet) {
              if (test.sheet_id) {
                const sheet = this.model.sheets.Find(test.sheet_id);
                if (sheet) {
                  test.sheet = sheet.name;
                }
              }
              if (!test.sheet) {
                test.sheet = this.active_sheet.name;
              }
            }
            if (unit.type === "range") {
              unit.end.absolute_column = unit.end.absolute_row = true;
            }
            return false;
          }
          return true;
        });
        const rendered = this.parser.Render(expr, { missing: "" });
        named_expressions.push({
          name,
          expression: rendered
        });
      }
    }
    return {
      sheet_data,
      active_sheet: this.active_sheet.id,
      named_ranges: this.model.named_ranges.Count() ? this.model.named_ranges.Serialize() : void 0,
      macro_functions,
      tables,
      named_expressions: named_expressions.length ? named_expressions : void 0
    };
  }
  // --- protected methods -----------------------------------------------------
  /**
   * see ResizeRowsInternal
   */
  ResizeColumnsInternal(command) {
    const sheet = command.sheet_id ? this.FindSheet(command.sheet_id) : this.active_sheet;
    let column = command.column;
    if (typeof column === "undefined") {
      column = [];
      for (let i = 0; i < sheet.columns; i++)
        column.push(i);
    }
    if (typeof column === "number")
      column = [column];
    if (command.width) {
      for (const entry of column) {
        sheet.SetColumnWidth(entry, command.width);
      }
    } else {
      console.error("auto size not supported");
    }
  }
  /**
   * resize rows. this supports auto size, but that will fail in !ui grid,
   * because it uses HTML. also non-ui doesn't really need to worry about 
   * scale... we should split.
   */
  ResizeRowsInternal(command) {
    const sheet = command.sheet_id ? this.FindSheet(command.sheet_id) : this.active_sheet;
    let row = command.row;
    if (typeof row === "undefined") {
      row = [];
      for (let i = 0; i < sheet.rows; i++)
        row.push(i);
    }
    if (typeof row === "number")
      row = [row];
    if (command.height) {
      for (const entry of row) {
        sheet.SetRowHeight(entry, command.height);
      }
    } else {
      console.error("auto size not supported");
    }
    return void 0;
  }
  ResetInternal() {
    Sheet.Reset();
    this.UpdateSheets([], true);
    this.model.named_ranges.Reset();
    this.model.named_expressions.clear();
    this.model.macro_functions.clear();
    this.model.tables.clear();
  }
  /**
   * check if we can paste into the target area(s). this will
   * return false if the areas contain locked cells, or part of
   * an array or merge but not the whole array or merge.
   * 
   * @param areas 
   * @returns 
   */
  ValidatePasteAreas(areas) {
    for (const area of areas) {
      let sheet = this.active_sheet;
      if (area.start.sheet_id && area.start.sheet_id !== sheet.id) {
        sheet = this.model.sheets.Find(area.start.sheet_id);
      }
      if (!sheet) {
        return false;
      }
      let valid = true;
      sheet.cells.Apply2(area, (cell) => {
        if (cell.style?.locked) {
          console.info("invalid: locked cells");
          valid = false;
        }
        if (cell.merge_area) {
          if (!area.Contains(cell.merge_area.start) || !area.Contains(cell.merge_area.end)) {
            console.info("invalid: merge area");
            valid = false;
          }
        }
        if (cell.area) {
          if (!area.Contains(cell.area.start) || !area.Contains(cell.area.end)) {
            console.info("invalid: array");
            valid = false;
          }
        }
        return valid;
      });
      if (!valid) {
        return false;
      }
    }
    return true;
  }
  SetValidationInternal(command) {
    let cell;
    const sheet = this.FindSheet(command.area);
    if (sheet) {
      cell = sheet.cells.GetCell(command.area, true);
    }
    if (!cell) {
      throw new Error("invalid cell in set validation");
    }
    if (command.range) {
      cell.validation = {
        type: "range" /* Range */,
        area: command.range,
        error: !!command.error
      };
    } else if (command.list) {
      cell.validation = {
        type: "list" /* List */,
        list: JSON.parse(JSON.stringify(command.list)),
        error: !!command.error
      };
    } else {
      cell.validation = void 0;
    }
  }
  /**
   * get values from a range of data
   * @param area 
   */
  GetValidationRange(area) {
    let list;
    const sheet = this.FindSheet(area);
    if (sheet) {
      list = [];
      area = sheet.RealArea(new Area(area.start, area.end), true);
      for (let row = area.start.row; row <= area.end.row; row++) {
        for (let column = area.start.column; column <= area.end.column; column++) {
          const cell = sheet.CellData({ row, column });
          if (cell && cell.formatted) {
            if (typeof cell.formatted === "string") {
              list.push(cell.formatted);
            } else {
              list.push(NumberFormat.FormatPartsAsText(cell.formatted));
            }
          }
        }
      }
    }
    return list;
  }
  /**
   * @returns true if we need a recalc, because references have broken.
   */
  DeleteSheetInternal(command) {
    let is_active = false;
    let index = -1;
    let target_name = "";
    let requires_recalc = false;
    const named_sheet = command.name ? command.name.toLowerCase() : "";
    const sheets = this.model.sheets.list.filter((sheet, i) => {
      if (i === command.index || sheet.id === command.id || sheet.name.toLowerCase() === named_sheet) {
        is_active = sheet === this.active_sheet;
        this.model.named_ranges.RemoveRangesForSheet(sheet.id);
        target_name = sheet.name;
        index = i;
        return false;
      }
      return true;
    });
    if (target_name) {
      const count = this.RenameSheetReferences(sheets, target_name, "#REF");
      if (count > 0) {
        requires_recalc = true;
      }
    }
    if (!sheets.length) {
      sheets.push(Sheet.Blank(this.model.theme_style_properties));
      index = 0;
    } else if (sheets.every((test) => !test.visible)) {
      sheets.unshift(Sheet.Blank(this.model.theme_style_properties));
      index = 0;
    } else {
      if (index >= sheets.length) {
        index = 0;
      }
      while (!sheets[index].visible) {
        index++;
      }
    }
    this.model.sheets.Assign(sheets);
    if (is_active) {
      this.ActivateSheetInternal({ key: 21 /* ActivateSheet */, index });
    }
    return requires_recalc;
  }
  /**
   * rename a sheet. this requires changing any formulae that refer to the
   * old name to refer to the new name. if there are any references by ID
   * those don't have to change.
   *
   * FIXME: can we do this using the dependency graph? (...)
   */
  RenameSheetInternal(target, name) {
    if (!name || IllegalSheetNameRegex.test(name)) {
      throw new Error("invalid sheet name");
    }
    const compare = name.toLowerCase();
    for (const sheet of this.model.sheets.list) {
      if (sheet !== target && sheet.name.toLowerCase() === compare) {
        throw new Error("sheet name already exists");
      }
    }
    const old_name = target.name;
    target.name = name;
    this.model.sheets.Assign(this.model.sheets.list);
    this.RenameSheetReferences(this.model.sheets.list, old_name, name);
  }
  /**
   *
   */
  SortTableInternal(command) {
    if (!command.table.area.start.sheet_id) {
      throw new Error("table has invalid area");
    }
    const sheet = this.model.sheets.Find(command.table.area.start.sheet_id);
    if (!sheet) {
      throw new Error("invalid sheet in table area");
    }
    const ranked = [];
    const visible = [];
    let end = command.table.area.end.row;
    if (command.table.totals_row) {
      end--;
    }
    let text_count = 0;
    let number_count = 0;
    for (let row = command.table.area.start.row + 1; row <= end; row++) {
      const height = sheet.GetRowHeight(row);
      if (height) {
        visible.push(row);
      } else {
        continue;
      }
      const row_data = {
        row,
        number: 0,
        text: "",
        type: 0 /* undefined */,
        data: []
      };
      for (let column = command.table.area.start.column; column <= command.table.area.end.column; column++) {
        const cd = sheet.CellData({ row, column });
        if (column === command.column + command.table.area.start.column) {
          const check_type = cd.calculated_type || cd.type;
          if (check_type === 2 /* string */) {
            text_count++;
          } else if (check_type === 3 /* number */) {
            number_count++;
          }
          const value = cd.calculated_type ? cd.calculated : cd.value;
          row_data.text = value?.toString() || "";
          row_data.number = Number(value) || 0;
          row_data.type = cd.calculated_type || cd.type;
        }
        row_data.data.push({
          address: { row, column },
          data: cd.value,
          type: cd.type,
          style: cd.style
        });
      }
      ranked.push(row_data);
    }
    let sort_type = command.type;
    if (sort_type === "auto") {
      if (number_count > text_count) {
        sort_type = "numeric";
      } else {
        sort_type = "text";
      }
    }
    const invert = command.asc ? 1 : -1;
    switch (sort_type) {
      case "numeric":
        ranked.sort((a, b) => {
          if (a.type === 0 /* undefined */) {
            return b.type === 0 /* undefined */ ? 0 : 1;
          }
          if (b.type === 0 /* undefined */) {
            return -1;
          }
          return (a.number - b.number) * invert;
        });
        break;
      case "text":
      default:
        ranked.sort((a, b) => {
          if (a.type === 0 /* undefined */) {
            return b.type === 0 /* undefined */ ? 0 : 1;
          }
          if (b.type === 0 /* undefined */) {
            return -1;
          }
          return a.text.localeCompare(b.text) * invert;
        });
        break;
    }
    const insert = { row: command.table.area.start.row + 1, column: command.table.area.start.column };
    for (let i = 0; i < visible.length; i++) {
      insert.row = visible[i];
      const entry = ranked[i];
      insert.column = command.table.area.start.column;
      for (const cell of entry.data) {
        if (cell.type === 1 /* formula */) {
          let data = cell.data;
          const offsets = { columns: 0, rows: insert.row - entry.row };
          const parse_result = this.parser.Parse(data);
          if (parse_result.expression) {
            data = "=" + this.parser.Render(parse_result.expression, { offset: offsets, missing: "" });
          }
          sheet.SetCellValue(insert, data);
        } else {
          sheet.SetCellValue(insert, cell.data);
        }
        sheet.UpdateCellStyle(insert, cell.style || {}, false);
        insert.column++;
      }
    }
    const ref = this.model.tables.get(command.table.name.toLowerCase());
    if (ref) {
      ref.sort = {
        type: command.type,
        asc: !!command.asc,
        column: command.column
      };
    }
    {
      let row = command.table.area.start.row;
      for (let column = command.table.area.start.column; column <= command.table.area.end.column; column++) {
        sheet.cells.data[row][column]?.FlushStyle();
      }
      if (command.table.totals_row) {
        row = command.table.area.end.row;
        for (let column = command.table.area.start.column; column <= command.table.area.end.column; column++) {
          sheet.cells.data[row][column]?.FlushStyle();
        }
      }
    }
    return new Area(command.table.area.start, command.table.area.end);
  }
  /**
   * update all columns of a table (collect column names). this
   * method rebuilds all columns; that's probably unecessary in
   * many cases, but we'll start here and we can drill down later.
   * 
   * we do two things here: we normalize column header values, and
   * we collect them for table headers.
   * 
   * @param table 
   */
  UpdateTableColumns(table) {
    if (!table.area.start.sheet_id) {
      throw new Error("invalid area in table");
    }
    const sheet = this.model.sheets.Find(table.area.start.sheet_id);
    if (!sheet) {
      throw new Error("invalid sheet in table");
    }
    const current_columns = table.columns?.slice(0) || void 0;
    const columns = [];
    const row = table.area.start.row;
    const count = table.area.end.column - table.area.start.column + 1;
    let column = table.area.start.column;
    for (let i = 0; i < count; i++, column++) {
      const header = sheet.CellData({ row, column });
      let value = "";
      if (header.type !== 2 /* string */) {
        if (typeof header.formatted !== "undefined") {
          value = header.formatted.toString();
        } else if (typeof header.calculated !== "undefined") {
          value = header.calculated.toString();
        } else if (typeof header.value !== "undefined") {
          value = header.value.toString();
        }
        header.Set(value, 2 /* string */);
      } else {
        value = header.value || "";
      }
      if (!value) {
        value = `Column${i + 1}`;
      }
      let proposed = value;
      let success = false;
      let index = 1;
      while (!success) {
        success = true;
        inner_loop:
          for (const check of columns) {
            if (check.toLowerCase() === proposed.toLowerCase()) {
              success = false;
              proposed = `${value}${++index}`;
              break inner_loop;
            }
          }
      }
      header.Set(proposed, 2 /* string */);
      columns.push(proposed.toLowerCase());
    }
    if (current_columns) {
      if (current_columns.length === columns.length) {
        const update = /* @__PURE__ */ new Map();
        for (let i = 0; i < current_columns.length; i++) {
          const compare = current_columns[i].toLowerCase();
          if (compare !== columns[i]) {
            update.set(compare, columns[i]);
          }
        }
        if (update.size) {
          const table_name = table.name.toLowerCase();
          for (const sheet2 of this.model.sheets.list) {
            sheet2.cells.IterateAll((cell) => {
              if (cell.ValueIsFormula()) {
                let updated_formula = false;
                const parse_result = this.parser.Parse(cell.value);
                if (parse_result.expression) {
                  this.parser.Walk(parse_result.expression, (unit) => {
                    if (unit.type === "structured-reference") {
                      if (unit.table.toLowerCase() === table_name || !unit.table && cell.table === table) {
                        for (const [key, value] of update.entries()) {
                          if (unit.column.toLowerCase() === key) {
                            unit.column = value;
                            updated_formula = true;
                          }
                        }
                      }
                    }
                    return true;
                  });
                  if (updated_formula) {
                    console.info("updating value");
                    cell.value = "=" + this.parser.Render(parse_result.expression, {
                      missing: ""
                    });
                  }
                }
              }
            });
          }
        }
      }
    }
    table.columns = columns;
    return {
      start: {
        ...table.area.start
      },
      end: {
        row: table.area.start.row,
        column: table.area.end.column
      }
    };
  }
  /**
   * set range, via command. returns affected area.
   * 
   * Adding a flags parameter (in/out) to support indicating 
   * that we need to update layout.
   */
  SetRangeInternal(command, flags = {}) {
    const area = IsCellAddress(command.area) ? new Area(command.area) : new Area(command.area.start, command.area.end);
    const sheet = this.FindSheet(area);
    if (!area.start.sheet_id) {
      area.start.sheet_id = sheet.id;
    }
    if (!area.entire_row && !area.entire_column && (area.end.row >= sheet.rows || area.end.column >= sheet.columns)) {
      sheet.cells.EnsureCell(area.end);
      if (sheet === this.active_sheet) {
        flags.layout = true;
      }
    }
    if (IsCellAddress(command.area)) {
      const cell = sheet.CellData(command.area);
      if (cell.area && (cell.area.rows > 1 || cell.area.columns > 1)) {
        this.Error(2 /* array */);
        return;
      }
      let value = Array.isArray(command.value) ? Array.isArray(command.value[0]) ? command.value[0][0] : command.value[0] : command.value;
      if (command.r1c1) {
        value = this.TranslateR1C1(command.area, value);
      }
      if (command.array) {
        sheet.SetArrayValue(area, value);
      } else {
        sheet.SetCellValue(command.area, value);
      }
      return area;
    } else {
      if (command.array) {
        let value = Array.isArray(command.value) ? Array.isArray(command.value[0]) ? command.value[0][0] : command.value[0] : command.value;
        if (command.r1c1) {
          value = this.TranslateR1C1(area.start, value);
        }
        sheet.SetArrayValue(area, value);
      } else {
        if (command.r1c1) {
          if (Array.isArray(command.value)) {
            for (let r = 0; r < command.value.length && r < area.rows; r++) {
              if (!command.value[r]) {
                command.value[r] = [];
              }
              const row = command.value[r];
              for (let c = 0; c < row.length && c < area.columns; c++) {
                const target = { ...area.start, row: area.start.row + r, column: area.start.column + c };
                row[c] = this.TranslateR1C1(target, row[c]);
              }
            }
          } else {
            if (typeof command.value === "string" && command.value[0] === "=") {
              const value = [];
              for (let r = 0; r < area.rows; r++) {
                const row = [];
                for (let c = 0; c < area.columns; c++) {
                  const target = { ...area.start, row: area.start.row + r, column: area.start.column + c };
                  row.push(this.TranslateR1C1(target, command.value));
                }
                value.push(row);
              }
              command.value = value;
            }
          }
        }
        sheet.SetAreaValues2(area, command.value);
      }
      return area;
    }
  }
  /**
   * basic implementation does not handle any UI, painting, or layout.
   */
  ActivateSheetInternal(command) {
    const candidate = this.ResolveSheet(command) || this.model.sheets.list[0];
    if (this.active_sheet === candidate && !command.force) {
      return;
    }
    if (!candidate.visible) {
      throw new Error("cannot activate hidden sheet");
    }
    const deactivate = this.active_sheet;
    this.active_sheet = candidate;
    this.grid_events.Publish({
      type: "sheet-change",
      deactivate,
      activate: this.active_sheet
    });
  }
  ShowSheetInternal(command) {
    const sheet = this.ResolveSheet(command);
    if (!sheet) {
      return;
    }
    if (sheet.visible === command.show) {
      return;
    }
    if (!command.show) {
      let count = 0;
      for (const test of this.model.sheets.list) {
        if (!sheet.visible || test === sheet) {
          count++;
        }
      }
      if (count >= this.model.sheets.length) {
        throw new Error("can't hide all sheets");
      }
    }
    sheet.visible = command.show;
    if (sheet === this.active_sheet) {
      const list = this.model.sheets.list;
      for (let i = 0; i < list.length; i++) {
        if (list[i] === this.active_sheet) {
          for (let j = i + 1; j < list.length; j++) {
            if (list[j].visible) {
              this.ActivateSheetInternal({
                key: 21 /* ActivateSheet */,
                index: j
              });
              return;
            }
          }
          for (let j = 0; j < list.length; j++) {
            if (list[j].visible) {
              this.ActivateSheetInternal({
                key: 21 /* ActivateSheet */,
                index: j
              });
              return;
            }
          }
          throw new Error("no visible sheet");
        }
      }
    }
  }
  /**
   * normalize commands. for co-editing support we need to ensure that
   * commands properly have sheet IDs in areas/addresses (and explicit 
   * fields in some cases).
   * 
   * at the same time we're editing the commands a little bit to make 
   * them a little more consistent (within reason).
   * 
   * @param commands 
   */
  NormalizeCommands(commands) {
    if (!Array.isArray(commands)) {
      commands = [commands];
    }
    const id = this.active_sheet.id;
    for (const command of commands) {
      switch (command.key) {
        case 0 /* Null */:
        case 17 /* ShowHeaders */:
        case 24 /* ShowSheet */:
        case 18 /* AddSheet */:
        case 19 /* DuplicateSheet */:
        case 20 /* DeleteSheet */:
        case 21 /* ActivateSheet */:
        case 22 /* RenameSheet */:
        case 23 /* ReorderSheet */:
        case 26 /* Reset */:
          break;
        case 27 /* SortTable */:
        case 29 /* RemoveTable */:
          if (!command.table.area.start.sheet_id) {
            command.table.area.start.sheet_id = id;
          }
          break;
        case 30 /* AddConditionalFormat */:
          if (!command.format.area.start.sheet_id) {
            command.format.area.start.sheet_id = id;
          }
          break;
        case 3 /* ResizeRows */:
        case 4 /* ResizeColumns */:
        case 2 /* InsertColumns */:
        case 1 /* InsertRows */:
        case 15 /* Freeze */:
          if (!command.sheet_id) {
            command.sheet_id = id;
          }
          break;
        case 11 /* Clear */:
        case 13 /* SetNote */:
        case 14 /* SetLink */:
        case 8 /* UpdateBorders */:
        case 9 /* MergeCells */:
        case 10 /* UnmergeCells */:
        case 25 /* DataValidation */:
        case 6 /* SetRange */:
        case 7 /* UpdateStyle */:
        case 16 /* SetName */:
        case 5 /* Select */:
        case 28 /* InsertTable */:
        case 31 /* RemoveConditionalFormat */:
          if (command.area) {
            if (IsCellAddress(command.area)) {
              if (!command.area.sheet_id) {
                command.area.sheet_id = id;
              }
            } else {
              if (!command.area.start.sheet_id) {
                command.area.start.sheet_id = id;
              }
            }
          }
          break;
        default:
          AssertNever(command);
      }
    }
    return commands;
  }
  /**
   * add sheet. data only.
   */
  AddSheetInternal(name = Sheet.default_sheet_name, insert_index = -1) {
    if (!this.options.add_tab) {
      console.warn("add tab option not set or false");
      return;
    }
    while (this.model.sheets.list.some((test) => test.name === name)) {
      const match = name.match(/^(.*?)(\d+)$/);
      if (match) {
        name = match[1] + (Number(match[2]) + 1);
      } else {
        name = name + "2";
      }
    }
    const sheet = Sheet.Blank(this.model.theme_style_properties, name);
    if (insert_index >= 0) {
      this.model.sheets.Splice(insert_index, 0, sheet);
    } else {
      this.model.sheets.Add(sheet);
    }
    return sheet.id;
  }
  /**
   * resolve sheet in a command that uses the SheetSelection interface;
   * that allows sheet selection by name, id or index.
   */
  ResolveSheet(command) {
    if (typeof command.index !== "undefined") {
      return this.model.sheets.list[command.index];
    }
    if (typeof command.name !== "undefined") {
      return this.model.sheets.Find(command.name);
    }
    if (command.id) {
      return this.model.sheets.Find(command.id);
    }
    return void 0;
  }
  /**
   * find sheet matching sheet_id in area.start, or active sheet
   * 
   * FIXME: should return undefined on !match
   * FIXME: should be in model, which should be a class
   */
  FindSheet(identifier) {
    if (identifier === void 0) {
      return this.active_sheet;
    }
    const id = typeof identifier === "number" ? identifier : IsCellAddress(identifier) ? identifier.sheet_id : identifier.start.sheet_id;
    if (!id || id === this.active_sheet.id) {
      return this.active_sheet;
    }
    const sheet = this.model.sheets.Find(id);
    if (sheet) {
      return sheet;
    }
    return this.active_sheet;
  }
  /** 
   * this function now works for both rows and columns, and can handle
   * sheets other than the active sheet. it does assume that you only ever
   * add rows/columns on the active sheet, but since that's all parameterized
   * you could get it to work either way.
   * 
   * in fact we should change the names of those parameters so it's a little
   * more generic.
   */
  PatchFormulasInternal(source, before_row, row_count, before_column, column_count, target_sheet_name, is_target) {
    const parsed = this.parser.Parse(source || "");
    let modified = false;
    if (parsed.expression) {
      this.parser.Walk(parsed.expression, (element) => {
        if (element.type === "range" || element.type === "address") {
          const addresses = [];
          if (element.type === "range") {
            if (element.start.sheet && element.start.sheet.toLowerCase() === target_sheet_name || !element.start.sheet && is_target) {
              addresses.push(element.start, element.end);
            }
          } else if (element.type === "address") {
            if (element.sheet && element.sheet.toLowerCase() === target_sheet_name || !element.sheet && is_target) {
              addresses.push(element);
            }
          }
          for (const address of addresses) {
            if (row_count && address.row >= before_row) {
              if (row_count < 0 && address.row + row_count < before_row) {
                address.column = address.row = -1;
              } else {
                address.row += row_count;
              }
              modified = true;
            }
            if (column_count && address.column >= before_column) {
              if (column_count < 0 && address.column + column_count < before_column) {
                address.column = address.row = -1;
              } else {
                address.column += column_count;
              }
              modified = true;
            }
          }
          return false;
        }
        return true;
      });
      if (modified) {
        return "=" + this.parser.Render(parsed.expression, { missing: "" });
      }
    }
    return void 0;
  }
  PatchExpressionSheetName(expression, old_name, name) {
    let modified = false;
    const parsed = this.parser.Parse(expression || "");
    if (parsed.expression) {
      this.parser.Walk(parsed.expression, (element) => {
        if (element.type === "address") {
          if (element.sheet && element.sheet.toLowerCase() === old_name) {
            element.sheet = name;
            modified = true;
          }
        }
        return true;
      });
      if (modified) {
        return "=" + this.parser.Render(parsed.expression, { missing: "" });
      }
    }
    return void 0;
  }
  /**
   * splitting this logic into a new function so we can reuse it 
   * for invalidating broken references. generally we'll call this
   * on all sheets, but I wanted to leave the option open.
   * 
   * @returns count of changes made. it's useful for the delete routine, 
   * so we can force a recalc.
   */
  RenameSheetReferences(sheets, old_name, name) {
    let changes = 0;
    old_name = old_name.toLowerCase();
    for (const sheet of sheets) {
      sheet.cells.IterateAll((cell) => {
        if (cell.ValueIsFormula()) {
          const updated = this.PatchExpressionSheetName(cell.value || "", old_name, name);
          if (updated) {
            cell.value = updated;
            changes++;
          }
        }
      });
      if (sheet.conditional_formats?.length) {
        for (const format of sheet.conditional_formats) {
          switch (format.type) {
            case "cell-match":
            case "expression":
              {
                const updated = this.PatchExpressionSheetName(format.expression, old_name, name);
                if (updated) {
                  format.expression = updated;
                  changes++;
                }
              }
              break;
          }
        }
      }
      for (const annotation of sheet.annotations) {
        if (annotation.data.formula) {
          const updated = this.PatchExpressionSheetName(annotation.data.formula, old_name, name);
          if (updated) {
            annotation.data.formula = updated;
            changes++;
          }
        }
      }
    }
    for (const element of this.model.connected_elements.values()) {
      if (element.formula) {
        const updated = this.PatchExpressionSheetName(element.formula, old_name, name);
        if (updated) {
          element.formula = updated;
          changes++;
        }
      }
    }
    return changes;
  }
  /**
   * these are all addative except for "none", which removes all borders.
   *
   * we no longer put borders into two cells at once (hurrah!). however
   * we still need to do some maintenance on the mirror cells -- because
   * if you apply a border to cell A1, then that should take precedence
   * over any border previously applied to cell A2.
   *
   * FIXME: is that right? perhaps we should just leave whatever the user
   * did -- with the exception of clearing, which should always mirror.
   *
   *
   * UPDATE: modifying function for use with ExecCommand. runs the style
   * updates and returns the affected area.
   *
   */
  ApplyBordersInternal(command) {
    const borders = command.borders;
    const width = command.borders === "none" /* None */ ? 0 : command.width;
    const area = new Area(command.area.start, command.area.end);
    const sheet = this.FindSheet(area);
    area.start.sheet_id = sheet.id;
    const top = { border_top: width };
    const bottom = { border_bottom: width };
    const left = { border_left: width };
    const right = { border_right: width };
    const clear_top = { border_top: 0, border_top_fill: {} };
    const clear_bottom = { border_bottom: 0, border_bottom_fill: {} };
    const clear_left = { border_left: 0, border_left_fill: {} };
    const clear_right = { border_right: 0, border_right_fill: {} };
    if (command.color) {
      top.border_top_fill = { ...command.color };
      bottom.border_bottom_fill = { ...command.color };
      left.border_left_fill = { ...command.color };
      right.border_right_fill = { ...command.color };
    } else {
      top.border_top_fill = {};
      bottom.border_bottom_fill = {};
      left.border_left_fill = {};
      right.border_right_fill = {};
    }
    if (borders === "none" /* None */ || borders === "all" /* All */) {
      sheet.UpdateAreaStyle(area, {
        ...top,
        ...bottom,
        ...left,
        ...right
      }, true);
    }
    if (borders === "top" /* Top */ || borders === "outside" /* Outside */) {
      if (!area.entire_column) {
        sheet.UpdateAreaStyle(area.top, { ...top }, true);
      }
    }
    if (borders === "none" /* None */ || borders === "all" /* All */ || borders === "outside" /* Outside */ || borders === "top" /* Top */) {
      if (!area.entire_column) {
        if (area.start.row) {
          sheet.UpdateAreaStyle(new Area(
            { row: area.start.row - 1, column: area.start.column },
            { row: area.start.row - 1, column: area.end.column }
          ), { ...clear_bottom }, true);
        }
      }
    }
    if (borders === "bottom" /* Bottom */ || borders === "outside" /* Outside */) {
      if (!area.entire_column) {
        sheet.UpdateAreaStyle(area.bottom, { ...bottom }, true);
      }
    }
    if (borders === "none" /* None */ || borders === "all" /* All */ || borders === "outside" /* Outside */ || borders === "bottom" /* Bottom */) {
      if (!area.entire_column) {
        sheet.UpdateAreaStyle(new Area(
          { row: area.end.row + 1, column: area.start.column },
          { row: area.end.row + 1, column: area.end.column }
        ), { ...clear_top }, true);
      }
    }
    if (borders === "left" /* Left */ || borders === "outside" /* Outside */) {
      if (!area.entire_row) {
        sheet.UpdateAreaStyle(area.left, { ...left }, true);
      }
    }
    if (borders === "none" /* None */ || borders === "all" /* All */ || borders === "outside" /* Outside */ || borders === "left" /* Left */) {
      if (!area.entire_row) {
        if (area.start.column) {
          sheet.UpdateAreaStyle(new Area(
            { row: area.start.row, column: area.start.column - 1 },
            { row: area.end.row, column: area.start.column - 1 }
          ), { ...clear_right }, true);
        }
      }
    }
    if (borders === "right" /* Right */ || borders === "outside" /* Outside */) {
      if (!area.entire_row) {
        sheet.UpdateAreaStyle(area.right, { ...right }, true);
      }
    }
    if (borders === "none" /* None */ || borders === "all" /* All */ || borders === "outside" /* Outside */ || borders === "right" /* Right */) {
      if (!area.entire_row) {
        sheet.UpdateAreaStyle(new Area(
          { row: area.start.row, column: area.end.column + 1 },
          { row: area.end.row, column: area.end.column + 1 }
        ), { ...clear_left }, true);
      }
    }
    return Area.Bleed(area);
  }
  TranslateR1C1(address, value) {
    let transformed = false;
    const cached = this.parser.flags.r1c1;
    this.parser.flags.r1c1 = true;
    if (typeof value === "string" && value[0] === "=") {
      const result = this.parser.Parse(value);
      if (result.expression) {
        this.parser.Walk(result.expression, (unit) => {
          if (unit.type === "address" && unit.r1c1) {
            transformed = true;
            if (unit.offset_column) {
              unit.column = unit.column + address.column;
            }
            if (unit.offset_row) {
              unit.row = unit.row + address.row;
            }
          }
          return true;
        });
        if (transformed) {
          value = "=" + this.parser.Render(result.expression, { missing: "" });
        }
      }
    }
    this.parser.flags.r1c1 = cached;
    return value;
  }
  ClearAreaInternal(area) {
    let sheet;
    if (area.start.sheet_id) {
      sheet = this.model.sheets.Find(area.start.sheet_id);
    } else {
      sheet = this.active_sheet;
    }
    if (!sheet) {
      console.warn(`can't resolve sheet in ClearAreaInternal`);
      return;
    }
    let error = false;
    area = sheet.RealArea(area);
    sheet.cells.Apply(area, (cell) => {
      if (cell.area && !area.ContainsArea(cell.area)) {
        error = true;
      }
    });
    const table_keys = this.model.tables.keys();
    for (const key of table_keys) {
      const table = this.model.tables.get(key);
      if (table && table.area.start.sheet_id === sheet.id) {
        const table_area = new Area(table.area.start, table.area.end);
        if (area.ContainsArea(table_area)) {
          for (let row = table_area.start.row; row <= table_area.end.row; row++) {
            for (let column = table_area.start.column; column <= table.area.end.column; column++) {
              const cell = sheet.cells.GetCell({ row, column }, false);
              if (cell) {
                cell.table = void 0;
              }
            }
          }
          this.model.tables.delete(key);
        }
      }
    }
    if (error) {
      this.Error(2 /* array */);
    } else {
      sheet.ClearArea(area);
    }
  }
  /**
   * send an error message. subscriber can figure out how to communicate it
   * to users. 
   * 
   * dropping strings, now we only allow error constants (via enum)
   *  
   * @param message 
   */
  Error(message) {
    this.grid_events.Publish({
      type: "error",
      code: message
    });
  }
  /**
   * this breaks (or doesn't work) if the add_tab option is false; that's 
   * fine, although we might want to make a distinction between UI add-tab 
   * and API add-tab. And allow it from the API.
   * 
   * @param command 
   * @returns 
   */
  DuplicateSheetInternal(command) {
    if (!this.options.add_tab) {
      console.warn("add tab option not set or false");
      return;
    }
    const source = this.ResolveSheet(command);
    const next_id = this.model.sheets.list.reduce((id, sheet) => Math.max(id, sheet.id), 0) + 1;
    let insert_index = -1;
    for (let i = 0; i < this.model.sheets.length; i++) {
      if (this.model.sheets.list[i] === source) {
        insert_index = i + 1;
      }
    }
    if (!source || insert_index < 0) {
      throw new Error("source sheet not found");
    }
    if (typeof command.insert_before === "number") {
      insert_index = command.insert_before;
    } else if (typeof command.insert_before === "string") {
      const lc = command.insert_before.toLowerCase();
      for (let i = 0; i < this.model.sheets.length; i++) {
        if (this.model.sheets.list[i].name.toLowerCase() === lc) {
          insert_index = i;
          break;
        }
      }
    }
    const options = {
      rendered_values: true
    };
    const clone = Sheet.FromJSON(source.toJSON(options), this.model.theme_style_properties);
    let name = command.new_name || source.name;
    while (this.model.sheets.list.some((test) => test.name === name)) {
      const match = name.match(/^(.*?)(\d+)$/);
      if (match) {
        name = match[1] + (Number(match[2]) + 1);
      } else {
        name = name + "2";
      }
    }
    clone.name = name;
    clone.id = next_id;
    this.model.sheets.Splice(insert_index, 0, clone);
    return clone.id;
  }
  /**
   * this is the callback method for the command-log select command
   * (which is not widely used). it does nothing. the specialization
   * should do something.
   * 
   * @param command 
   */
  SelectInternal(command) {
  }
  FreezeInternal(command) {
    const sheet = this.FindSheet(command.sheet_id || this.active_sheet.id);
    sheet.freeze.rows = command.rows;
    sheet.freeze.columns = command.columns;
  }
  /**
   * patch an expression for insert/delete row/column operations.
   * FIXME: should move, maybe to parser? (...)
   * 
   * NOTE: did I write this twice? we only need one. check which one is better.
   * @see PatchFormulasInternal
   * 
   * @returns the updated expression, or `undefined` if no changes were made.
   */
  PatchExpression(expression, options) {
    let count = 0;
    const parse_result = this.parser.Parse(expression);
    if (parse_result.expression) {
      this.parser.Walk(parse_result.expression, (unit) => {
        if (unit.type === "range") {
          if (!unit.start.sheet || unit.start.sheet.toLowerCase() === options.sheet.name.toLowerCase()) {
            const updated = Area.PatchArea(unit, options);
            if (updated) {
              unit.start.row = updated.start.row;
              unit.start.column = updated.start.column;
              unit.end.row = updated.end.row;
              unit.end.column = updated.end.column;
            } else {
              unit.start.row = unit.end.row = unit.start.column = unit.end.column = -1;
            }
          }
          count++;
          return false;
        } else if (unit.type === "address") {
          const updated = Area.PatchArea({ start: unit, end: unit }, options);
          if (updated) {
            unit.row = updated.start.row;
            unit.column = updated.start.column;
          } else {
            unit.row = unit.column = -1;
          }
          count++;
          return false;
        }
        return true;
      });
      if (count) {
        const rendered = this.parser.Render(parse_result.expression, {
          missing: ""
        });
        return rendered;
      }
    }
    return void 0;
  }
  /**
   * patch sheet conditionals for insert/delete row/column operations.
   * some of them may be deleted.
   */
  PatchConditionals(options) {
    if (options.sheet.conditional_formats?.length) {
      const delete_list = /* @__PURE__ */ new Set();
      for (const format of options.sheet.conditional_formats) {
        const updated = Area.PatchArea(format.area, options);
        if (updated) {
          format.area = JSON.parse(JSON.stringify(updated));
        } else {
          delete_list.add(format);
          continue;
        }
        switch (format.type) {
          case "expression":
          case "cell-match":
            {
              const updated2 = this.PatchExpression(format.expression, options);
              if (updated2) {
                format.expression = updated2;
              }
            }
            break;
        }
      }
      if (delete_list.size) {
        options.sheet.conditional_formats = options.sheet.conditional_formats.filter((test) => !delete_list.has(test));
      }
    }
  }
  /**
   * FIXME: should be API method
   * FIXME: need to handle annotations that are address-based
   *
   * @see InsertColumns for inline comments
   */
  InsertRowsInternal(command) {
    const target_sheet = this.FindSheet(command.sheet_id);
    if (command.count === Infinity) {
      command.count = 1;
    } else if (command.count === -Infinity) {
      command.count = -target_sheet.rows;
    }
    if (!target_sheet.InsertRows(command.before_row, command.count)) {
      this.Error(2 /* array */);
      return { error: true };
    }
    this.PatchConditionals({
      sheet: target_sheet,
      before_column: 0,
      column_count: 0,
      before_row: command.before_row,
      row_count: command.count
    });
    for (const external of this.model.connected_elements.values()) {
      if (external.formula) {
        const modified = this.PatchFormulasInternal(
          external.formula,
          command.before_row,
          command.count,
          0,
          0,
          target_sheet.name.toLowerCase(),
          false
        );
        if (modified) {
          external.formula = modified;
        }
      }
    }
    const tables = Array.from(this.model.tables.values());
    for (const table of tables) {
      if (table.area.start.sheet_id === command.sheet_id) {
        if (command.count > 0) {
          if (command.before_row <= table.area.start.row) {
            table.area.start.row += command.count;
            table.area.end.row += command.count;
          } else if (command.before_row <= table.area.end.row) {
            table.area.end.row += command.count;
            for (let row = table.area.start.row; row <= table.area.end.row; row++) {
              for (let column = table.area.start.column; column <= table.area.end.column; column++) {
                const cell = target_sheet.CellData({ row, column });
                cell.table = table;
              }
            }
          }
        } else {
          if (command.before_row <= table.area.start.row) {
            if (command.before_row - command.count <= table.area.start.row) {
              table.area.start.row += command.count;
              table.area.end.row += command.count;
            } else if (command.before_row - command.count >= table.area.end.row) {
              this.model.tables.delete(table.name.toLowerCase());
            } else {
              this.model.tables.delete(table.name.toLowerCase());
              for (let row = command.before_row; row <= table.area.end.row; row++) {
                for (let column = table.area.start.column; column <= table.area.end.column; column++) {
                  const cell = target_sheet.CellData({ row, column });
                  if (cell.table === table) {
                    cell.table = void 0;
                  }
                }
              }
            }
          } else if (command.before_row <= table.area.end.row) {
            if (command.before_row - command.count > table.area.end.row) {
              table.totals_row = false;
            }
            table.area.end.row = Math.max(0, table.area.end.row + command.count, command.before_row - 1);
          }
        }
      }
    }
    this.model.named_ranges.PatchNamedRanges(target_sheet.id, 0, 0, command.before_row, command.count);
    const target_sheet_name = target_sheet.name.toLowerCase();
    for (const sheet of this.model.sheets.list) {
      const is_target = sheet === target_sheet;
      sheet.cells.IterateAll((cell) => {
        if (cell.ValueIsFormula()) {
          const modified = this.PatchFormulasInternal(
            cell.value || "",
            command.before_row,
            command.count,
            0,
            0,
            target_sheet_name,
            is_target
          );
          if (modified) {
            cell.value = modified;
          }
        }
      });
      for (const annotation of sheet.annotations) {
        if (annotation.data.formula) {
          const modified = this.PatchFormulasInternal(
            annotation.data.formula || "",
            command.before_row,
            command.count,
            0,
            0,
            target_sheet_name,
            is_target
          );
          if (modified) {
            annotation.data.formula = modified;
          }
        }
      }
    }
    const update_annotations_list = [];
    const resize_annotations_list = [];
    const delete_annotations_list = [];
    if (command.count > 0) {
      const first = command.before_row;
      for (const annotation of target_sheet.annotations) {
        if (annotation.data.layout) {
          const [start, end, endy] = [
            annotation.data.layout.tl.address.row,
            annotation.data.layout.br.address.row,
            annotation.data.layout.br.offset.y
          ];
          if (first <= start) {
            annotation.data.layout.tl.address.row += command.count;
            annotation.data.layout.br.address.row += command.count;
          } else if (first < end || first === end && endy > 0) {
            annotation.data.layout.br.address.row += command.count;
            resize_annotations_list.push(annotation);
          } else {
            continue;
          }
          update_annotations_list.push(annotation);
        }
      }
    } else if (command.count < 0) {
      const first = command.before_row;
      const last = command.before_row - command.count - 1;
      for (const annotation of target_sheet.annotations) {
        if (annotation.data.layout) {
          const [start, end, endy] = [
            annotation.data.layout.tl.address.row,
            annotation.data.layout.br.address.row,
            annotation.data.layout.br.offset.y
          ];
          if (first <= start) {
            if (last < start) {
              annotation.data.layout.tl.address.row += command.count;
              annotation.data.layout.br.address.row += command.count;
            } else if (last < end - 1 || last === end - 1 && endy > 0) {
              annotation.data.layout.tl.address.row = first;
              annotation.data.layout.tl.offset.y = 0;
              annotation.data.layout.br.address.row += command.count;
              resize_annotations_list.push(annotation);
            } else {
              delete_annotations_list.push(annotation);
              continue;
            }
          } else if (first < end || first === end && endy > 0) {
            if (last < end - 1 || last === end - 1 && endy > 0) {
              annotation.data.layout.br.address.row += command.count;
              resize_annotations_list.push(annotation);
            } else {
              annotation.data.layout.br.address.row = first;
              annotation.data.layout.br.offset.y = 0;
              resize_annotations_list.push(annotation);
            }
          } else {
            continue;
          }
          update_annotations_list.push(annotation);
        }
      }
    }
    for (const annotation of delete_annotations_list) {
      target_sheet.annotations = target_sheet.annotations.filter((test) => test !== annotation);
    }
    return {
      update_annotations_list,
      resize_annotations_list,
      delete_annotations_list
    };
  }
  /**
   * 
   */
  InsertColumnsInternal(command) {
    const target_sheet = this.FindSheet(command.sheet_id);
    if (command.count === Infinity) {
      command.count = 1;
    } else if (command.count === -Infinity) {
      command.count = -target_sheet.columns;
    }
    if (!target_sheet.InsertColumns(command.before_column, command.count)) {
      this.Error(2 /* array */);
      return { error: true };
    }
    this.PatchConditionals({
      sheet: target_sheet,
      before_column: command.before_column,
      column_count: command.count,
      before_row: 0,
      row_count: 0
    });
    for (const element of this.model.connected_elements.values()) {
      if (element.formula) {
        const modified = this.PatchFormulasInternal(
          element.formula,
          0,
          0,
          command.before_column,
          command.count,
          target_sheet.name.toLowerCase(),
          false
        );
        if (modified) {
          element.formula = modified;
        }
      }
    }
    const tables = Array.from(this.model.tables.values());
    for (const table of tables) {
      if (table.area.start.sheet_id === command.sheet_id) {
        if (command.count > 0) {
          if (command.before_column <= table.area.start.column) {
            table.area.start.column += command.count;
            table.area.end.column += command.count;
          } else if (command.before_column <= table.area.end.column) {
            table.area.end.column += command.count;
            for (let row = table.area.start.row; row <= table.area.end.row; row++) {
              for (let column = table.area.start.column; column <= table.area.end.column; column++) {
                const cell = target_sheet.CellData({ row, column });
                cell.table = table;
              }
            }
            this.UpdateTableColumns(table);
          }
        } else {
          if (command.before_column <= table.area.start.column) {
            if (command.before_column - command.count <= table.area.start.column) {
              table.area.start.column += command.count;
              table.area.end.column += command.count;
            } else if (command.before_column - command.count >= table.area.end.column) {
              this.model.tables.delete(table.name.toLowerCase());
            } else {
              table.area.start.column = command.before_column;
              table.area.end.column += command.count;
              this.UpdateTableColumns(table);
            }
          } else if (command.before_column <= table.area.end.column) {
            table.area.end.column = Math.max(0, table.area.end.column + command.count, command.before_column - 1);
            this.UpdateTableColumns(table);
          }
        }
      }
    }
    this.model.named_ranges.PatchNamedRanges(target_sheet.id, command.before_column, command.count, 0, 0);
    const target_sheet_name = target_sheet.name.toLowerCase();
    for (const sheet of this.model.sheets.list) {
      const is_target = sheet === target_sheet;
      sheet.cells.IterateAll((cell) => {
        if (cell.ValueIsFormula()) {
          const modified = this.PatchFormulasInternal(
            cell.value || "",
            0,
            0,
            command.before_column,
            command.count,
            target_sheet_name,
            is_target
          );
          if (modified) {
            cell.value = modified;
          }
        }
      });
      for (const annotation of sheet.annotations) {
        if (annotation.data.formula) {
          const modified = this.PatchFormulasInternal(
            annotation.data.formula,
            0,
            0,
            command.before_column,
            command.count,
            target_sheet_name,
            is_target
          );
          if (modified) {
            annotation.data.formula = modified;
          }
        }
      }
    }
    const update_annotations_list = [];
    const resize_annotations_list = [];
    const delete_annotations_list = [];
    if (command.count > 0) {
      const first = command.before_column;
      for (const annotation of target_sheet.annotations) {
        if (annotation.data.layout) {
          const [start, end, endx] = [
            annotation.data.layout.tl.address.column,
            annotation.data.layout.br.address.column,
            annotation.data.layout.br.offset.x
          ];
          if (first <= start) {
            annotation.data.layout.tl.address.column += command.count;
            annotation.data.layout.br.address.column += command.count;
          } else if (first < end || first === end && endx > 0) {
            annotation.data.layout.br.address.column += command.count;
            resize_annotations_list.push(annotation);
          } else {
            continue;
          }
          update_annotations_list.push(annotation);
        }
      }
    } else if (command.count < 0) {
      const first = command.before_column;
      const last = command.before_column - command.count - 1;
      for (const annotation of target_sheet.annotations) {
        if (annotation.data.layout) {
          const [start, end, endx] = [
            annotation.data.layout.tl.address.column,
            annotation.data.layout.br.address.column,
            annotation.data.layout.br.offset.x
          ];
          if (first <= start) {
            if (last < start) {
              annotation.data.layout.tl.address.column += command.count;
              annotation.data.layout.br.address.column += command.count;
            } else if (last < end - 1 || last === end - 1 && endx > 0) {
              annotation.data.layout.tl.address.column = first;
              annotation.data.layout.tl.offset.x = 0;
              annotation.data.layout.br.address.column += command.count;
              resize_annotations_list.push(annotation);
            } else {
              delete_annotations_list.push(annotation);
              continue;
            }
          } else if (first < end || first === end && endx > 0) {
            if (last < end - 1 || last === end - 1 && endx > 0) {
              annotation.data.layout.br.address.column += command.count;
              resize_annotations_list.push(annotation);
            } else {
              annotation.data.layout.br.address.column = first;
              annotation.data.layout.br.offset.x = 0;
              resize_annotations_list.push(annotation);
            }
          } else {
            continue;
          }
          update_annotations_list.push(annotation);
        }
      }
    }
    for (const annotation of delete_annotations_list) {
      target_sheet.annotations = target_sheet.annotations.filter((test) => test !== annotation);
    }
    return {
      update_annotations_list,
      resize_annotations_list,
      delete_annotations_list
    };
  }
  //////////////////////////////////////////////////////////////////////////////
  /**
   * pass all data/style/structure operations through a command mechanism.
   * this method should optimally act as a dispatcher, so try to minimize
   * inline code in favor of method calls.
   *
   * [NOTE: don't go crazy with that, some simple operations can be inlined]
   * 
   * NOTE: working on coediting. we will need to handle different sheets.
   * going to work one command at a time...
   * 
   * @param queue -- push on the command log. this is default true so it
   * doesn't change existing behavior, but you can turn it off if the message
   * comes from a remote queue.
   * 
   */
  ExecCommand(commands, queue = true) {
    const flags = {
      pending: []
    };
    const events = [];
    commands = this.NormalizeCommands(commands);
    if (queue) {
      this.command_log.Publish({ command: commands, timestamp: (/* @__PURE__ */ new Date()).getTime() });
    }
    for (const command of commands) {
      switch (command.key) {
        case 26 /* Reset */:
          this.ResetInternal();
          break;
        case 11 /* Clear */:
          if (command.area) {
            const area = new Area(command.area.start, command.area.end);
            this.ClearAreaInternal(area);
            flags.data_area = Area.Join(area, flags.data_area);
            flags.formula = true;
          }
          break;
        case 5 /* Select */:
          this.SelectInternal(command);
          break;
        case 15 /* Freeze */:
          this.FreezeInternal(command);
          flags.structure_event = true;
          break;
        case 30 /* AddConditionalFormat */:
          {
            const sheet = this.FindSheet(command.format.area);
            sheet.conditional_formats.push(command.format);
            sheet.Invalidate(new Area(command.format.area.start, command.format.area.end));
            if (sheet === this.active_sheet) {
              flags.render_area = Area.Join(command.format.area, flags.render_area);
            } else {
            }
            flags.structure_event = true;
            flags.conditional_formatting_event = true;
          }
          break;
        case 31 /* RemoveConditionalFormat */:
          {
            let sheet;
            let count = 0;
            if (command.format) {
              const format = JSON.stringify(command.format);
              sheet = this.FindSheet(command.format.area);
              sheet.conditional_formats = sheet.conditional_formats.filter((test) => {
                if (JSON.stringify(test) === format) {
                  count++;
                  flags.render_area = Area.Join(test.area, flags.render_area);
                  return false;
                }
                return true;
              });
            } else if (command.area) {
              const area = new Area(command.area.start, command.area.end);
              sheet = this.FindSheet(command.area);
              sheet.conditional_formats = sheet.conditional_formats.filter((test) => {
                const compare = new Area(test.area.start, test.area.end);
                if (compare.Intersects(area)) {
                  count++;
                  flags.render_area = Area.Join(compare, flags.render_area);
                  return false;
                }
                return true;
              });
            }
            if (sheet && count) {
              sheet.FlushConditionalFormats();
              flags.structure_event = true;
              flags.conditional_formatting_event = true;
            }
          }
          break;
        case 28 /* InsertTable */:
          {
            const sheet = this.FindSheet(command.area);
            const area = new Area(command.area.start, command.area.end);
            let valid = true;
            validation_loop:
              for (let row = area.start.row; row <= area.end.row; row++) {
                for (let column = area.start.column; column <= area.end.column; column++) {
                  const cell = sheet.cells.GetCell({ row, column }, false);
                  if (cell && (cell.area || cell.merge_area || cell.table)) {
                    valid = false;
                    break validation_loop;
                  }
                }
              }
            if (valid) {
              let index = this.model.tables.size + 1;
              let name = "";
              for (; ; ) {
                name = `Table${index++}`;
                if (!this.model.tables.has(name.toLowerCase())) {
                  break;
                }
              }
              const table = {
                area: command.area,
                name,
                sortable: command.sortable,
                // defaults to true if !present
                theme: command.theme
              };
              if (command.totals) {
                table.totals_row = true;
              }
              this.model.tables.set(name.toLowerCase(), table);
              for (let row = area.start.row; row <= area.end.row; row++) {
                for (let column = area.start.column; column <= area.end.column; column++) {
                  const cell = sheet.cells.GetCell({ row, column }, true);
                  cell.table = table;
                }
              }
              this.UpdateTableColumns(table);
              sheet.Invalidate(new Area(table.area.start, table.area.end));
              if (sheet === this.active_sheet) {
                flags.style_area = Area.Join(area, flags.style_area);
                flags.render_area = Area.Join(area, flags.render_area);
              } else {
                flags.style_event = true;
              }
            }
          }
          break;
        case 29 /* RemoveTable */:
          {
            const sheet = this.FindSheet(command.table.area);
            const area = new Area(command.table.area.start, command.table.area.end);
            for (let row = area.start.row; row <= area.end.row; row++) {
              for (let column = area.start.column; column <= area.end.column; column++) {
                const cell = sheet.cells.GetCell({ row, column }, false);
                if (cell) {
                  cell.table = void 0;
                }
              }
            }
            this.model.tables.delete(command.table.name.toLowerCase());
            const invalid = sheet.RealArea(area.Clone().Shift(-1, -1).Resize(area.rows + 2, area.columns + 2));
            sheet.Invalidate(invalid);
            if (sheet === this.active_sheet) {
              flags.style_area = Area.Join(area, flags.style_area);
              flags.render_area = Area.Join(area, flags.render_area);
            } else {
              flags.style_event = true;
            }
          }
          break;
        case 9 /* MergeCells */:
          {
            const sheet = this.FindSheet(command.area);
            sheet.MergeCells(
              new Area(command.area.start, command.area.end)
            );
            flags.structure_event = true;
            flags.structure_rebuild_required = true;
            if (sheet === this.active_sheet) {
              flags.data_area = Area.Join(command.area, flags.data_area);
              flags.render_area = Area.Join(command.area, flags.render_area);
            } else {
              flags.data_event = true;
              if (!flags.pending) {
                flags.pending = [];
              }
              flags.pending.push(sheet.id);
            }
          }
          break;
        case 10 /* UnmergeCells */:
          {
            const sheet = this.FindSheet(command.area);
            const list = {};
            const area = new Area(command.area.start, command.area.end);
            sheet.cells.Apply(area, (cell) => {
              if (cell.merge_area) {
                const label = Area.CellAddressToLabel(cell.merge_area.start) + ":" + Area.CellAddressToLabel(cell.merge_area.end);
                list[label] = cell.merge_area;
              }
            }, false);
            const keys = Object.keys(list);
            for (let i = 0; i < keys.length; i++) {
              sheet.UnmergeCells(list[keys[i]]);
            }
            if (sheet === this.active_sheet) {
              flags.render_area = Area.Join(command.area, flags.render_area);
              flags.data_area = Area.Join(command.area, flags.data_area);
            } else {
              flags.data_event = true;
              if (!flags.pending) {
                flags.pending = [];
              }
              flags.pending.push(sheet.id);
            }
            flags.structure_event = true;
            flags.structure_rebuild_required = true;
          }
          break;
        case 7 /* UpdateStyle */:
          {
            let area;
            const sheet = this.FindSheet(command.area);
            if (IsCellAddress(command.area)) {
              area = new Area(command.area);
              sheet.UpdateCellStyle(command.area, command.style, !!command.delta);
            } else {
              area = new Area(command.area.start, command.area.end);
              sheet.UpdateAreaStyle(area, command.style, !!command.delta);
            }
            if (sheet === this.active_sheet) {
              flags.style_area = Area.Join(area, flags.style_area);
              if (!command.delta || command.style.fill || command.style.border_top || command.style.border_left || command.style.border_right || command.style.border_bottom) {
                area = Area.Bleed(area);
                this.active_sheet.Invalidate(area);
              }
              flags.render_area = Area.Join(area, flags.render_area);
            } else {
              flags.style_event = true;
            }
          }
          break;
        case 25 /* DataValidation */:
          this.SetValidationInternal(command);
          if (!command.area.sheet_id || command.area.sheet_id === this.active_sheet.id) {
            flags.render_area = Area.Join(new Area(command.area), flags.render_area);
          }
          break;
        case 16 /* SetName */:
          if (command.area) {
            this.model.named_expressions.delete(command.name);
            this.model.named_ranges.SetName(
              command.name,
              new Area(command.area.start, command.area.end)
            );
            this.autocomplete_matcher.AddFunctions({
              type: 1 /* Token */,
              name: command.name
            });
          } else if (command.expression) {
            this.model.named_ranges.ClearName(command.name);
            this.model.named_expressions.set(command.name, command.expression);
            this.autocomplete_matcher.AddFunctions({
              type: 1 /* Token */,
              name: command.name
            });
          } else {
            this.model.named_ranges.ClearName(command.name);
            this.model.named_expressions.delete(command.name);
            this.autocomplete_matcher.RemoveFunctions({
              type: 1 /* Token */,
              name: command.name
            });
          }
          flags.structure_event = true;
          flags.structure_rebuild_required = true;
          break;
        case 8 /* UpdateBorders */:
          {
            const area = this.ApplyBordersInternal(command);
            if (area.start.sheet_id === this.active_sheet.id) {
              flags.render_area = Area.Join(area, flags.render_area);
              flags.style_area = Area.Join(area, flags.style_area);
            } else {
              flags.style_event = true;
            }
          }
          break;
        case 24 /* ShowSheet */:
          this.ShowSheetInternal(command);
          flags.sheets = true;
          flags.structure_event = true;
          break;
        case 23 /* ReorderSheet */:
          {
            const sheets = [];
            const target = this.model.sheets.list[command.index];
            for (let i = 0; i < this.model.sheets.length; i++) {
              if (i !== command.index) {
                if (i === command.move_before) {
                  sheets.push(target);
                }
                sheets.push(this.model.sheets.list[i]);
              }
            }
            if (command.move_before >= this.model.sheets.length) {
              sheets.push(target);
            }
            this.model.sheets.Assign(sheets);
            flags.sheets = true;
            flags.structure_event = true;
          }
          break;
        case 22 /* RenameSheet */:
          {
            const sheet = this.ResolveSheet(command);
            if (sheet) {
              this.RenameSheetInternal(sheet, command.new_name);
              flags.sheets = true;
              flags.structure_event = true;
            }
          }
          break;
        case 3 /* ResizeRows */:
          {
            const area = this.ResizeRowsInternal(command);
            if (area) {
              if (area.start.sheet_id === this.active_sheet.id) {
                const real_area = this.active_sheet.RealArea(new Area(area.start, area.end));
                flags.render_area = Area.Join(real_area, flags.render_area);
                flags.data_area = Area.Join(real_area, flags.data_area);
                flags.data_event = true;
              } else {
                flags.data_event = true;
                if (!flags.pending) {
                  flags.pending = [];
                }
                if (area.start.sheet_id) {
                  flags.pending.push(area.start.sheet_id);
                }
              }
            }
            flags.structure_event = true;
          }
          break;
        case 4 /* ResizeColumns */:
          this.ResizeColumnsInternal(command);
          flags.structure_event = true;
          break;
        case 17 /* ShowHeaders */:
          this.active_sheet.SetHeaderSize(command.show ? void 0 : 1, command.show ? void 0 : 1);
          this.flags.layout = true;
          this.flags.repaint = true;
          break;
        case 1 /* InsertRows */:
          this.InsertRowsInternal(command);
          flags.structure_event = true;
          flags.structure_rebuild_required = true;
          break;
        case 2 /* InsertColumns */:
          this.InsertColumnsInternal(command);
          flags.structure_event = true;
          flags.structure_rebuild_required = true;
          break;
        case 14 /* SetLink */:
        case 13 /* SetNote */:
          {
            const sheet = this.FindSheet(command.area);
            let cell = sheet.cells.GetCell(command.area, true);
            if (cell) {
              let area;
              if (cell.merge_area) {
                area = new Area(cell.merge_area.start);
                cell = sheet.cells.GetCell(cell.merge_area.start, true);
              } else {
                area = new Area(command.area);
              }
              if (command.key === 13 /* SetNote */) {
                cell.SetNote(command.note);
              } else {
                cell.hyperlink = command.reference || void 0;
                cell.render_clean = [];
              }
              if (sheet === this.active_sheet) {
                flags.style_area = Area.Join(area, flags.style_area);
                flags.render_area = Area.Join(area, flags.render_area);
              } else {
                flags.style_event = true;
              }
            }
          }
          break;
        case 27 /* SortTable */:
          {
            const area = this.SortTableInternal(command);
            if (area && area.start.sheet_id === this.active_sheet.id) {
              flags.data_area = Area.Join(area, flags.data_area);
              if (this.options.repaint_on_cell_change) {
                flags.render_area = Area.Join(area, flags.render_area);
              }
            } else {
              flags.data_event = true;
            }
          }
          break;
        case 6 /* SetRange */:
          {
            const area = this.SetRangeInternal(command, flags);
            if (area) {
              const sheet = this.model.sheets.Find(area.start.sheet_id || this.active_sheet.id);
              const tables = sheet?.TablesFromArea(area, true) || [];
              for (const table of tables) {
                this.UpdateTableColumns(table);
              }
            }
            if (area && area.start.sheet_id === this.active_sheet.id) {
              flags.data_area = Area.Join(area, flags.data_area);
              if (this.options.repaint_on_cell_change) {
                flags.render_area = Area.Join(area, flags.render_area);
              }
            } else {
              flags.data_event = true;
            }
          }
          break;
        case 20 /* DeleteSheet */:
          this.DeleteSheetInternal(command);
          flags.sheets = true;
          flags.structure_event = true;
          flags.structure_rebuild_required = true;
          break;
        case 19 /* DuplicateSheet */:
          this.DuplicateSheetInternal(command);
          flags.sheets = true;
          flags.structure_event = true;
          flags.structure_rebuild_required = true;
          break;
        case 18 /* AddSheet */:
          {
            const id = this.AddSheetInternal(command.name, command.insert_index);
            if (typeof id === "number" && command.show) {
              this.ActivateSheetInternal({
                key: 21 /* ActivateSheet */,
                id
              });
            }
            flags.structure_event = true;
            flags.sheets = true;
            flags.structure = true;
          }
          break;
        case 21 /* ActivateSheet */:
          this.ActivateSheetInternal(command);
          break;
        default:
          console.warn(`unhandled command: ${CommandKey[command.key]} (${command.key})`);
      }
    }
    if (flags.data_area) {
      if (!flags.data_area.start.sheet_id) {
        flags.data_area.SetSheetID(this.active_sheet.id);
      }
      events.push({ type: "data", area: flags.data_area });
    } else if (flags.data_event) {
      events.push({ type: "data" });
    }
    if (flags.style_area) {
      if (!flags.style_area.start.sheet_id) {
        flags.style_area.SetSheetID(this.active_sheet.id);
      }
      events.push({ type: "style", area: flags.style_area });
    } else if (flags.style_event) {
      events.push({ type: "style" });
    }
    if (flags.structure_event) {
      events.push({
        type: "structure",
        rebuild_required: flags.structure_rebuild_required,
        conditional_format: flags.conditional_formatting_event
      });
    }
    if (this.batch) {
      this.batch_events.push(...events);
    } else {
      this.grid_events.Publish(events);
    }
    return flags;
  }
};

// treb-grid/src/editors/external_editor.ts
var ExternalEditor = class extends Editor {
  get active() {
    return this.nodes.length > 0;
  }
  Reset() {
    this.AttachNodes();
  }
  /**
   * attach to a set of nodes (one is fine). 
   * 
   * FIXME: since this is not used in subclasses for ICE and formula bar,
   * perhaps we should move it into a new subclass specifically for 
   * external editor. we can add some flags as well. TODO/FIXME
   * 
   * update modifying how this works. we will now watch focus ourselves.
   */
  AttachNodes(nodes = [], assume_formula = true) {
    this.assume_formula = assume_formula;
    let descriptors = [];
    descriptors = nodes.map((node) => {
      for (const compare of this.nodes) {
        if (compare.node === node) {
          return compare;
        }
      }
      return { node };
    });
    for (const descriptor of this.nodes) {
      if (descriptor.listeners) {
        for (const [key, value] of descriptor.listeners.entries()) {
          descriptor.node.removeEventListener(key, value);
        }
        descriptor.listeners.clear();
      }
    }
    this.nodes = descriptors;
    for (const descriptor of this.nodes) {
      if (descriptor.formatted_text === descriptor.node.textContent) {
        const test = descriptor.node.innerHTML.length;
        if (descriptor.check !== test) {
          descriptor.formatted_text = void 0;
        }
      }
      if (descriptor.node.ownerDocument.activeElement === descriptor.node) {
        this.active_editor = descriptor;
      }
      this.UpdateText(descriptor, { toll_events: true });
      this.RegisterListener(descriptor, "focusin", () => {
        this.active_editor = descriptor;
      });
      this.RegisterListener(descriptor, "focusout", () => {
        this.active_editor = void 0;
      });
      this.RegisterListener(descriptor, "input", (event) => {
        if (event.isTrusted) {
          this.UpdateText(descriptor);
          this.UpdateColors();
        }
      });
    }
    this.UpdateColors(true);
  }
};

// treb-grid/src/types/grid.ts
var Grid = class extends GridBase {
  // --- public members --------------------------------------------------------
  hide_selection = false;
  // new...
  headless = false;
  get scale() {
    return this.layout.scale;
  }
  set scale(value) {
    this.layout.scale = value;
    this.UpdateLayout();
    this.UpdateAnnotationLayout();
    this.layout.UpdateAnnotation(this.active_sheet.annotations);
    this.layout.ApplyTheme(this.theme);
    this.overlay_editor?.UpdateScale(value);
    this.tab_bar?.UpdateScale(value);
    this.grid_events.Publish({
      type: "scale",
      scale: value
    });
    for (const sheet of this.model.sheets.list) {
      for (const annotation of sheet.annotations) {
        annotation.dirty = true;
      }
    }
  }
  /**
   * the theme object exists so we can pass it to constructors for
   * various components, but it's no longer initialized until the
   * initialization step (when we have a node).
   */
  theme;
  // ExtendedTheme;
  // --- private members -------------------------------------------------------
  /** 
   * maps common language (english) -> local language. this should 
   * be passed in (actually set via a function).
   */
  language_map;
  /**
   * maps local language -> common (english). this should be constructed
   * when the forward function is passed in, so there's a 1-1 correspondence.
   */
  reverse_language_map;
  // testing
  hover_data = {};
  /** are we editing? */
  editing_state = 0 /* NotEditing */;
  /** if we are editing, what is the cell? */
  editing_cell = { row: -1, column: -1, sheet_id: 0 };
  /**  */
  selected_annotation;
  /** */
  editing_annotation;
  /** */
  view_node;
  /** containing element, passed in */
  container;
  /** dom structure for grid */
  layout;
  /**
   * this flag is used to lazily rebuild tiles. that prevents flashing if
   * there is a lot of work between a reset/document change and the next
   * paint call.
   */
  tile_update_pending = false;
  scroll_offset_pending;
  /**
   * for coediting/remotes, we may make a structural change that requires
   * a full repaint of another sheet -- we won't be able to do that until
   * the sheet is displayed. so let's keep track of these. 
   * 
   * these are numbers so we can use a sparse array. (or we could use a set...)
   */
  pending_layout_update = /* @__PURE__ */ new Set();
  /* *
   * spreadsheet language parser. used to pull out address
   * references from functions, for highlighting
   * 
   * ...
   * 
   * it's used for lots of stuff now, in addition to highlighting.
   * copy/paste with translation; csv; defines; and some other stuff.
   * still would like to share w/ parent though, if possible.
   * 
   * 
   * FIXME: need a way to share/pass parser flags
   * UPDATE: sharing parser w/ owner (embedded sheet)
   * /
  private parser;
    */
  /** this is used when testing if a typed character is numeric */
  decimal_separator_code = 46;
  // "."
  /** new key capture overlay/ICE */
  overlay_editor;
  /** moving autocomplete to a class field */
  autocomplete;
  /** formula bar editor (optional) */
  formula_bar;
  RESIZE_PIXEL_BUFFER = 5;
  /**
   * formalizing the concept of external selection to support outside tooling.
   * 
   * FIXME: stop testing on this field. we need a better way to figure out
   * if the external editor is active.
   */
  external_editor_config;
  /**
   * support for external editor. created on demand.
   */
  external_editor;
  /**
   * flag indicating we're resizing, or hovering over a resize.
   * we use this so we know what to do when we see a click on the headers.
   */
  cell_resize = { row: -1, column: -1 };
  /**
   * this is the only thing that was used in the old 'render state',
   * so we dropped the container.
   */
  render_tiles = new Area({ row: 0, column: 0 });
  // primary and active selections now _always_ exist. we use flags
  // to indicate that they're empty (i.e. nothing is selected). this
  // allows us to pass and test actual objects.
  //
  // like const, readonly only affects the immediate property and not
  // subproperties. so here we use it to ensure selections are never
  // reassigned or deassigned.
  /**
   * the main selection for interacting with the spreadsheet
   */
  primary_selection = {
    target: { row: 0, column: 0 },
    area: new Area({ row: 0, column: 0 }),
    empty: true
  };
  /**
   * active selection when selecting arguments (while editing)
   */
  active_selection = {
    target: { row: 0, column: 0 },
    area: new Area({ row: 0, column: 0 }),
    empty: true
  };
  /**
   * this flag is for testing if we were previously in the nub
   */
  nub_select_flag = false;
  /**
   * additional selections that are rendered but not otherwise used.
   * this array is now readonly, so we can bind it to the selection
   * renderer (we do this with the primary selection as well)
   */
  additional_selections = [];
  /**
   * state data for handling double-clicks. because we're using
   * mousedown, we need to synthesize double-clicks with a timeout.
   */
  double_click_data = {};
  /**
   * window timer/request animation frame token. this is used to prevent
   * excess repaints on scroll. FIXME: can this merge with the delayed
   * render token? I think originally it was separate because that other
   * method was too slow for scrolling... maybe...
   */
  layout_token = 0;
  /** window timer/request animation frame token */
  render_token = 0;
  /** */
  tile_renderer;
  /** */
  selection_renderer;
  // FIXME: move [why?]
  tab_bar;
  DOM = DOMContext.GetInstance();
  // --- constructor -----------------------------------------------------------
  /**
   * FIXME: NO PARAMETER INITIALIZATIONS
   */
  constructor(options = {}, model, theme = DefaultTheme, initialze_dom = true, DOM) {
    super(options, model);
    this.decimal_separator_code = Localization.decimal_separator.charCodeAt(0);
    this.theme = JSON.parse(JSON.stringify(theme));
    if (!initialze_dom) {
      this.headless = true;
      this.layout = new MockLayout(this.model, this.view);
      return;
    }
    this.DOM = DOM;
    this.layout = new GridLayout(this.model, this.view, DOM);
    if (options.initial_scale) {
      if (typeof options.initial_scale === "string") {
        options.initial_scale = Number(options.initial_scale);
      }
      this.layout.scale = options.initial_scale;
    }
    this.tile_renderer = new TileRenderer(
      this.theme,
      this.layout,
      this.model,
      this.view,
      this.options
    );
    this.selection_renderer = new SelectionRenderer(
      this.theme,
      this.layout,
      this.model,
      this.view,
      this.primary_selection,
      this.additional_selections
    );
  }
  // --- public methods --------------------------------------------------------
  /**
   * set the language translation map. this is a set of function names 
   * (in english) -> the local equivalent. both should be in canonical form,
   * as that will be used when we translate one way or the other.
   */
  SetLanguageMap(language_map) {
    if (!language_map) {
      this.language_map = this.reverse_language_map = void 0;
    } else {
      const keys = Object.keys(language_map);
      this.language_map = {};
      for (const key of keys) {
        this.language_map[key.toUpperCase()] = language_map[key];
      }
      this.reverse_language_map = {};
      for (const key of keys) {
        const value = language_map[key];
        this.reverse_language_map[value.toUpperCase()] = key;
      }
    }
    if (!this.primary_selection.empty) {
      this.Select(this.primary_selection, this.primary_selection.area, this.primary_selection.target);
    }
  }
  /**
   * set note at the given address, or current selection
   * @param address optional address; if not used, note will be set/cleared
   * at current selection
   * @param note new note, or undefined to clear note
   */
  SetNote(address, note) {
    if (!address) {
      if (this.primary_selection.empty)
        return;
      address = this.primary_selection.target;
    }
    this.ExecCommand({
      key: 13 /* SetNote */,
      area: address,
      note
    });
  }
  /** find an annotation, given a node */
  FindAnnotation(node) {
    for (const annotation of this.active_sheet.annotations) {
      const view = annotation.view[this.view_index] || {};
      if (view.node === node) {
        return annotation;
      }
    }
    return void 0;
  }
  /**
   * create an annotation, with properties, without an original object.
   * optionally (and by default) add to sheet.
   *
   * @param offset check for a matching position (top-left) and if found,
   * shift by (X) pixels. intended for copy-paste, where we don't want to
   * paste immediately on top of the original.
   * 
   * @param target new parameter allows setting annotation as rect or as
   * cell range
   */
  CreateAnnotation(properties = {}, add_to_sheet = true, offset = false, target) {
    const annotation = new Annotation(properties);
    if (offset) {
      if (!annotation.data.layout && annotation.scaled_rect) {
        annotation.data.layout = this.layout.RectToAnnotationLayout(annotation.scaled_rect);
      }
      if (!annotation.data.layout) {
        console.warn(`can't offset annotation without layout`);
      } else {
        let target_rect = this.layout.AnnotationLayoutToRect(annotation.data.layout).Shift(20, 20);
        let recheck = true;
        while (recheck) {
          recheck = false;
          for (const test of this.active_sheet.annotations) {
            if (test === annotation) {
              continue;
            }
            if (test.scaled_rect && test.scaled_rect.top === target_rect.top && test.scaled_rect.left === target_rect.left) {
              target_rect = target_rect.Shift(20, 20);
              recheck = true;
              break;
            }
          }
        }
        annotation.data.layout = this.layout.RectToAnnotationLayout(target_rect);
      }
    }
    if (target) {
      if (Rectangle.IsRectangle(target)) {
        annotation.data.layout = void 0;
        annotation.rect = Rectangle.Create(target);
      } else if (target.start) {
        annotation.rect = void 0;
        annotation.data.layout = this.layout.AddressToAnnotationLayout(target.start, target.end || target.start);
      }
    }
    if (add_to_sheet) {
      if (!this.active_sheet.annotations.some((test) => test === annotation)) {
        this.active_sheet.annotations.push(annotation);
      }
      this.AddAnnotation(annotation);
    }
    return annotation;
  }
  /** placeholder */
  UpdateAnnotationLayout() {
  }
  /** add an annotation. it will be returned with a usable node. */
  AddAnnotation(annotation, toll_events = false, add_to_layout = true) {
    let view = annotation.view[this.view_index];
    if (!view) {
      view = {};
      annotation.view[this.view_index] = view;
    }
    if (!view.node) {
      const node = this.DOM.Div("annotation", void 0, {
        data: { scale: this.layout.scale.toString() },
        style: { fontSize: `${10 * this.layout.scale}pt` },
        attrs: { tabindex: "-1" },
        events: {
          mousedown: (event) => {
            if (event.button !== 0) {
              return;
            }
            this.layout.AnnotationMouseDown(annotation, node, event, move_target, resize_target).then((event2) => {
              if (event2) {
                this.grid_events.Publish(event2);
              }
              if (annotation.data.layout) {
                this.EnsureAddress(annotation.data.layout.br.address, 1);
              }
            });
          },
          focusin: () => {
            for (const element of this.layout.GetFrozenAnnotations(annotation)) {
              element.classList.add("clone-focus");
            }
            this.selected_annotation = annotation;
            this.primary_selection.empty = true;
            this.primary_selection.target = { row: -1, column: -1, sheet_id: this.active_sheet.id };
            this.HideGridSelection();
          },
          focusout: (event) => {
            for (const element of this.layout.GetFrozenAnnotations(annotation)) {
              element.classList.remove("clone-focus");
            }
            if (this.formula_bar && this.formula_bar.IsElement(event.relatedTarget)) {
              this.primary_selection.empty = true;
              this.RenderSelections();
              this.editing_annotation = annotation;
              this.layout.ShowSelections(true);
            } else {
              if (this.selected_annotation === annotation) {
                this.selected_annotation = void 0;
              }
              this.ShowGridSelection();
            }
          }
        }
      });
      view.node = node;
      view.content_node = this.DOM.Div("annotation-content", node);
      const move_target = this.DOM.Div("annotation-move-target", node);
      const resize_target = this.DOM.Div("annotation-resize-target", node);
      node.addEventListener("keydown", (event) => {
        const rect = annotation.scaled_rect;
        if (!rect) {
          console.info("missing scaled rect!");
          return;
        }
        const elements = [node, ...this.layout.GetFrozenAnnotations(annotation)];
        const target = { x: rect.left, y: rect.top };
        switch (event.key) {
          case "ArrowUp":
          case "Up":
            if (event.ctrlKey) {
              if (this.layout.AnnotationLayoutOrder(annotation, 1)) {
                this.grid_events.Publish({ type: "annotation", event: "move", annotation });
              }
              node.focus();
            } else {
              target.y--;
            }
            break;
          case "ArrowLeft":
          case "Left":
            if (event.ctrlKey) {
              return;
            } else {
              target.x--;
            }
            break;
          case "ArrowRight":
          case "Right":
            if (event.ctrlKey) {
              return;
            } else {
              target.x++;
            }
            break;
          case "ArrowDown":
          case "Down":
            if (event.ctrlKey) {
              if (this.layout.AnnotationLayoutOrder(annotation, -1)) {
                this.grid_events.Publish({ type: "annotation", event: "move", annotation });
              }
              node.focus();
            } else {
              target.y++;
            }
            break;
          case "Escape":
          case "Esc":
            this.Focus();
            break;
          case "Backspace":
            if (event.metaKey && UA.is_mac) {
              this.Focus();
              this.RemoveAnnotation(annotation);
            }
            break;
          case "Delete":
          case "Del":
            this.Focus();
            this.RemoveAnnotation(annotation);
            break;
          default:
            return;
        }
        event.stopPropagation();
        event.preventDefault();
        target.x = Math.max(target.x, 0);
        target.y = Math.max(target.y, 0);
        if (rect.left !== target.x || rect.top !== target.y) {
          rect.left = Math.round(target.x);
          rect.top = Math.round(target.y);
          for (const element of elements) {
            element.style.top = rect.top + "px";
            element.style.left = rect.left + "px";
          }
          annotation.data.extent = void 0;
          this.grid_events.Publish({ type: "annotation", event: "move", annotation });
          annotation.data.layout = this.layout.RectToAnnotationLayout(rect);
        }
      });
    }
    if (add_to_layout) {
      this.layout.AddAnnotation(annotation);
      if (annotation.data.layout) {
        this.EnsureAddress(annotation.data.layout.br.address, 1);
      }
    } else {
    }
    if (!toll_events) {
      this.grid_events.Publish({
        type: "annotation",
        annotation,
        event: "create"
      });
    }
  }
  /**
   * call this method if an annotation is updated externally -- we're not 
   * watching for mutation, so if they change and we need to update, we
   * won't know about it unless you tell us. sometimes this will be 
   * superfluous but (assuming it's one at a time) should not be too expensive
   */
  AnnotationUpdated(annotation) {
    this.layout.CloneFrozenAnnotation(annotation);
  }
  /**
   * removes an annotation from the list, and removes the node its
   * the parent (although the node still exists in the annotation, if
   * it existed before).
   */
  RemoveAnnotation(annotation) {
    for (let i = 0; i < this.active_sheet.annotations.length; i++) {
      if (annotation === this.active_sheet.annotations[i]) {
        this.active_sheet.annotations.splice(i, 1);
        this.layout.RemoveAnnotation(annotation);
        this.grid_events.Publish({
          type: "annotation",
          annotation,
          event: "delete"
        });
        return;
      }
    }
  }
  /**
   * this method removes annotation nodes from the grid/layout, but doesn't
   * affect the underlying data. this should be used to remove annotations
   * when switching sheets.
   *
   * you can also use it when cleaning up, if the underlying data will also
   * be wiped from the model.
   */
  RemoveAnnotationNodes() {
    if (!this.headless) {
      this.layout.RemoveAnnotationNodes();
    }
  }
  /**
   * specialization: update selection, scroll offset
   */
  Serialize(options = {}) {
    this.active_sheet.selection = JSON.parse(JSON.stringify(this.primary_selection));
    this.active_sheet.scroll_offset = this.layout.scroll_offset;
    return super.Serialize(options);
  }
  /**
   * show or hide headers
   * 
   * FIXME: this shouldn't be sent if the current value === the desired value
   * 
   * FIXME: this is a display option. I'm not sure it should go through the 
   * command queue, because it's a local choice. leaving for now, but FIXME
   */
  ShowHeaders(show = true) {
    this.ExecCommand({
      key: 17 /* ShowHeaders */,
      show
    });
  }
  /** 
   * this method is called after an XLSX import.
   * 
   * FIXME: should this not be in base? (...)
   * 
   * I suppose it's specific to an environment that _could_ import XLSX, 
   * so it's not strictly speaking generic.
   */
  FromImportData(import_data, render = false) {
    this.RemoveAnnotationNodes();
    const sheet_data = import_data.sheets;
    const base_sheets = sheet_data.map(() => {
      return Sheet.Blank(this.model.theme_style_properties).toJSON();
    });
    let visible_sheet;
    if (typeof import_data.active_tab === "number") {
      visible_sheet = base_sheets[import_data.active_tab]?.id;
    } else {
      for (let i = 0; i < import_data.sheets.length; i++) {
        if (!import_data.sheets[i].hidden) {
          visible_sheet = base_sheets[i].id;
          break;
        }
      }
    }
    this.UpdateSheets(base_sheets, true, visible_sheet);
    const name_map2 = {};
    this.model.macro_functions.clear();
    this.ClearSelection(this.primary_selection);
    this.model.tables.clear();
    for (let i = 0; i < sheet_data.length; i++) {
      const sheet = this.model.sheets.list[i];
      sheet.ImportData(sheet_data[i]);
      name_map2[sheet.name] = sheet.id;
      for (const cell of sheet_data[i].cells) {
        if (cell.table) {
          cell.table.area.start.sheet_id = sheet.id;
          this.model.tables.set(cell.table.name.toLowerCase(), cell.table);
        }
      }
      for (const table of this.model.tables.values()) {
        this.UpdateTableColumns(table);
      }
    }
    this.model.sheets.UpdateIndexes();
    this.model.named_ranges.Reset();
    this.model.named_expressions.clear();
    if (import_data.names) {
      for (const name of Object.keys(import_data.names)) {
        const validated = this.model.named_ranges.ValidateNamed(name);
        if (!validated) {
          console.warn(`invalid name: ${name}`);
          continue;
        }
        const label = import_data.names[name];
        if (typeof label === "number") {
        } else {
          const parse_result = this.parser.Parse(label);
          if (parse_result.expression) {
            if (parse_result.expression.type === "range") {
              const sheet_id = name_map2[parse_result.expression.start.sheet || ""];
              if (sheet_id) {
                parse_result.expression.start.sheet_id = sheet_id;
                this.model.named_ranges.SetName(validated, new Area(parse_result.expression.start, parse_result.expression.end), false);
              }
            } else if (parse_result.expression.type === "address") {
              const sheet_id = name_map2[parse_result.expression.sheet || ""];
              if (sheet_id) {
                parse_result.expression.sheet_id = sheet_id;
                this.model.named_ranges.SetName(validated, new Area(parse_result.expression), false);
              }
            } else {
              const expr = parse_result.expression;
              this.parser.Walk(expr, (unit) => {
                if (unit.type === "address" || unit.type === "range") {
                  if (unit.type === "range") {
                    unit = unit.start;
                  }
                  if (!unit.sheet_id) {
                    unit.sheet_id = name_map2[unit.sheet || ""] || 0;
                  }
                  return false;
                }
                return true;
              });
              this.model.named_expressions.set(validated, expr);
            }
          }
        }
      }
      this.model.named_ranges.RebuildList();
    }
    for (const element of this.active_sheet.annotations) {
      this.AddAnnotation(element, true);
    }
    this.ActivateSheetTasks();
    this.QueueLayoutUpdate();
    this.StyleDefaultFromTheme();
    if (render) {
      this.Repaint(false, false);
    }
    if (this.tab_bar) {
      this.tab_bar.Update();
    }
  }
  /**
   * This function is called via Shift+PageUp/PageDown. We need
   * to update to account for hidden sheets, which can't be activated.
   */
  NextSheet(step = 1) {
    if (this.model.sheets.length === 1) {
      return;
    }
    const visible = this.model.sheets.list.map((sheet, index) => ({ sheet, index })).filter((test) => test.sheet.visible);
    if (visible.length === 1) {
      return;
    }
    for (let i = 0; i < visible.length; i++) {
      if (visible[i].sheet === this.active_sheet) {
        let index = (i + step) % visible.length;
        while (index < 0) {
          index += visible.length;
        }
        this.ActivateSheet(visible[index].index);
        return;
      }
    }
  }
  /** 
   * UpdateSheets means "set these as the sheets, drop any old stuff".
   * there's an implicit reset (in fact we may do that twice in some
   * cases).
   * 
   */
  UpdateSheets(data, render = false, activate_sheet) {
    super.UpdateSheets(data, render, activate_sheet);
    this.RemoveAnnotationNodes();
    this.ClearSelection(this.primary_selection);
    if (data[0] && data[0].primary_selection) {
      const selection = data[0].primary_selection;
      if (!selection.empty) {
        this.Select(
          this.primary_selection,
          new Area(selection.area.start, selection.area.end),
          selection.target
        );
      }
    } else if (!this.active_sheet.selection.empty) {
      const template = this.active_sheet.selection;
      this.Select(
        this.primary_selection,
        new Area(template.area.start, template.area.end),
        template.target
      );
    }
    this.layout.ClearLayoutCaches();
    for (const sheet of this.model.sheets.list) {
      for (const annotation of sheet.annotations) {
        this.AddAnnotation(annotation, true, sheet === this.active_sheet);
      }
    }
    this.ActivateSheetTasks();
    this.QueueLayoutUpdate(JSON.parse(JSON.stringify(this.active_sheet.scroll_offset)));
    this.StyleDefaultFromTheme();
    if (render) {
      this.Repaint(false, false);
    }
    if (this.tab_bar) {
      this.tab_bar.Update();
    }
  }
  /**
   * rebuild layout on a resize. we are not trapping resize events, clients
   * should do that (also this works for embedded elements that are not
   * directly affected by document resize).
   */
  UpdateLayout() {
    this.layout.UpdateTiles();
    this.render_tiles = this.layout.VisibleTiles();
    this.Repaint(true);
  }
  /**
   * @param initial first call, from the grid Initialize() method
   */
  UpdateTheme(initial = false, additional_properties) {
    if (!initial) {
      for (const key of Object.keys(this.theme)) {
        delete this.theme[key];
      }
    }
    let composite = JSON.parse(JSON.stringify(DefaultTheme));
    if (this.view_node) {
      const theme_properties = LoadThemeProperties(this.view_node);
      composite = { ...theme_properties };
    }
    composite = {
      // ...theme_properties,
      ...this.theme,
      ...composite,
      ...additional_properties
    };
    Object.assign(this.theme, composite);
    this.StyleDefaultFromTheme();
    this.active_sheet.UpdateDefaultRowHeight();
    this.active_sheet.FlushCellStyles();
    this.layout.ApplyTheme(this.theme);
    if (!initial) {
      this.UpdateLayout();
      this.overlay_editor?.UpdateScale(this.layout.scale);
      this.Repaint(true, true, true);
    }
  }
  /**
   * @param container html container element
   */
  Initialize(view_node, toll_initial_render = false) {
    if (!this.tile_renderer || !this.selection_renderer) {
      return;
    }
    this.view_node = view_node;
    this.UpdateTheme(true);
    const higher_level_container = view_node.querySelector(".treb-spreadsheet-body");
    const container = higher_level_container.querySelector("div");
    if (this.options.formula_bar) {
      if (!this.autocomplete) {
        this.autocomplete = new Autocomplete({ theme: this.theme, container });
      }
      this.InitFormulaBar(view_node, this.autocomplete);
    }
    if (this.options.tab_bar) {
      this.tab_bar = new TabBar(this.layout, this.model, this.view, this.options, view_node);
      this.tab_bar.Subscribe((event) => {
        switch (event.type) {
          case "cancel":
            break;
          case "scale":
            {
              let scale = this.layout.scale;
              scale = Math.round(event.value * 1e3) / 1e3;
              scale = Math.min(2, Math.max(scale, 0.5));
              if (this.options.persist_scale_key) {
                localStorage.setItem(this.options.persist_scale_key, JSON.stringify({ scale }));
              }
              this.scale = scale;
              if (event.keep_focus) {
                return;
              }
            }
            break;
          case "reorder-sheet":
            this.ReorderSheet(event.index, event.move_before);
            break;
          case "delete-sheet":
            this.DeleteSheet();
            break;
          case "add-sheet":
            this.AddSheet();
            break;
          case "rename-sheet":
            this.RenameSheet(event.sheet, event.name);
            break;
          case "activate-sheet":
            this.ActivateSheetID(event.sheet.id);
            break;
        }
        if (!this.SelectingArgument()) {
          this.Focus();
        }
      });
    }
    this.container = container;
    this.container.classList.add("treb-grid");
    if (UA.is_mac && UA.is_safari) {
      this.container.classList.add("safari");
    }
    this.container.setAttribute("tabindex", "-1");
    this.layout.Initialize(
      container,
      {
        // scroll callback
        scroll: () => this.OnScroll(),
        // dropdown callback
        dropdown: (value) => this.OnDropdownSelect(value),
        // sort (table) callback
        sort: (name, column, asc) => {
          const table = this.model.tables.get(name.toLowerCase());
          if (table) {
            this.SortTable(table, {
              column,
              asc
            });
          }
        },
        // focus callback
        focus: () => this.Focus()
      },
      this.options.scrollbars
    );
    this.selection_renderer.Initialize();
    this.layout.UpdateTiles();
    if (!this.autocomplete) {
      this.autocomplete = new Autocomplete({ theme: this.theme, container });
    }
    this.InitOverlayEditor(this.autocomplete);
    this.AttachListeners();
    this.render_tiles = this.layout.VisibleTiles();
    if (!toll_initial_render) {
      this.tab_bar?.Update();
      this.Repaint(true);
    }
  }
  /**
   * merge target area or selection
   */
  MergeCells(area) {
    if (!area && this.primary_selection.empty) {
      return;
    }
    this.layout.HideDropdownCaret();
    this.ExecCommand({
      key: 9 /* MergeCells */,
      area: area || this.primary_selection.area
    });
  }
  /**
   * unmerge cells
   */
  UnmergeCells(area) {
    if (!area && this.primary_selection.empty) {
      return;
    }
    this.layout.HideDropdownCaret();
    this.ExecCommand({
      key: 10 /* UnmergeCells */,
      area: area || this.primary_selection.area
    });
  }
  /**
   * focus on the container. you must call this method to get copying
   * to work properly (because it creates a selection)
   */
  Focus(text = "") {
    if (UA.is_mobile) {
      this.container?.focus();
    } else {
      this.overlay_editor?.Focus(text);
    }
  }
  /**
   * set "data validation", which (atm) only supports a list of options
   * and will render as a dropdown; the list can be a list of values or
   * a range reference.
   */
  SetValidation(target, data, error) {
    if (!target) {
      if (this.primary_selection.empty) {
        throw new Error("invalid target in set validation");
      }
      target = this.primary_selection.target;
    }
    const command = {
      key: 25 /* DataValidation */,
      area: target,
      error
    };
    if (data) {
      if (Array.isArray(data)) {
        command.list = data;
      } else if (typeof data === "object") {
        if (data.start && data.end && IsCellAddress(data.start) && IsCellAddress(data.end)) {
          command.range = data;
        }
      }
    }
    this.ExecCommand(command);
    if (!this.primary_selection.empty && (!target.sheet_id || target.sheet_id === this.active_sheet.id) && this.primary_selection.target.row === target.row && this.primary_selection.target.column === target.column) {
      requestAnimationFrame(() => this.Select(
        this.primary_selection,
        this.primary_selection.area,
        this.primary_selection.target
      ));
    }
  }
  /**
   * set or clear name
   */
  SetName(name, range, expression) {
    const validated = this.model.named_ranges.ValidateNamed(name);
    if (!validated) {
      throw new Error("invalid name");
    }
    const compare = name.trim().toUpperCase();
    if (this.autocomplete_matcher) {
      for (const name2 of Object.keys(this.autocomplete_matcher.function_map)) {
        if (compare === name2.toUpperCase()) {
          if (range || expression) {
            throw new Error("name already defined");
          }
          break;
        }
      }
    }
    name = validated;
    const command = {
      key: 16 /* SetName */,
      name
    };
    if (range) {
      if (IsCellAddress(range)) {
        range = new Area(range);
      }
      if (!range.start.sheet_id) {
        range = new Area(
          { ...range.start, sheet_id: this.active_sheet.id },
          range.end
        );
      }
      command.area = new Area(range.start, range.end);
    } else if (expression) {
      const parse_result = this.parser.Parse(expression);
      if (parse_result.valid && parse_result.expression) {
        this.parser.Walk(parse_result.expression, (unit) => {
          if (unit.type === "address" || unit.type === "range") {
            if (unit.type === "range") {
              unit = unit.start;
            }
            if (!unit.sheet_id) {
              if (unit.sheet) {
                const sheet = this.model.sheets.Find(unit.sheet);
                if (sheet) {
                  unit.sheet_id = sheet.id;
                }
              }
            }
            if (!unit.sheet_id) {
              unit.sheet_id = this.active_sheet.id;
            }
            return false;
          }
          return true;
        });
        command.expression = parse_result.expression;
      } else {
        throw new Error("invalid expression");
      }
    }
    this.ExecCommand(command);
  }
  SelectAll() {
    this.Select(this.primary_selection, new Area({ row: Infinity, column: Infinity }), void 0, true);
    this.RenderSelections();
  }
  /**
   * set or remove external editor. this is not an accessor because I don't
   * want to have to use a duplicate internal field, it's clumsy and this
   * class isn't public-facing so it's not super important.
   */
  ExternalEditor(config) {
    this.external_editor_config = config;
    if (config) {
      const areas = (config.dependencies || []).filter(
        (test) => !!test
      ).map((reference) => IsCellAddress(reference) ? new Area(reference) : new Area(reference.start, reference.end));
      if (config.nodes?.length) {
        if (!this.external_editor) {
          const editor = new ExternalEditor(this.model, this.view);
          this.external_editor = editor;
          editor.Subscribe((event) => this.HighlightDependencies(editor.dependencies));
        }
        this.external_editor.AttachNodes(config.nodes, config.assume_formula ?? true);
      } else {
        if (this.external_editor) {
          this.external_editor.Reset();
        }
      }
      if (config.dependencies) {
        this.HighlightDependencies(areas);
      }
    } else {
      if (this.external_editor) {
        this.external_editor.Reset();
      }
      this.ClearAdditionalSelections();
      this.RenderSelections(true);
    }
  }
  /** API method */
  SelectRange(range) {
    this.Select(this.primary_selection, range);
    this.RenderSelections();
  }
  /* *
   * FIXME: who uses this? anyone?
   * /
  public GetNumberFormat(address: ICellAddress): string|undefined {
    const style = this.active_sheet.CellStyleData(address);
    if (style && style.number_format) {
      return NumberFormatCache.Get(style.number_format).toString();
    }
  }
  */
  /**
   * I can't figure out a way in typescript to overload the GetRange function 
   * but call it with a variable to determine the overload (the aim is to have
   * different return types).
   * 
   * it seems to work fine if we use static values for the parameter (type, 
   * below) but not a variable which is (theoretically) type-restricted to the
   * same values. One to work on, maybe.
   * 
   * @param range 
   * @returns 
   */
  GetRangeStyle(range, apply_theme = false) {
    let sheet_id = 0;
    if (IsCellAddress(range)) {
      sheet_id = range.sheet_id || this.active_sheet.id;
    } else {
      sheet_id = range.start.sheet_id || this.active_sheet.id;
    }
    if (sheet_id) {
      const sheet = this.model.sheets.Find(sheet_id);
      return sheet?.GetCellStyle(range, apply_theme) || void 0;
    }
    return void 0;
  }
  /**
   * get data in a given range, optionally formulas
   * API method
   */
  GetRange(range, type) {
    if (IsCellAddress(range)) {
      const sheet2 = this.model.sheets.Find(range.sheet_id || this.active_sheet.id);
      if (sheet2) {
        if (type === "formula") {
          return sheet2.cells.RawValue(range);
        }
        if (type === "formatted") {
          return sheet2.GetFormattedRange(range);
        }
        return sheet2.cells.GetRange(range);
      }
      return void 0;
    }
    const sheet = this.model.sheets.Find(range.start.sheet_id || this.active_sheet.id);
    if (sheet) {
      if (type === "formula") {
        return sheet.cells.RawValue(range.start, range.end);
      }
      if (type === "formatted") {
        return sheet.GetFormattedRange(range.start, range.end);
      }
      return sheet.cells.GetRange(range.start, range.end);
    }
    return void 0;
  }
  /**
   * set data in given range
   * API method
   *
   * not sure why we have support for ArrayBufferView in here. this is an API
   * method, called by the embed sheet's API method, so there are no particular
   * requirements. we should lock down the allowable types.
   * 
   * @param range target range. if range is smaller than data, range controls.
   * if range is larger, behavior depends on the recycle parameter.
   * @param data single value, array (column), or 2d array
   * @param recycle recycle values. we only recycle single values or single
   * rows/columns -- we will not recycle a matrix.
   * @param transpose transpose before inserting (data is column-major)
   * @param r1c1 - support R1C1 notation. this does not mean the data _is_ in
   * R1C1, just that we need to check for it and handle it. R1C1 is useful for
   * relative offsets.
   */
  SetRange(range, data, options = {}) {
    const { recycle, transpose, array, r1c1 } = options;
    if (options.argument_separator) {
      const current = {
        argument_separator: this.parser.argument_separator,
        decimal_mark: this.parser.decimal_mark
      };
      let convert = false;
      if (options.argument_separator === "," && this.parser.argument_separator !== "," /* Comma */) {
        this.parser.argument_separator = "," /* Comma */;
        this.parser.decimal_mark = "." /* Period */;
        convert = true;
      }
      if (options.argument_separator === ";" && this.parser.argument_separator !== ";" /* Semicolon */) {
        this.parser.argument_separator = ";" /* Semicolon */;
        this.parser.decimal_mark = "," /* Comma */;
        convert = true;
      }
      if (convert) {
        const Convert = (value) => {
          if (typeof value === "string" && value[0] === "=") {
            const result = this.parser.Parse(value);
            if (result.expression) {
              value = "=" + this.parser.Render(result.expression, {
                missing: "",
                convert_decimal: current.decimal_mark,
                convert_argument_separator: current.argument_separator
              });
            }
          }
          return value;
        };
        if (Array.isArray(data)) {
          data = data.map((entry) => {
            if (Array.isArray(entry)) {
              return entry.map((cell) => {
                return Convert(cell);
              });
            } else {
              return Convert(entry);
            }
          });
        } else {
          data = Convert(data);
        }
      }
      this.parser.argument_separator = current.argument_separator;
      this.parser.decimal_mark = current.decimal_mark;
    }
    data = this.UntranslateData(data);
    if (!Array.isArray(data)) {
      if (recycle || array) {
        this.ExecCommand({ key: 6 /* SetRange */, area: range, value: data, array, r1c1 });
      } else {
        this.ExecCommand({ key: 6 /* SetRange */, area: range.start, value: data, array, r1c1 });
      }
    } else {
      if (!Is2DArray(data)) {
        if (recycle) {
          const rows = range.entire_column ? this.active_sheet.rows : range.rows;
          const columns = range.entire_row ? this.active_sheet.columns : range.columns;
          const count = rows * columns;
          if (count > data.length) {
            let tmp = data.slice(0);
            const multiple = Math.ceil(count / tmp.length);
            for (let i = 1; i < multiple; i++) {
              tmp = tmp.concat(data.slice(0));
            }
            data = tmp;
          }
          const reshaped = [];
          for (let c = 0, index = 0; c < columns; c++, index += rows) {
            reshaped[c] = data.slice(index, index + rows);
          }
          data = reshaped;
        } else {
          data = [data];
        }
      }
      if (transpose) {
        data = this.Transpose(data);
      }
      this.ExecCommand({ key: 6 /* SetRange */, area: range, value: data, array, r1c1 });
    }
    if (!this.primary_selection.empty && range.Contains(this.primary_selection.target)) {
      this.UpdateFormulaBarFormula();
    }
  }
  /**
   * applies the given style properties to the passed array, or to the
   * current primary selection
   *
   * API method
   */
  ApplyStyle(area, properties = {}, delta = true) {
    if (!area) {
      if (this.primary_selection.empty) {
        return;
      } else
        area = this.primary_selection.area;
    }
    Sheet.UpdateStyle(properties);
    this.ExecCommand({
      key: 7 /* UpdateStyle */,
      area,
      style: properties,
      delta
    });
    this.UpdateFormulaBarFormula();
  }
  /**
   * returns the primary selection. we use a reference to the real selection
   * sp callers can track; however, you can break things if you modify it.
   * so don't modify it. FIXME: proxy view? (...)
   *
   * API method
   */
  GetSelection() {
    return this.primary_selection;
  }
  /** repaint after an external event (calculation) */
  Update(force = false, area) {
    this.DelayedRender(force, area);
  }
  /* *
     * API method
     *
     * @param area
     * @param borders
     * @param color
     * @param width
     * /
    public ApplyBorders(area?: Area, borders: BorderConstants = BorderConstants.None, color?: string, width = 1): void {
  
      if (!area) {
        if (this.primary_selection.empty) { return; }
        area = this.primary_selection.area;
      }
  
      if (borders === BorderConstants.None) {
        width = 0;
      }
  
      this.ExecCommand({
        key: CommandKey.UpdateBorders,
        color: { text: color },
        area,
        borders,
        width,
      });
  
    }
    */
  /** updated API method, probably change the name */
  ApplyBorders2(area, borders = "none" /* None */, color, width = 1) {
    if (!area) {
      if (this.primary_selection.empty) {
        return;
      }
      area = this.primary_selection.area;
    }
    if (borders === "none" /* None */) {
      width = 0;
    }
    this.ExecCommand({
      key: 8 /* UpdateBorders */,
      color,
      area,
      borders,
      width
    });
  }
  /**
   * batch updates. returns all the events that _would_ have been sent.
   * also does a paint (can disable).
   * @param func 
   */
  Batch(func, paint = true) {
    this.batch = true;
    func();
    this.batch = false;
    const events = this.batch_events.slice(0);
    this.batch_events = [];
    if (paint) {
      this.DelayedRender(false);
    }
    return events;
  }
  /**
   * scrolls so that the given cell is in the top-left (assuming that is
   * possible)
   */
  ScrollTo(address, x = true, y = true, smooth = false) {
    this.layout.ScrollTo(address, x, y, smooth);
  }
  /**
   * scrolls the given address into view (assuming it's not in view now)
   *
   * FIXME: we need a way to do this without scrolling the containing
   * page, in the event we do a scroll-on-load. small problem.
   */
  ScrollIntoView(address, smooth = false) {
    if (this.options.scrollbars) {
      this.layout.ScrollIntoView(address, smooth);
    }
  }
  GetScrollOffset() {
    return this.layout.GetScrollOffset();
  }
  /**
   * get/set the raw scroll offset (ignoring headers). support for API method.
   * @param offset 
   */
  ScrollOffset(offset) {
    if (offset) {
      this.layout.scroll_offset = offset;
    } else {
      return this.layout.scroll_offset;
    }
  }
  // --- private methods -------------------------------------------------------
  /**
   * translation back and forth is the same operation, with a different 
   * (inverted) map. although it still might be worth inlining depending
   * on cost.
   * 
   * FIXME: it's about time we started using proper maps, we dropped 
   * support for IE11 some time ago.
   */
  TranslateInternal(value, map) {
    const parse_result = this.parser.Parse(value);
    if (parse_result.expression) {
      let modified = false;
      this.parser.Walk(parse_result.expression, (unit) => {
        if (unit.type === "call") {
          const replacement = map[unit.name.toUpperCase()];
          if (replacement) {
            modified = true;
            unit.name = replacement;
          }
        }
        return true;
      });
      if (modified) {
        return "=" + this.parser.Render(parse_result.expression, { missing: "" });
      }
    }
    return value;
  }
  RenameSheetInternal(target, name) {
    super.RenameSheetInternal(target, name);
    this.tab_bar?.Update();
  }
  /**
   * translate function from common (english) -> local language. this could
   * be inlined (assuming it's only called in one place), but we are breaking
   * it out so we can develop/test/manage it.
   */
  TranslateFunction(value) {
    if (this.language_map) {
      return this.TranslateInternal(value, this.language_map);
    }
    return value;
  }
  /**
   * translate from local language -> common (english).
   * @see TranslateFunction
   */
  UntranslateFunction(value) {
    if (this.reverse_language_map) {
      return this.TranslateInternal(value, this.reverse_language_map);
    }
    return value;
  }
  UntranslateData(value) {
    if (Array.isArray(value)) {
      if (Is2DArray(value)) {
        return value.map((row) => row.map((entry) => {
          if (entry && typeof entry === "string" && entry[0] === "=") {
            return this.UntranslateFunction(entry);
          }
          return entry;
        }));
      } else {
        return value.map((entry) => {
          if (entry && typeof entry === "string" && entry[0] === "=") {
            return this.UntranslateFunction(entry);
          }
          return entry;
        });
      }
    } else if (value && typeof value === "string" && value[0] === "=") {
      value = this.UntranslateFunction(value);
    }
    return value;
  }
  StyleDefaultFromTheme() {
    this.model.theme_style_properties.font_face = this.theme.grid_cell?.font_face || "";
    this.model.theme_style_properties.font_size = this.theme.grid_cell?.font_size || { unit: "pt", value: 10 };
  }
  AutoSizeColumn(sheet, column, allow_shrink = true) {
    if (!this.tile_renderer) {
      return;
    }
    let width = 12;
    const padding = 4 * 2;
    if (!allow_shrink)
      width = sheet.GetColumnWidth(column);
    for (let row = 0; row < sheet.cells.rows; row++) {
      const cell = sheet.CellData({ row, column });
      let text = cell.formatted || "";
      if (typeof text !== "string") {
        text = text.map((part) => part.text).join("");
      }
      if (text && text.length) {
        const metrics = this.tile_renderer.MeasureText(text, Style.Font(cell.style || {}));
        width = Math.max(width, Math.ceil(metrics.width) + padding);
      }
    }
    sheet.SetColumnWidth(column, width);
  }
  /**
   * we have to handle the case where we have a split view and the model
   * changes in some way -- remove a sheet, for example -- that invalidates
   * our active sheet. if that happens, we need to switch to a different
   * sheet.
   * 
   * we don't get events about this (should we?) so someone will have to 
   * call it. FIXME: we should get events about that.
   */
  EnsureActiveSheet(force = false) {
    for (const sheet of this.model.sheets.list) {
      if (sheet === this.active_sheet) {
        if (force) {
          this.ActivateSheetInternal({
            key: 21 /* ActivateSheet */,
            id: sheet.id,
            force: true
          });
        }
        return;
      }
    }
    this.ActivateSheetInternal({
      key: 21 /* ActivateSheet */,
      index: 0
    });
  }
  /**
   * specialization for grid. note that we don't call superclass,
   * so we need to do everything that method does as well.
   */
  ActivateSheetInternal(command) {
    const selecting_argument = this.SelectingArgument();
    const candidate = this.ResolveSheet(command) || this.model.sheets.list[0];
    if (this.active_sheet === candidate && !command.force) {
      return;
    }
    if (!candidate.visible) {
      throw new Error("cannot activate hidden sheet");
    }
    this.HideHoverInfo();
    this.active_sheet.selection = JSON.parse(JSON.stringify(this.primary_selection));
    this.active_sheet.scroll_offset = this.layout.scroll_offset;
    const deactivate = this.active_sheet;
    this.RemoveAnnotationNodes();
    this.active_sheet = candidate;
    if (!selecting_argument) {
      this.ClearSelection(this.primary_selection);
      if (candidate.selection && !candidate.selection.empty) {
        this.Select(
          this.primary_selection,
          new Area(candidate.selection.area.start, candidate.selection.area.end),
          candidate.selection.target
        );
      }
    } else {
      this.RenderSelections();
    }
    const annotations = this.active_sheet.annotations;
    for (const element of annotations) {
      this.AddAnnotation(element, true);
    }
    this.ActivateSheetTasks();
    this.QueueLayoutUpdate();
    if (this.pending_layout_update.has(this.active_sheet.id)) {
      this.Repaint(true, true);
      this.pending_layout_update.delete(this.active_sheet.id);
    } else {
      this.Repaint(false, false);
    }
    this.grid_events.Publish({
      type: "sheet-change",
      deactivate,
      activate: this.active_sheet
    });
    if (this.tab_bar) {
      this.tab_bar.Update();
    }
    this.layout.scroll_offset = this.active_sheet.scroll_offset;
    if (this.formula_bar?.selecting) {
      requestAnimationFrame(() => this.formula_bar?.FocusEditor());
    }
  }
  /**
   * handle any tasks the sheet needs to do on activation
   */
  ActivateSheetTasks() {
    this.active_sheet.Activate(this.DOM);
    if (this.active_sheet.image && !this.active_sheet.image.complete) {
      const image = this.active_sheet.image;
      let counter = 0;
      const RepaintLayout = () => {
        if (!image.complete) {
          if (counter++ < 5) {
            setTimeout(() => RepaintLayout(), 10);
          }
        } else {
          this.UpdateLayout();
        }
      };
      RepaintLayout();
    }
  }
  /**
   * why is this not in layout? (...)
   * how is this layout? it's an effect. make an effects class.
   */
  HighlightFreezeArea() {
    for (const node of [
      this.layout.corner_selection,
      this.layout.row_header_selection,
      this.layout.column_header_selection
    ]) {
      node.classList.add("highlight-area");
      setTimeout(() => {
        node.classList.remove("highlight-area");
      }, 400);
    }
  }
  /**
   * layout has changed, and needs update. we clear the rectangle cache
   * immediately, to prevent any garbage, but we don't actually do the layout
   * until the next paint.
   *
   * FIXME: that makes no sense -- because rectangles will be calculated
   * incorrectly until the layout has been updated.
   */
  QueueLayoutUpdate(scroll) {
    this.tile_update_pending = true;
    if (scroll) {
      this.scroll_offset_pending = scroll;
    }
  }
  HandleAddressLabelEvent(text) {
    if (text) {
      const resolve_sheet_name = (name = "") => {
        const lc = name.toLowerCase();
        for (const sheet of this.model.sheets.list) {
          if (sheet.name.toLowerCase() === lc) {
            return sheet.id;
          }
        }
        return this.active_sheet.id;
      };
      const get_sheet = (id) => {
        for (const sheet of this.model.sheets.list) {
          if (sheet.id === id) {
            return sheet;
          }
        }
        return this.active_sheet;
      };
      let target_area;
      const parse_result = this.parser.Parse(text);
      if (parse_result.expression) {
        switch (parse_result.expression.type) {
          case "address":
            parse_result.expression.sheet_id = resolve_sheet_name(parse_result.expression.sheet);
            target_area = new Area(parse_result.expression);
            break;
          case "range":
            parse_result.expression.start.sheet_id = resolve_sheet_name(parse_result.expression.start.sheet);
            target_area = new Area(parse_result.expression.start, parse_result.expression.end);
            break;
          case "identifier":
            {
              target_area = this.model.named_ranges.Get(parse_result.expression.name);
              if (!target_area) {
                if (!this.primary_selection.empty) {
                  this.SetName(parse_result.expression.name.toUpperCase(), this.primary_selection.area);
                }
              }
            }
            break;
          default:
            break;
        }
      }
      if (target_area) {
        const sheet = get_sheet(target_area.start.sheet_id);
        if (sheet.columns >= target_area.end.column && sheet.rows >= target_area.end.row) {
          this.ExecCommand({
            key: 5 /* Select */,
            area: target_area
          });
          return;
        } else {
          console.warn("address out of range");
        }
      }
    }
    this.UpdateAddressLabel();
    this.Focus();
  }
  InitFormulaBar(grid_container, autocomplete) {
    this.formula_bar = new FormulaBar(
      grid_container,
      // this.parser,
      // this.theme,
      this.model,
      this.view,
      this.options,
      autocomplete
    );
    this.formula_bar.autocomplete_matcher = this.autocomplete_matcher;
    this.formula_bar.Subscribe((event) => {
      switch (event.type) {
        case "address-label-event":
          this.HandleAddressLabelEvent(event.text);
          break;
        case "stop-editing":
          this.editing_state = 0 /* NotEditing */;
          break;
        case "start-editing":
          this.editing_state = 2 /* FormulaBar */;
          this.editing_cell = { ...this.primary_selection.target };
          break;
        case "discard":
          this.editing_state = 0 /* NotEditing */;
          if (this.editing_annotation) {
            this.ClearAdditionalSelections();
            this.ClearSelection(this.active_selection);
            const node = this.editing_annotation.view[this.view_index]?.node;
            if (node) {
              node.focus();
            }
            this.editing_annotation = void 0;
            this.UpdateFormulaBarFormula();
            this.DelayedRender();
            return;
          }
          if (this.container)
            this.Focus();
          this.ClearAdditionalSelections();
          this.ClearSelection(this.active_selection);
          this.UpdateFormulaBarFormula();
          this.DelayedRender();
          break;
        case "commit":
          if (this.active_sheet.id !== this.editing_cell.sheet_id) {
            if (this.editing_cell.sheet_id) {
              this.ActivateSheetID(this.editing_cell.sheet_id);
            }
          }
          this.editing_state = 0 /* NotEditing */;
          if (this.editing_annotation) {
            const annotation = this.editing_annotation;
            this.ClearAdditionalSelections();
            this.ClearSelection(this.active_selection);
            annotation.data.formula = event.value ? this.FixFormula(event.value) : "";
            const node = this.editing_annotation.view[this.view_index]?.node;
            if (node) {
              node.focus();
            }
            this.grid_events.Publish({ type: "annotation", event: "update", annotation });
            this.editing_annotation = void 0;
            this.DelayedRender();
            return;
          }
          if (this.container)
            this.Focus();
          this.SetInferredType(this.primary_selection, event.value, event.array);
          this.ClearAdditionalSelections();
          this.ClearSelection(this.active_selection);
          if (this.options.repaint_on_cell_change) {
            this.DelayedRender(false, this.primary_selection.area);
          }
          if (event.event) {
            this.OverlayKeyDown(event.event);
          }
          break;
        case "update":
          if (event.dependencies) {
            this.HighlightDependencies(event.dependencies);
          }
          break;
      }
    });
  }
  InitOverlayEditor(autocomplete) {
    if (!this.container) {
      return;
    }
    this.overlay_editor = new OverlayEditor(
      this.container,
      this.theme,
      this.model,
      this.view,
      autocomplete
    );
    this.overlay_editor.UpdateScale(this.layout.scale);
    this.overlay_editor.autocomplete_matcher = this.autocomplete_matcher;
    this.overlay_editor.Subscribe((event) => {
      switch (event.type) {
        case "stop-editing":
          this.editing_state = 0 /* NotEditing */;
          break;
        case "start-editing":
          this.editing_state = 1 /* CellEditor */;
          this.editing_cell = { ...this.primary_selection.target };
          break;
        case "update":
          if (event.dependencies) {
            this.HighlightDependencies(event.dependencies);
          }
          break;
        case "end-selection":
        case "reset-selection":
          this.ClearSelection(this.active_selection);
          if (this.overlay_editor?.target_address?.sheet_id && this.active_sheet.id !== this.overlay_editor.target_address.sheet_id) {
            this.ActivateSheetID(this.overlay_editor.target_address.sheet_id);
          }
          this.DelayedRender();
          break;
      }
    });
  }
  DelayedRender(force = false, area, full_tile = false) {
    if (!this.tile_update_pending && area) {
      this.layout.DirtyArea(area);
    } else if (!this.tile_update_pending && force) {
      this.layout.DirtyAll();
    }
    if (!this.render_token) {
      this.render_token = 1;
      Promise.resolve().then(() => {
        this.render_token = 0;
        this.Repaint(force, full_tile);
      });
    }
  }
  Repaint(force = false, full_tile = false, force_headers = false) {
    if (this.headless || !this.tile_renderer) {
      return;
    }
    if (this.tile_update_pending) {
      this.tile_update_pending = false;
      this.layout.UpdateTiles();
      if (this.scroll_offset_pending) {
        this.layout.scroll_offset = this.scroll_offset_pending;
        this.scroll_offset_pending = void 0;
      }
      this.render_tiles = this.layout.VisibleTiles();
      this.layout.UpdateAnnotation(this.active_sheet.annotations);
    }
    this.layout_token = 0;
    this.tile_renderer.OverflowDirty(full_tile);
    if (force) {
      for (const column of this.layout.grid_tiles) {
        for (const tile of column) {
          tile.dirty = true;
        }
      }
    }
    const start = this.render_tiles.start;
    const end = this.render_tiles.end;
    const row_list = [];
    for (let row = start.row; row <= end.row; row++)
      row_list.push(row);
    const column_list = [];
    for (let column = start.column; column <= end.column; column++)
      column_list.push(column);
    if (start.row > 0 && this.active_sheet.freeze.rows)
      row_list.push(0);
    if (start.column > 0 && this.active_sheet.freeze.columns)
      column_list.push(0);
    for (const column of column_list) {
      for (const row of row_list) {
        const tile = this.layout.grid_tiles[column][row];
        if (force || tile.dirty || tile.needs_full_repaint) {
          this.tile_renderer.Render(tile);
          tile.dirty = tile.needs_full_repaint = false;
        }
      }
    }
    this.tile_renderer.RenderHeaders(this.render_tiles, force_headers);
    this.tile_renderer.RenderCorner();
    this.RenderSelections();
  }
  MouseMove_RowHeader(event) {
    const header = this.layout.CoordinateToRowHeader(event.offsetY);
    const rect = this.layout.OffsetCellAddressToRectangle({ row: header.row, column: 0 });
    if (this.hover_data.address && (this.hover_data.address.row !== -1 || this.hover_data.address.column !== -1)) {
      this.HoverCell({ row: -1, column: -1 });
    }
    let resize_row = -1;
    if (event.offsetY - rect.top <= this.RESIZE_PIXEL_BUFFER && header.row > 0) {
      resize_row = header.row - 1;
    } else if (rect.bottom - event.offsetY <= this.RESIZE_PIXEL_BUFFER) {
      resize_row = header.row;
    }
    if (resize_row >= 0) {
      this.layout.ResizeCursor("row");
    } else if (this.cell_resize.row) {
      this.cell_resize.row = -1;
      this.layout.ResizeCursor();
    }
    this.cell_resize.row = resize_row;
  }
  MouseMove_ColumnHeader(event) {
    const header = this.layout.CoordinateToColumnHeader(event.offsetX);
    const rect = this.layout.OffsetCellAddressToRectangle({ row: 0, column: header.column });
    if (this.hover_data.address && (this.hover_data.address.row !== -1 || this.hover_data.address.column !== -1)) {
      this.HoverCell({ row: -1, column: -1 });
    }
    let resize_column = -1;
    if (event.offsetX - rect.left <= this.RESIZE_PIXEL_BUFFER && header.column > 0) {
      resize_column = header.column - 1;
    } else if (rect.right - event.offsetX <= this.RESIZE_PIXEL_BUFFER) {
      resize_column = header.column;
    }
    if (resize_column >= 0) {
      this.layout.ResizeCursor("column");
    } else if (this.cell_resize.column) {
      this.cell_resize.column = -1;
      this.layout.ResizeCursor();
    }
    this.cell_resize.column = resize_column;
  }
  /**
   * handler for mousedown events on the row (left) header.
   * handles selection and resizing.
   *
   * FIXME: argument selection
   */
  MouseDown_RowHeader(event) {
    if (event.button !== 0) {
      return;
    }
    event.stopPropagation();
    event.preventDefault();
    let base_address = this.layout.CoordinateToRowHeader(event.offsetY);
    const bounding_rect = this.layout.row_header_cover.getBoundingClientRect();
    const offset = {
      x: bounding_rect.left,
      y: bounding_rect.top
    };
    if (this.cell_resize.row >= 0) {
      const row = this.cell_resize.row;
      const base = offset.y + event.offsetY;
      this.layout.HideDropdownCaret();
      if (this.IsDoubleClick({ row, column: -1 })) {
        let rows = [row];
        if (!this.primary_selection.empty && this.primary_selection.area.rows > 1 && this.primary_selection.area.start.column === Infinity && this.primary_selection.area.ContainsRow(row)) {
          const area = this.active_sheet.RealArea(this.primary_selection.area);
          rows = [];
          for (let r = area.start.row; r <= area.end.row; r++) {
            rows.push(r);
          }
        }
        this.ExecCommand({
          key: 3 /* ResizeRows */,
          row: rows
        });
        return;
      }
      const original_height = this.layout.RowHeight(row);
      let height = original_height;
      const rect = this.layout.OffsetCellAddressToRectangle({ row, column: 0 });
      const tooltip_base = offset.y + rect.bottom;
      this.layout.ShowTooltip({
        left: true,
        text: `${height}px`,
        x: Math.round(bounding_rect.right + 10),
        y: tooltip_base
      });
      const move_annotation_list = [];
      const size_annotation_list = [];
      for (const annotation of this.active_sheet.annotations) {
        const y = rect.bottom - 1;
        if (!annotation.scaled_rect || annotation.scaled_rect.bottom < y) {
          continue;
        }
        const nodes = [...this.layout.GetFrozenAnnotations(annotation)];
        const node = annotation.view[this.view_index]?.node;
        if (node) {
          nodes.push(node);
        }
        if (y <= annotation.scaled_rect.top && annotation.data.move_with_cells) {
          move_annotation_list.push({ annotation, y: annotation.scaled_rect.top, nodes });
        } else if (y > annotation.scaled_rect.top && annotation.data.resize_with_cells) {
          size_annotation_list.push({ annotation, height: annotation.scaled_rect.height, nodes });
        }
      }
      MouseDrag(this.layout.mask, "row-resize", (move_event) => {
        const delta = Math.max(-original_height, Math.round(move_event.offsetY - base));
        if (delta + original_height !== height) {
          height = delta + original_height;
          this.layout.SetRowHeight(row, height);
          this.layout.UpdateTooltip({
            text: `${height}px`,
            y: tooltip_base + delta
          });
          for (const { annotation, y } of move_annotation_list) {
            if (annotation.scaled_rect) {
              annotation.scaled_rect.top = y + delta;
            }
          }
          for (const { annotation, height: height2 } of size_annotation_list) {
            if (annotation.scaled_rect) {
              annotation.scaled_rect.height = height2 + delta;
            }
          }
          requestAnimationFrame(() => {
            for (const { annotation, nodes } of size_annotation_list) {
              if (annotation.scaled_rect) {
                for (const node of nodes) {
                  annotation.scaled_rect.ApplyStyle(node);
                }
              }
            }
            for (const { annotation, nodes } of move_annotation_list) {
              if (annotation.scaled_rect) {
                for (const node of nodes) {
                  annotation.scaled_rect.ApplyStyle(node);
                }
              }
            }
            this.layout.UpdateTileHeights(true, row);
            this.Repaint(false, true);
            this.layout.UpdateAnnotation(this.active_sheet.annotations);
          });
        }
      }, () => {
        this.layout.HideTooltip();
        requestAnimationFrame(() => {
          let rows = [row];
          if (!this.primary_selection.empty && this.primary_selection.area.rows > 1 && this.primary_selection.area.start.column === Infinity && this.primary_selection.area.ContainsRow(row)) {
            const area = this.active_sheet.RealArea(this.primary_selection.area);
            rows = [];
            for (let r = area.start.row; r <= area.end.row; r++) {
              rows.push(r);
            }
          }
          this.layout.SetRowHeight(row, original_height);
          this.ExecCommand({
            key: 3 /* ResizeRows */,
            row: rows,
            height: height / this.scale
          });
          for (const { annotation } of move_annotation_list) {
            if (annotation.scaled_rect) {
              annotation.data.layout = this.layout.RectToAnnotationLayout(annotation.scaled_rect);
            }
          }
          for (const { annotation } of size_annotation_list) {
            if (annotation.scaled_rect) {
              annotation.data.layout = this.layout.RectToAnnotationLayout(annotation.scaled_rect);
            }
            const view = annotation.view[this.view_index];
            if (view && view.resize_callback) {
              view.resize_callback.call(void 0);
            }
          }
        });
      });
    } else {
      const selection = this.SelectingArgument() ? this.active_selection : this.primary_selection;
      if (!this.SelectingArgument()) {
        this.Focus();
      }
      if (event.shiftKey && !selection.empty) {
        const tmp = selection.target;
        this.Select(selection, new Area(selection.target, base_address, true), void 0, true);
        base_address = tmp;
      } else {
        this.Select(selection, new Area(base_address), { column: 0, row: base_address.row });
      }
      this.RenderSelections();
      MouseDrag(this.layout.mask, [], (move_event) => {
        const address = this.layout.CoordinateToRowHeader(move_event.offsetY - offset.y);
        const area = new Area(address, base_address, true);
        if (selection.empty || !area.Equals(selection.area)) {
          this.Select(selection, area, void 0, true);
          this.RenderSelections();
        }
      }, () => {
      });
    }
  }
  /**
   * handler for mousedown events on the column (top) header.
   * handles selection and resizing.
   *
   * FIXME: argument selection
   */
  MouseDown_ColumnHeader(event) {
    if (event.button !== 0) {
      return;
    }
    event.stopPropagation();
    event.preventDefault();
    let base_address = this.layout.CoordinateToColumnHeader(event.offsetX);
    const bounding_rect = this.layout.column_header_cover.getBoundingClientRect();
    const offset = {
      x: bounding_rect.left,
      y: bounding_rect.top
    };
    if (this.cell_resize.column >= 0) {
      const column = this.cell_resize.column;
      const base = offset.x + event.offsetX;
      this.layout.HideDropdownCaret();
      if (this.IsDoubleClick({ row: -1, column })) {
        let columns = [column];
        if (!this.primary_selection.empty && this.primary_selection.area.columns > 1 && this.primary_selection.area.start.row === Infinity && this.primary_selection.area.ContainsColumn(column)) {
          const area = this.active_sheet.RealArea(this.primary_selection.area);
          columns = [];
          for (let c = area.start.column; c <= area.end.column; c++) {
            columns.push(c);
          }
        }
        this.ExecCommand({
          key: 4 /* ResizeColumns */,
          column: columns
        });
        return;
      }
      const original_width = this.layout.ColumnWidth(column);
      let width = original_width;
      const rect = this.layout.OffsetCellAddressToRectangle({ row: 0, column });
      const tooltip_base = offset.x + rect.right;
      this.layout.ShowTooltip({
        up: true,
        text: `${width}px`,
        x: tooltip_base,
        y: Math.round(bounding_rect.bottom + 10)
      });
      const move_annotation_list = [];
      const size_annotation_list = [];
      for (const annotation of this.active_sheet.annotations) {
        const x = rect.right - 1;
        if (!annotation.scaled_rect || annotation.scaled_rect.right < x) {
          continue;
        }
        const nodes = [...this.layout.GetFrozenAnnotations(annotation)];
        const node = annotation.view[this.view_index]?.node;
        if (node) {
          nodes.push(node);
        }
        if (x <= annotation.scaled_rect.left && annotation.data.move_with_cells) {
          move_annotation_list.push({ annotation, x: annotation.scaled_rect.left, nodes });
        } else if (x > annotation.scaled_rect.left && annotation.data.resize_with_cells) {
          size_annotation_list.push({ annotation, width: annotation.scaled_rect.width, nodes });
        }
      }
      MouseDrag(this.layout.mask, "column-resize", (move_event) => {
        const delta = Math.max(-original_width, Math.round(move_event.offsetX - base));
        if (delta + original_width !== width) {
          width = delta + original_width;
          this.layout.UpdateTooltip({
            text: `${width}px`,
            x: tooltip_base + delta
          });
          this.layout.SetColumnWidth(column, width);
          for (const { annotation, x } of move_annotation_list) {
            if (annotation.scaled_rect) {
              annotation.scaled_rect.left = x + delta;
            }
          }
          for (const { annotation, width: width2 } of size_annotation_list) {
            if (annotation.scaled_rect) {
              annotation.scaled_rect.width = width2 + delta;
            }
          }
          requestAnimationFrame(() => {
            for (const { annotation, nodes } of size_annotation_list) {
              if (annotation.scaled_rect) {
                for (const node of nodes) {
                  annotation.scaled_rect.ApplyStyle(node);
                }
              }
            }
            for (const { annotation, nodes } of move_annotation_list) {
              if (annotation.scaled_rect) {
                for (const node of nodes) {
                  annotation.scaled_rect.ApplyStyle(node);
                }
              }
            }
            this.layout.UpdateTileWidths(true, column);
            this.Repaint(false, true);
          });
        }
      }, () => {
        this.layout.HideTooltip();
        requestAnimationFrame(() => {
          const columns = [column];
          if (!this.primary_selection.empty && this.primary_selection.area.columns > 1 && this.primary_selection.area.start.row === Infinity && this.primary_selection.area.ContainsColumn(column)) {
            const area = this.active_sheet.RealArea(this.primary_selection.area);
            for (let c = area.start.column; c <= area.end.column; c++) {
              columns.push(c);
            }
          }
          this.ExecCommand({
            key: 4 /* ResizeColumns */,
            column: columns,
            width: width / this.scale
          });
          for (const { annotation } of move_annotation_list) {
            if (annotation.scaled_rect) {
              annotation.data.layout = this.layout.RectToAnnotationLayout(annotation.scaled_rect);
            }
          }
          for (const { annotation } of size_annotation_list) {
            if (annotation.scaled_rect) {
              annotation.data.layout = this.layout.RectToAnnotationLayout(annotation.scaled_rect);
            }
            const view = annotation.view[this.view_index];
            if (view && view.resize_callback) {
              view.resize_callback.call(void 0);
            }
          }
        });
      });
    } else {
      const selection = this.SelectingArgument() ? this.active_selection : this.primary_selection;
      if (!this.SelectingArgument()) {
        this.Focus();
      }
      if (event.shiftKey && !selection.empty) {
        const tmp = selection.target;
        this.Select(selection, new Area(selection.target, base_address, true), void 0, true);
        base_address = tmp;
      } else {
        this.Select(selection, new Area(base_address), { row: 0, column: base_address.column });
      }
      this.RenderSelections();
      MouseDrag(this.layout.mask, [], (move_event) => {
        const address = this.layout.CoordinateToColumnHeader(move_event.offsetX - offset.x);
        const area = new Area(address, base_address, true);
        if (selection.empty || !area.Equals(selection.area)) {
          this.Select(selection, area, void 0, true);
          this.RenderSelections();
        }
      });
    }
  }
  HoverCell(address, event) {
    let cell = this.active_sheet.cells.GetCell(address, false);
    if (cell?.table && cell.table.area.start.row === address.row && cell.table.sortable !== false) {
      this.hover_data.table_header = true;
      this.layout.ShowTableSortButton(cell.table, address.column - cell.table.area.start.column, address);
    } else {
      if (this.hover_data.table_header) {
        this.layout.HideTableSortButton();
      }
      this.hover_data.table_header = false;
    }
    if (cell?.merge_area) {
      const area = cell.merge_area;
      address = area.start;
      cell = this.active_sheet.cells.GetCell(address, false);
      address = { row: area.start.row, column: area.end.column };
    }
    if (cell?.note) {
      const md = this.options.markdown ? MDParser.instance.HTML(MDParser.instance.Parse(cell.note)) : void 0;
      this.layout.ShowNote(cell.note, address, event, md);
      this.hover_data.note = true;
    } else if (this.hover_data.note) {
      this.layout.HideNote();
      this.hover_data.note = false;
    }
    if (cell?.hyperlink) {
      this.layout.ShowTitle("Link: " + cell.hyperlink, address);
      this.hover_data.link = true;
      this.hover_data.cell = cell;
    } else if (this.hover_data.link) {
      this.layout.HideTitle();
      this.hover_data.cell = void 0;
    }
    this.hover_data.address = { ...address };
  }
  HideHoverInfo() {
    this.layout.HideTitle();
    this.layout.HideTooltip();
    this.hover_data.note = this.hover_data.link = false;
    this.hover_data.cell = void 0;
    if (this.hover_data.pointer) {
      this.layout.grid_cover.classList.remove("link-pointer");
    }
    this.hover_data.pointer = false;
  }
  /**
   * grid move handler for hit-testing various areas
   */
  MouseMove_Grid(event) {
    event.stopPropagation();
    event.preventDefault();
    if (!this.selection_renderer) {
      return;
    }
    if (this.cell_resize.row >= 0 || this.cell_resize.column >= 0) {
      this.layout.ResizeCursor();
    }
    const offset_point = {
      x: event.offsetX,
      y: event.offsetY
    };
    let address;
    if (!this.overlay_editor?.editing) {
      address = this.layout.PointToAddress_Grid(offset_point);
      if (!this.hover_data.address || this.hover_data.address.row !== address.row || this.hover_data.address.column !== address.column) {
        this.HoverCell(address, event);
      }
    }
    if (this.hover_data.link && address) {
      this.hover_data.point = offset_point;
      if (!this.hover_data.handler) {
        this.hover_data.handler = requestAnimationFrame(() => {
          const link_active = this.hover_data.address && this.hover_data.point && this.hover_data.cell && this.PointInTextPart(this.hover_data.address, this.hover_data.point, this.hover_data.cell);
          if (link_active !== !!this.hover_data.pointer) {
            this.hover_data.pointer = link_active;
            if (link_active) {
              this.layout.grid_cover.classList.add("link-pointer");
            } else {
              this.layout.grid_cover.classList.remove("link-pointer");
            }
          }
          this.hover_data.handler = void 0;
        });
      }
    }
    if (this.primary_selection.empty || !this.selection_renderer.nub_rectangle) {
      if (this.nub_select_flag) {
        this.layout.grid_cover.classList.remove("nub-select");
        this.nub_select_flag = false;
      }
      return;
    }
    const nub = this.selection_renderer.nub_rectangle.Contains(event.offsetX, event.offsetY);
    if (nub === this.nub_select_flag)
      return;
    if (nub) {
      this.layout.grid_cover.classList.add("nub-select");
    } else {
      this.layout.grid_cover.classList.remove("nub-select");
    }
    this.nub_select_flag = nub;
  }
  /** 
   * special case: we don't want the previous click to be treated
   * as part of a double-click.
   */
  ClearDoubleClick() {
    this.double_click_data.address = void 0;
  }
  /**
   * unifying double-click. pass the test address. returns true if this looks
   * like a double-click on that address. otherwise sets flags to capture the
   * next one.
   *
   * FIXME: parameterize timeout?
   */
  IsDoubleClick(address, timeout = 300) {
    if (this.double_click_data.address && this.double_click_data.address.row === address.row && this.double_click_data.address.column === address.column) {
      clearTimeout(this.double_click_data.timeout);
      this.double_click_data.address = void 0;
      this.double_click_data.timeout = void 0;
      return true;
    } else {
      if (this.double_click_data.timeout)
        clearTimeout(this.double_click_data.timeout);
      this.double_click_data.address = { ...address };
      this.double_click_data.timeout = window.setTimeout(() => {
        this.double_click_data.address = void 0;
        this.double_click_data.timeout = void 0;
      }, timeout);
    }
  }
  PointInTextPart(address, offset_point, cell) {
    let rectangle = this.layout.CellAddressToRectangle(address);
    if (cell.merge_area) {
      rectangle = rectangle.Combine(
        this.layout.CellAddressToRectangle(cell.merge_area.end)
      );
    }
    const x = offset_point.x - rectangle.left;
    const y = offset_point.y - rectangle.top;
    const parts = cell.renderer_data?.text_data?.strings || [];
    for (const line of parts) {
      for (const part of line) {
        if (typeof part.left === "number" && typeof part.top === "number" && typeof part.width === "number" && typeof part.height === "number") {
          if (x >= part.left && y >= part.top && x <= part.left + part.width && y <= part.top + part.height) {
            return true;
          }
        }
      }
    }
    return false;
  }
  /**
   * handles mouse down events on the grid area:
   * selection (click-drag) and editing (double-click)
   */
  MouseDown_Grid(event) {
    if (event.button !== 0) {
      return;
    }
    event.stopPropagation();
    event.preventDefault();
    const selecting_argument = this.SelectingArgument();
    if (!selecting_argument && this.additional_selections.length) {
      this.ClearAdditionalSelections();
    }
    if (!selecting_argument || !this.formula_bar?.selecting && !this.external_editor?.selecting) {
      this.Focus();
    }
    if (this.overlay_editor?.editing && !this.overlay_editor?.selecting) {
      this.DismissEditor();
    }
    const offset_point = {
      x: event.offsetX,
      y: event.offsetY
    };
    let base_address = this.layout.PointToAddress_Grid(offset_point);
    const selection = selecting_argument ? this.active_selection : this.primary_selection;
    if (!selecting_argument) {
      if (this.IsDoubleClick(base_address)) {
        if (UA.is_mobile) {
          this.overlay_editor?.edit_node?.focus();
        }
        this.OverlayEditCell({ target: base_address, area: new Area(base_address) }, false);
        return;
      }
    }
    let bounding_rect = this.layout.grid_cover.getBoundingClientRect();
    const offset = {
      x: bounding_rect.left,
      y: bounding_rect.top
    };
    const overlay_classes = [];
    let nub_area;
    if (event.shiftKey && !selection.empty) {
      const tmp = selection.target;
      this.Select(selection, new Area(base_address, selection.target, true), void 0, true);
      base_address = tmp;
    } else if (this.nub_select_flag) {
      base_address = selection.area.TopLeft();
      overlay_classes.push("nub-select");
      nub_area = this.active_sheet.RealArea(selection.area);
    } else {
      let address = base_address;
      let cell = this.active_sheet.CellData(address);
      if (cell.merge_area) {
        address = cell.merge_area.start;
        cell = this.active_sheet.CellData(cell.merge_area.start);
      }
      if (cell.hyperlink) {
        if (this.PointInTextPart(address, offset_point, cell)) {
          const link = cell.hyperlink;
          Promise.resolve().then(() => {
            this.grid_events.Publish({
              type: "cell-event",
              data: {
                type: "hyperlink",
                data: link
              }
            });
          });
          this.ClearDoubleClick();
          return;
        }
      }
      if (cell.click_function) {
        let rectangle = this.layout.CellAddressToRectangle(address);
        if (cell.merge_area) {
          rectangle = rectangle.Combine(
            this.layout.CellAddressToRectangle(cell.merge_area.end)
          );
        }
        const result = cell.click_function.call(this, {
          cell,
          x: offset_point.x - rectangle.left,
          y: offset_point.y - rectangle.top,
          width: rectangle.width,
          height: rectangle.height,
          scale: this.layout.scale
        });
        if (result.value) {
          this.ExecCommand({
            key: 6 /* SetRange */,
            value: result.value,
            area: address
          });
        }
        if (result.block_selection) {
          this.ClearDoubleClick();
          if (!this.primary_selection.empty && this.primary_selection.target.row === address.row && this.primary_selection.target.column === address.column) {
            this.UpdateFormulaBarFormula();
          }
          return;
        }
      }
      this.Select(selection, new Area(base_address), base_address);
    }
    this.RenderSelections();
    if (selecting_argument)
      this.UpdateSelectedArgument(selection);
    const grid_rect = this.layout.CellAddressToRectangle({ row: 0, column: 0 }).Combine(
      this.layout.CellAddressToRectangle({
        row: this.active_sheet.rows - 1,
        column: this.active_sheet.columns - 1
      })
    ).Expand(-1, -1);
    MouseDrag(this.layout.mask, overlay_classes, (move_event) => {
      const point = {
        x: move_event.offsetX - offset.x,
        y: move_event.offsetY - offset.y
      };
      const testpoint = grid_rect.Clamp(point.x, point.y);
      const address = this.layout.PointToAddress_Grid(testpoint, true);
      const scroll_node = this.layout.scroll_reference_node;
      let reset_offset = false;
      if (this.container && this.options.scrollbars) {
        if (point.x < scroll_node.scrollLeft) {
          scroll_node.scrollLeft -= 25;
          reset_offset = true;
        } else if (point.x > scroll_node.scrollLeft + this.container.clientWidth) {
          scroll_node.scrollLeft += 25;
          reset_offset = true;
        }
        if (point.y < scroll_node.scrollTop) {
          scroll_node.scrollTop -= 25;
          reset_offset = true;
        } else if (point.y > scroll_node.scrollTop + this.container.clientHeight) {
          scroll_node.scrollTop += 25;
          reset_offset = true;
        }
        if (reset_offset) {
          bounding_rect = this.layout.grid_cover.getBoundingClientRect();
          offset.x = bounding_rect.left + document.body.scrollLeft;
          offset.y = bounding_rect.top + document.body.scrollTop;
        }
      }
      let area = new Area(address, base_address, true);
      if (nub_area) {
        area = nub_area.Clone();
        area.ConsumeAddress(address);
        if (area.rows !== nub_area.rows && area.columns !== nub_area.columns) {
          const delta = {
            rows: address.row > nub_area.end.row ? address.row - nub_area.end.row : nub_area.start.row - address.row,
            columns: address.column > nub_area.end.column ? address.column - nub_area.end.column : nub_area.start.column - address.column
          };
          if (delta.rows >= delta.columns) {
            area = new Area(
              { row: area.start.row, column: nub_area.start.column },
              { row: area.end.row, column: nub_area.end.column }
            );
          } else {
            area = new Area(
              { row: nub_area.start.row, column: area.start.column },
              { row: nub_area.end.row, column: area.end.column }
            );
          }
        }
      }
      if (selection.empty || !area.Equals(selection.area)) {
        this.Select(selection, area, void 0, true);
        this.RenderSelections();
        if (selecting_argument) {
          this.UpdateSelectedArgument(selection);
        } else if (!selection.empty && !selection.area.entire_sheet) {
          if (selection.area.entire_column) {
            this.UpdateAddressLabel(void 0, selection.area.columns + "C");
          } else if (selection.area.entire_row) {
            this.UpdateAddressLabel(void 0, selection.area.rows + "R");
          } else if (selection.area.count > 1) {
            this.UpdateAddressLabel(void 0, selection.area.rows + "R x " + selection.area.columns + "C");
          } else {
            this.UpdateAddressLabel(selection);
          }
        }
      }
    }, () => {
      this.UpdateAddressLabel();
      if (selecting_argument) {
        if (this.overlay_editor?.editing) {
        } else if (this.external_editor_config) {
          if (this.external_editor?.active) {
            this.external_editor.FocusEditor();
          }
          if (this.external_editor_config.update) {
          }
        } else if (this.formula_bar) {
          this.formula_bar.FocusEditor();
        }
      } else if (nub_area) {
        this.RecycleNubArea(selection.area, nub_area);
      }
    });
  }
  /**
   * FIXME: -> util library
   * @param arr 
   */
  Transpose(arr) {
    const tmp = [];
    const cols = arr.length;
    const rows = arr[0].length;
    for (let r = 0; r < rows; r++) {
      tmp[r] = [];
      for (let c = 0; c < cols; c++) {
        tmp[r][c] = arr[c][r];
      }
    }
    return tmp;
  }
  /**
   * when you drag from the nub, we copy the contents of the original
   * selection into the new selection, but there are some special recycling
   * rules.
   * 
   * FIXME: expand tables
   */
  RecycleNubArea(target_area, source_area) {
    if (target_area.Equals(source_area)) {
      return;
    }
    let cells = [];
    for (let row = 0; row < source_area.rows; row++) {
      cells[row] = [];
      for (let column = 0; column < source_area.columns; column++) {
        const address = {
          row: source_area.start.row + row,
          column: source_area.start.column + column
        };
        cells[row][column] = this.active_sheet.CellData(address);
      }
    }
    if (cells[0][0].area && cells[0][0].area.Equals(source_area)) {
      this.ExecCommand({
        key: 6 /* SetRange */,
        value: cells[0][0].value,
        array: true,
        area: target_area
      });
      return;
    }
    if (cells[0][0].table && source_area.Equals(new Area(cells[0][0].table.area.start, cells[0][0].table.area.end))) {
      const table = cells[0][0].table;
      const sortable = table.sortable;
      const totals = table.totals_row;
      const theme = table.theme;
      this.ExecCommand([
        {
          key: 29 /* RemoveTable */,
          table
        },
        {
          key: 28 /* InsertTable */,
          area: target_area,
          sortable,
          totals,
          theme
        }
      ]);
      return;
    }
    const data = [];
    let style = [];
    let source_columns = source_area.columns;
    let target_rows = target_area.rows;
    let inverted = false;
    let transposed = false;
    if (target_area.columns === source_area.columns) {
      inverted = target_area.start.row < source_area.start.row;
    } else {
      source_columns = source_area.rows;
      target_rows = target_area.columns;
      inverted = target_area.start.column < source_area.start.column;
      cells = this.Transpose(cells);
      transposed = true;
    }
    for (let row = 0; row < target_rows; row++) {
      data[row] = [];
      style[row] = [];
    }
    for (let column = 0; column < source_columns; column++) {
      let pattern_step = 0;
      if (cells.length > 1) {
        pattern_step = 1;
        const pattern = [];
        const indices = [];
        for (let source_row = 0; source_row < cells.length; source_row++) {
          const cell = cells[source_row][column];
          if (cell.ValueIsNumber()) {
            indices.push(source_row);
            pattern.push(cell.value);
          }
        }
        if (pattern.length > 1) {
          const deltas = pattern.slice(1).map((value, index) => value - pattern[index]);
          if (deltas.every((delta) => delta === deltas[0])) {
            pattern_step = deltas[0];
          }
        }
        if (pattern.length) {
          pattern_step += pattern[pattern.length - 1] - pattern[0];
        }
      }
      for (let source_row = 0; source_row < cells.length; source_row++) {
        let translate;
        const cell = cells[source_row][column];
        if (cell.ValueIsFormula()) {
          const parsed = this.parser.Parse(cell.value);
          if (parsed.expression && parsed.full_reference_list?.length) {
            translate = parsed.expression;
          }
        }
        let offset = 0;
        let start = source_row;
        let step = cells.length;
        let pattern_increment = 0;
        let pattern = pattern_step;
        if (inverted) {
          start = target_rows - cells.length + source_row;
          step = -cells.length;
          pattern = -pattern_step;
        }
        for (let row = start; row >= 0 && row < target_rows; row += step, offset += step, pattern_increment += pattern) {
          if (translate) {
            data[row][column] = "=" + this.parser.Render(translate, {
              offset: { rows: offset, columns: 0 }
            });
          } else {
            const cell2 = cells[source_row][column];
            if (cell2.ValueIsNumber()) {
              data[row][column] = cell2.value + pattern_increment;
            } else {
              data[row][column] = cell2.value;
            }
          }
          style[row][column] = cells[source_row][column].style || {};
        }
      }
    }
    const commands = [{
      key: 6 /* SetRange */,
      value: transposed ? this.Transpose(data) : data,
      array: false,
      area: target_area
    }];
    if (transposed) {
      style = this.Transpose(style);
    }
    for (let row = 0; row < style.length; row++) {
      for (let column = 0; column < style[row].length; column++) {
        commands.push({
          key: 7 /* UpdateStyle */,
          area: {
            row: row + target_area.start.row,
            column: column + target_area.start.column
          },
          style: style[row][column],
          delta: false
        });
      }
    }
    this.ExecCommand(commands);
  }
  UpdateSelectedArgument(selection) {
    const data = this.active_sheet.CellData(selection.area.start);
    const target = new Area(data.merge_area ? data.merge_area.start : selection.target);
    let label = this.model.named_ranges.MatchSelection(selection.area, target);
    if (!label) {
      label = selection.area.spreadsheet_label;
      if (data.merge_area && data.merge_area.Equals(selection.area)) {
        label = Area.CellAddressToLabel(data.merge_area.start);
      }
      if (this.external_editor_config || this.active_sheet.id !== this.editing_cell.sheet_id) {
        const name = this.active_sheet.name;
        if (QuotedSheetNameRegex.test(name)) {
          label = `'${name}'!${label}`;
        } else {
          label = `${name}!${label}`;
        }
      }
    }
    if (this.overlay_editor?.editing && this.overlay_editor.selecting) {
      this.overlay_editor.InsertReference(label, 0);
    } else if (this.formula_bar && this.formula_bar.selecting) {
      this.formula_bar.InsertReference(label, 0);
    } else if (this.external_editor_config) {
      if (this.external_editor?.active) {
        this.external_editor.FocusEditor();
        this.external_editor.InsertReference(label, 0);
      }
      if (this.external_editor_config.update) {
        const result = this.external_editor_config.update.call(0, label);
        if (result && Array.isArray(result)) {
          this.HighlightDependencies(
            result.filter((entry) => !!entry).map((reference) => IsCellAddress(reference) ? new Area(reference) : new Area(reference.start, reference.end))
          );
        }
      }
    }
  }
  /**
   * unified method to check if we are selecting an argument in the formula
   * bar editor or the in-cell editor
   *
   * FIXME: why is this not an accessor?
   */
  SelectingArgument() {
    return this.overlay_editor?.editing && this.overlay_editor?.selecting || this.formula_bar && this.formula_bar.selecting || !!this.external_editor_config;
  }
  /**
   * consolidated event handler for overlay, which both handles grid keys
   * and acts as the ICE, depending on state. going to be a little tricky
   * to keep track of code paths.
   * 
   * old comment:
   * 
   *   event handler for keyboard events. some we handle directly (directional
   *   navigation), some we ignore (most control-key combinations), and if you
   *   type text we start the in-cell editor and pass on the event.
   * 
   * which is largely still true, except that we can handle the ICE more 
   * directly.
   * 
   */
  OverlayKeyDown(event) {
    let editor_open = false;
    if (this.overlay_editor && this.overlay_editor.editing) {
      editor_open = true;
      const result = this.overlay_editor.HandleKeyDown(event);
      switch (result) {
        case "handled":
          return;
        case "discard":
          this.editing_state = 0 /* NotEditing */;
          this.DismissEditor();
          this.DelayedRender();
          return;
        case "commit":
          if (this.active_sheet.id !== this.editing_cell.sheet_id) {
            if (this.editing_cell.sheet_id) {
              this.ActivateSheetID(this.editing_cell.sheet_id);
            }
          }
          this.editing_state = 0 /* NotEditing */;
          if (this.overlay_editor?.selection) {
            const value = this.overlay_editor?.edit_node.textContent || void 0;
            const array = event.key === "Enter" && event.ctrlKey && event.shiftKey;
            this.SetInferredType(this.overlay_editor.selection, value, array);
          }
          this.DismissEditor();
          if (this.options.repaint_on_cell_change) {
            this.DelayedRender(false, this.overlay_editor?.selection.area || void 0);
          }
          break;
      }
    }
    const selecting_argument = this.SelectingArgument();
    if (this.formula_bar && this.formula_bar.focused && !selecting_argument) {
      return;
    }
    if (this.selected_annotation && !selecting_argument) {
      return;
    }
    const selection = selecting_argument ? this.active_selection : this.primary_selection;
    const delta = { rows: 0, columns: 0 };
    let within_selection = false;
    let expand_selection = false;
    if (event.ctrlKey || UA.is_mac && event.metaKey) {
      switch (event.key) {
        case "ArrowDown":
        case "Down":
          delta.rows++;
          break;
        case "ArrowUp":
        case "Up":
          delta.rows--;
          break;
        case "ArrowLeft":
        case "Left":
          delta.columns--;
          break;
        case "ArrowRight":
        case "Right":
          delta.columns++;
          break;
        case "Backspace":
          if (event.metaKey && UA.is_mac) {
            if (!selection.empty) {
              this.DeleteSelection(selection);
            }
          }
          break;
        case "Delete":
        case "Del":
          {
            event.stopPropagation();
            event.preventDefault();
            for (let i = 0; i < this.model.sheets.length; i++) {
              if (this.model.sheets.list[i] === this.active_sheet) {
                this.DeleteSheet(i);
                break;
              }
            }
            return;
          }
          break;
        case "/":
          event.stopPropagation();
          event.preventDefault();
          this.SelectArrayOrTable();
          break;
        default:
          if (event.shiftKey) {
            return;
          }
      }
      if (delta.columns || delta.rows) {
        event.stopPropagation();
        event.preventDefault();
        if (!selection.empty && (delta.columns || delta.rows)) {
          if (this.BlockSelection(selection, !!event.shiftKey, delta.columns, delta.rows)) {
            return;
          }
        } else {
          return;
        }
      } else {
        const applied_style = {};
        const selected_style = this.primary_selection.empty ? {} : this.active_sheet.CellData(this.primary_selection.target).style || {};
        switch (event.key.toLowerCase()) {
          case "b":
            applied_style.bold = !selected_style.bold;
            break;
          case "i":
            applied_style.italic = !selected_style.italic;
            break;
          case "u":
            applied_style.underline = !selected_style.underline;
            break;
          case "a":
            this.SelectAll();
            break;
          case "0":
            if (!event.altKey)
              return;
            this.ClearSelection(this.primary_selection);
            this.RenderSelections();
            break;
          default:
            if (event.key !== "Control") {
            }
            return;
        }
        if (Object.keys(applied_style).length) {
          this.ApplyStyle(void 0, applied_style);
        }
      }
    } else {
      if (/^F\d+$/.test(event.key)) {
        return;
      }
      switch (event.key) {
        case "Tab":
          if (event.shiftKey)
            delta.columns--;
          else
            delta.columns++;
          within_selection = true;
          break;
        case "Enter":
          if (event.shiftKey)
            delta.rows--;
          else
            delta.rows++;
          within_selection = true;
          break;
        case "ArrowDown":
        case "Down":
          delta.rows++;
          expand_selection = event.shiftKey;
          break;
        case "ArrowUp":
        case "Up":
          delta.rows--;
          expand_selection = event.shiftKey;
          break;
        case "ArrowLeft":
        case "Left":
          delta.columns--;
          expand_selection = event.shiftKey;
          break;
        case "ArrowRight":
        case "Right":
          delta.columns++;
          expand_selection = event.shiftKey;
          break;
        case "Delete":
        case "Del":
          if (!selection.empty) {
            this.DeleteSelection(selection);
          }
          break;
        case "PageUp":
        case "PageDown":
          if (event.shiftKey) {
            this.NextSheet(event.key === "PageUp" ? -1 : 1);
            break;
          }
          return;
        case "Control":
        case "Shift":
        case "Alt":
          return;
        default:
          if (!selection.empty) {
            if (event.key !== "Escape") {
              this.OverlayEditCell(selection, true, event);
            }
          }
          return;
      }
    }
    event.stopPropagation();
    event.preventDefault();
    if (delta.rows || delta.columns) {
      this.AdvanceSelection(delta, selection, within_selection, expand_selection, !editor_open);
    }
  }
  /**
   * select the array containing the current cell, if any. if there's no
   * array, do nothing. updated to support selecting tables as well as arrays.
   */
  SelectArrayOrTable() {
    if (this.primary_selection.empty) {
      return;
    }
    const cell = this.active_sheet.CellData(this.primary_selection.target);
    if (!cell || !cell.area && !cell.table) {
      return;
    }
    if (cell.area) {
      this.Select(this.primary_selection, cell.area, cell.area.start);
    }
    if (cell.table) {
      const area = new Area(cell.table.area.start, cell.table.area.end);
      this.Select(this.primary_selection, area, area.start);
    }
    this.RenderSelections();
  }
  /**
   * render selections. we are wrapping this up in a method so we can
   * hide the primary selection in some cases (one case).
   */
  RenderSelections(rerender = true) {
    const show_primary_selection = this.hide_selection ? false : !this.editing_state || this.editing_cell.sheet_id === this.active_sheet.id;
    this.selection_renderer?.RenderSelections(show_primary_selection, rerender);
  }
  /**
   * select a block. returns true if we've handled it; returns false
   * if we want to revert to the standard behavior.
   *
   * (block selection refers to selecting more than one cell at once,
   * using ctrl+arrow. selection jumps across all populated cells in
   * a given direction for a given row/column).
   */
  BlockSelection(selection, expand_selection, columns, rows, render = true) {
    if (selection.empty)
      return false;
    const start = { ...selection.target };
    if (rows > 0)
      start.row = Math.max(start.row, selection.area.end.row);
    else if (rows < 0)
      start.row = Math.min(start.row, selection.area.start.row);
    if (columns > 0)
      start.column = Math.max(start.column, selection.area.end.column);
    else if (columns < 0)
      start.column = Math.min(start.column, selection.area.start.column);
    const cells = this.active_sheet.cells;
    let cell = cells.GetCell(selection.target, false);
    if (!cell || cell.type === 0 /* undefined */ && !cell.area) {
      return false;
    }
    let end = { ...start };
    for (; ; ) {
      const test = { row: end.row + rows, column: end.column + columns };
      if (test.column < 0 || test.row < 0 || test.column >= this.active_sheet.columns || test.row >= this.active_sheet.rows)
        break;
      let has_value = false;
      if (rows) {
        for (let column = selection.area.start.column; !has_value && column <= selection.area.end.column; column++) {
          cell = cells.GetCell({ row: test.row, column }, false);
          has_value = has_value || !!cell && (cell.type !== 0 /* undefined */ || !!cell.area);
          if (!has_value && cell && cell.merge_area) {
            cell = cells.GetCell(cell.merge_area.start, false);
            has_value = has_value || !!cell && (cell.type !== 0 /* undefined */ || !!cell.area);
          }
        }
      } else {
        for (let row = selection.area.start.row; !has_value && row <= selection.area.end.row; row++) {
          cell = cells.GetCell({ row, column: test.column }, false);
          has_value = has_value || !!cell && (cell.type !== 0 /* undefined */ || !!cell.area);
          if (!has_value && cell && cell.merge_area) {
            cell = cells.GetCell(cell.merge_area.start, false);
            has_value = has_value || !!cell && (cell.type !== 0 /* undefined */ || !!cell.area);
          }
        }
      }
      if (!has_value) {
        break;
      }
      end = test;
    }
    if (expand_selection) {
      if (rows) {
        start.row = selection.target.row;
        start.column = selection.area.start.column;
        end.column = selection.area.end.column;
      } else {
        start.column = selection.target.column;
        start.row = selection.area.start.row;
        end.row = selection.area.end.row;
      }
      const area = new Area(start, end, true);
      this.Select(selection, area, selection.target, true);
    } else {
      this.Select(selection, new Area(end));
    }
    this.ScrollIntoView(end);
    if (this.SelectingArgument())
      this.UpdateSelectedArgument(selection);
    if (render) {
      this.DelayedRender();
    }
    return true;
  }
  /**
   * deletes (clears) the selected area.
   *
   * FIXME: should probably be an API method, or have a second method that
   * clears the primary selection
   */
  DeleteSelection(selection) {
    if (selection.empty)
      return;
    const area = this.active_sheet.RealArea(selection.area);
    this.ExecCommand({ key: 11 /* Clear */, area });
  }
  /**
   * sets cell value, inferring type and (possibly) inferring cell style
   * (numbers only), so that 10% and $1,000 retain styles. this should only
   * be used for direct editing -- copy and paste can copy and paste styles.
   *
   * @param address cell address
   * 
   * @param value value entered, usually this will be a string (we will try
   * to parse numbers/booleans)
   * 
   * in what case would these not be strings? (...) not sure that's a thing.
   * 
   *
   * @param exec execute commands immediately; alternatively, return the list
   * of commands. the former is the default for editor commits; the latter
   * is used for paste.
   */
  SetInferredType(selection, value, array = false, exec = true) {
    let target = selection.target || selection.area.start;
    const cell = this.active_sheet.CellData(target);
    if (cell.area) {
      if (!array && cell.area.count > 1 || !selection.area || !selection.area.Equals(cell.area)) {
        this.Error(2 /* array */);
        return;
      }
    } else if (array) {
      let existing_array = false;
      this.active_sheet.cells.Apply(selection.area, (element) => {
        if (element.area) {
          existing_array = true;
        }
      }, false);
      if (existing_array) {
        this.Error(2 /* array */);
        return;
      }
    }
    if (cell.validation && cell.validation.error) {
      let list;
      if (cell.validation.type === "list" /* List */) {
        list = cell.validation.list;
      } else if (cell.validation.type === "range" /* Range */) {
        list = this.GetValidationRange(cell.validation.area);
      }
      if (list && list.length) {
        let match = false;
        if (value) {
          const uc = value.toUpperCase();
          for (const entry of list) {
            if (entry && entry.toString().toUpperCase() === uc) {
              value = entry.toString();
              match = true;
              break;
            }
          }
        }
        if (!match) {
          this.Error(3 /* data_validation */);
          return;
        }
      }
    }
    if (cell.merge_area)
      target = cell.merge_area.start;
    const is_function = typeof value === "string" && value.trim()[0] === "=";
    const commands = [];
    if (is_function) {
      value = this.FixFormula(value || "");
      if (!this.active_sheet.HasCellStyle(target)) {
        const formula_parse_result = this.parser.Parse(value);
        if (formula_parse_result) {
          if (formula_parse_result.expression?.type === "call") {
            if (!cell.style || !cell.style.number_format || NumberFormatCache.Equals(cell.style.number_format, "General")) {
              const func = formula_parse_result.expression.name.toLowerCase();
              let number_format;
              switch (func) {
                case "today":
                  number_format = "Short Date";
                  break;
                case "now":
                  number_format = "Timestamp";
                  break;
              }
              if (number_format) {
                commands.push({
                  key: 7 /* UpdateStyle */,
                  area: array ? selection.area : target,
                  style: { number_format },
                  delta: true
                });
              }
            }
          }
          if (formula_parse_result.dependencies) {
            let found_number_format = void 0;
            const list = formula_parse_result.dependencies;
            for (const key of Object.keys(list.addresses)) {
              const address = list.addresses[key];
              if (this.active_sheet.HasCellStyle({ ...address })) {
                const test = this.active_sheet.CellData({ ...address });
                if (test.style && test.style.number_format) {
                  if (!found_number_format || /%/.test(found_number_format)) {
                    found_number_format = NumberFormatCache.Translate(test.style.number_format);
                    if (!/%/.test(found_number_format)) {
                      break;
                    }
                  }
                }
              }
            }
            if (found_number_format) {
              const style = {
                number_format: NumberFormatCache.SymbolicName(found_number_format) || found_number_format
              };
              commands.push({
                key: 7 /* UpdateStyle */,
                area: array ? selection.area : target,
                style,
                delta: true
              });
            }
          }
        }
      }
    }
    let expression = this.parser.Parse(value || "").expression;
    if (expression?.type === "group" && expression.elements.length === 1 && expression.elements[0].type === "complex") {
      expression = expression.elements[0];
    }
    const parse_result = expression && expression.type === "complex" ? {
      type: 7 /* complex */,
      value: {
        real: expression.real,
        imaginary: expression.imaginary
      }
    } : ValueParser.TryParse(value);
    if (!is_function && parse_result.type === 3 /* number */) {
      let number_format = "";
      const hints = parse_result.hints || {};
      if (!cell.style || !cell.style.number_format || NumberFormatCache.Equals(cell.style.number_format, "General")) {
        if (hints.Date) {
          number_format = "Short Date";
        } else if (hints.Exponential) {
          number_format = "Exponential";
        } else if (hints.Percent) {
          number_format = "Percent";
        } else if (hints.Currency) {
          number_format = "Currency";
        } else if (hints.Grouping || hints.Parens) {
          number_format = "Accounting";
        }
      }
      if (number_format) {
        commands.push({
          key: 7 /* UpdateStyle */,
          area: array ? selection.area : target,
          style: { number_format },
          delta: true
        });
      }
    }
    commands.push({
      key: 6 /* SetRange */,
      area: array ? selection.area : target,
      array,
      value: is_function ? this.UntranslateFunction(value || "") : parse_result.value
    });
    if (exec) {
      this.ExecCommand(commands);
    } else {
      return commands;
    }
  }
  /**
   * tries to correct some basic formula errors, opening with a space,
   * not closing all parens, (...)
   */
  FixFormula(formula) {
    if (formula.trim()[0] !== "=")
      return formula;
    formula = formula.replace(/^\s+/, "");
    let q = false;
    let a = false;
    let paren = 0;
    let escape = false;
    const len = formula.length;
    for (let i = 0; i < len; i++) {
      const char = formula[i];
      if (!escape) {
        switch (char) {
          case '"':
            if (q) {
              if (formula[i + 1] === '"') {
                i++;
              } else {
                q = false;
              }
            } else if (!a) {
              q = true;
            }
            break;
          case "'":
            if (a)
              a = false;
            else if (!q)
              a = true;
            break;
          case "\\":
            escape = true;
            break;
          case "(":
            if (!q && !a)
              paren++;
            break;
          case ")":
            if (!q && !a)
              paren--;
            break;
        }
      }
    }
    if (q)
      formula += '"';
    else if (a)
      formula += "'";
    while (paren > 0) {
      formula += ")";
      paren--;
    }
    formula = this.NormalizeFormula(formula);
    return formula;
  }
  /**
   * normalize addresses (UC), function names (-> canonical) and
   * defined names (UC, for now)
   */
  NormalizeFormula(formula) {
    const parse_result = this.parser.Parse(formula);
    if (parse_result.error) {
      console.warn(parse_result.error);
    }
    if (parse_result && parse_result.expression) {
      this.parser.Walk(parse_result.expression, (unit) => {
        switch (unit.type) {
          case "call":
            unit.name = this.autocomplete_matcher.NormalizeIdentifier(unit.name) || unit.name;
            break;
          case "identifier":
            if (this.model.named_ranges.Get(unit.name)) {
              unit.name = unit.name.toUpperCase();
            }
            break;
        }
        return true;
      });
      formula = "=" + this.parser.Render(parse_result.expression, { missing: "" });
    }
    return formula;
  }
  /**
   * dismisses the in-cell editor and returns to normal behavior.
   * removes any highlighted selections (arguments).
   */
  DismissEditor() {
    if (this.overlay_editor?.active_cell) {
      this.overlay_editor.active_cell.editing = false;
      this.overlay_editor.active_cell.render_clean = [];
      this.DelayedRender(void 0, this.overlay_editor.selection.area);
    }
    this.editing_state = 0 /* NotEditing */;
    this.Focus();
    this.overlay_editor?.CloseEditor();
    this.ClearAdditionalSelections();
    this.ClearSelection(this.active_selection);
  }
  /**
   * this prepares the cell value for _editing_ -- it's not the displayed
   * value, it's how we want the value to be displayed in the editor and 
   * formula bar. 
   * 
   * NOTE: is this the spot to do translation -> local language? (...)
   * 
   */
  NormalizeCellValue(cell) {
    let cell_value = cell.value;
    if (cell.ValueIsNumber() && cell.style && cell.style.number_format) {
      const format = NumberFormatCache.Get(cell.style.number_format);
      if (format.date_format) {
        const date = LotusDate(cell.value);
        const number_format = date.getUTCHours() || date.getUTCMinutes() || date.getUTCSeconds() ? "Timestamp" : "Short Date";
        cell_value = NumberFormatCache.Get(number_format).Format(cell_value);
      } else if (/(?:%|percent)/i.test(cell.style.number_format)) {
        let precision = 0;
        const match = cell.value.toString().match(/\.(.*?)$/);
        if (match && match[1]) {
          precision = Math.max(0, match[1].length - 2);
        }
        cell_value = (cell.value * 100).toFixed(precision) + "%";
        if (Localization.decimal_separator === ",") {
          cell_value = cell_value.replace(/\./, ",");
        }
      } else {
        if (cell_value && Localization.decimal_separator === ",") {
          cell_value = cell.value.toString().replace(/\./, ",");
        }
      }
    } else if (cell.ValueIsBoolean()) {
      return cell.value.toString().toUpperCase();
    } else if (cell.ValueIsNumber()) {
      if (cell_value && Localization.decimal_separator === ",") {
        cell_value = cell.value.toString().replace(/\./, ",");
      }
    } else if (cell.ValueIsComplex()) {
      if (cell.value.imaginary) {
        if (cell.value.real) {
          cell_value = `${cell.value.real.toString()}${cell.value.imaginary < 0 ? " - " : " + "}${cell.value.imaginary === 1 || cell.value.imaginary === -1 ? "" : Math.abs(cell.value.imaginary).toString()}i`;
        } else {
          if (cell.value.imaginary === 1) {
            cell_value = "i";
          } else if (cell.value.imaginary === -1) {
            cell_value = "-i";
          } else {
            cell_value = cell.value.imaginary.toString() + "i";
          }
        }
      } else {
        cell_value = cell.value.real.toString();
      }
      if (Localization.decimal_separator === ",") {
        cell_value = cell_value.replace(/\./, ",");
      }
    } else if (cell.ValueIsFormula()) {
      cell_value = this.TranslateFunction(cell.value);
    }
    return cell_value;
  }
  /**
   * this is used to handle a trailing % sign when entering a new value.
   * we need to decide if the user is typing a number, in which case we
   * retain the %; or something else, like a formula or a string, in which
   * case we want to drop the %.
   * 
   * FIXME: move to utils lib
   */
  IsNumeric(c) {
    return c >= 48 && c <= 57 || c === this.decimal_separator_code || c === 45 || c === 43;
  }
  /**
   * start the ICE, using the new overlay editor 
   * 
   * old comment:
   * 
   * starts the in-cell editor at the given sheet address. this method doesn't
   * handle scroll-into-view, do that first if necessary.
   *
   * @param address the cell address. we'll check for merge head before editing.
   * @param flush flush contents before editing -- default for typing, !default
   * for double-click
   * @param event if this is triggered by typing, we want to pass the key
   * event directly to the editor (actually we'll pass a synthetic copy)
   * 
   * @param selection 
   * @param flush 
   * @param event 
   */
  OverlayEditCell(selection, flush = true, event) {
    if (!this.options.in_cell_editor) {
      return;
    }
    let address = selection.target || selection.area.start;
    let cell = this.active_sheet.CellData(address);
    let rect;
    this.HideHoverInfo();
    if (cell.merge_area) {
      rect = this.layout.OffsetCellAddressToRectangle(cell.merge_area.start).Combine(
        this.layout.OffsetCellAddressToRectangle(cell.merge_area.end)
      );
      address = cell.merge_area.start;
      cell = this.active_sheet.CellData(address);
    } else {
      rect = this.layout.OffsetCellAddressToRectangle(address);
    }
    if (cell.style?.locked) {
      console.info("cell is locked for editing");
      return;
    }
    rect = rect.Shift(this.layout.header_size.width, this.layout.header_size.height);
    let cell_value = cell.value;
    if (flush) {
      if ((cell.type === 3 /* number */ || cell.rendered_type === 3 /* number */) && cell.style && cell.style.number_format && /(?:%|percent)/i.test(cell.style.number_format) && (!event || this.IsNumeric(event.key.charCodeAt(0)))) {
        cell_value = "%";
      } else {
        cell_value = void 0;
      }
    } else {
      cell_value = this.NormalizeCellValue(cell);
    }
    this.overlay_editor?.Edit(selection, rect.Expand(-1, -1), cell, cell_value, event);
    cell.editing = true;
    cell.render_clean = [];
    this.DelayedRender(false, selection.area);
  }
  BoundAddressArea(address, area) {
    if (address.column > area.end.column) {
      address.row = this.StepVisibleRows(address.row, 1);
      if (address.row > area.end.row)
        address.row = area.start.row;
      address.column = area.start.column;
    } else if (address.column < area.start.column) {
      address.row = this.StepVisibleRows(address.row, -1);
      if (address.row < area.start.row)
        address.row = area.end.row;
      address.column = area.end.column;
    } else if (address.row > area.end.row) {
      address.column = this.StepVisibleColumns(address.column, 1);
      if (address.column > area.end.column)
        address.column = area.start.column;
      address.row = area.start.row;
    } else if (address.row < area.start.row) {
      address.column = this.StepVisibleColumns(address.column, -1);
      if (address.column < area.start.column)
        address.column = area.end.column;
      address.row = area.end.row;
    }
  }
  /**
   * step from row X to row (X+Y). Y can be negative. we add this method to
   * support stepping across hidden (0-height) rows, so if you down arrow
   * it doesn't get stuck inside the hidden row (bad UX).
   *
   * UPDATE: no longer clamping. various methods rely on tests for < 0, so
   * we can't change that behavior. [FIXME: return an underflow flag?]. just
   * treat negative rows as not hidden, return the result.
   */
  StepVisibleRows(start, step) {
    if (step > 0) {
      for (let i = 0; i < step; i++) {
        if (!this.layout.RowHeight(++start))
          i--;
      }
    } else if (step < 0) {
      for (let i = 0; i > step; i--) {
        if (--start >= 0 && !this.layout.RowHeight(start))
          i++;
      }
    }
    return start;
  }
  /**
   * step columns.
   * @see StepVisibleRows
   */
  StepVisibleColumns(start, step) {
    if (step > 0) {
      for (let i = 0; i < step; i++) {
        if (!this.layout.ColumnWidth(++start))
          i--;
      }
    } else if (step < 0) {
      for (let i = 0; i > step; i--) {
        if (--start >= 0 && !this.layout.ColumnWidth(start))
          i++;
      }
    }
    return start;
  }
  /** 
   * if the address is outside of current extent, expand 
   */
  EnsureAddress(address, step = 8) {
    let expanded = false;
    if (this.options.expand) {
      if (address.row !== Infinity && address.row >= this.active_sheet.rows) {
        let row = this.active_sheet.rows;
        while (address.row >= row) {
          row += step;
        }
        this.active_sheet.cells.EnsureRow(row);
        expanded = true;
      }
      if (address.column !== Infinity && address.column >= this.active_sheet.columns) {
        let column = this.active_sheet.columns;
        while (address.column >= column) {
          column += step;
        }
        this.active_sheet.cells.EnsureColumn(column);
        expanded = true;
      }
      if (expanded) {
        this.layout.UpdateTiles();
        this.layout.UpdateContentsSize();
        this.Repaint(true, true);
      }
    }
    return expanded;
  }
  /**
   * advances selection by x rows and columns. you can also step around
   * within a selection, generally by using enter and tab when there is
   * a multi-cell selection.
   *
   * not sure why this function renders by default, but we don't want that
   * in the case of closing the ICE. since normal operation may rely on this
   * behavior, at least for now, we'll make a parameter to disable. but it
   * should probably not render.
   */
  AdvanceSelection(delta, selection, within_selection = false, expand_selection = false, render = true) {
    const selecting_argument = this.SelectingArgument();
    if (selection.empty) {
      if (selecting_argument) {
        const target = {
          row: Math.max(0, this.StepVisibleRows(this.primary_selection.target.row, delta.rows)),
          column: Math.max(0, this.StepVisibleColumns(this.primary_selection.target.column, delta.columns))
        };
        this.Select(selection, new Area(target));
      } else {
        this.Select(selection, new Area({ row: 0, column: 0 }));
      }
    } else {
      const target_cell = this.active_sheet.CellData(selection.target);
      if (target_cell.merge_area && within_selection) {
        within_selection = !target_cell.merge_area.Equals(selection.area);
      }
      if (within_selection && selection.area.count > 1) {
        const area = this.active_sheet.RealArea(selection.area);
        const address = selection.target;
        for (; ; ) {
          address.row = this.StepVisibleRows(address.row, delta.rows);
          address.column = this.StepVisibleColumns(address.column, delta.columns);
          this.BoundAddressArea(address, area);
          const check_cell = this.active_sheet.CellData(address);
          if (!check_cell.merge_area || check_cell.merge_area.start.row === address.row && check_cell.merge_area.start.column === address.column)
            break;
        }
        this.Select(selection, area, address);
      } else if (expand_selection && selection && selection.target) {
        const area = selection.area;
        const target = selection.target;
        const start = area.start;
        const end = area.end;
        const scroll_target = { row: Infinity, column: Infinity };
        if (delta.columns) {
          if (area.columns === 1) {
            if (delta.columns > 0) {
              end.column = this.StepVisibleColumns(end.column, 1);
              scroll_target.column = end.column;
            } else {
              start.column = this.StepVisibleColumns(start.column, -1);
              scroll_target.column = start.column;
            }
          } else if (area.end.column > target.column) {
            end.column = this.StepVisibleColumns(end.column, delta.columns);
            scroll_target.column = end.column;
          } else if (area.start.column < target.column) {
            start.column = this.StepVisibleColumns(start.column, delta.columns);
            scroll_target.column = start.column;
          }
          end.column = Math.max(0, end.column);
          start.column = Math.max(0, start.column);
        }
        if (delta.rows) {
          if (area.rows === 1) {
            if (delta.rows > 0) {
              end.row = this.StepVisibleRows(end.row, 1);
              scroll_target.row = end.row;
            } else {
              start.row = this.StepVisibleRows(start.row, -1);
              scroll_target.row = start.row;
            }
          } else if (area.end.row > target.row) {
            end.row = this.StepVisibleRows(end.row, delta.rows);
            scroll_target.row = end.row;
          } else if (area.start.row < target.row) {
            start.row = this.StepVisibleRows(start.row, delta.rows);
            scroll_target.row = start.row;
          }
          end.row = Math.max(0, end.row);
          start.row = Math.max(0, start.row);
        }
        if (!this.options.expand) {
          for (const addr of [start, end, scroll_target]) {
            if (addr.row !== Infinity) {
              addr.row = Math.max(0, Math.min(addr.row, this.active_sheet.rows - 1));
            }
            if (addr.column !== Infinity) {
              addr.column = Math.max(0, Math.min(addr.column, this.active_sheet.columns - 1));
            }
          }
          this.ScrollIntoView(scroll_target);
          this.Select(selection, new Area(start, end), void 0, true);
        } else {
          for (const addr of [start, end, scroll_target]) {
            if (addr.row !== Infinity) {
              addr.row = Math.max(0, addr.row);
            }
            if (addr.column !== Infinity) {
              addr.column = Math.max(0, addr.column);
            }
          }
          if (this.EnsureAddress(end)) {
            render = true;
          }
          this.ScrollIntoView(scroll_target);
          this.Select(selection, new Area(start, end), void 0, true);
        }
      } else {
        const address = selection.target;
        if (target_cell.merge_area) {
          if (delta.columns < 0) {
            address.column = this.StepVisibleColumns(target_cell.merge_area.start.column, -1);
          } else if (delta.columns > 0) {
            address.column = this.StepVisibleColumns(target_cell.merge_area.end.column, 1);
          }
          if (delta.rows < 0) {
            address.row = this.StepVisibleRows(target_cell.merge_area.start.row, -1);
          } else if (delta.rows > 0) {
            address.row = this.StepVisibleRows(target_cell.merge_area.end.row, 1);
          }
        } else {
          address.row = this.StepVisibleRows(address.row, delta.rows);
          address.column = this.StepVisibleColumns(address.column, delta.columns);
        }
        if (this.EnsureAddress(address)) {
          render = true;
        }
        this.Select(selection, new Area({
          row: Math.min(
            Math.max(0, address.row),
            this.active_sheet.rows - 1
          ),
          column: Math.min(
            Math.max(0, address.column),
            this.active_sheet.columns - 1
          )
        }));
        this.RenderSelections();
        this.ScrollIntoView(selection.target);
      }
    }
    if (this.SelectingArgument())
      this.UpdateSelectedArgument(selection);
    if (render) {
      this.DelayedRender();
    }
  }
  /** highlight formula dependencies */
  HighlightDependencies(dependencies, render = true) {
    let index = 0;
    step:
      for (let area of dependencies) {
        if ((area.start.row === Infinity || area.start.row < this.active_sheet.rows) && (area.start.column === Infinity || area.start.column < this.active_sheet.columns)) {
          area = this.active_sheet.RealArea(area);
          const label = area.spreadsheet_label;
          if (this.additional_selections[index] && this.additional_selections[index].area.spreadsheet_label === label) {
            index++;
          } else {
            for (let i = 0; i < index; i++) {
              if (this.additional_selections[i].area.spreadsheet_label === label && this.additional_selections[i].area.start.sheet_id === area.start.sheet_id) {
                continue step;
              }
            }
            this.additional_selections[index++] = { target: area.start, area };
          }
        }
      }
    this.additional_selections.splice(index);
    if (render)
      this.RenderSelections(false);
  }
  /** remove all additonla (argument) selections */
  ClearAdditionalSelections() {
    this.additional_selections.splice(0, this.additional_selections.length);
  }
  /**
   * utility method, internally calls Select with an undefined area
   */
  ClearSelection(selection) {
    this.Select(selection);
  }
  HideGridSelection() {
    this.UpdateAddressLabel(void 0, "");
    const formula = this.selected_annotation && this.selected_annotation.data.formula ? this.selected_annotation.data.formula : "";
    this.UpdateFormulaBarFormula(formula);
    this.layout.ShowSelections(false);
  }
  ShowGridSelection() {
    this.UpdateAddressLabel();
    this.UpdateFormulaBarFormula();
    this.layout.ShowSelections(true);
  }
  /**
   * updates a selection, and handles marking headers as dirty
   * for subsequent renders (including any old selection).
   *
   * if the selection contains part of a merge area, it will be expanded
   * to include the full merge area (because you can't select part of a merge).
   *
   * @param area selection area
   * @param target optional selection target. if no target is passed and
   * the preseve_target field is not set, target will be set to the first
   * cell of the selection area
   * @param preserve_target preserve existing selection target
   */
  Select(selection, area, target, preserve_target = false) {
    if (!selection.empty) {
      if (preserve_target)
        target = selection.target;
    }
    if (area) {
      let real_area = this.active_sheet.RealArea(area);
      if (!target)
        target = real_area.start;
      let recheck = true;
      while (recheck) {
        recheck = false;
        this.active_sheet.cells.Apply(real_area, (cell) => {
          if (cell.merge_area && !real_area.ContainsArea(cell.merge_area)) {
            area.ConsumeArea(cell.merge_area);
            real_area = this.active_sheet.RealArea(area);
            recheck = true;
          }
        });
      }
      selection.area = new Area({ ...area.start, sheet_id: this.active_sheet.id }, area.end);
      if (target) {
        selection.target = { ...target, sheet_id: this.active_sheet.id };
      }
      selection.empty = false;
      const cell_data = this.active_sheet.CellData(selection.target);
      let text = "";
      if (cell_data.formatted) {
        if (typeof cell_data.formatted === "string") {
          text = cell_data.formatted;
        } else {
          text = cell_data.formatted.map((value) => value.flag === 1 /* hidden */ || value.flag === 6 /* formatting */ ? "" : value.text).join("");
        }
      }
      this.overlay_editor?.UpdateCaption(text);
    } else {
      selection.empty = true;
    }
    if (selection === this.primary_selection) {
      if (UA.is_edge) {
        this.Focus();
      }
      this.grid_events.Publish({
        type: "selection",
        selection: this.primary_selection
      });
      this.UpdateAddressLabel();
      this.UpdateFormulaBarFormula();
      if (this.formula_bar) {
        this.formula_bar.target_address = { ...this.primary_selection.target };
      }
      if (this.options.stats) {
        this.UpdateStats();
      }
    }
  }
  /**
   *
   */
  UpdateFormulaBarFormula(override) {
    if (!this.formula_bar) {
      return;
    }
    if (override) {
      this.formula_bar.formula = override;
      return;
    }
    if (this.primary_selection.empty) {
      this.formula_bar.formula = "";
    } else {
      let data = this.active_sheet.CellData(this.primary_selection.target);
      const head = data.merge_area || data.area;
      if (head) {
        if (head.start.column !== this.primary_selection.target.column || head.start.row !== this.primary_selection.target.row) {
          data = this.active_sheet.CellData(head.start);
        }
      }
      this.formula_bar.editable = !data.style?.locked;
      const value = this.NormalizeCellValue(data);
      if (data.validation && !data.style?.locked) {
        let list;
        if (data.validation.type === "list" /* List */) {
          list = data.validation.list;
        } else if (data.validation.type === "range" /* Range */) {
          list = this.GetValidationRange(data.validation.area);
        }
        if (list && list.length) {
          this.layout.ShowDropdownCaret(
            data.merge_area || new Area(this.primary_selection.target),
            list,
            data.value
          );
        }
      } else {
        this.layout.HideDropdownCaret();
      }
      if (data.area) {
        this.formula_bar.formula = "{" + (value || "") + "}";
      } else {
        this.formula_bar.formula = typeof value !== "undefined" ? value.toString() : "";
      }
    }
  }
  /**
   * splitting the stats update call and the rendering method, 
   * if we want to make a pluggable stats method.
   * 
   * default will show count/sum/average of numbers, either real 
   * or complex.
   */
  RenderStats(values) {
    if (!Array.isArray(values)) {
      return [];
    }
    let count = 0;
    let numbers = 0;
    const sum = { real: 0, imaginary: 0 };
    for (const row of values) {
      for (const cell of row) {
        if (typeof cell === "number") {
          sum.real += cell;
          numbers++;
        } else if (IsComplex(cell)) {
          sum.real += cell.real;
          sum.imaginary += cell.imaginary;
          numbers++;
        }
        if (typeof cell !== "undefined") {
          count++;
        }
      }
    }
    const SelectFormat = (value) => {
      const log = Math.floor(Math.log10(value));
      if (log < -6 || log > 10) {
        return NumberFormatCache.Get("Exponential");
      }
      if (log <= -1) {
        return NumberFormatCache.Get("General");
      }
      return NumberFormatCache.Get("Number");
    };
    if (count > 1) {
      if (numbers > 0) {
        const general = NumberFormatCache.Get("General");
        if (sum.imaginary) {
          const average = { real: sum.real / numbers, imaginary: sum.imaginary / numbers };
          return [
            { label: "Count", value: count.toString() },
            { label: "Sum", value: NumberFormat.FormatPartsAsText(general.FormatComplex(sum)) },
            { label: "Average", value: NumberFormat.FormatPartsAsText(general.FormatComplex(average)) }
          ];
        } else {
          return [
            { label: "Count", value: count.toString() },
            { label: "Sum", value: SelectFormat(sum.real).Format(sum.real) },
            { label: "Average", value: SelectFormat(sum.real / numbers).Format(sum.real / numbers) }
          ];
        }
      } else {
        return [{ label: "Count", value: count.toString() }];
      }
    }
    return [];
  }
  UpdateStats() {
    if (this.tab_bar) {
      let data = [];
      if (typeof this.options.stats === "function") {
        if (!this.primary_selection.empty) {
          data = this.options.stats.call(void 0, this.GetRange(this.primary_selection.area));
        }
      } else {
        if (!this.primary_selection.empty && this.primary_selection.area.count > 1) {
          data = this.RenderStats(this.GetRange(this.primary_selection.area));
        }
      }
      this.tab_bar.stats_data = data;
    }
  }
  UpdateAddressLabel(selection = this.primary_selection, text) {
    if (!this.formula_bar) {
      return;
    }
    if (typeof text !== "undefined") {
      this.formula_bar.label = text;
    } else if (selection.empty) {
      this.formula_bar.label = "";
    } else {
      const data = this.active_sheet.CellData(this.primary_selection.target);
      const target = new Area(data.merge_area ? data.merge_area.start : selection.target);
      this.formula_bar.label = this.model.named_ranges.MatchSelection(selection.area, target) || Area.CellAddressToLabel(target.start);
    }
  }
  OnDropdownSelect(value) {
    if (typeof value !== "undefined") {
      const result = ValueParser.TryParse(value.toString());
      if (result.type === 3 /* number */) {
        value = result.value;
      }
    }
    const data = this.active_sheet.CellData(this.primary_selection.target);
    const area = data.merge_area ? data.merge_area.start : this.primary_selection.target;
    this.ExecCommand({
      key: 6 /* SetRange */,
      area,
      value
    });
    this.UpdateFormulaBarFormula();
  }
  OnScroll() {
    const tiles = this.layout.VisibleTiles();
    if (!tiles.Equals(this.render_tiles)) {
      this.render_tiles = tiles;
      if (!this.layout_token) {
        this.layout_token = requestAnimationFrame(() => this.Repaint());
      }
    }
  }
  AttachListeners() {
    if (!this.container)
      throw new Error("invalid container");
    this.container.addEventListener("copy", this.HandleCopy.bind(this));
    this.container.addEventListener("cut", this.HandleCut.bind(this));
    this.container.addEventListener("paste", this.HandlePaste.bind(this));
    this.layout.grid_cover.addEventListener("mousedown", (event) => this.MouseDown_Grid(event));
    this.layout.column_header_cover.addEventListener("mousedown", (event) => this.MouseDown_ColumnHeader(event));
    this.layout.row_header_cover.addEventListener("mousedown", (event) => this.MouseDown_RowHeader(event));
    this.layout.column_header_cover.addEventListener("mousemove", (event) => this.MouseMove_ColumnHeader(event));
    this.layout.row_header_cover.addEventListener("mousemove", (event) => this.MouseMove_RowHeader(event));
    this.layout.grid_cover.addEventListener("mousemove", (event) => this.MouseMove_Grid(event));
    this.overlay_editor?.edit_node.addEventListener("keydown", (event) => this.OverlayKeyDown(event));
    this.layout.corner.addEventListener("dblclick", () => {
      this.SelectAll();
    });
    window.addEventListener("resize", () => {
      const update = this.layout.UpdateDPR();
      if (update) {
        this.QueueLayoutUpdate();
        this.Repaint(true, true, true);
      }
    });
  }
  HandleCopy(event) {
    event.stopPropagation();
    event.preventDefault();
    if (this.primary_selection.empty) {
      if (event.clipboardData) {
        event.clipboardData.clearData();
      }
      if (this.selected_annotation) {
        if (event.clipboardData) {
          const composite = JSON.stringify({
            data: this.selected_annotation,
            source: this.active_sheet.id
          });
          event.clipboardData.setData("text/x-treb-annotation", composite);
          const view = this.selected_annotation.view[this.view_index];
          if (view && view.node) {
            const node = view.node.firstChild;
            if (node) {
              const html = SerializeHTML(node).outerHTML;
              const type = "text/plain";
              event.clipboardData.setData(type, html);
            }
          }
        }
      }
    } else {
      const area = this.active_sheet.RealArea(this.primary_selection.area);
      const columns = area.columns;
      const rows = area.rows;
      const tsv_data = [];
      const treb_data = [];
      for (let row = 0; row < rows; row++) {
        const tsv_row = [];
        for (let column = 0; column < columns; column++) {
          const address = { row: area.start.row + row, column: area.start.column + column };
          const cell = this.active_sheet.CellData(address);
          let text_value = "";
          if (cell.calculated) {
            if (cell.calculated_type === 7 /* complex */) {
              text_value = ComplexToString(cell.calculated);
            } else {
              text_value = cell.calculated.toString();
            }
          } else {
            if (cell.type === 7 /* complex */) {
              text_value = ComplexToString(cell.value);
            } else {
              text_value = cell.value?.toString() || "";
            }
          }
          tsv_row.push(text_value);
          const data_entry = {
            address,
            data: cell.value,
            type: cell.type,
            style: this.active_sheet.GetCopyStyle(address)
            // excludes row pattern
          };
          if (cell.area && cell.area.start.row === address.row && cell.area.start.column === address.column) {
            data_entry.array = {
              rows: cell.area.rows,
              columns: cell.area.columns
            };
          }
          treb_data.push(JSON.parse(JSON.stringify(data_entry)));
        }
        tsv_data.push(tsv_row);
      }
      const tsv = tsv_data.map((row) => row.join("	")).join("\n");
      if (event.clipboardData) {
        event.clipboardData.clearData();
        event.clipboardData.setData("text/plain", tsv);
        event.clipboardData.setData("text/x-treb", JSON.stringify({ source: area, data: treb_data }));
      }
    }
  }
  HandleCut(event) {
    event.stopPropagation();
    event.preventDefault();
    this.HandleCopy(event);
    if (!this.primary_selection.empty) {
      const area = this.active_sheet.RealArea(this.primary_selection.area);
      this.ExecCommand({ key: 11 /* Clear */, area });
    } else if (this.selected_annotation) {
      this.RemoveAnnotation(this.selected_annotation);
    }
  }
  RecyclePasteAreas(source_area, target_area) {
    const paste_areas = [];
    if (source_area.count === 1) {
      for (let row = target_area.start.row; row <= target_area.end.row; row++) {
        for (let column = target_area.start.column; column <= target_area.end.column; column++) {
          paste_areas.push(new Area({ row, column }));
        }
      }
    } else if (source_area.columns === target_area.columns && target_area.rows >= source_area.rows && target_area.rows % source_area.rows === 0) {
      for (let row = target_area.start.row; row <= target_area.end.row; row += source_area.rows) {
        paste_areas.push(new Area(
          { row, column: target_area.start.column },
          { row: row + source_area.rows - 1, column: target_area.end.column }
        ));
      }
    } else if (source_area.rows === target_area.rows && target_area.columns >= source_area.columns && target_area.columns % source_area.columns === 0) {
      for (let column = target_area.start.column; column <= target_area.end.column; column += source_area.columns) {
        paste_areas.push(new Area(
          { column, row: target_area.start.row },
          { column: column + source_area.columns - 1, row: target_area.end.row }
        ));
      }
    } else {
      paste_areas.push(target_area.Clone().Resize(source_area.rows, source_area.columns));
    }
    return paste_areas;
  }
  HandlePaste(event) {
    if (this.overlay_editor?.editing) {
      return;
    }
    event.stopPropagation();
    event.preventDefault();
    if (!event.clipboardData)
      return;
    const annotation_data = event.clipboardData.getData("text/x-treb-annotation");
    if (annotation_data) {
      try {
        const composite = JSON.parse(annotation_data);
        if (composite.source && composite.source !== this.active_sheet.id) {
          if (composite.data && composite.data.formula) {
            let name = "";
            const sheet = this.model.sheets.Find(composite.source);
            if (sheet) {
              name = sheet.name;
            }
            if (name) {
              const parse_result = this.parser.Parse(composite.data.formula);
              if (parse_result.expression) {
                this.parser.Walk(parse_result.expression, (unit) => {
                  if (unit.type === "range") {
                    if (!unit.start.sheet_id && !unit.start.sheet) {
                      unit.start.sheet = name;
                    }
                    return false;
                  } else if (unit.type === "address") {
                    if (!unit.sheet_id && !unit.sheet) {
                      unit.sheet = name;
                    }
                  }
                  return true;
                });
                composite.data.formula = "=" + this.parser.Render(parse_result.expression, { missing: "" });
              }
            }
          }
        }
        const annotation = this.CreateAnnotation(composite.data, true, true);
        const view = annotation.view[this.view_index];
        if (view && view.node) {
          const node = view.node;
          setTimeout(() => {
            node.focus();
          }, 1);
        }
      } catch (e) {
        console.error(e);
      }
      return;
    }
    if (this.primary_selection.empty) {
      return;
    }
    const area = this.active_sheet.RealArea(this.primary_selection.area);
    const commands = [];
    const treb_data = event.clipboardData.getData("text/x-treb");
    if (treb_data) {
      try {
        const object_data = JSON.parse(treb_data);
        const source_area = new Area(object_data.source.start, object_data.source.end);
        const paste_areas = this.RecyclePasteAreas(source_area, area);
        if (paste_areas.length === 1) {
          area.Resize(paste_areas[0].rows, paste_areas[0].columns);
        }
        if (!this.ValidatePasteAreas(paste_areas)) {
          this.Error(5 /* invalid_area_for_paste */);
          return;
        }
        const arrays = [];
        for (const paste_area of paste_areas) {
          this.active_sheet.cells.EnsureCell(paste_area.end);
          commands.push({ key: 11 /* Clear */, area: paste_area });
          const offsets = {
            rows: paste_area.start.row - source_area.start.row,
            columns: paste_area.start.column - source_area.start.column
          };
          object_data.data.forEach((cell_info) => {
            let data = cell_info.data;
            const target_address = {
              row: cell_info.address.row - source_area.start.row + paste_area.start.row,
              column: cell_info.address.column - source_area.start.column + paste_area.start.column
            };
            if (cell_info.type === 1 /* formula */) {
              const parse_result = this.parser.Parse(data);
              if (parse_result.expression) {
                data = "=" + this.parser.Render(parse_result.expression, {
                  offset: offsets,
                  missing: ""
                });
              }
            }
            if (cell_info.array) {
              const target_array = {
                start: {
                  ...target_address
                },
                end: {
                  row: target_address.row + cell_info.array.rows - 1,
                  column: target_address.column + cell_info.array.columns - 1
                }
              };
              const command = {
                key: 6 /* SetRange */,
                value: data,
                array: true,
                area: target_array
              };
              arrays.push(new Area(target_array.start, target_array.end));
              commands.push(command);
            } else {
              let skip = false;
              for (const array of arrays) {
                if (array.Contains(target_address)) {
                  skip = true;
                  break;
                }
              }
              if (!skip) {
                commands.push({ key: 6 /* SetRange */, value: data, area: target_address });
              }
            }
            commands.push({ key: 7 /* UpdateStyle */, style: cell_info.style || {}, area: target_address });
          });
        }
      } catch (e) {
        console.error("invalid treb data on clipboard");
        console.info(e);
        return;
      }
    } else {
      const text_data = event.clipboardData.getData("text/plain");
      if (!text_data)
        return true;
      const lines = text_data.trim().split("\n");
      const source = lines.map((line) => line.split("	").map((x) => x.trim()));
      const paste_areas = this.RecyclePasteAreas(
        new Area({ row: 0, column: 0 }, { row: source.length - 1, column: source[0].length - 1 }),
        area
      );
      if (paste_areas.length === 1) {
        area.Resize(source.length, source[0].length);
        area.Resize(paste_areas[0].rows, paste_areas[0].columns);
      }
      if (!this.ValidatePasteAreas(paste_areas)) {
        this.Error(5 /* invalid_area_for_paste */);
        return;
      }
      for (const paste_area of paste_areas) {
        for (let r = 0; r < source.length; r++) {
          for (let c = 0; c < source[0].length; c++) {
            const target_area = new Area({ row: r + paste_area.start.row, column: c + paste_area.start.column });
            this.active_sheet.cells.EnsureCell(target_area.end);
            if (source[r][c]) {
              const tmp = this.SetInferredType(
                { area: target_area, target: target_area.start, empty: false },
                source[r][c],
                false,
                false
              );
              if (tmp) {
                for (const command of tmp) {
                  commands.push(command);
                }
              }
            } else {
              const current = this.active_sheet.cells.GetCell(target_area.start, false);
              if (current && current.type !== 0 /* undefined */) {
                commands.push({ key: 11 /* Clear */, area: target_area.Clone() });
              }
            }
          }
        }
      }
    }
    this.ExecCommand(commands);
    this.Select(this.primary_selection, area);
  }
  /**
   * utility method returns all selections (primary, active and any additional
   * selections) as an array. defaults to non-empty selections only, but
   * can optionally returns empty non-null selections.
   */
  AllSelections(include_empty_selections = false) {
    const selections = [this.primary_selection, this.active_selection].concat(this.additional_selections);
    if (include_empty_selections)
      return selections;
    return selections.filter((selection) => !selection.empty);
  }
  /**
   * UI method for inserting rows; updates layout
   */
  InsertRowsInternal(command) {
    const result = super.InsertRowsInternal(command);
    if (result.error) {
      return result;
    }
    const target_sheet = this.FindSheet(command.sheet_id);
    if (target_sheet === this.active_sheet) {
      if (command.count < 0) {
        for (const selection of this.AllSelections()) {
          selection.empty = true;
        }
      } else {
        for (const selection of this.AllSelections()) {
          if (selection.target.row >= command.before_row) {
            selection.target.row += command.count;
          }
          if (!selection.area.entire_column) {
            if (selection.area.start.row >= command.before_row) {
              selection.area.Shift(command.count, 0);
            } else if (selection.area.end.row >= command.before_row) {
              selection.area.ConsumeAddress({
                row: selection.area.end.row + command.count,
                column: selection.area.end.column
              });
            }
          }
        }
      }
      for (const annotation of result.delete_annotations_list || []) {
        this.layout.RemoveAnnotation(annotation);
      }
      this.QueueLayoutUpdate();
      this.Repaint();
      if (result.update_annotations_list?.length) {
        this.layout.UpdateAnnotation(result.update_annotations_list);
        for (const annotation of result.resize_annotations_list || []) {
          const view = annotation.view[this.view_index];
          if (view?.resize_callback) {
            view.resize_callback.call(void 0);
          }
        }
      }
    } else {
      this.pending_layout_update.add(target_sheet.id);
    }
    return result;
  }
  /**
   * UI method for inserting columns; updates layout
   */
  InsertColumnsInternal(command) {
    const result = super.InsertColumnsInternal(command);
    if (result.error) {
      return result;
    }
    const target_sheet = this.FindSheet(command.sheet_id);
    if (target_sheet === this.active_sheet) {
      if (command.count < 0) {
        for (const selection of this.AllSelections()) {
          selection.empty = true;
        }
      } else {
        for (const selection of this.AllSelections()) {
          if (selection.target.column >= command.before_column) {
            selection.target.column += command.count;
          }
          if (!selection.area.entire_row) {
            if (selection.area.start.column >= command.before_column) {
              selection.area.Shift(0, command.count);
            } else if (selection.area.end.column >= command.before_column) {
              selection.area.ConsumeAddress({
                row: selection.area.end.row,
                column: selection.area.end.column + command.count
              });
            }
          }
        }
      }
      for (const annotation of result.delete_annotations_list || []) {
        this.layout.RemoveAnnotation(annotation);
      }
      this.tile_renderer?.FlushOverflows();
      this.QueueLayoutUpdate();
      this.DelayedRender(true, void 0, true);
      if (result.update_annotations_list?.length) {
        this.layout.UpdateAnnotation(result.update_annotations_list);
        for (const annotation of result.resize_annotations_list || []) {
          const view = annotation.view[this.view_index];
          if (view?.resize_callback) {
            view.resize_callback.call(void 0);
          }
        }
      }
    } else {
      this.pending_layout_update.add(target_sheet.id);
    }
    return result;
  }
  /**
   * specialization
   */
  ResetInternal() {
    super.ResetInternal();
    this.RemoveAnnotationNodes();
    this.ClearSelection(this.primary_selection);
    this.ScrollIntoView({ row: 0, column: 0 });
    this.QueueLayoutUpdate();
    this.layout.HideNote();
  }
  /**
   * overload: see ResizeRowsInternal
   */
  ResizeColumnsInternal(command) {
    const sheet = command.sheet_id ? this.FindSheet(command.sheet_id) : this.active_sheet;
    let column = command.column;
    if (typeof column === "undefined") {
      column = [];
      for (let i = 0; i < sheet.columns; i++)
        column.push(i);
    }
    if (typeof column === "number")
      column = [column];
    const auto = typeof command.width !== "number";
    const width = Math.round(command.width || 0 / this.scale);
    if (auto) {
      for (const entry of column) {
        this.AutoSizeColumn(sheet, entry, false);
      }
    } else {
      for (const entry of column) {
        sheet.SetColumnWidth(entry, width);
      }
    }
    if (sheet === this.active_sheet) {
      this.layout.UpdateTotalSize();
      if (this.layout.container && this.layout.container.offsetWidth && this.layout.container.offsetWidth > this.layout.total_width) {
        this.UpdateLayout();
      } else {
        this.layout.UpdateTileWidths(true);
        this.render_tiles = this.layout.VisibleTiles();
        this.Repaint(false, true);
      }
      this.layout.UpdateAnnotation(this.active_sheet.annotations);
      this.RenderSelections();
    } else {
      this.pending_layout_update.add(sheet.id);
    }
  }
  /**
   * UI grid supports scale and auto-size, so we're overloading.
   * @param command 
   */
  ResizeRowsInternal(command) {
    let updated;
    const sheet = command.sheet_id ? this.FindSheet(command.sheet_id) : this.active_sheet;
    let row = command.row;
    if (typeof row === "undefined") {
      row = [];
      for (let i = 0; i < sheet.rows; i++)
        row.push(i);
    }
    if (typeof row === "number")
      row = [row];
    const shrink = typeof command.shrink === "boolean" ? command.shrink : true;
    const auto = typeof command.height !== "number";
    const height = Math.round(command.height || 0 / this.scale);
    if (auto) {
      for (const entry of row) {
        const current = sheet.GetRowHeight(entry);
        if (!current) {
          if (!updated) {
            updated = new Area({ row: entry, column: Infinity, sheet_id: sheet.id });
          } else {
            updated.ConsumeAddress({ row: entry, column: 1 });
          }
        }
        sheet.AutoSizeRow(entry, this.theme.grid_cell, shrink);
      }
    } else {
      for (const entry of row) {
        const current = sheet.GetRowHeight(entry);
        if (!current && height || current && !height) {
          if (!updated) {
            updated = new Area({ row: entry, column: Infinity, sheet_id: sheet.id });
          } else {
            updated.ConsumeAddress({ row: entry, column: 1 });
          }
        }
        sheet.SetRowHeight(entry, height);
      }
    }
    if (sheet === this.active_sheet) {
      this.layout.UpdateTotalSize();
      if (this.layout.container && this.layout.container.offsetHeight && this.layout.container.offsetHeight > this.layout.total_height) {
        this.UpdateLayout();
      } else {
        this.layout.UpdateTileHeights(true);
        this.render_tiles = this.layout.VisibleTiles();
        this.Repaint(false, true);
      }
      this.layout.UpdateAnnotation(this.active_sheet.annotations);
      this.RenderSelections();
    } else {
      this.pending_layout_update.add(sheet.id);
    }
    return updated ? { start: updated.start, end: updated.end } : void 0;
  }
  /**
   * specialization
   */
  SelectInternal(command) {
    if (!command.area) {
      this.ClearSelection(this.primary_selection);
    } else {
      if (command.area.start.sheet_id && command.area.start.sheet_id !== this.active_sheet.id) {
        this.ActivateSheetInternal({
          key: 21 /* ActivateSheet */,
          id: command.area.start.sheet_id
        });
      }
      this.Select(this.primary_selection, new Area(command.area.start, command.area.end));
      this.RenderSelections();
    }
  }
  /**
   * specialization. all the base class method does is set the sheet 
   * fields, so we don't need to call it, we can do that.
   * 
   */
  FreezeInternal(command) {
    const sheet = this.FindSheet(command.sheet_id || this.active_sheet.id);
    const highlight = (typeof command.highlight_transition === "boolean" ? command.highlight_transition : true) && sheet === this.active_sheet;
    if (command.rows === sheet.freeze.rows && command.columns === sheet.freeze.columns) {
      if (highlight) {
        this.HighlightFreezeArea();
      }
      return;
    }
    sheet.freeze.rows = command.rows;
    sheet.freeze.columns = command.columns;
    if (sheet === this.active_sheet) {
      this.QueueLayoutUpdate();
      this.Repaint();
      if (highlight) {
        this.HighlightFreezeArea();
      }
      if (command.rows || command.columns) {
        this.layout.CloneFrozenAnnotations();
      } else {
        this.layout.ClearFrozenAnnotations();
      }
    } else {
      this.pending_layout_update.add(sheet.id);
    }
  }
  //////////////////////////////////////////////////////////////////////////////
  ExecCommand(commands, queue = true) {
    const flags = super.ExecCommand(commands, queue);
    if (!this.batch) {
      if (flags.render_area) {
        this.DelayedRender(false, flags.render_area);
      }
    }
    if (flags.repaint) {
      this.Repaint();
    }
    for (const id of flags.pending || []) {
      this.pending_layout_update.add(id);
    }
    if (flags.layout) {
      this.QueueLayoutUpdate();
    }
    if (flags.sheets && this.tab_bar) {
      this.tab_bar.Update();
    }
    if (flags.formula) {
      this.UpdateFormulaBarFormula();
    }
    return flags;
  }
};

// treb-grid/src/types/named_range.ts
var NamedRangeCollection = class {
  forward = {};
  backward = [];
  /** FIXME: why not an accessor? */
  Count() {
    return this.backward.length;
  }
  /** FIXME: why not just use toJSON? */
  Serialize() {
    return JSON.parse(JSON.stringify(this.Map()));
  }
  Deserialize(data) {
    this.Reset();
    if (data) {
      for (const key of Object.keys(data)) {
        this.SetName(key, new Area(data[key].start, data[key].end), false);
      }
      this.RebuildList();
    }
  }
  /**
   * match an area, optionally a target within a larger area (for selections).
   * we don't use the selection directly, as we may need to adjust target for
   * merge area.
   */
  MatchSelection(area, target) {
    if (!area.start.sheet_id) {
      throw new Error("match selection without sheet id");
    }
    let label;
    for (const entry of this.List()) {
      if (entry.range.start.sheet_id === area.start.sheet_id) {
        if (entry.range.Equals(area)) {
          label = entry.name;
        }
        if (target?.Equals(entry.range)) {
          return entry.name;
        }
      }
    }
    return label;
  }
  /**
   * add name. names are case-insensitive. if the name already
   * exists, it will be overwritten.
   * 
   * update: returns success (FIXME: proper errors)
   */
  SetName(name, range, apply = true) {
    const validated = this.ValidateNamed(name);
    if (!validated) {
      console.warn("invalid name");
      return false;
    }
    if (range.entire_column || range.entire_row) {
      console.warn("invalid range");
      return false;
    }
    this.forward[validated] = range;
    if (apply) {
      this.RebuildList();
    }
    return true;
  }
  SetNames(list) {
    for (const key of Object.keys(list)) {
      const area = list[key];
      this.SetName(key, new Area(area.start, area.end), false);
    }
    this.RebuildList();
  }
  ClearName(name, apply = true) {
    delete this.forward[name];
    if (apply) {
      this.RebuildList();
    }
  }
  /**
   * if we delete a sheet, remove ranges in that sheet
   * @param sheet_id 
   */
  RemoveRangesForSheet(sheet_id, apply = true) {
    const temp = {};
    const list = this.List();
    for (const entry of list) {
      if (entry.range.start.sheet_id !== sheet_id) {
        temp[entry.name] = entry.range;
      }
    }
    this.forward = temp;
    if (apply) {
      this.RebuildList();
    }
  }
  Reset() {
    this.forward = {};
    this.backward = [];
  }
  Get(name) {
    return this.forward[name.toUpperCase()];
  }
  /** FIXME: accessor */
  Map() {
    return this.forward;
  }
  /** FIXME: accessor */
  List() {
    return this.backward;
  }
  /**
   * named range rules:
   *
   * - legal characters are alphanumeric, underscore and dot.
   * - must start with letter or underscore (not a number or dot).
   * - cannot look like a spreadsheet address, which is 1-3 letters followed by numbers.
   *
   * returns a normalized name (just caps, atm)
   */
  ValidateNamed(name) {
    name = name.trim();
    if (!name.length)
      return false;
    if (/^[A-Za-z]{1,3}\d+$/.test(name))
      return false;
    if (/[^A-Za-z\d_.]/.test(name))
      return false;
    if (/^[^A-Za-z_]/.test(name))
      return false;
    return name.toUpperCase();
  }
  // was in sheet
  /**
   * fix named range references after row/column insert/delete
   */
  PatchNamedRanges(sheet_id, before_column, column_count, before_row, row_count) {
    const copy = this.List().slice(0);
    for (const entry of copy) {
      const key = entry.name;
      const range = entry.range;
      if (range.start.sheet_id !== sheet_id) {
        console.info("skipping name", key);
        continue;
      }
      if (column_count && before_column <= range.end.column) {
        if (column_count > 0) {
          if (before_column <= range.start.column) {
            range.Shift(0, column_count);
          } else if (before_column > range.start.column && before_column <= range.end.column) {
            range.ConsumeAddress({ row: range.end.row, column: range.end.column + column_count });
          } else {
            console.warn(`PNR X case 1`, before_column, column_count, JSON.stringify(range));
          }
        } else if (column_count < 0) {
          if (before_column - column_count <= range.start.column) {
            range.Shift(0, column_count);
          } else if (before_column <= range.start.column && before_column - column_count > range.end.column) {
            this.ClearName(key, false);
          } else if (before_column <= range.start.column) {
            const last_column = before_column - column_count - 1;
            this.SetName(key, new Area({
              row: range.start.row,
              column: last_column + 1 + column_count,
              sheet_id
            }, {
              row: range.end.row,
              column: range.end.column + column_count
            }), false);
          } else if (before_column <= range.end.column) {
            const last_column = before_column - column_count - 1;
            if (last_column >= range.end.column) {
              this.SetName(key, new Area({
                row: range.start.row,
                column: range.start.column,
                sheet_id
              }, {
                row: range.end.row,
                column: before_column - 1
              }), false);
            } else {
              this.SetName(key, new Area({
                row: range.start.row,
                column: range.start.column,
                sheet_id
              }, {
                row: range.end.row,
                column: range.start.column + range.columns + column_count - 1
              }), false);
            }
          } else {
            console.warn(`PNR X case 2`, before_column, column_count, JSON.stringify(range));
          }
        }
      }
      if (row_count && before_row <= range.end.row) {
        if (row_count > 0) {
          if (before_row <= range.start.row) {
            range.Shift(row_count, 0);
          } else if (before_row > range.start.row && before_row <= range.end.row) {
            range.ConsumeAddress({ row: range.end.row + row_count, column: range.end.column });
          } else {
            console.warn(`PNR X case 3`, before_row, row_count, JSON.stringify(range));
          }
        } else if (row_count < 0) {
          if (before_row - row_count <= range.start.row) {
            range.Shift(row_count, 0);
          } else if (before_row <= range.start.row && before_row - row_count > range.end.row) {
            this.ClearName(key, false);
          } else if (before_row <= range.start.row) {
            const last_row = before_row - row_count - 1;
            this.SetName(key, new Area({
              column: range.start.column,
              row: last_row + 1 + row_count,
              sheet_id
            }, {
              column: range.end.column,
              row: range.end.row + row_count
            }), false);
          } else if (before_row <= range.end.row) {
            const last_row = before_row - row_count - 1;
            if (last_row >= range.end.row) {
              this.SetName(key, new Area({
                column: range.start.column,
                row: range.start.row,
                sheet_id
              }, {
                column: range.end.column,
                row: before_row - 1
              }), false);
            } else {
              this.SetName(key, new Area({
                column: range.start.column,
                row: range.start.row,
                sheet_id
              }, {
                column: range.end.column,
                row: range.start.row + range.rows + row_count - 1
              }), false);
            }
          } else {
            console.warn(`PNR X case 4`, before_row, row_count, JSON.stringify(range));
          }
        }
      }
    }
    this.RebuildList();
  }
  RebuildList() {
    this.backward = [];
    for (const key of Object.keys(this.forward)) {
      this.backward.push({ name: key, range: this.forward[key] });
    }
  }
};

// treb-grid/src/types/data_model.ts
var SheetCollection = class {
  /** 
   * returns a read-only copy of the list. useful for indexing or 
   * functional-style calls. it's not actually read-only, but it's a 
   * copy, so changes will be ignored.
   */
  get list() {
    return this.sheets_.slice(0);
  }
  /**
   * length of list
   */
  get length() {
    return this.sheets_.length;
  }
  /** map of (normalized) name -> sheet */
  names = /* @__PURE__ */ new Map();
  /** map of id -> sheet */
  ids = /* @__PURE__ */ new Map();
  /** the actual list */
  sheets_ = [];
  /**
   * remove any existing sheets and add the passed list. updates indexes.
   */
  Assign(sheets) {
    this.sheets_ = [...sheets];
    this.UpdateIndexes();
  }
  /** 
   * add a new sheet to the end of the list (push). updates indexes. 
   */
  Add(sheet) {
    this.sheets_.push(sheet);
    this.UpdateIndexes();
  }
  /** 
   * wrapper for array splice. updates indexes. 
   */
  Splice(insert_index, delete_count, ...items) {
    this.sheets_.splice(insert_index, delete_count, ...items);
    this.UpdateIndexes();
  }
  /**
   * so our new strategy is to add lookup methods first -- then 
   * we can fix the underlying storage implementation.
   * 
   * NOTE we normalize strings here so you do not need to do it (don't)
   */
  Find(id) {
    if (typeof id === "string") {
      return this.names.get(id.toLocaleUpperCase());
    } else {
      return this.ids.get(id);
    }
    return void 0;
  }
  /** get name for sheet with given id */
  Name(id) {
    return this.ids.get(id)?.name || void 0;
  }
  /** get ID for sheet with given name */
  ID(name) {
    return this.names.get(name.toLocaleUpperCase())?.id || void 0;
  }
  /** not sure why this is private, makes it a little more complicated */
  UpdateIndexes() {
    this.names.clear();
    this.ids.clear();
    for (const sheet of this.sheets_) {
      const uc = sheet.name.toLocaleUpperCase();
      this.names.set(uc, sheet);
      this.ids.set(sheet.id, sheet);
    }
  }
};
var DataModel = class {
  parser = new Parser();
  /** document metadata */
  document_name;
  /** document metadata */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  user_data;
  /** 
   * list of sheets. we _should_ index these by ID, so we 
   * don't have to look up. FIXME/TODO
   */
  // public sheets: Sheet[] = [];
  /**
   * this prevents assignment, but not push/pop/splice (baby steps)
   */
  // public get sheets(): Sheet[] {
  //  return this._sheets;
  //}
  sheets = new SheetCollection();
  /** named ranges are document-scope, we don't support sheet-scope names */
  named_ranges = new NamedRangeCollection();
  /** macro functions are functions written in spreadsheet language */
  // public macro_functions: Record<string, MacroFunction> = {};
  macro_functions = /* @__PURE__ */ new Map();
  /** 
   * new, for parametric. these might move to a different construct. 
   */
  //public named_expressions: Record<string, ExpressionUnit> = {};
  named_expressions = /* @__PURE__ */ new Map();
  /** index for views */
  view_count = 0;
  /**
   * base style properties moved to model, so we can have a single
   * and consistent reference.
   */
  theme_style_properties = JSON.parse(JSON.stringify(Style.DefaultProperties));
  /**
   * tables are global, because we need to reference them by name; and they
   * need unique names, so we need to keep track of names. name matching is
   * icase so we lc the names before inserting.
   */
  tables = /* @__PURE__ */ new Map();
  /**
   * putting this here temporarily. it should probably move into a table
   * manager class or something like that.
   */
  ResolveStructuredReference(ref, context) {
    let table;
    if (ref.table) {
      table = this.tables.get(ref.table.toLowerCase());
    } else {
      if (context.sheet_id) {
        const sheet = this.sheets.Find(context.sheet_id);
        const cell = sheet?.CellData(context);
        table = cell?.table;
      }
    }
    if (!table) {
      return void 0;
    }
    const reference_column = ref.column.toLowerCase();
    let column = -1;
    if (table.columns) {
      for (let i = 0; i < table.columns.length; i++) {
        if (reference_column === table.columns[i]) {
          column = table.area.start.column + i;
          break;
        }
      }
    }
    if (column < 0) {
      return void 0;
    }
    if (ref.scope === "row") {
      const row = context.row;
      if (row < table.area.start.row || row > table.area.end.row) {
        return void 0;
      }
      return {
        label: ref.label,
        type: "address",
        row,
        column,
        sheet_id: table.area.start.sheet_id,
        id: ref.id,
        position: ref.position
      };
    } else {
      let start_row = table.area.start.row;
      let end_row = table.area.end.row;
      if (ref.scope === "column") {
        start_row++;
        if (table.totals_row) {
          end_row--;
        }
      }
      return {
        label: ref.label,
        type: "range",
        position: ref.position,
        id: ref.id,
        start: {
          type: "address",
          row: start_row,
          column,
          sheet_id: table.area.start.sheet_id,
          label: ref.label,
          position: ref.position,
          id: 0
        },
        end: {
          type: "address",
          row: end_row,
          column,
          label: ref.label,
          position: ref.position,
          id: 0
        }
      };
    }
    return void 0;
  }
  /**
   * return an address label for this address (single cell or range)
   * 
   * @param address 
   * @param active_sheet 
   */
  AddressToLabel(address, active_sheet) {
    const start = IsCellAddress(address) ? address : address.start;
    const parts = IsCellAddress(address) ? [Area.CellAddressToLabel(address)] : [Area.CellAddressToLabel(address.start), Area.CellAddressToLabel(address.end)];
    const sheet = this.sheets.Find(start.sheet_id || 0);
    const name = sheet?.name ? QuotedSheetNameRegex.test(sheet.name) ? `'${sheet.name}'` : sheet.name : "";
    return name + (name ? "!" : "") + (parts[0] === parts[1] ? parts[0] : parts.join(":"));
  }
  // --- resolution api, moved from calculator ---------------------------------
  /**
   * returns false if the sheet cannot be resolved, which probably
   * means the name changed (that's the case we are working on with
   * this fix).
   */
  ResolveSheetID(expr, context, active_sheet) {
    const target = expr.type === "address" ? expr : expr.start;
    if (target.sheet_id) {
      return true;
    }
    if (target.sheet) {
      const sheet = this.sheets.Find(target.sheet);
      if (sheet) {
        target.sheet_id = sheet.id;
        return true;
      }
    } else if (context?.sheet_id) {
      target.sheet_id = context.sheet_id;
      return true;
    } else if (active_sheet?.id) {
      target.sheet_id = active_sheet.id;
      return true;
    }
    return false;
  }
  /** wrapper method ensures it always returns an Area (instance, not interface) */
  ResolveArea(address, active_sheet) {
    const resolved = this.ResolveAddress(address, active_sheet);
    return IsCellAddress(resolved) ? new Area(resolved) : new Area(resolved.start, resolved.end);
  }
  /** 
   * moved from embedded sheet. also modified to preserve ranges, so it
   * might return a range (area). if you are expecting the old behavior
   * you need to check (perhaps we could have a wrapper, or make it optional?)
   * 
   * Q: why does this not go in grid? or model? (...)
   * Q: why are we not preserving absoute/relative? (...)
   * 
   */
  ResolveAddress(address, active_sheet) {
    if (typeof address === "string") {
      const parse_result = this.parser.Parse(address);
      if (parse_result.expression && parse_result.expression.type === "address") {
        this.ResolveSheetID(parse_result.expression, void 0, active_sheet);
        return {
          row: parse_result.expression.row,
          column: parse_result.expression.column,
          sheet_id: parse_result.expression.sheet_id
        };
      } else if (parse_result.expression && parse_result.expression.type === "range") {
        this.ResolveSheetID(parse_result.expression, void 0, active_sheet);
        return {
          start: {
            row: parse_result.expression.start.row,
            column: parse_result.expression.start.column,
            sheet_id: parse_result.expression.start.sheet_id
          },
          end: {
            row: parse_result.expression.end.row,
            column: parse_result.expression.end.column
          }
        };
      } else if (parse_result.expression && parse_result.expression.type === "identifier") {
        const named_range = this.named_ranges.Get(parse_result.expression.name);
        if (named_range) {
          return named_range;
        }
      }
      return { row: 0, column: 0 };
    }
    return address;
  }
  AddConnectedElement(connected_element) {
    const id = this.connected_element_id++;
    this.connected_elements.set(id, connected_element);
    return id;
  }
  RemoveConnectedElement(id) {
    const element = this.connected_elements.get(id);
    this.connected_elements.delete(id);
    return element;
  }
  /** 
   * identifier for connected elements, used to manage. these need to be 
   * unique in the lifetime of a model instance, but no more than that.
   */
  connected_element_id = 100;
  /** 
   * these are intentionally NOT serialized. they're ephemeral, created 
   * at runtime and not persistent.
   * 
   * @internal
   */
  connected_elements = /* @__PURE__ */ new Map();
};

// treb-grid/src/types/conditional_format.ts
var StandardGradientsList = {
  "red-green": {
    color_space: "RGB",
    stops: [
      { value: 0, color: { theme: 5, tint: 0.5 } },
      { value: 1, color: { theme: 9, tint: 0.5 } }
    ]
  },
  "red-yellow-green": {
    color_space: "RGB",
    stops: [
      { value: 0, color: { theme: 5, tint: 0.5 } },
      { value: 0.5, color: { theme: 7, tint: 0.5 } },
      { value: 1, color: { theme: 9, tint: 0.5 } }
    ]
  },
  "green-red": {
    color_space: "RGB",
    stops: [
      { value: 0, color: { theme: 9, tint: 0.5 } },
      { value: 1, color: { theme: 5, tint: 0.5 } }
    ]
  },
  "green-yellow-red": {
    color_space: "RGB",
    stops: [
      { value: 0, color: { theme: 9, tint: 0.5 } },
      { value: 0.5, color: { theme: 7, tint: 0.5 } },
      { value: 1, color: { theme: 5, tint: 0.5 } }
    ]
  }
};

// treb-calculator/src/dag/vertex.ts
var Vertex = class _Vertex {
  /** 
   * vertex and its subclasses have a type parameter for type 
   * guards/reflection; each instance has a type that is set
   * to the static class type.
   */
  static type = "vertex";
  // --- members ---
  type = _Vertex.type;
  // for type guard
  color = 0 /* white */;
  // for loop check
  /** dependencies */
  // public edges_in: Vertex[] = [];
  edges_in = /* @__PURE__ */ new Set();
  /** dependents */
  // public edges_out: Vertex[] = [];
  edges_out = /* @__PURE__ */ new Set();
  // --- accessors ---
  get has_inbound_edges() {
    return this.edges_in.size > 0;
  }
  get has_outbound_edges() {
    return this.edges_out.size > 0;
  }
  // --- cleanup operations ---
  /** reset this node */
  Reset() {
    for (const edge of this.edges_out) {
      edge.RemoveDependency(this);
    }
    for (const edge of this.edges_in) {
      edge.RemoveDependent(this);
    }
    this.edges_out.clear();
    this.edges_in.clear();
  }
  /** removes all inbound edges (dependencies) */
  ClearDependencies() {
    for (const edge of this.edges_in) {
      edge.RemoveDependent(this);
    }
    this.edges_in.clear();
  }
  // --- basic node operations ---
  /** add a dependent. doesn't add if already in the list */
  AddDependent(edge) {
    if (edge === this)
      return;
    if (this.edges_out.has(edge)) {
      return;
    }
    this.edges_out.add(edge);
  }
  /** remove a dependent */
  RemoveDependent(edge) {
    this.edges_out.delete(edge);
  }
  /** add a dependency. doesn't add if already in the list */
  AddDependency(edge) {
    if (edge === this)
      return;
    if (this.edges_in.has(edge)) {
      return;
    }
    this.edges_in.add(edge);
  }
  /** remove a dependency */
  RemoveDependency(edge) {
    this.edges_in.delete(edge);
  }
  /** 
   * this is a composite operation, because the operations are always called 
   * in pairs. this means create a pair of links such that _edge_ depends on
   * _this_.
   */
  LinkTo(edge) {
    this.AddDependent(edge);
    edge.AddDependency(this);
  }
  /**
   * this is an alteranate formulation that may make more intuitive sense.
   * it creates a pair of forward/backward links, such that _this_ depends
   * on _edge_.
   */
  DependsOn(edge) {
    this.AddDependency(edge);
    edge.AddDependent(this);
  }
  /**
   * this is called during calculation (if necessary). on a hit (loop), we 
   * reset the color of this, the test node, to white. there are two reasons 
   * for this: 
   * 
   * one, we want subsequent tests to also find the hit. in some cases we may
   * not be marking the node as a loop (if it precedes the backref in the graph),
   * so we want subsequent nodes to also hit the loop. [Q: this makes no sense,
   * because this would still hit if the node were marked grey, assuming you
   * test for that].
   * 
   * two, if you fix the loop, on a subsequent call we want to force a re-check,
   * which we can do if the vertex is marked white. [Q: could also be done on
   * gray?]
   * 
   * [A: logically you are correct, but this works, and matching grey does not].
   */
  LoopCheck() {
    const stack = [this];
    while (stack.length) {
      const v = stack[stack.length - 1];
      let complete = true;
      if (v.color !== 2 /* black */) {
        v.color = 1 /* gray */;
        for (const edge of v.edges_out) {
          if (edge.color === 1 /* gray */) {
            this.color = 0 /* white */;
            return true;
          }
          if (edge.color === 0 /* white */ && edge.edges_out.size) {
            stack.push(edge);
            complete = false;
          }
        }
      }
      if (complete) {
        v.color = 2 /* black */;
        stack.pop();
      }
    }
    this.color = 2 /* black */;
    return false;
  }
  /*
    public LoopCheck2(compare: Vertex = this): boolean {
      this.color = Color.gray;
  
      for (const edge of this.edges_out) {
        if (edge.color === Color.gray || (edge.color === Color.white && edge.LoopCheck2(compare))) { 
          this.color = Color.white; // someone else can test
          return edge === compare; // loop
        } 
      }
  
      this.color = Color.black;
      return false;
      
    }
    */
};

// treb-calculator/src/dag/spreadsheet_vertex_base.ts
var SpreadsheetVertexBase = class extends Vertex {
  dirty = false;
};

// treb-calculator/src/function-error.ts
var NotImplError = { error: "NOTIMPL" /* NotImpl */ };
var NAError = () => {
  return { type: 6 /* error */, value: "N/A" /* NA */ };
};
var ExpressionError = () => {
  return { type: 6 /* error */, value: "EXPR" /* Expression */ };
};
var DivideByZeroError = () => {
  return { type: 6 /* error */, value: "DIV/0" /* Div0 */ };
};
var ArgumentError = () => {
  return { type: 6 /* error */, value: "ARG" /* Argument */ };
};
var ValueError = () => {
  return { type: 6 /* error */, value: "VALUE" /* Value */ };
};
var ReferenceError2 = () => {
  return { type: 6 /* error */, value: "REF" /* Reference */ };
};
var NameError = () => {
  return { type: 6 /* error */, value: "NAME" /* Name */ };
};
var UnknownError = () => {
  return { type: 6 /* error */, value: "UNK" /* Unknown */ };
};

// treb-calculator/src/dag/spreadsheet_vertex.ts
var SpreadsheetVertex = class _SpreadsheetVertex extends SpreadsheetVertexBase {
  static type = "spreadsheet-vertex";
  // I wonder if we should drop this and look up on demand -- might
  // help in large blocks...
  reference;
  error = 0 /* None */;
  // why is this (?)? can't we use a default junk address?
  address;
  //public result: UnionOrArray = UndefinedUnion();
  result = { type: 0 /* undefined */ };
  expression = { type: "missing", id: -1 };
  expression_error = false;
  short_circuit = false;
  type = _SpreadsheetVertex.type;
  // for type guard
  /** 
   * it seems like this could be cached, if it gets checked a lot 
   * also what's with the crazy return signature? [fixed]
   */
  get array_head() {
    if (!this.address)
      return false;
    return !!this.reference && !!this.reference.area && this.reference.area.start.column === this.address.column && this.reference.area.start.row === this.address.row;
  }
  /**
   * to support restoring cached values (from file), we need a way to get
   * the value from the reference (cell). normally this is done during
   * calculation, and in reverse (we set the value).
   *
   * some additional implications of this:
   *
   * - does not set volatile/nonvolatile, which is usually managed as a
   *   side-effect of the calculation.
   *
   * - does not remove the entry from the dirty list
   *
   * - does not clear the internal dirty flag. it used to do that, but we
   *   took it out because we are now managing multple vertex types, and
   *   we don't want to attach that behavior to a type-specific method.
   *
   * so the caller needs to explicitly address the dirty and volatile lists
   * for this vertex.
   */
  TakeReferenceValue() {
    if (this.reference) {
      this.result = Box(this.reference.GetValue());
    }
  }
  /**
   * calculates the function, but only if all dependencies are clean.
   * if one or more dependencies are dirty, just exit. this should work out
   * so that when the last dependency is satisfied, the propagation will
   * succeed. FIXME: optimize order.
   *
   * FIXME: why is this in vertex, instead of graph? [a: dirty check?]
   * A: for overloading. leaf extends this class, and has a separate
   * calculation routine.
   */
  Calculate(graph) {
    if (!this.dirty)
      return;
    if (this.color === 0 /* white */ && this.LoopCheck()) {
      this.dirty = false;
      if (this.edges_in.size) {
        if (this.reference && (this.array_head || this.reference.type === 1 /* formula */)) {
          this.reference.SetCalculationError("LOOP" /* Loop */);
        }
        for (const edge of this.edges_out) {
          edge.Calculate(graph);
        }
        return;
      }
    }
    for (const edge of this.edges_in) {
      if (edge.dirty) {
        return;
      }
    }
    if (this.reference) {
      if (this.reference.type === 1 /* formula */) {
        this.short_circuit = false;
        const result = graph.CalculationCallback.call(graph, this);
        this.result = result.value;
        if (this.short_circuit) {
          return;
        }
        if (result.volatile)
          graph.volatile_list.push(this);
      } else
        this.result = this.reference.GetValue4();
      if (this.array_head) {
        graph.SpreadCallback.call(graph, this, this.result);
      } else if (this.reference.type === 1 /* formula */) {
        const single = this.result.type === 8 /* array */ ? this.result.value[0][0] : this.result;
        {
          this.reference.SetCalculatedValue(single.value, single.type);
        }
      }
    } else {
      console.info("skip dirty constant? [or dangling...]");
    }
    this.dirty = false;
    for (const edge of this.edges_out) {
      if (edge.dirty) {
        graph.calculation_list.push(edge);
      }
    }
  }
};

// treb-calculator/src/dag/array-vertex.ts
var ArrayVertex = class _ArrayVertex extends SpreadsheetVertexBase {
  static type = "array-vertex";
  /**
   * this is the list of currently used array vertices. it will get cleaned
   * up when a vertex is no longer used (via the instance RemoveDependent 
   * overload) and when the graph is reset (via the static Clear method).
   * 
   * we could theoretically optimize this store, which might be useful if 
   * we start using a lot of these: split by sheet ID, sort in start/end order,
   * and so on. 
   */
  static list = [];
  type = _ArrayVertex.type;
  // for type guard
  /** the target area */
  area;
  /* * temporary method, we should clean up explicitly * /
  public static CheckOutbound(): void {
    for (const vertex of this.list) {
      if (vertex.edges_out.length === 0) {
        console.info('no outbound edges', vertex);
      }
    }
  }
  */
  /** 
   * factory/lookup method: creates a vertex if it does not exist, or 
   * returns existing vertex. returns the vertex and a flag indicating
   * if this was created new (true) or not (false).
   */
  static GetVertex(area) {
    for (const entry of this.list) {
      if (entry.area.start.sheet_id === area.start.sheet_id && entry.area.Equals(area)) {
        return [entry, false];
      }
    }
    return [new _ArrayVertex(area), true];
  }
  /**
   * this seems sloppy, does this clean up properly?
   */
  static Clear() {
    this.list = [];
  }
  /**
   * returns a list of arrays that contain this address
   */
  static GetContainingArrays(address) {
    const list = [];
    for (const entry of this.list) {
      if (entry.area.start.sheet_id === address.sheet_id && entry.area.Contains(address)) {
        list.push(entry);
      }
    }
    return list;
  }
  /**
   * if any arrays contain this address, add edges
   */
  static CreateImplicitEdges(vertex, address) {
    for (const entry of this.list) {
      if (entry.area.start.sheet_id === address.sheet_id && entry.area.Contains(address)) {
        entry.DependsOn(vertex);
      }
    }
  }
  /**
   * constructor adds the vertex to the internal list (static to this class).
   * 
   * UPDATE: use the factory method, which can check if a reference to this
   * area already exists. 
   */
  constructor(range) {
    super();
    this.area = range.Clone();
    _ArrayVertex.list.push(this);
  }
  /**
   * override for RemoveDependent. if there are no more dependents, it will
   * be removed from our internal list (and hopefully GCd, but check). 
   */
  RemoveDependent(edge) {
    super.RemoveDependent(edge);
    if (!this.edges_out.size) {
      this.Reset();
      _ArrayVertex.list = _ArrayVertex.list.filter((test) => test !== this);
    }
  }
  Calculate(graph) {
    if (!this.dirty) {
      return;
    }
    if (this.color === 0 /* white */ && this.LoopCheck()) {
      this.dirty = false;
      if (this.edges_in.size) {
        for (const edge of this.edges_out) {
          edge.Calculate(graph);
        }
        return;
      }
    }
    for (const edge of this.edges_in) {
      if (edge.dirty) {
        return;
      }
    }
    this.dirty = false;
    for (const edge of this.edges_out) {
      edge.Calculate(graph);
    }
  }
};

// treb-calculator/src/dag/graph.ts
var Graph = class {
  /**
   * list of vertices, indexed by address as [sheet id][column][row]
   */
  vertices = [[]];
  volatile_list = [];
  calculation_list = [];
  /**
   * where is the loop in the graph (or at least the first one we found)?
   */
  loop_hint;
  // special
  // public leaf_vertices: LeafVertex[] = [];
  leaf_vertices = /* @__PURE__ */ new Set();
  /** lock down access */
  dirty_list = [];
  /** flag set on add edge */
  loop_check_required = false;
  /*
  public IsArrayVertex(vertex: Vertex): vertex is ArrayVertex {
    return vertex.type === ArrayVertex.type;
  }
  */
  IsSpreadsheetVertex(vertex) {
    return vertex.type === SpreadsheetVertex.type;
  }
  /* *
   * we used to attach the data model here, but it's now an instance
   * property (and readonly). we map still need to rebuild the map, 
   * so we're retaining the method for the time being (but renamed and 
   * reparameterized).
   * 
   * if model were a class we wouldn't have to do this...
   * /
  protected RebuildMap(): void {
    this.cells_map = {};
    for (const sheet of this.model.sheets.list) {
      this.cells_map[sheet.id] = sheet.cells;
    }
  }
  */
  /**
   * flush the graph, calculation tree and cells reference
   */
  FlushTree() {
    this.dirty_list = [];
    this.volatile_list = [];
    this.vertices = [[]];
    this.leaf_vertices.clear();
    ArrayVertex.Clear();
  }
  ResolveArrayHead(address) {
    if (!address.sheet_id) {
      throw new Error("resolve array head with no sheet id");
    }
    const cells = this.model.sheets.Find(address.sheet_id)?.cells;
    if (!cells) {
      throw new Error("no cells? sheet id " + address.sheet_id);
    }
    const row = cells.data[address.row];
    if (row) {
      const cell = row[address.column];
      if (cell && cell.area) {
        const resolved = { row: cell.area.start.row, column: cell.area.start.column, sheet_id: address.sheet_id };
        console.info("array head", address, resolved);
        return resolved;
      }
    }
    return address;
  }
  /** returns the vertex at this address. creates it if necessary. */
  GetVertex(address, create) {
    if (!address.sheet_id) {
      console.info({ address, create });
      throw new Error("getvertex with no sheet id");
    }
    const cells = this.model.sheets.Find(address.sheet_id)?.cells;
    if (!cells) {
      throw new Error("no cells? sheet id " + address.sheet_id);
      return void 0;
    }
    if (!this.vertices[address.sheet_id]) {
      if (!create) {
        return void 0;
      }
      this.vertices[address.sheet_id] = [];
    }
    if (!this.vertices[address.sheet_id][address.column]) {
      if (!create) {
        return void 0;
      }
      this.vertices[address.sheet_id][address.column] = [];
    } else {
      const existing_vertex = this.vertices[address.sheet_id][address.column][address.row];
      if (existing_vertex) {
        return existing_vertex;
      }
      if (!create)
        return void 0;
    }
    const vertex = new SpreadsheetVertex();
    vertex.address = {
      row: address.row,
      column: address.column,
      absolute_row: address.absolute_row,
      absolute_column: address.absolute_column,
      sheet_id: address.sheet_id
    };
    vertex.reference = cells.EnsureCell(address);
    this.vertices[address.sheet_id][address.column][address.row] = vertex;
    ArrayVertex.CreateImplicitEdges(vertex, address);
    return vertex;
  }
  /** deletes the vertex at this address. */
  RemoveVertex(address) {
    if (!address.sheet_id) {
      throw new Error("removevertex with no sheet id");
    }
    const vertex = this.GetVertex(address, false);
    if (!vertex)
      return;
    vertex.Reset();
    this.vertices[address.sheet_id][address.column][address.row] = void 0;
  }
  /** removes all edges, for rebuilding. leaves value/formula as-is. */
  ResetVertex(address) {
    const vertex = this.GetVertex(address, false);
    if (vertex)
      vertex.Reset();
  }
  RIBcount = 0;
  /**
   * resets the vertex by removing inbound edges and clearing formula flag.
   * we have an option to set dirty because they get called together
   * frequently, saves a lookup.
   */
  ResetInbound(address, set_dirty = false, create = true, remove = false) {
    this.RIBcount++;
    const vertex = this.GetVertex(address, create);
    if (!vertex) {
      if (set_dirty) {
        const list = ArrayVertex.GetContainingArrays(address);
        for (const entry of list) {
          this.SetVertexDirty(entry);
        }
      }
      return;
    }
    let dependencies = [];
    if (remove) {
      dependencies = Array.from(vertex.edges_in);
    }
    vertex.ClearDependencies();
    if (set_dirty) {
      this.SetVertexDirty(vertex);
    }
    if (remove) {
      if (!vertex.has_outbound_edges) {
        this.RemoveVertex(address);
      }
      for (const dependency of dependencies) {
        if (!dependency.has_inbound_edges && !dependency.has_outbound_edges) {
          const target = dependency;
          if (target.address) {
            this.RemoveVertex(target.address);
          }
        }
      }
    }
  }
  /* * dev * /
    public ForceClean() {
      for (const l1 of this.vertices) {
        if (l1) {
          for (const l2 of l1) {
            if (l2) {
              for (const vertex of l2) {
                if (vertex && vertex.dirty) {
                  vertex.dirty = false;
                }
              }
            }
          }
        }
      }
  
    }
  
    / * * dev, check if any vertices are dirtices * /
    public CheckDirty() {
  
      for (const l1 of this.vertices) {
        if (l1) {
          for (const l2 of l1) {
            if (l2) {
              for (const vertex of l2) {
                if (vertex && vertex.dirty) {
                  console.info("DIRTY", `R${vertex.address?.row} C${vertex.address?.column}`, vertex);
  
  
                }
              }
            }
          }
        }
      }
      
    }
    */
  /**
   * reset all vertices. this method is used so we can run the loop check
   * as part of the graph calculation, instead of requiring the separate call.
   */
  ResetLoopState() {
    for (const l1 of this.vertices) {
      if (l1) {
        for (const l2 of l1) {
          if (l2) {
            for (const vertex of l2) {
              if (vertex) {
                vertex.color = vertex.edges_out.size ? 0 /* white */ : 2 /* black */;
              }
            }
          }
        }
      }
    }
    for (const vertex of this.leaf_vertices) {
      vertex.color = 2 /* black */;
    }
  }
  /**
   * global check returns true if there is any loop. this is more efficient
   * than detecting loops on every call to AddEdge. uses the color algorithm
   * from CLRS.
   * 
   * UPDATE we switched to a stack-based check because we were hitting 
   * recursion limits, although that seemed to only happen in workers -- 
   * perhaps they have different stack [in the malloc sense] sizes? in any 
   * event, I think the version below is now stable. 
   * 
   * @param force force a check, for dev/debug
   */
  LoopCheck(force = false) {
    if (!this.loop_check_required && !force) {
      return false;
    }
    const list = [];
    for (const l1 of this.vertices) {
      if (l1) {
        for (const l2 of l1) {
          if (l2) {
            for (const vertex of l2) {
              if (vertex) {
                vertex.color = vertex.edges_out.size ? 0 /* white */ : 2 /* black */;
                list.push(vertex);
              }
            }
          }
        }
      }
    }
    const stack = [];
    for (const vertex of list) {
      if (vertex.color === 0 /* white */) {
        vertex.color = 1 /* gray */;
        stack.push(vertex);
        while (stack.length) {
          const v = stack[stack.length - 1];
          let completed = true;
          if (v.color !== 2 /* black */) {
            for (const edge of v.edges_out) {
              if (edge.color === 1 /* gray */) {
                this.loop_hint = this.RenderAddress(vertex.address);
                console.info("loop detected @", this.loop_hint);
                return true;
              } else if (edge.color === 0 /* white */) {
                stack.push(edge);
                completed = false;
              }
            }
          }
          if (completed) {
            stack.pop();
            v.color = 2 /* black */;
          }
        }
        vertex.color = 2 /* black */;
      }
    }
    this.loop_check_required = false;
    this.loop_hint = void 0;
    return false;
  }
  /**
   * render address as string; this is for reporting loops
   */
  RenderAddress(address) {
    if (!address) {
      return "undefined";
    }
    let sheet_name = "";
    if (address.sheet_id) {
      const sheet = this.model.sheets.Find(address.sheet_id);
      if (sheet) {
        sheet_name = sheet.name + "!";
      }
    }
    const area = new Area(address);
    return sheet_name + area.spreadsheet_label;
  }
  /** 
   * new array vertices
   */
  AddArrayEdge(u, v) {
    if (!u.start.sheet_id) {
      throw new Error("AddArrayEdge called without sheet ID");
    }
    const v_v = this.GetVertex(v, true);
    const [array_vertex, created] = ArrayVertex.GetVertex(u);
    v_v.DependsOn(array_vertex);
    this.loop_check_required = true;
    if (!created) {
      return;
    }
    const map = this.vertices[u.start.sheet_id];
    if (!map) {
      return;
    }
    if (u.entire_row) {
      for (let column = 0; column < map.length; column++) {
        if (map[column]) {
          for (let row = u.start.row; row <= u.end.row; row++) {
            const vertex = map[column][row];
            if (vertex) {
              array_vertex.DependsOn(vertex);
            }
          }
        }
      }
    } else if (u.entire_column) {
      for (let column = u.start.column; column <= u.end.column; column++) {
        if (map[column]) {
          for (const vertex of map[column]) {
            if (vertex?.address) {
              array_vertex.DependsOn(vertex);
            }
          }
        }
      }
    } else {
      for (let row = u.start.row; row <= u.end.row; row++) {
        for (let column = u.start.column; column <= u.end.column; column++) {
          const vertex = map[column][row];
          if (vertex) {
            array_vertex.DependsOn(vertex);
          }
        }
      }
    }
  }
  /** adds an edge from u -> v */
  AddEdge(u, v, tag) {
    const v_u = this.GetVertex(u, true);
    const v_v = this.GetVertex(v, true);
    v_v.DependsOn(v_u);
    if (v_u.reference && v_u.reference.area && !v_u.array_head) {
      this.AddEdge({
        ...u,
        row: v_u.reference.area.start.row,
        column: v_u.reference.area.start.column
      }, v, "implicit");
    }
    this.loop_check_required = true;
  }
  /** removes edge from u -> v */
  RemoveEdge(u, v) {
    const v_u = this.GetVertex(u, false);
    const v_v = this.GetVertex(v, false);
    if (!v_u || !v_v)
      return;
    v_u.RemoveDependent(v_v);
    v_v.RemoveDependency(v_u);
  }
  /**
   * not used? remove
   * @deprecated
   */
  SetAreaDirty(area) {
    if (area.start.column === Infinity || area.end.column === Infinity || area.start.row === Infinity || area.end.row === Infinity) {
      throw new Error("don't iterate over infinite area");
    }
    const sheet_id = area.start.sheet_id;
    if (!sheet_id) {
      throw new Error("invalid area, missing sheet id");
    }
    for (let column = area.start.column; column <= area.end.column; column++) {
      for (let row = area.start.row; row <= area.end.row; row++) {
        const address = { row, column, sheet_id };
        const vertex = this.GetVertex(address, false);
        if (vertex) {
          this.SetDirty(address);
        }
      }
    }
  }
  SetVertexDirty(vertex) {
    if (vertex.dirty) {
      return;
    }
    this.dirty_list.push(vertex);
    vertex.dirty = true;
    for (const edge of vertex.edges_out) {
      this.SetVertexDirty(edge);
    }
  }
  /** sets dirty */
  SetDirty(address) {
    const vertex = this.GetVertex(address, true);
    this.SetVertexDirty(vertex);
  }
  // --- leaf vertex api ---
  /**
   * adds a leaf vertex to the graph. this implies that someone else is
   * managing and maintaining these vertices: we only need references.
   */
  AddLeafVertex(vertex) {
    this.leaf_vertices.add(vertex);
  }
  /** removes vertex */
  RemoveLeafVertex(vertex) {
    this.leaf_vertices.delete(vertex);
  }
  /**
   * adds an edge from u -> v where v is a leaf vertex. this doesn't use
   * the normal semantics, and you must pass in the actual vertex instead
   * of an address.
   *
   * there is no loop check (leaves are not allowed to have outbound
   * edges).
   */
  AddLeafVertexEdge(u, v) {
    const v_u = this.GetVertex(u, true);
    v.DependsOn(v_u);
    return 0 /* OK */;
  }
  /** removes edge from u -> v */
  RemoveLeafVertexEdge(u, v) {
    const v_u = this.GetVertex(u, false);
    if (!v_u)
      return;
    v_u.RemoveDependent(v);
    v.RemoveDependency(v_u);
  }
  // --- for initial load ---
  InitializeGraph() {
    for (const vertex of this.dirty_list) {
      if (this.IsSpreadsheetVertex(vertex)) {
        vertex.TakeReferenceValue();
        if (this.CheckVolatile(vertex)) {
          this.volatile_list.push(vertex);
        }
      }
      vertex.dirty = false;
    }
    this.dirty_list = [];
  }
  // --- calculation ---
  /** runs calculation */
  Recalculate() {
    for (const vertex of this.volatile_list) {
      this.SetVertexDirty(vertex);
    }
    this.calculation_list = this.dirty_list.slice(0);
    this.volatile_list = [];
    this.dirty_list = [];
    if (this.loop_check_required) {
      this.ResetLoopState();
      this.loop_check_required = false;
    }
    for (let i = 0; i < this.calculation_list.length; i++) {
      this.calculation_list[i].Calculate(this);
    }
    this.calculation_list = [];
  }
};

// treb-calculator/src/complex-math.ts
var ComplexMatrix = (n) => {
  const mat = {
    m: n,
    n,
    array: []
  };
  for (let i = 0; i < n; i++) {
    const row = [];
    for (let j = 0; j < n; j++) {
      row.push({ real: 0, imaginary: 0 });
    }
    mat.array.push(row);
  }
  return mat;
};
var PolarToRectangular = (a) => {
  const { r, theta } = a;
  const real = r * Math.cos(theta);
  const imaginary = r * Math.sin(theta);
  return { real, imaginary };
};
var RectangularToPolar = (value) => {
  const r = Math.sqrt(value.real * value.real + value.imaginary * value.imaginary);
  const theta = Math.atan2(value.imaginary, value.real);
  return { r, theta };
};
var Multiply = (a, b) => {
  return {
    real: a.real * b.real - a.imaginary * b.imaginary,
    imaginary: a.real * b.imaginary + a.imaginary * b.real
  };
};
var RealSum = (a, b) => {
  const array = [];
  for (let i = 0; i < a.m; i++) {
    const row = [];
    for (let j = 0; j < a.n; j++) {
      row.push(a.array[i][j] + b.array[i][j]);
    }
    array.push(row);
  }
  return { m: a.m, n: a.n, array };
};
var RealProduct = (a, b) => {
  const array = [];
  for (let i = 0; i < a.m; i++) {
    const row = [];
    for (let j = 0; j < b.n; j++) {
      let sum = 0;
      for (let k = 0; k < a.n; k++) {
        sum += a.array[i][k] * b.array[k][j];
      }
      row.push(sum);
    }
    array.push(row);
  }
  return { array, m: a.m, n: b.n };
};
var ComplexProduct = (a, b) => {
  const result = [];
  for (let i = 0; i < a.m; i++) {
    const row = [];
    for (let j = 0; j < b.n; j++) {
      const sum = { real: 0, imaginary: 0 };
      for (let k = 0; k < a.n; k++) {
        sum.real += a.array[i][k].real * b.array[k][j].real - a.array[i][k].imaginary * b.array[k][j].imaginary;
        sum.imaginary += a.array[i][k].real * b.array[k][j].imaginary + a.array[i][k].imaginary * b.array[k][j].real;
      }
      row.push(sum);
    }
    result.push(row);
  }
  return result;
};
var ComplexDeterminant = (matrix) => {
  const det = { real: 0, imaginary: 0 };
  const n = matrix.n;
  if (n == 2) {
    const a = Multiply(matrix.array[0][0], matrix.array[1][1]);
    const b = Multiply(matrix.array[1][0], matrix.array[0][1]);
    return {
      real: a.real - b.real,
      imaginary: a.imaginary - b.imaginary
    };
  }
  const submatrix = ComplexMatrix(matrix.n);
  for (let x = 0; x < n; x++) {
    let subi = 0;
    for (let i = 1; i < n; i++) {
      let subj = 0;
      for (let j = 0; j < n; j++) {
        if (j == x) {
          continue;
        }
        submatrix.array[subi][subj] = { ...matrix.array[i][j] };
        subj++;
      }
      subi++;
    }
    submatrix.m = submatrix.n = n - 1;
    const factor = Math.pow(-1, x);
    const product = Multiply({
      real: matrix.array[0][x].real * factor,
      imaginary: matrix.array[0][x].imaginary * factor
    }, ComplexDeterminant(submatrix));
    det.real += product.real;
    det.imaginary += product.imaginary;
  }
  return det;
};
var Split = (matrix) => {
  const flags = {
    real_values: false,
    imaginary_values: false,
    square: matrix.m === matrix.n,
    unit_diagonal: true
  };
  const real = {
    m: matrix.m,
    n: matrix.n,
    array: []
  };
  const imaginary = {
    m: matrix.m,
    n: matrix.n,
    array: []
  };
  for (let i = 0; i < matrix.m; i++) {
    const row = matrix.array[i];
    const real_row = [];
    const imaginary_row = [];
    for (let j = 0; j < matrix.n; j++) {
      if (row[j].real) {
        flags.real_values = true;
      }
      if (row[j].imaginary) {
        flags.imaginary_values = true;
      }
      if (j === i && flags.unit_diagonal) {
        if (row[j].real !== 1 || row[j].imaginary !== 0) {
          flags.unit_diagonal = false;
        }
      }
      real_row.push(row[j].real);
      imaginary_row.push(row[j].imaginary);
    }
    real.array.push(real_row);
    imaginary.array.push(imaginary_row);
  }
  return { real, imaginary, flags };
};
var CloneReal = (matrix) => {
  const array = matrix.array.map((row) => row.slice(0));
  return { m: matrix.m, n: matrix.n, array };
};
var RealInverse = (matrix) => {
  if (matrix.m !== matrix.n) {
    return void 0;
  }
  const result = CloneReal(matrix);
  const M = result.array;
  let sum = 0;
  let i = 0;
  let j = 0;
  let k = 0;
  const order = matrix.m;
  for (i = 1; i < order; i++)
    M[0][i] /= M[0][0];
  for (i = 1; i < order; i++) {
    for (j = i; j < order; j++) {
      sum = 0;
      for (k = 0; k < i; k++) {
        sum += M[j][k] * M[k][i];
      }
      M[j][i] -= sum;
    }
    if (i == order - 1)
      continue;
    for (j = i + 1; j < order; j++) {
      sum = 0;
      for (k = 0; k < i; k++) {
        sum += M[i][k] * M[k][j];
      }
      M[i][j] = (M[i][j] - sum) / M[i][i];
    }
  }
  for (i = 0; i < order; i++) {
    for (j = i; j < order; j++) {
      let x = 1;
      if (i != j) {
        x = 0;
        for (k = i; k < j; k++) {
          x -= M[j][k] * M[k][i];
        }
      }
      M[j][i] = x / M[j][j];
    }
  }
  for (i = 0; i < order; i++) {
    for (j = i; j < order; j++) {
      if (i == j)
        continue;
      sum = 0;
      for (k = i; k < j; k++) {
        sum += M[k][j] * (i == k ? 1 : M[i][k]);
      }
      M[i][j] = -sum;
    }
  }
  for (i = 0; i < order; i++) {
    for (j = 0; j < order; j++) {
      sum = 0;
      for (k = i > j ? i : j; k < order; k++) {
        sum += (j == k ? 1 : M[j][k]) * M[k][i];
      }
      M[j][i] = sum;
    }
  }
  return result;
};
var MatrixInverse = (a) => {
  const result = [];
  if (a.m !== a.n) {
    return void 0;
  }
  const { real, imaginary, flags } = Split(a);
  const C1 = RealInverse(real);
  if (!C1) {
    return void 0;
  }
  if (!flags.imaginary_values) {
    for (let i = 0; i < a.m; i++) {
      const row = [];
      for (let j = 0; j < a.n; j++) {
        row.push({
          real: C1.array[i][j],
          imaginary: 0
        });
      }
      result.push(row);
    }
    return result;
  }
  const C2 = RealProduct(C1, imaginary);
  const C3 = RealProduct(imaginary, C2);
  const C4 = RealSum(real, C3);
  const C5 = RealInverse(C4);
  if (!C5) {
    return void 0;
  }
  const C6 = RealProduct(C2, C5);
  for (let i = 0; i < a.m; i++) {
    const row = [];
    for (let j = 0; j < a.n; j++) {
      row.push({
        real: C5.array[i][j],
        imaginary: -C6.array[i][j]
      });
    }
    result.push(row);
  }
  return result;
};
var Divide = (a, b) => {
  const conjugate = { real: b.real, imaginary: -b.imaginary };
  const numerator = Multiply(a, conjugate);
  const denominator = Multiply(b, conjugate);
  return {
    real: numerator.real / denominator.real,
    imaginary: numerator.imaginary / denominator.real
  };
};
var Exp = (value) => {
  const a = value.real || 0;
  const b = value.imaginary || 0;
  return Multiply(
    { real: Math.exp(a), imaginary: 0 },
    { real: Math.cos(b), imaginary: Math.sin(b) }
  );
};
var Log = (value) => {
  const polar = RectangularToPolar(value);
  return {
    real: Math.log(polar.r),
    imaginary: polar.theta
  };
};
var Power = (a, b) => {
  if (!b.imaginary) {
    const polar = RectangularToPolar(a);
    const value = PolarToRectangular({
      r: Math.pow(polar.r, b.real),
      theta: polar.theta * b.real
    });
    return value;
  } else {
    return Exp(Multiply(b, Log(a)));
  }
};

// treb-calculator/src/primitives.ts
var EnsureComplex = (a, real = 0) => {
  if (a && a.type === 7 /* complex */) {
    return a;
  }
  return {
    type: 7 /* complex */,
    value: {
      real,
      imaginary: 0
    }
  };
};
var BoxComplex = (value) => {
  return value.imaginary ? { type: 7 /* complex */, value } : { type: 3 /* number */, value: value.real };
};
var NumericTypes = (a, b) => {
  if (a.type === 6 /* error */) {
    return [0, 0, a];
  }
  if (b.type === 6 /* error */) {
    return [0, 0, b];
  }
  const result = [0, 0];
  switch (a.type) {
    case 3 /* number */:
      result[0] = a.value;
      break;
    case 4 /* boolean */:
      result[0] = a.value ? 1 : 0;
      break;
    case 0 /* undefined */:
      break;
    case 7 /* complex */:
      result[3] = a;
      break;
    default:
      return [0, 0, ValueError()];
  }
  switch (b.type) {
    case 3 /* number */:
      result[1] = b.value;
      break;
    case 4 /* boolean */:
      result[1] = b.value ? 1 : 0;
      break;
    case 0 /* undefined */:
      break;
    case 7 /* complex */:
      result[4] = b;
      break;
    default:
      return [0, 0, ValueError()];
  }
  if (result[3] || result[4]) {
    result[3] = EnsureComplex(result[3], result[0]);
    result[4] = EnsureComplex(result[4], result[1]);
  }
  return result;
};
var Add = (a, b) => {
  const [x, y, z, c1, c2] = NumericTypes(a, b);
  if (z) {
    return z;
  }
  if (c1 && c2) {
    return BoxComplex({
      real: c1.value.real + c2.value.real,
      imaginary: c1.value.imaginary + c2.value.imaginary
    });
  }
  return { value: x + y, type: 3 /* number */ };
};
var Subtract = (a, b) => {
  const [x, y, z, c1, c2] = NumericTypes(a, b);
  if (z) {
    return z;
  }
  if (c1 && c2) {
    return BoxComplex({
      real: c1.value.real - c2.value.real,
      imaginary: c1.value.imaginary - c2.value.imaginary
    });
  }
  return { value: x - y, type: 3 /* number */ };
};
var PowerGated = (a, b) => {
  const [x, y, z, c1, c2] = NumericTypes(a, b);
  if (z) {
    return z;
  }
  if (c1 && c2) {
    return BoxComplex(Power(c1.value, c2.value));
  }
  const value = Math.pow(x, y);
  if (isNaN(value)) {
    return ValueError();
  }
  return { type: 3 /* number */, value };
};
var PowerComplex = (a, b) => {
  const [x, y, z, c1, c2] = NumericTypes(a, b);
  if (z) {
    return z;
  }
  if (c1 && c2) {
    return BoxComplex(Power(c1.value, c2.value));
  }
  if (x < 0 && y !== 0 && Math.abs(y) < 1) {
    return BoxComplex(Power(
      { real: x, imaginary: 0 },
      { real: y, imaginary: 0 }
    ));
  }
  const value = Math.pow(x, y);
  if (isNaN(value)) {
    return ValueError();
  }
  return { type: 3 /* number */, value };
};
var Power2 = PowerGated;
var Multiply2 = (a, b) => {
  const [x, y, z, c1, c2] = NumericTypes(a, b);
  if (z) {
    return z;
  }
  if (c1 && c2) {
    return BoxComplex(Multiply(c1.value, c2.value));
  }
  return { value: x * y, type: 3 /* number */ };
};
var Divide2 = (a, b) => {
  const [x, y, z, c1, c2] = NumericTypes(a, b);
  if (z) {
    return z;
  }
  if (c1 && c2) {
    if (c2.value.real === 0 && c2.value.imaginary === 0) {
      return DivideByZeroError();
    }
    return BoxComplex(Divide(c1.value, c2.value));
  }
  if (y === 0) {
    return DivideByZeroError();
  }
  return { value: x / y, type: 3 /* number */ };
};
var Modulo = (a, b) => {
  const [x, y, z] = NumericTypes(a, b);
  if (z) {
    return z;
  }
  if (y === 0) {
    return DivideByZeroError();
  }
  return { value: x % y, type: 3 /* number */ };
};
var Concatenate = (a, b) => {
  if (a.type === 6 /* error */) {
    return a;
  }
  if (b.type === 6 /* error */) {
    return b;
  }
  return {
    type: 2 /* string */,
    value: `${a.type === 0 /* undefined */ ? "" : a.value}${b.type === 0 /* undefined */ ? "" : b.value}`
  };
};
var Equals = (a, b) => {
  if (a.type === 6 /* error */) {
    return a;
  }
  if (b.type === 6 /* error */) {
    return b;
  }
  if (a.type === 0 /* undefined */ && (b.value === "" || b.value === 0 || b.type === 7 /* complex */ && b.value.real === 0 && b.value.imaginary === 0) || b.type === 0 /* undefined */ && (a.value === "" || a.value === 0 || a.type === 7 /* complex */ && a.value.real === 0 && a.value.imaginary === 0)) {
    return { type: 4 /* boolean */, value: true };
  }
  if (a.type === 7 /* complex */ || b.type === 7 /* complex */) {
    let equals = false;
    if (a.type === b.type) {
      equals = a.value.real == b.value.real && // == ?
      a.value.imaginary == b.value.imaginary;
    } else if (a.type === 3 /* number */) {
      equals = b.value.real == a.value && !b.value.imaginary;
    } else if (b.type === 3 /* number */) {
      equals = a.value.real == b.value && !a.value.imaginary;
    }
    return { type: 4 /* boolean */, value: equals };
  }
  return { type: 4 /* boolean */, value: a.value == b.value };
};
var NotEquals = (a, b) => {
  const result = Equals(a, b);
  if (result.type === 6 /* error */) {
    return result;
  }
  return {
    type: 4 /* boolean */,
    value: !result.value
  };
};
var GreaterThan = (a, b) => {
  if (a.type === 6 /* error */) {
    return a;
  }
  if (b.type === 6 /* error */) {
    return b;
  }
  if (a.type === 7 /* complex */ || b.type === 7 /* complex */) {
    return ValueError();
  }
  return { type: 4 /* boolean */, value: (a.value || 0) > (b.value || 0) };
};
var GreaterThanEqual = (a, b) => {
  if (a.type === 6 /* error */) {
    return a;
  }
  if (b.type === 6 /* error */) {
    return b;
  }
  if (a.type === 7 /* complex */ || b.type === 7 /* complex */) {
    return ValueError();
  }
  return { type: 4 /* boolean */, value: a.value >= b.value };
};
var LessThan = (a, b) => {
  if (a.type === 6 /* error */) {
    return a;
  }
  if (b.type === 6 /* error */) {
    return b;
  }
  if (a.type === 7 /* complex */ || b.type === 7 /* complex */) {
    return ValueError();
  }
  return { type: 4 /* boolean */, value: a.value < b.value };
};
var LessThanEqual = (a, b) => {
  if (a.type === 6 /* error */) {
    return a;
  }
  if (b.type === 6 /* error */) {
    return b;
  }
  if (a.type === 7 /* complex */ || b.type === 7 /* complex */) {
    return ValueError();
  }
  return { type: 4 /* boolean */, value: a.value <= b.value };
};
var UseComplex = () => {
  Power2 = PowerComplex;
};
var MapOperator = (operator) => {
  switch (operator) {
    case "&":
      return Concatenate;
    case "+":
      return Add;
    case "-":
      return Subtract;
    case "*":
      return Multiply2;
    case "/":
      return Divide2;
    case "^":
      return Power2;
    case "**":
      return Power2;
    case "%":
      return Modulo;
    case "=":
      return Equals;
    case "==":
      return Equals;
    case "!=":
      return NotEquals;
    case "<>":
      return NotEquals;
    case ">":
      return GreaterThan;
    case ">=":
      return GreaterThanEqual;
    case "<":
      return LessThan;
    case "<=":
      return LessThanEqual;
  }
  return void 0;
};

// treb-calculator/src/expression-calculator.ts
var UnionIsExpressionUnit = (test) => {
  return !Array.isArray(test) && test.type === 5 /* object */ && !!test.value.type;
};
var UnionIsMetadata = (test) => {
  return test.type === 5 /* object */ && test.key === "metadata";
};
var ExpressionCalculator = class {
  // --- public API -----------------------------------------------------------
  constructor(library, parser) {
    this.library = library;
    this.parser = parser;
  }
  context = {
    address: { row: -1, column: -1 },
    volatile: false,
    call_index: 0
  };
  /**
   * this refers to the number of function call within a single cell.
   * so if you have a function like
   *
   * =A(B())
   *
   * then when calculating A call index should be set to 1; and when
   * calculating B, call index is 2. and so on. 
   */
  call_index = 0;
  // local reference
  // protected cells: Cells = new Cells();
  // protected cells_map: {[index: number]: Cells} = {};
  // protected sheet_name_map: {[index: string]: number} = {};
  // local reference
  named_range_map = {};
  // protected bound_name_stack: Array<Record<string, ExpressionUnit>> = [];
  //
  data_model;
  SetModel(model) {
    this.data_model = model;
    this.named_range_map = model.named_ranges.Map();
    this.context.model = model;
  }
  /**
   * there's a case where we are calling this from within a function
   * (which is weird, but hey) and to do that we need to preserve flags.
   */
  Calculate(expr, addr, preserve_flags = false) {
    if (!preserve_flags) {
      this.context.address = addr;
      this.context.volatile = false;
      this.context.call_index = 0;
      this.call_index = 0;
    }
    return {
      value: this.CalculateExpression(expr),
      volatile: this.context.volatile
    };
  }
  // --- /public API ----------------------------------------------------------
  /**
   * resolve value from cell. returns a function bound to specific cell.
   */
  CellFunction2(expr) {
    if (!expr.sheet_id) {
      if (expr.sheet) {
        expr.sheet_id = this.data_model.sheets.ID(expr.sheet) || 0;
      } else {
        return () => ReferenceError2();
      }
    }
    const cells = this.data_model.sheets.Find(expr.sheet_id)?.cells;
    if (!cells) {
      console.warn("missing cells reference @ " + expr.sheet_id);
      return () => ReferenceError2();
    }
    const cell = cells.GetCell(expr);
    if (!cell) {
      return () => {
        return { type: 3 /* number */, value: 0 };
      };
    }
    return () => cell.GetValue4();
  }
  /**
   * returns range as union type. returns a single value for a single cell,
   * or a 2d array (never a 1d array)
   */
  CellFunction4(start, end) {
    if (!start.sheet_id) {
      return ReferenceError2();
    }
    const cells = this.data_model.sheets.Find(start.sheet_id)?.cells;
    return cells?.GetRange4(start, end, true) || ReferenceError2();
  }
  /** breaking this out to de-dupe */
  GetMetadata(arg, map_result) {
    let address;
    let range;
    switch (arg.type) {
      case "address":
        address = arg;
        break;
      case "range":
        range = arg;
        break;
      case "structured-reference":
        {
          const resolved = this.data_model.ResolveStructuredReference(arg, this.context.address);
          if (resolved) {
            if (resolved.type === "address") {
              address = resolved;
            } else if (resolved.type === "range") {
              range = resolved;
            }
          }
        }
        break;
      case "identifier":
        {
          const named_range = this.named_range_map[arg.name.toUpperCase()];
          if (named_range) {
            if (named_range.count === 1) {
              address = named_range.start;
            } else {
              range = named_range;
            }
          }
        }
        break;
      case "call":
        {
          const result = this.CalculateExpression(arg, true);
          if (UnionIsExpressionUnit(result)) {
            if (result.value.type === "address") {
              address = result.value;
            } else if (result.value.type === "range") {
              range = result.value;
            } else {
              return result;
            }
          } else
            return result;
        }
        break;
      default:
        return this.CalculateExpression(arg);
    }
    if (address) {
      let sheet;
      if (address.sheet_id) {
        sheet = this.data_model.sheets.Find(address.sheet_id);
      }
      if (!sheet) {
        console.error("missing sheet [ac8]");
        return ReferenceError2();
      }
      const cell_data = sheet.CellData(address);
      const value = (
        // (cell_data.type === ValueType.formula) ? cell_data.calculated : cell_data.value;
        cell_data.calculated_type ? cell_data.calculated : cell_data.value
      );
      const metadata = {
        type: "metadata",
        address: { ...address },
        value,
        format: cell_data.style ? cell_data.style.number_format : void 0,
        ...map_result(cell_data, address)
      };
      return { type: 5 /* object */, value: metadata, key: "metadata" };
    } else if (range) {
      if (range.start.row === Infinity || range.start.column === Infinity) {
        return ReferenceError2();
      }
      let sheet;
      if (range.start.sheet_id) {
        sheet = this.data_model.sheets.Find(range.start.sheet_id);
      }
      if (!sheet) {
        throw new Error("missing sheet [ac9]");
      }
      const range_result = [];
      for (let column = range.start.column; column <= range.end.column; column++) {
        const column_result = [];
        for (let row = range.start.row; row <= range.end.row; row++) {
          const cell_data = sheet.CellData({ row, column });
          address = { ...range.start, row, column };
          const value = (
            // (cell_data.type === ValueType.formula) ? cell_data.calculated : cell_data.value;
            cell_data.calculated_type ? cell_data.calculated : cell_data.value
          );
          const metadata = {
            type: "metadata",
            address,
            value,
            format: cell_data.style ? cell_data.style.number_format : void 0,
            ...map_result(cell_data, address)
          };
          column_result.push({
            type: 5 /* object */,
            value: metadata,
            key: "metadata"
          });
        }
        range_result.push(column_result);
      }
      return { type: 8 /* array */, value: range_result };
    }
    return this.CalculateExpression(arg);
  }
  RewriteMacro(unit, names) {
    let expr;
    switch (unit.type) {
      case "identifier":
        expr = names[unit.name.toUpperCase()];
        if (expr) {
          return JSON.parse(JSON.stringify(expr));
        }
        break;
      case "binary":
        unit.left = this.RewriteMacro(unit.left, names);
        unit.right = this.RewriteMacro(unit.right, names);
        break;
      case "unary":
        unit.operand = this.RewriteMacro(unit.operand, names);
        break;
      case "group":
        unit.elements = unit.elements.map((element) => this.RewriteMacro(element, names));
        break;
      case "call":
        unit.args = unit.args.map((arg) => this.RewriteMacro(arg, names));
        break;
    }
    return unit;
  }
  CallMacro(outer, macro) {
    if (!macro.expression) {
      return () => ExpressionError();
    }
    const text_expr = JSON.stringify(macro.expression);
    const names = {};
    const upper_case_names = macro.argument_names?.map((name) => name.toUpperCase()) || [];
    return (expr) => {
      const clone = JSON.parse(text_expr);
      for (let i = 0; i < upper_case_names.length; i++) {
        names[upper_case_names[i]] = expr.args[i] || { type: "missing", id: 0 };
      }
      return this.CalculateExpression(this.RewriteMacro(clone, names));
    };
  }
  /** 
   * excutes a function call 
   *
   * the return type of functions has never been locked down, and as a result
   * there are a couple of things we need to handle. 
   * 
   * return type can be any value, essentially, or array, error object, or 
   * (in the case of some of the reference/lookup functions) an address or 
   * range expression. array must be 2d, I think? not sure that that is true.
   * 
   * this wrapper function returns a function which returns one of those
   * things, i.e. it returns (expr) => return type
   * 
   * it will only return address/range if the parameter flag is set, so we
   * could in theory lock it down a bit with overloads.
   * 
   * ---
   * 
   * UPDATE: that's no longer the case. we require that functions return 
   * a UnionValue type (union), which can itself contain an array.
   * 
   * ---
   * 
   * FIXME: there is far too much duplication between this and the MC version
   * (in simulation-expression-calculator). we need to find a way to consolidate
   * these.
   * 
   * I think the problem is that we don't want a lot of switches, but the cost
   * is an almost complete duplicate of this function in the subclass.
   * 
   */
  CallExpression(outer, return_reference = false) {
    const func = this.library.Get(outer.name);
    if (!func) {
      return () => NameError();
    }
    return (expr) => {
      const call_index = this.call_index++;
      this.context.volatile = this.context.volatile || !!func.volatile;
      const if_function = outer.name.toLowerCase() === "if";
      let skip_argument_index = -1;
      let argument_error;
      const argument_descriptors = func.arguments || [];
      const mapped_args = expr.args.map((arg, arg_index) => {
        if (argument_error) {
          return void 0;
        }
        const descriptor = argument_descriptors[Math.min(arg_index, argument_descriptors.length - 1)] || {};
        if (arg_index === skip_argument_index) {
          return descriptor.boxed ? { type: 0 /* undefined */ } : void 0;
        }
        if (typeof arg === "undefined") {
          if (if_function && arg_index === 0) {
            skip_argument_index = 1;
          }
          return descriptor.boxed ? { type: 0 /* undefined */ } : void 0;
        }
        if (descriptor.address) {
          return descriptor.boxed ? {
            type: 2 /* string */,
            value: this.parser.Render(arg).replace(/\$/g, "")
          } : this.parser.Render(arg).replace(/\$/g, "");
        } else if (descriptor.metadata) {
          return this.GetMetadata(arg, () => {
            return {};
          });
        } else {
          const result = this.CalculateExpression(arg);
          if (result.type === 6 /* error */) {
            if (descriptor.allow_error) {
              return result;
            }
            argument_error = result;
            return void 0;
          }
          if (if_function && arg_index === 0 && result.type !== 8 /* array */) {
            let result_truthy = false;
            if (result.type === 2 /* string */) {
              const lowercase = result.value.toLowerCase().trim();
              result_truthy = lowercase !== "false" && lowercase !== "f";
            } else {
              result_truthy = !!result.value;
            }
            skip_argument_index = result_truthy ? 2 : 1;
          }
          if (descriptor.boxed) {
            return result;
          }
          if (result.type === 8 /* array */) {
            return result.value.map((row) => row.map((value) => value.value));
          } else {
            return result.value;
          }
        }
      });
      if (argument_error) {
        return argument_error;
      }
      this.context.call_index = call_index;
      if (func.return_type === 1 /* reference */) {
        const result = func.fn.apply(null, mapped_args);
        if (return_reference) {
          return result;
        }
        if (UnionIsExpressionUnit(result)) {
          if (result.value.type === "address") {
            return this.CellFunction2(result.value)();
          } else if (result.value.type === "range") {
            return this.CellFunction4(result.value.start, result.value.end);
          }
        }
        return result;
      }
      return func.fn.apply(null, mapped_args);
    };
  }
  ResolveStructuredReference(expr) {
    const resolved = this.data_model.ResolveStructuredReference(expr, this.context.address);
    if (resolved) {
      if (resolved.type === "address") {
        return this.CellFunction2(resolved);
      } else if (resolved.type === "range") {
        return () => this.CellFunction4(resolved.start, resolved.end);
      }
    }
    return () => ReferenceError2();
  }
  ResolveDimensionedQuantity() {
    return (expr) => {
      const expression = this.CalculateExpression(expr.expression);
      return {
        type: 9 /* dimensioned_quantity */,
        value: {
          value: expression.value,
          unit: expr.unit.name
        }
      };
    };
  }
  UnaryExpression(x) {
    switch (x.operator) {
      case "+":
        return (expr) => {
          return this.CalculateExpression(expr.operand);
        };
      case "-": {
        const func = Subtract;
        const zero = { type: 3 /* number */, value: 0 };
        return (expr) => {
          const operand = this.CalculateExpression(expr.operand);
          if (operand.type === 8 /* array */) {
            return {
              type: 8 /* array */,
              value: operand.value.map((column) => column.map((value) => func(zero, value)))
            };
          }
          return func(zero, operand);
        };
      }
      default:
        return () => {
          console.warn("unexpected unary operator:", x.operator);
          return ExpressionError();
        };
    }
  }
  /**
   * expands the size of an array by recycling values in columns and rows
   * 
   * FIXME: seems like this is more a generic thing, -> utils lib
   *
   * @param arr 2d array
   * @param columns target columns
   * @param rows target rows
   */
  RecycleArray(arr, columns, rows) {
    if (arr[0].length < rows) {
      const len = arr[0].length;
      for (const column of arr) {
        for (let r = len; r < rows; r++) {
          column[r] = column[r % len];
        }
      }
    }
    if (arr.length < columns) {
      const len = arr.length;
      for (let c = len; c < columns; c++)
        arr[c] = arr[c % len].slice(0);
    }
    return arr;
  }
  //protected ElementwiseBinaryExpression(fn: Primitives.PrimitiveBinaryExpression, left: UnionValue[][], right: UnionValue[][]): UnionValue[][] {
  ElementwiseBinaryExpression(fn, left, right) {
    const columns = Math.max(left.value.length, right.value.length);
    const rows = Math.max(left.value[0].length, right.value[0].length);
    const left_values = this.RecycleArray(left.value, columns, rows);
    const right_values = this.RecycleArray(right.value, columns, rows);
    const value = [];
    for (let c = 0; c < columns; c++) {
      const col = [];
      for (let r = 0; r < rows; r++) {
        col[r] = fn(left_values[c][r], right_values[c][r]);
      }
      value.push(col);
    }
    return { type: 8 /* array */, value };
  }
  BinaryExpression(x) {
    const fn = MapOperator(x.operator);
    if (!fn) {
      return () => {
        console.info(`(unexpected binary operator: ${x.operator})`);
        return ExpressionError();
      };
    } else {
      return (expr) => {
        const left = this.CalculateExpression(expr.left);
        const right = this.CalculateExpression(expr.right);
        if (left.type === 8 /* array */) {
          if (right.type === 8 /* array */) {
            return this.ElementwiseBinaryExpression(fn, left, right);
          }
          return this.ElementwiseBinaryExpression(fn, left, { type: 8 /* array */, value: [[right]] });
        } else if (right.type === 8 /* array */) {
          return this.ElementwiseBinaryExpression(fn, { type: 8 /* array */, value: [[left]] }, right);
        }
        return fn(left, right);
      };
    }
  }
  Identifier(expr) {
    const identifier = expr.name;
    if (identifier[0] === "#") {
      return () => ReferenceError2();
    }
    const upper_case = identifier.toUpperCase();
    switch (upper_case) {
      case "FALSE":
      case "F":
        return () => {
          return { value: false, type: 4 /* boolean */ };
        };
      case "TRUE":
      case "T":
        return () => {
          return { value: true, type: 4 /* boolean */ };
        };
      case "UNDEFINED":
        return () => {
          return { value: void 0, type: 0 /* undefined */ };
        };
    }
    return () => {
      const named_range = this.named_range_map[upper_case];
      if (named_range) {
        if (named_range.count === 1) {
          return this.CellFunction4(named_range.start, named_range.start);
        } else {
          return this.CellFunction4(named_range.start, named_range.end);
        }
      }
      const named_expression = this.data_model.named_expressions.get(upper_case);
      if (named_expression) {
        return this.CalculateExpression(named_expression);
      }
      return NameError();
    };
  }
  GroupExpression(x) {
    if (!x.elements || x.elements.length !== 1) {
      console.warn(`Can't handle group !== 1`);
      return () => ExpressionError();
    }
    return (expr) => this.CalculateExpression(expr.elements[0]);
  }
  CalculateExpression(expr, return_reference = false) {
    if (expr.user_data) {
      return expr.user_data(expr);
    }
    switch (expr.type) {
      case "call": {
        const macro = this.data_model.macro_functions.get(expr.name.toUpperCase());
        if (macro) {
          return (expr.user_data = this.CallMacro(expr, macro))(expr);
        }
        return (expr.user_data = this.CallExpression(expr, return_reference))(expr);
      }
      case "address":
        return (expr.user_data = this.CellFunction2(expr))();
      case "range":
        return (expr.user_data = (x) => this.CellFunction4(x.start, x.end))(expr);
      case "binary":
        return (expr.user_data = this.BinaryExpression(expr))(expr);
      case "unary":
        return (expr.user_data = this.UnaryExpression(expr))(expr);
      case "identifier":
        return (expr.user_data = this.Identifier(expr))();
      case "missing":
        return (expr.user_data = () => {
          return { value: void 0, type: 0 /* undefined */ };
        })();
      case "dimensioned":
        return (expr.user_data = this.ResolveDimensionedQuantity())(expr);
      case "literal": {
        const literal = { value: expr.value, type: GetValueType(expr.value) };
        return (expr.user_data = () => literal)();
      }
      case "group":
        return (expr.user_data = this.GroupExpression(expr))(expr);
      case "complex": {
        const literal = { value: { real: expr.real, imaginary: expr.imaginary }, type: 7 /* complex */ };
        return (expr.user_data = () => literal)();
      }
      case "structured-reference":
        return (expr.user_data = this.ResolveStructuredReference(expr))();
      case "array": {
        return (expr.user_data = () => {
          return {
            type: 8 /* array */,
            value: expr.values.map((row) => (Array.isArray(row) ? row : [row]).map((value) => {
              return { type: GetValueType(value), value };
            }))
          };
        })();
      }
      default:
        console.warn("Unhandled parse expr:", expr);
        return UnknownError();
    }
  }
};

// treb-calculator/src/utilities.ts
var DAY_MS = 1e3 * 60 * 60 * 24;
var Transpose2 = (arr) => {
  const result = [];
  const cols = arr.length;
  const rows = arr[0].length;
  for (let r = 0; r < rows; r++) {
    result[r] = [];
    for (let c = 0; c < cols; c++) {
      result[r][c] = arr[c][r];
    }
  }
  return result;
};
var FlattenBoxed = (args) => {
  let result = [];
  for (const arg of args) {
    if (arg.type === 8 /* array */) {
      for (const row of arg.value) {
        result = result.concat(FlattenBoxed(row));
      }
    } else {
      result.push(arg);
    }
  }
  return result;
};
var FlattenUnboxed = (args) => {
  if (!Array.isArray(args)) {
    return [args];
  }
  return args.reduce((a, b) => {
    if (typeof b === "undefined")
      return a;
    if (Array.isArray(b))
      return a.concat(FlattenUnboxed(b));
    if (b instanceof Float32Array)
      return a.concat(Array.from(b));
    if (b instanceof Float64Array)
      return a.concat(Array.from(b));
    return a.concat([b]);
  }, []);
};
var ApplyAsArray = (base) => {
  return (a, ...rest) => {
    if (Array.isArray(a)) {
      return {
        type: 8 /* array */,
        value: a.map((row) => row.map((element) => {
          return base(element, ...rest);
        }))
      };
    } else if (typeof a === "object" && !!a && a.type === 8 /* array */) {
      return {
        type: 8 /* array */,
        value: a.value.map((row) => row.map((element) => {
          return base(element, ...rest);
        }))
      };
    } else {
      return base(a, ...rest);
    }
  };
};
var ApplyAsArray2 = (base) => {
  return (a, b, ...rest) => {
    let a_array = false;
    let b_array = false;
    if (!!a && typeof a === "object" && a.type === 8 /* array */) {
      a = a.value;
      a_array = true;
    } else {
      a_array = Array.isArray(a);
    }
    if (!!b && typeof b === "object" && b.type === 8 /* array */) {
      b = b.value;
      b_array = true;
    } else {
      b_array = Array.isArray(b);
    }
    if (a_array) {
      if (b_array) {
        return {
          type: 8 /* array */,
          value: a.map((row, i) => row.map((element, j) => {
            return base(element, b[i][j], ...rest);
          }))
        };
      }
      return {
        type: 8 /* array */,
        value: a.map((row) => row.map((element) => {
          return base(element, b, ...rest);
        }))
      };
    } else if (b_array) {
      return {
        type: 8 /* array */,
        value: b.map((row) => row.map((element) => {
          return base(a, element, ...rest);
        }))
      };
    }
    return base(a, b, ...rest);
  };
};

// treb-calculator/src/function-library.ts
var FunctionLibrary = class {
  /** the actual functions */
  functions = {};
  /**
   * register one or more functions. keys in the passed object are
   * considered the canonical function names, and must be (icase) unique.
   */
  Register(...maps) {
    for (const map of maps) {
      for (const name of Object.keys(map)) {
        if (/[^a-zA-Z0-9._]/.test(name)) {
          throw new Error("invalid function name (invalid character)");
        }
        if (name.length > 255) {
          throw new Error("invalid function name (too long, > 255)");
        }
        if (/^[^a-zA-Z]/.test(name)) {
          throw new Error("invalid function name (start with an ascii letter)");
        }
        const normalized = name.toLowerCase();
        if (this.functions[normalized]) {
          throw new Error(`function name (${normalized}) is already in use`);
        }
        const descriptor = map[name];
        descriptor.canonical_name = name;
        this.functions[normalized] = descriptor;
      }
    }
  }
  /** lookup function (actual map is protected) */
  Get(name) {
    const normalized = name.toLowerCase();
    return this.functions[normalized];
  }
  /** get a list, for AC services */
  List(filter_internal = true) {
    const list = {};
    for (const key of Object.keys(this.functions)) {
      if (filter_internal && this.functions[key].visibility === "internal") {
        continue;
      }
      list[key] = this.functions[key];
    }
    return list;
  }
  /**
   * create an alias. we clone the descriptor and use the alias as the
   * canonical name, so should work better than just a pointer.
   */
  Alias(name, reference) {
    const ref = this.Get(reference);
    if (!ref) {
      throw new Error(`referenced function ${reference} does not exist`);
    }
    this.Register({ [name]: { ...ref } });
  }
};

// treb-calculator/src/functions/sparkline.ts
var Sparkline = class {
  // public static SingleColor = ['#333'];
  // public static TwoColors = ['green', 'red'];
  static default_color = "#888";
  // should never be used, but jic
  /**
   * three possible cases: 
   * 
   * (1) array of numbers, possibly including missing values
   * (2) typed array
   * (3) nested array, so we need to recurse and concatenate 
   *
   * there's actually one more case, where data comes in from serialized
   * representation (loading file); in that case it's an object with numeric
   * indexes (sadly)
   */
  static UnpackValues(underlying) {
    if (Array.isArray(underlying)) {
      const test = underlying[0];
      if (Array.isArray(test) || test instanceof Float64Array || test instanceof Float32Array) {
        return underlying.reduce((a, subset) => a.concat(this.UnpackValues(subset)), []);
      } else {
        return underlying.map((test2) => isNaN(test2) ? void 0 : test2);
      }
    } else if (underlying instanceof Float32Array || underlying instanceof Float64Array) {
      return Array.prototype.slice.call(underlying);
    } else if (underlying && typeof underlying === "object") {
      const keys = Object.keys(underlying);
      const len = keys.length;
      if (typeof underlying["0"] !== "undefined" && typeof underlying[(len - 1).toString()] !== "undefined") {
        const data = [];
        for (let i = 0; i < len; i++) {
          data[i] = underlying[i.toString()];
        }
        return data;
      }
    }
    return [];
  }
  static SparklineCommon(cell, style) {
    let values = [];
    const text_color = style.text?.text || this.default_color;
    const colors = [text_color, text_color];
    if (Array.isArray(cell.calculated)) {
      values = this.UnpackValues(cell.calculated[0]);
      if (typeof cell.calculated[1] === "string") {
        colors[0] = cell.calculated[1];
      }
      if (typeof cell.calculated[2] === "string") {
        colors[1] = cell.calculated[2];
      }
    }
    return { values, colors };
  }
  static RenderLine(width, height, context, cell, style) {
    const { values, colors } = this.SparklineCommon(cell, style);
    const x_margin = 0.05;
    const y_margin = 0.1;
    let line_width = 1;
    if (Array.isArray(cell.calculated) && typeof cell.calculated[2] === "number") {
      line_width = cell.calculated[2];
    }
    let min = 0;
    let max = 0;
    let first_index = -1;
    for (let i = 0; i < values.length; i++) {
      const value = values[i];
      if (typeof value === "number") {
        if (first_index >= 0) {
          min = Math.min(min, value);
          max = Math.max(max, value);
        } else {
          first_index = i;
          min = max = value;
        }
      }
    }
    if (min !== max) {
      const step = width * (1 - 2 * x_margin) / (values.length - 1);
      const range = max - min;
      const pixel_range = height * (1 - 2 * y_margin);
      const base = height * y_margin;
      context.strokeStyle = colors[0];
      context.lineWidth = line_width;
      context.lineCap = "round";
      context.lineJoin = "round";
      context.beginPath();
      let op = 0 /* move */;
      for (let i = first_index; i < values.length; i++) {
        const value = values[i];
        if (typeof value === "number") {
          const x = width * x_margin + step * i;
          const y = height - (value - min) * pixel_range / range - base;
          if (op === 0 /* move */) {
            context.moveTo(x, y);
            op = 1 /* line */;
          } else {
            context.lineTo(x, y);
          }
        } else {
          op = 0 /* move */;
        }
      }
      context.stroke();
    }
  }
  static RenderColumn(width, height, context, cell, style) {
    const { values, colors } = this.SparklineCommon(cell, style);
    const x_margin = 3;
    const y_margin = 2.5;
    let min = 0;
    let max = 0;
    let first_value = false;
    for (const value of values) {
      if (typeof value === "number") {
        if (first_value) {
          min = Math.min(min, value);
          max = Math.max(max, value);
        } else {
          first_value = true;
          min = max = value;
        }
      }
    }
    if (values.length) {
      const step = (width - 2 * x_margin - 2) / (values.length - 0);
      const pixel_range = height - 2 * y_margin;
      const base = y_margin;
      if (min !== max) {
        if (min < 0 && max > 0) {
          const range = max - min;
          const zero = base + max / range * pixel_range;
          for (let i = 0; i < values.length; i++) {
            const value = values[i];
            if (typeof value === "number") {
              const x = x_margin + i * step;
              const bar_height = Math.abs(value) / range * pixel_range;
              if (value >= 0) {
                context.fillStyle = colors[0];
                const top = zero - bar_height;
                context.fillRect(x + 2, top, step - 2, bar_height);
              } else {
                context.fillStyle = colors[1];
                const top = zero;
                context.fillRect(x + 2, top, step - 2, bar_height);
              }
            }
          }
        } else if (max > 0) {
          context.fillStyle = colors[0];
          const range = max - min;
          for (let i = 0; i < values.length; i++) {
            const value = values[i];
            if (typeof value === "number") {
              const x = x_margin + i * step;
              const bar_height = Math.max(1, (value - min) / range * pixel_range);
              const top = height - base - bar_height;
              context.fillRect(x + 2, top, step - 2, bar_height);
            }
          }
        } else {
          context.fillStyle = colors[1];
          const range = max - min;
          for (let i = 0; i < values.length; i++) {
            const value = values[i];
            if (typeof value === "number") {
              const x = x_margin + i * step;
              const bar_height = Math.max(1, Math.abs(max - value) / range * pixel_range);
              const top = base;
              context.fillRect(x + 2, top, step - 2, bar_height);
            }
          }
        }
      }
    }
  }
};

// treb-calculator/src/functions/checkbox.ts
var ClickCheckbox = (options) => {
  const { x, y, width, height, cell } = options;
  const result = {};
  const offset = 3;
  const scaled = Math.round(16 * (options.scale || 1));
  if (cell && width && height && x && y) {
    const box = {
      x: offset,
      y: height - offset - scaled
    };
    if (cell.style) {
      switch (cell.style.vertical_align) {
        case "top":
          box.y = offset;
          break;
        case "middle":
          box.y = Math.round((height - scaled) / 2);
          break;
      }
      switch (cell.style.horizontal_align) {
        case "right":
          box.x = Math.round(width - offset - scaled);
          break;
        case "center":
          box.x = Math.round((width - scaled) / 2);
          break;
      }
    }
    if (x >= box.x && x <= box.x + scaled && y >= box.y && y <= box.y + scaled) {
      result.value = `=Checkbox(${cell.calculated ? "FALSE" : "TRUE"})`;
      result.block_selection = true;
    }
  }
  return result;
};
var RenderCheckbox = (options) => {
  const { context, width, height, cell } = options;
  const scale = options.scale || 1;
  context.lineJoin = "round";
  context.lineCap = "round";
  const offset = 3 * scale;
  const scaled = 16 * scale;
  let x = offset;
  let y = height - offset - scaled;
  if (cell.style) {
    switch (cell.style.vertical_align) {
      case "top":
        y = offset;
        break;
      case "middle":
        y = // Math.round
        (height - scaled) / 2;
        break;
    }
    switch (cell.style.horizontal_align) {
      case "right":
        x = // Math.round
        width - offset - scaled;
        break;
      case "center":
        x = // Math.round
        (width - scaled) / 2;
        break;
    }
  }
  x = Math.floor(x) + 0.5;
  y = Math.floor(y) + 0.5;
  const x2 = Math.floor(x + scaled) + 0.5;
  const y2 = Math.floor(y + scaled) + 0.5;
  if (cell && cell.calculated) {
    context.lineWidth = 0.5;
    context.fillStyle = context.strokeStyle;
    context.beginPath();
    context.moveTo(x, y);
    context.lineTo(x + 16 * scale, y);
    context.lineTo(x + 16 * scale, y + 16 * scale);
    context.lineTo(x, y + 16 * scale);
    context.closePath();
    context.moveTo(x + 15 * scale, y + 4 * scale);
    for (const point of [
      [13.59, 2.58],
      [6, 10.17],
      [2.41, 6.59],
      [1, 8],
      [6, 13]
    ]) {
      context.lineTo(x + point[0] * scale, y + point[1] * scale);
    }
    context.closePath();
    context.fill();
  } else {
    context.lineWidth = 1;
    context.lineJoin = "round";
    context.beginPath();
    context.moveTo(x, y);
    context.lineTo(x2, y);
    context.lineTo(x2, y2);
    context.lineTo(x, y2);
    context.closePath();
    context.stroke();
  }
  return { handled: true };
};

// treb-calculator/src/functions/base-functions.ts
var erf = (x) => {
  const a1 = 0.254829592;
  const a2 = -0.284496736;
  const a3 = 1.421413741;
  const a4 = -1.453152027;
  const a5 = 1.061405429;
  const p = 0.3275911;
  x = Math.abs(x);
  const t = 1 / (1 + p * x);
  return 1 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-1 * x * x);
};
var sqrt2pi = Math.sqrt(2 * Math.PI);
var inverse_normal = (q) => {
  if (q === 0.5) {
    return 0;
  }
  const p = q < 1 && q > 0.5 ? 1 - q : q;
  const t = Math.sqrt(Math.log(1 / Math.pow(p, 2)));
  const x = t - (2.515517 + 0.802853 * t + 0.010328 * Math.pow(t, 2)) / (1 + 1.432788 * t + 0.189269 * Math.pow(t, 2) + 1308e-6 * Math.pow(t, 3));
  return q > 0.5 ? x : -x;
};
var AltFunctionLibrary = {
  Sqrt: {
    description: "Returns the square root of the argument",
    arguments: [
      { boxed: true }
    ],
    fn: ApplyAsArray((ref) => {
      if (ref.type === 7 /* complex */) {
        const value = Power(ref.value, { real: 0.5, imaginary: 0 });
        return ComplexOrReal(value);
      } else if (ref.type === 0 /* undefined */ || !ref.value) {
        return {
          type: 3 /* number */,
          value: 0
        };
      } else if (ref.type === 3 /* number */ && ref.value < 0) {
        const value = Power({ real: ref.value, imaginary: 0 }, { real: 0.5, imaginary: 0 });
        return {
          type: 7 /* complex */,
          value
        };
      } else {
        const value = Math.sqrt(ref.value);
        if (isNaN(value)) {
          return ValueError();
        }
        return { type: 3 /* number */, value };
      }
    })
  },
  Power: {
    description: "Returns base raised to the given power",
    arguments: [
      { name: "base", boxed: true },
      { name: "exponent", boxed: true }
    ],
    fn: ApplyAsArray2((base, exponent) => {
      if (base.type === 3 /* number */ && exponent.type === 3 /* number */) {
        if (base.value >= 0 || exponent.value === 0 || Math.abs(exponent.value) >= 1) {
          const value2 = Math.pow(base.value, exponent.value);
          if (isNaN(value2)) {
            return ValueError();
          }
          return { type: 3 /* number */, value: value2 };
        }
      }
      const a = base.type === 7 /* complex */ ? base.value : { real: base.value || 0, imaginary: 0 };
      const b = exponent.type === 7 /* complex */ ? exponent.value : { real: exponent.value || 0, imaginary: 0 };
      const value = Power(a, b);
      return ComplexOrReal(value);
    })
  }
};
var BaseFunctionLibrary = {
  Int: {
    fn: (value) => {
      return { type: 3 /* number */, value: Math.floor(value) };
    }
  },
  Rand: {
    volatile: true,
    fn: () => {
      return { type: 3 /* number */, value: Math.random() };
    }
  },
  RandBetween: {
    arguments: [{ name: "min" }, { name: "max" }],
    volatile: true,
    fn: (min = 0, max = 1) => {
      if (min > max) {
        const tmp = min;
        min = max;
        max = tmp;
      }
      return { type: 3 /* number */, value: Math.floor(Math.random() * (max + 1 - min) + min) };
    }
  },
  Sum: {
    description: "Adds arguments and ranges",
    arguments: [{ boxed: true, name: "values or ranges" }],
    fn: (...args) => {
      const sum = { real: 0, imaginary: 0 };
      const values = FlattenBoxed(args);
      for (const value of values) {
        switch (value.type) {
          case 3 /* number */:
            sum.real += value.value;
            break;
          case 4 /* boolean */:
            sum.real += value.value ? 1 : 0;
            break;
          case 7 /* complex */:
            sum.real += value.value.real;
            sum.imaginary += value.value.imaginary;
            break;
          case 6 /* error */:
            return value;
        }
      }
      return ComplexOrReal(sum);
    }
  },
  Now: {
    description: "Returns current time",
    volatile: true,
    fn: () => {
      return { type: 3 /* number */, value: UnlotusDate((/* @__PURE__ */ new Date()).getTime()) };
    }
  },
  Date: {
    description: "Constructs a Lotus date from parts",
    arguments: [
      { name: "year" },
      { name: "month" },
      { name: "day" }
    ],
    fn: (year, month, day) => {
      const date = /* @__PURE__ */ new Date();
      date.setMilliseconds(0);
      date.setSeconds(0);
      date.setMinutes(0);
      date.setHours(0);
      if (year < 0 || year > 1e4) {
        return ArgumentError();
      }
      if (year < 1899) {
        year += 1900;
      }
      date.setFullYear(year);
      if (month < 1 || month > 12) {
        return ArgumentError();
      }
      date.setMonth(month - 1);
      if (day < 1 || day > 31) {
        return ArgumentError();
      }
      date.setDate(day);
      return { type: 3 /* number */, value: UnlotusDate(date.getTime()) };
    }
  },
  Today: {
    description: "Returns current day",
    volatile: true,
    fn: () => {
      const date = /* @__PURE__ */ new Date();
      date.setMilliseconds(0);
      date.setSeconds(0);
      date.setMinutes(0);
      date.setHours(12);
      return { type: 3 /* number */, value: UnlotusDate(date.getTime()) };
    }
  },
  IfError: {
    description: "Returns the original value, or the alternate value if the original value contains an error",
    arguments: [{ name: "original value", allow_error: true, boxed: true }, { name: "alternate value" }],
    fn: (ref, value_if_error = 0) => {
      if (ref && ref.type === 6 /* error */) {
        return { value: value_if_error, type: GetValueType(value_if_error) };
      }
      return ref;
    }
  },
  IsError: {
    description: "Checks if another cell contains an error",
    arguments: [{ name: "reference", allow_error: true, boxed: true }],
    fn: (...args) => {
      const values = FlattenBoxed(args);
      for (const value of values) {
        if (value.type === 6 /* error */) {
          return { type: 4 /* boolean */, value: true };
        }
      }
      return { type: 4 /* boolean */, value: false };
    }
  },
  Cell: {
    description: "Returns data about a cell",
    arguments: [
      { name: "type", description: "Type of data to return" },
      { name: "reference", description: "Cell reference", metadata: true }
    ],
    // there's no concept of "structure volatile", and structure events
    // don't trigger recalc, so this is not helpful -- we may need to 
    // think about both of those things
    // volatile: true, 
    fn: ApplyAsArray2((type, reference) => {
      if (!UnionIsMetadata(reference)) {
        return ReferenceError2();
      }
      if (type) {
        switch (type.toString().toLowerCase()) {
          case "format":
            return reference.value.format ? (
              // || ReferenceError;
              { type: 2 /* string */, value: reference.value.format }
            ) : ReferenceError2();
          case "address":
            return { type: 2 /* string */, value: reference.value.address.label.replace(/\$/g, "") };
        }
      }
      return { type: 6 /* error */, value: NotImplError.error };
    })
  },
  Year: {
    description: "Returns year from date",
    arguments: [{
      name: "date"
    }],
    fn: (source) => {
      return Box(new Date(LotusDate(source)).getUTCFullYear());
    }
  },
  Month: {
    description: "Returns month from date",
    arguments: [{
      name: "date"
    }],
    fn: (source) => {
      return Box(new Date(LotusDate(source)).getUTCMonth() + 1);
    }
  },
  Day: {
    description: "Returns day of month from date",
    arguments: [{
      name: "date"
    }],
    fn: (source) => {
      return Box(new Date(LotusDate(source)).getUTCDate());
    }
  },
  Radians: {
    description: "Converts degrees to radians",
    arguments: [{ name: "Degrees", description: "Angle in degrees" }],
    fn: ApplyAsArray((degrees) => {
      return Box(degrees * Math.PI / 180);
    })
  },
  Degrees: {
    description: "Converts radians to degrees",
    arguments: [{ name: "Radians", description: "Angle in radians" }],
    fn: ApplyAsArray((radians) => {
      return Box(radians / Math.PI * 180);
    })
  },
  CountA: {
    description: "Counts cells that are not empty",
    fn: (...args) => {
      return Box(FlattenUnboxed(args).reduce((a, b) => {
        if (typeof b === "undefined")
          return a;
        return a + 1;
      }, 0));
    }
  },
  Count: {
    description: "Counts cells that contain numbers",
    fn: (...args) => {
      return Box(FlattenUnboxed(args).reduce((a, b) => {
        if (typeof b === "number" || IsComplex(b))
          return a + 1;
        return a;
      }, 0));
    }
  },
  Or: {
    fn: (...args) => {
      let result = false;
      args = FlattenUnboxed(args);
      for (const arg of args) {
        result = result || !!arg;
      }
      return Box(result);
    }
  },
  And: {
    fn: (...args) => {
      let result = true;
      args = FlattenUnboxed(args);
      for (const arg of args) {
        result = result && !!arg;
      }
      return Box(result);
    }
  },
  Not: {
    fn: ApplyAsArray((...args) => {
      if (args.length === 0) {
        return ArgumentError();
      }
      if (args.length === 1) {
        return Box(!args[0]);
      }
      return Box(true);
    })
  },
  If: {
    arguments: [
      { name: "test value", boxed: true },
      { name: "value if true", boxed: true, allow_error: true },
      { name: "value if false", boxed: true, allow_error: true }
    ],
    /**
     * should we really have defaults for the t/f paths? not sure what X does
     * @returns 
     */
    fn: (a, b = { type: 4 /* boolean */, value: true }, c = { type: 4 /* boolean */, value: false }) => {
      const b_array = b.type === 8 /* array */;
      const c_array = c.type === 8 /* array */;
      if (a.type === 8 /* array */) {
        return {
          type: 8 /* array */,
          value: a.value.map((row, x) => row.map((cell, y) => {
            const value2 = cell.type === 2 /* string */ ? cell.value.toLowerCase() !== "false" && cell.value.toLowerCase() !== "f" : !!cell.value;
            return value2 ? b_array ? b.value[x][y] : b : c_array ? c.value[x][y] : c;
          }))
        };
      }
      const value = a.type === 2 /* string */ ? (
        //  UnionIs.String(a) ? 
        a.value.toLowerCase() !== "false" && a.value.toLowerCase() !== "f"
      ) : !!a.value;
      return value ? b : c;
    }
  },
  Fact: {
    description: "Returns the factorial of a number",
    arguments: [
      { name: "number" }
    ],
    fn: ApplyAsArray((number) => {
      number = Math.floor(number);
      let value = 1;
      while (number > 1) {
        value *= number;
        number--;
      }
      return {
        type: 3 /* number */,
        value
      };
    })
  },
  Power: {
    description: "Returns base raised to the given power",
    arguments: [
      { name: "base", boxed: true },
      { name: "exponent", boxed: true }
    ],
    fn: ApplyAsArray2((base, exponent) => {
      if (base.type === 7 /* complex */ || exponent.type === 7 /* complex */) {
        const a = base.type === 7 /* complex */ ? base.value : { real: base.value || 0, imaginary: 0 };
        const b = exponent.type === 7 /* complex */ ? exponent.value : { real: exponent.value || 0, imaginary: 0 };
        const value = Power(a, b);
        return ComplexOrReal(value);
      } else {
        const value = Math.pow(base.value, exponent.value);
        if (isNaN(value)) {
          return ValueError();
        }
        return { type: 3 /* number */, value };
      }
    })
  },
  Mod: {
    fn: ApplyAsArray2((num, divisor) => {
      if (!divisor) {
        return DivideByZeroError();
      }
      return Box(num % divisor);
    })
  },
  /**
   * sort arguments, but ensure we return empty strings to
   * fill up the result array
   * 
   * FIXME: instead of boxing all the values, why not pass them in boxed?
   * was this function just written at the wrong time?
   */
  Sort: {
    arguments: [
      { name: "values" }
    ],
    fn: (...args) => {
      args = FlattenUnboxed(args);
      if (args.every((test) => typeof test === "number")) {
        args.sort((a, b) => a - b);
      } else {
        args.sort();
      }
      return { type: 8 /* array */, value: [args.map((value) => Box(value))] };
    }
  },
  Transpose: {
    description: "Returns transpose of input matrix",
    arguments: [{ name: "matrix", boxed: true }],
    fn: (mat) => {
      if (mat.type === 8 /* array */) {
        return {
          type: 8 /* array */,
          value: Transpose2(mat.value)
        };
      }
      return mat;
    }
  },
  Max: {
    fn: (...args) => {
      return {
        type: 3 /* number */,
        value: Math.max.apply(0, FlattenUnboxed(args).filter((x) => typeof x === "number"))
      };
    }
  },
  Min: {
    fn: (...args) => {
      return {
        type: 3 /* number */,
        value: Math.min.apply(0, FlattenUnboxed(args).filter((x) => typeof x === "number"))
      };
    }
  },
  /*
      MMult: {
        description: 'Multiplies two matrices',
        arguments: [{ name: 'Matrix 1'}, { name: 'Matrix 2'}],
        fn: (a, b) => {
          if (!a || !b) return ArgumentError;
  
          const a_cols = a.length || 0;
          const a_rows = a[0]?.length || 0;
  
          const b_cols = b.length || 0;
          const b_rows = b[0]?.length || 0;
  
          if (!a_rows || !b_rows || !a_cols || !b_cols
             || a_rows !== b_cols || a_cols !== b_rows) return ValueError;
  
          const result: number[][] = [];
  
          // slightly confusing because we're column-major
  
          for (let c = 0; c < b_cols; c++) {
            result[c] = [];
            for (let r = 0; r < a_rows; r++) {
              result[c][r] = 0;
              for (let x = 0; x < a_cols; x++) {
                result[c][r] += a[x][r] * b[c][x];
              }
            }
          }
          return result;
  
        }
      },
      */
  SumProduct: {
    description: "Returns the sum of pairwise products of two or more ranges",
    fn: (...args) => {
      const flattened = args.map((arg) => FlattenUnboxed(arg));
      const len = Math.max.apply(0, flattened.map((x) => x.length));
      let sum = 0;
      for (let i = 0; i < len; i++) {
        sum += flattened.reduce((a, arg) => {
          return a * (arg[i] || 0);
        }, 1);
      }
      return { type: 3 /* number */, value: sum };
    }
  },
  /**
       * 
       * match type: 
       * 
       *  1: largest value <= target value; assumes table is in ascending order.
       *  0: exact match only.
       * -1: smallest value >= target value; assumes table is in descending order.
       * 
       * NOTE that string matches can accept wildcards in Excel, not sure if we 
       * necessarily want to support that... how does string matching deal with
       * inequalities?
       * /
      Match: {
        fn: (value: CellValue, table: CellValue[][], match_type: 1|0|-1 = 1) => {
  
          const flat = table.reduce((a, row) => ([...a, ...row]), []);
          for (let i = 0; i < flat.length; i++) {
  
            const compare = flat[i];
  
            console.info("CV", compare, value);
  
            // this is true regardless of match type... right?
            if (compare === value) {
              return { type: ValueType.number, value: i + 1 };
            }
   
            if ((typeof compare !== 'undefined' && typeof value !== 'undefined') && (
                (match_type === 1 && compare > value) || 
                (match_type === -1 && compare < value))) {
  
              if (i === 0 || i === flat.length - 1) {
                return NAError();
              }
  
              return { type: ValueType.number, value: i }; // implicit -1
            }
  
          }
          return NAError();
        },
      },
      */
  /**
   * FIXME: does not implement inexact matching (what's the algo for
   * that, anyway? nearest? price is right style? what about ties?)
   */
  VLookup: {
    fn: (value, table, col, inexact = true) => {
      col = Math.max(0, col - 1);
      if (inexact) {
        let min = Math.abs(value - table[0][0]);
        let result = table[col][0];
        for (let i = 1; i < table[0].length; i++) {
          const abs = Math.abs(table[0][i] - value);
          if (abs < min) {
            min = abs;
            result = table[col][i];
          }
        }
        return Box(result);
      } else {
        for (let i = 1; i < table[0].length; i++) {
          if (table[0][i] == value) {
            return table[col][i];
          }
        }
        return NAError();
      }
    }
  },
  Product: {
    arguments: [{ boxed: true }],
    fn: (...args) => {
      let product = { real: 1, imaginary: 0 };
      args = FlattenBoxed(args);
      for (const arg of args) {
        if (arg.type === 7 /* complex */) {
          product = Multiply(product, arg.value);
        } else if (arg.type === 3 /* number */) {
          product.real *= arg.value;
          product.imaginary *= arg.value;
        }
      }
      return ComplexOrReal(product);
    }
  },
  Log: {
    /** default is base 10; allow specific base */
    fn: ApplyAsArray2((a, base = 10) => {
      return { type: 3 /* number */, value: Math.log(a) / Math.log(base) };
    })
  },
  Log10: {
    fn: ApplyAsArray((a) => {
      return { type: 3 /* number */, value: Math.log(a) / Math.log(10) };
    })
  },
  Ln: {
    fn: ApplyAsArray((a) => {
      return { type: 3 /* number */, value: Math.log(a) };
    })
  },
  Round: {
    fn: ApplyAsArray2((a, digits = 0) => {
      const m = Math.pow(10, digits);
      return {
        type: 3 /* number */,
        value: Math.round(m * a) / m
      };
    })
  },
  RoundDown: {
    fn: ApplyAsArray2((a, digits = 0) => {
      const m = Math.pow(10, digits);
      const positive = a >= 0;
      return {
        type: 3 /* number */,
        value: positive ? Math.floor(m * a) / m : Math.ceil(m * a) / m
      };
    })
  },
  RoundUp: {
    fn: ApplyAsArray2((a, digits = 0) => {
      const m = Math.pow(10, digits);
      const positive = a >= 0;
      return {
        type: 3 /* number */,
        value: positive ? Math.ceil(m * a) / m : Math.floor(m * a) / m
      };
    })
  },
  /*
  
      Round: {
        description: 'Round to a specified number of digits',
  
        / ** round with variable digits * /
        fn: (value: number, digits = 0) => {
          const m = Math.pow(10, digits);
          return Math.round(m * value) / m;
        },
      },
  
      RoundDown: {
        / ** round down with variable digits * /
        fn: (value: number, digits = 0) => {
          digits = Math.max(0, digits);
          const m = Math.pow(10, digits);
          return Math.floor(m * value) / m;
        },
      },
  
  
      */
  Reverse: {
    arguments: [
      { boxed: true }
    ],
    fn: (a) => {
      if (a.type === 8 /* array */) {
        if (a.value.length === 1) {
          a.value[0].reverse();
        } else {
          a.value.reverse();
        }
        return a;
      }
      return {
        type: 2 /* string */,
        value: a.value.toString().split("").reverse().join("")
      };
    }
  },
  /**
   * exp was not broken out, but added so we can support complex numbers.
   */
  Exp: {
    arguments: [
      { boxed: true }
    ],
    fn: ApplyAsArray((x) => {
      if (x.type === 7 /* complex */) {
        const value = Exp(x.value);
        return ComplexOrReal(value);
      }
      return { type: 3 /* number */, value: Math.exp(x.value || 0) };
    })
  },
  /**
   * abs was already broken out so we could support array application,
   * then updated to support complex numbers.
   */
  Abs: {
    arguments: [
      { boxed: true }
    ],
    fn: ApplyAsArray((a) => {
      if (a.type === 7 /* complex */) {
        return {
          type: 3 /* number */,
          value: Math.sqrt(a.value.real * a.value.real + a.value.imaginary * a.value.imaginary)
        };
      }
      return { type: 3 /* number */, value: Math.abs(a.value || 0) };
    })
  },
  Simplify: {
    arguments: [
      { name: "value" },
      { name: "significant digits" }
    ],
    fn: ApplyAsArray2((value, significant_digits = 2) => {
      significant_digits = significant_digits || 2;
      if (value === 0) {
        return { type: 3 /* number */, value };
      }
      const negative = value < 0 ? -1 : 1;
      value *= negative;
      const x = Math.pow(10, Math.floor(Math.log10(value)) + 1 - significant_digits);
      return {
        type: 3 /* number */,
        value: Math.round(value / x) * x * negative
      };
    })
  },
  Erf: {
    fn: (a) => {
      return { type: 3 /* number */, value: erf(a) };
    }
  },
  "NormsInv": {
    description: "Inverse of the normal cumulative distribution",
    arguments: [
      { name: "probability" }
    ],
    fn: (q) => {
      return {
        type: 3 /* number */,
        value: inverse_normal(q)
      };
    }
  },
  "Norm.Inv": {
    description: "Inverse of the normal cumulative distribution",
    arguments: [
      { name: "probability" },
      { name: "mean", default: 0 },
      { name: "standard deviation", default: 1 }
    ],
    xlfn: true,
    fn: (q, mean = 0, stdev = 1) => {
      return {
        type: 3 /* number */,
        value: inverse_normal(q) * stdev + mean
      };
    }
  },
  "Norm.Dist": {
    description: "Cumulative normal distribution",
    arguments: [
      { name: "value" },
      { name: "mean", default: 0 },
      { name: "standard deviation", default: 1 },
      { name: "cumulative", default: true }
    ],
    // this does need xlfn but it also requires four parameters
    // (we have three and they are not required).
    xlfn: true,
    fn: (x, mean = 0, stdev = 1, cumulative = true) => {
      let value = 0;
      if (cumulative) {
        const sign = x < mean ? -1 : 1;
        value = 0.5 * (1 + sign * erf(Math.abs(x - mean) / (stdev * Math.sqrt(2))));
      } else {
        value = Math.exp(-1 / 2 * Math.pow((x - mean) / stdev, 2)) / (stdev * sqrt2pi);
      }
      return {
        type: 3 /* number */,
        value
      };
    }
  },
  Sqrt: {
    description: "Returns the square root of the argument",
    arguments: [
      { boxed: true }
    ],
    fn: ApplyAsArray((ref) => {
      if (ref.type === 7 /* complex */) {
        const value = Power(ref.value, { real: 0.5, imaginary: 0 });
        return ComplexOrReal(value);
      } else if (ref.type === 0 /* undefined */ || !ref.value) {
        return {
          type: 3 /* number */,
          value: 0
        };
      } else {
        const value = Math.sqrt(ref.value);
        if (isNaN(value)) {
          return ValueError();
        }
        return { type: 3 /* number */, value };
      }
    })
  },
  HexToDec: {
    arguments: [{ description: "hexadecimal string" }],
    fn: (hex) => {
      return { type: 3 /* number */, value: parseInt(hex, 16) };
    }
  },
  DecToHex: {
    arguments: [{ description: "number" }],
    fn: (num) => {
      return { type: 2 /* string */, value: num.toString(16) };
    }
  },
  Checkbox: {
    arguments: [
      { name: "checked" }
    ],
    click: ClickCheckbox,
    render: RenderCheckbox,
    fn: (checked) => {
      return { value: !!checked, type: 4 /* boolean */ };
    }
  },
  "Sparkline.Column": {
    arguments: [
      { name: "data" },
      { name: "color" },
      { name: "negative color" }
    ],
    render: (options) => {
      Sparkline.RenderColumn(options.width, options.height, options.context, options.cell, options.style);
      return { handled: true };
    },
    fn: (...args) => {
      return { type: 5 /* object */, value: args, key: "sparkline-data" };
    }
  },
  "Sparkline.Line": {
    arguments: [
      { name: "data" },
      { name: "color" },
      { name: "line width" }
    ],
    render: (options) => {
      Sparkline.RenderLine(options.width, options.height, options.context, options.cell, options.style);
      return { handled: true };
    },
    fn: (...args) => {
      return { type: 5 /* object */, value: args, key: "sparkline-data" };
    }
  },
  UniqueValues: {
    arguments: [
      { name: "range", boxed: true }
    ],
    visibility: "internal",
    fn: (area) => {
      if (area.type === 8 /* array */) {
        const cols = area.value.length;
        const rows = area.value[0]?.length;
        const Normalize = (cell) => {
          if (!cell) {
            return "";
          } else
            switch (cell.type) {
              case 2 /* string */:
              case 3 /* number */:
              case 4 /* boolean */:
                return cell.value;
              case 0 /* undefined */:
                return "";
              default:
                console.info("check", cell, cell.value);
                return cell.value?.toString() || "";
            }
        };
        const set = /* @__PURE__ */ new Set();
        const duplicates = /* @__PURE__ */ new Set();
        for (const column of area.value) {
          for (const cell of column) {
            const normalized = Normalize(cell);
            if (set.has(normalized)) {
              duplicates.add(normalized);
            } else {
              set.add(normalized);
            }
          }
        }
        const result = [];
        for (const column of area.value) {
          const column_result = [];
          for (const cell of column) {
            const value = Normalize(cell);
            column_result.push({
              type: 4 /* boolean */,
              value: !duplicates.has(value)
            });
          }
          result.push(column_result);
        }
        return {
          type: 8 /* array */,
          value: result
        };
      }
      return {
        type: 4 /* boolean */,
        value: true
      };
    }
  },
  Gradient: {
    arguments: [
      { name: "range", boxed: true },
      { name: "min" },
      { name: "max" }
    ],
    visibility: "internal",
    fn: (area, static_min, static_max) => {
      const tmp = FlattenBoxed([area]);
      let sum = 0;
      let count = 0;
      let min = 0;
      let max = 0;
      for (const ref of tmp) {
        if (ref.type === 6 /* error */) {
          return ref;
        }
        if (ref.type === 3 /* number */) {
          if (count === 0) {
            min = ref.value;
            max = ref.value;
          } else {
            min = Math.min(min, ref.value);
            max = Math.max(max, ref.value);
          }
          count++;
        }
      }
      if (typeof static_max === "number") {
        max = static_max;
      }
      if (typeof static_min === "number") {
        min = static_min;
      }
      let range = max - min;
      let rows = 1;
      let columns = 1;
      if (area.type === 8 /* array */) {
        rows = area.value.length;
        columns = area.value[0]?.length || 0;
        const result = [];
        for (let r = 0; r < rows; r++) {
          const row = [];
          for (let c = 0; c < columns; c++) {
            const src = area.value[r][c];
            if (src.type === 3 /* number */) {
              let calc = 0;
              if (max === min) {
                if (src.value > max) {
                  calc = 1;
                } else if (src.value < max) {
                  calc = 0;
                } else {
                  calc = 0.5;
                }
              } else if (range > 0) {
                calc = (src.value - min) / range;
              }
              row.push({ type: 3 /* number */, value: calc });
            } else {
              row.push({ type: 0 /* undefined */ });
            }
          }
          result.push(row);
        }
        return { type: 8 /* array */, value: result };
      } else {
        return ArgumentError();
      }
    }
  }
};
var name_map = {};
for (const key of Object.keys(BaseFunctionLibrary)) {
  name_map[key.toLowerCase()] = key;
}
var block_list = [
  "pow"
];
var block_map = {};
for (const entry of block_list) {
  block_map[entry.toLowerCase()] = entry;
}
for (const name of Object.getOwnPropertyNames(Math)) {
  const lc = name.toLowerCase();
  if (name_map[lc]) {
    continue;
  }
  if (block_map[lc]) {
    continue;
  }
  const descriptor = Object.getOwnPropertyDescriptor(Math, name);
  if (!descriptor) {
    continue;
  }
  const value = descriptor.value;
  const type = typeof value;
  switch (type) {
    case "number":
      BaseFunctionLibrary[name] = {
        fn: () => {
          return { type: 3 /* number */, value };
        },
        category: ["Math Functions"]
      };
      break;
    case "function":
      BaseFunctionLibrary[name] = {
        fn: (...args) => {
          return Box(value(...args));
        },
        category: ["Math Functions"]
      };
      break;
    default:
      console.info("unexpected type:", type, name);
      break;
  }
}
if (!Math.log10) {
  Math.log10 = (a) => Math.log(a) / Math.log(10);
}

// treb-calculator/src/functions/finance-functions.ts
var payment_function = (rate, periods, pv = 0, fv = 0, type = 0) => {
  if (type) {
    return -(pv * (rate / (1 - Math.pow(1 + rate, -periods)))) / (1 + rate) - fv * (1 / ((1 + rate) * ((Math.pow(1 + rate, periods) - 1) / rate)));
  }
  return -(pv * rate * Math.pow(1 + rate, periods) + fv * rate) / (Math.pow(1 + rate, periods) - 1);
};
var fv_function = (rate, periods, payment, pv = 0, type = 0) => {
  if (type) {
    return (1 + rate) * -payment / rate * (Math.pow(1 + rate, periods) - 1) - pv * Math.pow(1 + rate, periods);
  }
  return -payment / rate * (Math.pow(1 + rate, periods) - 1) - pv * Math.pow(1 + rate, periods);
};
var ipmt_function = (rate, period, periods, pv = 0, fv = 0, type = 0) => {
  if (period < 1) {
    return NaN;
  }
  if (period === 1 && type) {
    return 0;
  }
  const total_payment = payment_function(rate, periods, pv, fv, type);
  const interest = fv_function(rate, period - 1, total_payment, pv, type) * rate;
  return type ? interest / (1 + rate) : interest;
};
var ppmt_function = (rate, period, periods, pv = 0, fv = 0, type = 0) => {
  return payment_function(rate, periods, pv, fv, type) - ipmt_function(rate, period, periods, pv, fv, type);
};
var FinanceFunctionLibrary = {
  /**
   * Excel's NPV function is somewhat broken because it assumes the first
   * (usually negative) cashflow is in year 1, not year 0. so the thing to
   * do is just use it on the future cashflows and add the initial outlay
   * as a scalar value.
   */
  NPV: {
    description: "Returns the present value of a series of future cashflows",
    arguments: [
      { name: "Rate" },
      { name: "Cashflow" }
    ],
    fn: (rate = 0, ...args) => {
      let result = 0;
      const flat = FlattenUnboxed(args);
      for (let i = 0; i < flat.length; i++) {
        const arg = flat[i];
        if (typeof arg === "number") {
          result += Math.pow(1 + rate, -(i + 1)) * arg;
        }
      }
      return {
        type: 3 /* number */,
        value: result
      };
    }
  },
  XNPV: {
    description: "returns the NPV of a nonperiodic stream of payments at a given rate",
    arguments: [
      { name: "Discount rate" },
      { name: "Values" },
      { name: "Dates" }
    ],
    fn: (rate, input_values, input_dates) => {
      if (typeof rate !== "number") {
        return ArgumentError();
      }
      input_values = FlattenUnboxed(input_values);
      input_dates = FlattenUnboxed(input_dates);
      if (input_values.length !== input_dates.length) {
        return ArgumentError();
      }
      const values = [];
      for (const value of input_values) {
        if (typeof value !== "number") {
          return ArgumentError();
        }
        values.push(value);
      }
      const dates = [];
      for (const date of input_dates) {
        if (typeof date !== "number") {
          return ArgumentError();
        }
        dates.push(Math.floor(date));
      }
      let npv = 0;
      for (let j = 0; j < values.length; j++) {
        npv += (values[j] || 0) / Math.pow(1 + rate, (dates[j] - dates[0]) / 365);
      }
      return {
        type: 3 /* number */,
        value: npv
      };
    }
  },
  XIRR: {
    description: "returns the internal rate of return of a nonperiodic stream of payments",
    arguments: [
      { name: "Values" },
      { name: "Dates" },
      { name: "Guess", default: 0.1 }
    ],
    fn: (input_values, input_dates, guess = 0.1) => {
      input_values = FlattenUnboxed(input_values);
      input_dates = FlattenUnboxed(input_dates);
      if (input_values.length !== input_dates.length) {
        return ArgumentError();
      }
      let positive = 0;
      let negative = 0;
      const values = [];
      for (const value of input_values) {
        if (typeof value !== "number") {
          return ArgumentError();
        }
        if (value > 0) {
          positive++;
        }
        if (value < 0) {
          negative++;
        }
        values.push(value);
      }
      if (positive <= 0 || negative <= 0) {
        return ArgumentError();
      }
      const dates = [];
      for (const date of input_dates) {
        if (typeof date !== "number") {
          return ArgumentError();
        }
        dates.push(Math.floor(date));
      }
      const start = dates[0];
      for (const date of dates) {
        if (date < start) {
          return ArgumentError();
        }
      }
      const step = 0.1;
      const bounds = [
        { found: false, value: 0 },
        { found: false, value: 0 }
      ];
      const count = values.length;
      for (let i = 0; i < 100; i++) {
        let npv = 0;
        for (let j = 0; j < count; j++) {
          npv += (values[j] || 0) / Math.pow(1 + guess, (dates[j] - dates[0]) / 365);
        }
        if (Math.abs(npv) <= 1e-6) {
          return {
            type: 3 /* number */,
            value: guess
          };
        }
        if (npv > 0) {
          bounds[0].value = bounds[0].found ? Math.max(bounds[0].value, guess) : guess;
          bounds[0].found = true;
          if (!bounds[1].found) {
            guess += step;
            continue;
          }
        } else {
          bounds[1].value = bounds[1].found ? Math.min(bounds[1].value, guess) : guess;
          bounds[1].found = true;
          if (!bounds[0].found) {
            guess -= step;
            continue;
          }
        }
        guess = bounds[0].value + (bounds[1].value - bounds[0].value) / 2;
      }
      return ValueError();
    }
  },
  IRR: {
    description: "Calculates the internal rate of return of a series of cashflows",
    arguments: [
      { name: "Cashflows" },
      { name: "Guess", default: 0.1 }
    ],
    fn: (args, guess = 0.1) => {
      const flat = FlattenUnboxed(args).map((value) => typeof value === "number" ? value : 0);
      const step = 0.1;
      const bounds = [
        { found: false, value: 0 },
        { found: false, value: 0 }
      ];
      for (let i = 0; i < 50; i++) {
        let npv = 0;
        for (let j = 0; j < flat.length; j++) {
          npv += Math.pow(1 + guess, -(j + 1)) * flat[j];
        }
        if (Math.abs(npv) <= 125e-5) {
          return {
            type: 3 /* number */,
            value: guess
          };
        }
        if (npv > 0) {
          bounds[0].value = bounds[0].found ? Math.max(bounds[0].value, guess) : guess;
          bounds[0].found = true;
          if (!bounds[1].found) {
            guess += step;
            continue;
          }
        } else {
          bounds[1].value = bounds[1].found ? Math.min(bounds[1].value, guess) : guess;
          bounds[1].found = true;
          if (!bounds[0].found) {
            guess -= step;
            continue;
          }
        }
        guess = bounds[0].value + (bounds[1].value - bounds[0].value) / 2;
      }
      return {
        type: 6 /* error */,
        value: "NUM"
      };
    }
  },
  CUMPRINC: {
    description: "Returns cumulative principal paid on a loan between two periods",
    arguments: [
      { name: "Rate" },
      { name: "Periods" },
      { name: "Present Value" },
      { name: "Start Period" },
      { name: "End Period" },
      { name: "Type", default: 0 }
    ],
    fn: (rate, periods, pv, start, end, type = 0) => {
      let accum = 0;
      for (let i = start; i <= end; i++) {
        accum += ppmt_function(rate, i, periods, pv, 0, type);
      }
      return { type: 3 /* number */, value: accum };
    }
  },
  CUMIPMT: {
    description: "Returns cumulative interest paid on a loan between two periods",
    arguments: [
      { name: "Rate" },
      { name: "Periods" },
      { name: "Present Value" },
      { name: "Start Period" },
      { name: "End Period" },
      { name: "Type", default: 0 }
    ],
    fn: (rate, periods, pv, start, end, type = 0) => {
      let accum = 0;
      for (let i = start; i <= end; i++) {
        accum += ipmt_function(rate, i, periods, pv, 0, type);
      }
      return { type: 3 /* number */, value: accum };
    }
  },
  IPMT: {
    description: "Returns the interest portion of a payment",
    arguments: [
      { name: "Rate" },
      { name: "Period" },
      { name: "Periods" },
      { name: "Present Value", default: 0 },
      { name: "Future Value", default: 0 },
      { name: "Type", default: 0 }
    ],
    fn: (rate, period, periods, pv = 0, fv = 0, type = 0) => {
      return { type: 3 /* number */, value: ipmt_function(rate, period, periods, pv, fv, type) };
    }
  },
  PPMT: {
    description: "Returns the principal portion of a payment",
    arguments: [
      { name: "Rate" },
      { name: "Period" },
      { name: "Periods" },
      { name: "Present Value", default: 0 },
      { name: "Future Value", default: 0 },
      { name: "Type", default: 0 }
    ],
    fn: (rate, period, periods, pv = 0, fv = 0, type = 0) => {
      return { type: 3 /* number */, value: ppmt_function(rate, period, periods, pv, fv, type) };
    }
  },
  Rate: {
    description: "Returns the interest rate of a loan",
    arguments: [
      { name: "Periods" },
      { name: "Payment" },
      { name: "Present Value", default: 0 },
      { name: "Future Value", default: 0 },
      { name: "Type", default: 0 }
    ],
    fn: (periods, payment, pv = 0, fv = 0, type = 0) => {
      let rate = 0.25;
      const bounds = [-1, 1];
      const steps = 32;
      const epsilon = 1e-6;
      for (let i = 0; i < steps; i++) {
        const a = payment_function(rate, periods, pv, fv, type);
        if (Math.abs(a - payment) <= epsilon) {
          return { type: 3 /* number */, value: rate };
        }
        const b = payment_function(bounds[1], periods, pv, fv, type);
        if (payment >= a && payment <= b || payment >= b && payment <= a) {
          bounds[0] = rate;
        } else {
          bounds[1] = rate;
        }
        rate = bounds[0] + (bounds[1] - bounds[0]) / 2;
      }
      return { type: 3 /* number */, value: rate };
    }
  },
  FV: {
    description: "Returns the future value of an investment",
    arguments: [
      { name: "Rate" },
      { name: "Periods" },
      { name: "Payment" },
      { name: "Present Value", default: 0 },
      { name: "Type", default: 0 }
    ],
    fn: (rate, periods, payment, pv = 0, type = 0) => {
      return { type: 3 /* number */, value: fv_function(rate, periods, payment, pv, type) };
    }
  },
  PV: {
    description: "Returns the present value of an investment",
    arguments: [
      { name: "Rate" },
      { name: "Periods" },
      { name: "Payment" },
      { name: "Future Value", default: 0 },
      { name: "Type", default: 0 }
    ],
    fn: (rate, periods, payment, fv = 0, type = 0) => {
      if (type) {
        payment += fv * (1 / ((1 + rate) * ((Math.pow(1 + rate, periods) - 1) / rate)));
        return {
          type: 3 /* number */,
          value: -(payment + payment / rate * (1 - Math.pow(1 + rate, -(periods - 1))))
        };
      }
      return {
        type: 3 /* number */,
        value: -(fv + payment / rate * (Math.pow(1 + rate, periods) - 1)) / Math.pow(1 + rate, periods)
      };
    }
  },
  NPER: {
    description: "Returns the number of periods of an investment",
    arguments: [
      { name: "Rate" },
      { name: "Payment" },
      { name: "Present Value" },
      { name: "Future Value", default: 0 },
      { name: "Type", default: 0 }
    ],
    fn: (rate, payment, pv = 0, fv = 0, type = 0) => {
      if (type) {
        return {
          type: 3 /* number */,
          value: 1 + (-Math.log(1 + rate * (1 - pv / -payment)) + Math.log(1 + fv * rate / (-payment * (1 + rate)))) / Math.log(1 + rate)
        };
      }
      return {
        type: 3 /* number */,
        value: (Math.log(Math.pow(1 - pv * rate / -payment, -1)) + Math.log(1 + fv * rate / -payment)) / Math.log(1 + rate)
      };
    }
  },
  PMT: {
    description: "Returns the periodic payment of a loan",
    arguments: [
      { name: "Rate" },
      { name: "Periods" },
      { name: "Present Value" },
      { name: "Future Value", default: 0 },
      { name: "Type", default: 0 }
    ],
    fn: (rate, periods, pv, fv = 0, type = 0) => {
      return {
        type: 3 /* number */,
        value: payment_function(rate, periods, pv, fv, type)
      };
    }
  }
};

// treb-calculator/src/functions/text-functions.ts
var ParseWildcards = (text) => {
  const result = [];
  const length = text.length;
  const escaped_chars = "[\\^$.|?*+()";
  for (let i = 0; i < length; i++) {
    let char = text[i];
    switch (char) {
      case "*":
        result.push(".", "*");
        break;
      case "?":
        result.push(".");
        break;
      case "~":
        char = text[++i] || "";
      default:
        for (let j = 0; j < escaped_chars.length; j++) {
          if (char === escaped_chars[j]) {
            result.push("\\");
            break;
          }
        }
        result.push(char);
        break;
    }
  }
  return result.join("");
};
var TextFunctionLibrary = {
  Char: {
    arguments: [{
      name: "number"
    }],
    fn: (num) => {
      return { type: 2 /* string */, value: String.fromCodePoint(num || 32) };
    },
    category: ["text"]
  },
  Code: {
    arguments: [{
      name: "string"
    }],
    fn: (str) => {
      return { type: 3 /* number */, value: str.codePointAt(0) || 0 };
    },
    category: ["text"]
  },
  Value: {
    arguments: [
      { name: "text" }
    ],
    fn: (text) => {
      const value = ValueParser.TryParse(text);
      if (value.type === 3 /* number */) {
        return { type: 3 /* number */, value: value.value };
      }
      return ArgumentError();
    },
    category: ["text"]
  },
  Text: {
    arguments: [
      { name: "value" },
      { name: "number format" }
    ],
    fn: (value, format = "0.00####") => {
      return { type: 2 /* string */, value: NumberFormatCache.Get(format).Format(value || 0) };
    },
    category: ["text"]
  },
  Left: {
    arguments: [
      { name: "string" },
      { name: "count" }
    ],
    fn: (str, count = 1) => {
      return { type: 2 /* string */, value: str.substr(0, count) };
    },
    category: ["text"]
  },
  Right: {
    arguments: [
      { name: "string" },
      { name: "count" }
    ],
    fn: (str, count = 1) => {
      return { type: 2 /* string */, value: str.slice(-count) };
    },
    category: ["text"]
  },
  Mid: {
    arguments: [
      { name: "string" },
      { name: "left" },
      { name: "count" }
    ],
    fn: (str, left = 0, count = 1) => {
      return { type: 2 /* string */, value: str.substr(Math.max(0, left - 1), count) };
    },
    category: ["text"]
  },
  /*
  
    Concatenate: {
      description: 'Pastes strings together',
      fn: (...args: any[]) => {
        return args.map((arg) => {
  
          // this is used when concatenating cells that contain numbers
          // FIXME: get cell number format?
  
          const string_arg = (typeof arg === 'undefined') ? '' : arg.toString();
  
          if (typeof arg === 'number' && Localization.decimal_separator === ',') {
            return string_arg.replace(/\./, ',');
          }
  
          return string_arg;
        }).join('');
      },
    },
  
    */
  /**
   * shame we can't write a proper search function, but we need to be 
   * consistent. some notes:
   * 
   * FIND is case-sensitive and does not support wildcards
   * SEARCH is icase and supports wildcards
   * 
   * re: wildcards, from
   * https://exceljet.net/glossary/wildcard
   * 
   * Excel has 3 wildcards you can use in your formulas:
   *
   * Asterisk (*) - zero or more characters
   * Question mark (?) - any one character
   * Tilde (~) - escape for literal character (~*) a literal question mark (~?), or a literal tilde (~~)
   * 
   * start index is 1-based, and defaults to 1; < 1 is an error. if the string
   * is not found, that's an error. if needle is empty, return start.
   * 
   */
  Search: {
    description: "Find a string (needle) in another string (haystack). Case-insensitive.",
    arguments: [
      { name: "Needle" },
      { name: "Haystack" },
      { name: "Start", default: 1 }
    ],
    fn: (needle, haystack, start = 1) => {
      if (start >= 1) {
        if (!needle) {
          return {
            type: 3 /* number */,
            value: start
          };
        }
        const pattern = ParseWildcards(needle);
        const match = new RegExp(pattern, "i").exec(haystack.substr(start - 1));
        if (match) {
          return {
            type: 3 /* number */,
            value: match.index + start
          };
        }
      }
      return ValueError();
    }
  },
  Find: {
    description: "Find a string (needle) in another string (haystack). Case-sensitive.",
    arguments: [
      { name: "Needle" },
      { name: "Haystack" },
      { name: "Start", default: 1 }
    ],
    fn: (needle, haystack, start = 1) => {
      if (start >= 1) {
        if (!needle) {
          return {
            type: 3 /* number */,
            value: start
          };
        }
        const match = new RegExp(needle).exec(haystack.substr(start - 1));
        if (match) {
          return {
            type: 3 /* number */,
            value: match.index + start
          };
        }
      }
      return ValueError();
    }
  },
  /** canonical should be CONCAT; concatenate can be an alias */
  Concat: {
    description: "Pastes strings together",
    fn: (...args) => {
      const values = FlattenUnboxed(args);
      const value = values.map((arg) => {
        const string_arg = arg?.toString() || "";
        if (typeof arg === "number" && Localization.decimal_separator === ",") {
          return string_arg.replace(/\./, ",");
        }
        return string_arg;
      }).join("");
      return { type: 2 /* string */, value };
    }
  }
};
var TextFunctionAliases = {
  Concatenate: "Concat"
};

// treb-calculator/src/functions/information-functions.ts
var InformationFunctionLibrary = {
  IsBlank: {
    description: "Returns true if the reference is blank",
    arguments: [{
      name: "Reference",
      metadata: true
    }],
    fn: ApplyAsArray((ref) => {
      return {
        type: 4 /* boolean */,
        value: !ref?.value || typeof ref.value.value === "undefined"
      };
    })
  },
  IsNumber: {
    description: "Returns true if the reference is a number",
    arguments: [{
      name: "Reference",
      metadata: true
    }],
    fn: ApplyAsArray((ref) => {
      return {
        type: 4 /* boolean */,
        value: ref?.value && typeof ref.value.value === "number"
      };
    })
  },
  IsLogical: {
    description: "Returns true if the reference is a logical TRUE or FALSE",
    arguments: [{
      name: "Reference",
      metadata: true
    }],
    fn: ApplyAsArray((ref) => {
      return {
        type: 4 /* boolean */,
        value: ref?.value && typeof ref.value.value === "boolean"
      };
    })
  },
  IsText: {
    description: "Returns true if the reference is text",
    arguments: [{
      name: "Reference",
      metadata: true
    }],
    fn: ApplyAsArray((ref) => {
      return {
        type: 4 /* boolean */,
        value: ref?.value && typeof ref.value.value === "string"
      };
    })
  }
  /* needs more data
  ISFORMULA: {
    description: 'Returns true if the reference is a formula',
    arguments: [{
      name: 'Reference',
      metadata: true,
    }],
    fn: (ref: UnionValue): UnionValue => {
      console.info("RR", ref);
      return { 
        type: ValueType.boolean, 
        value: ref?.value && typeof ref.value.value === 'string' && ref.value.value[0] === '=',
      };
    },
  },
  */
};

// treb-calculator/src/functions/statistics-functions.ts
var Variance = (data, sample = false) => {
  const len = data.length;
  let m = 0;
  let v = 0;
  for (let i = 0; i < len; i++)
    m += data[i];
  m /= len;
  for (let i = 0; i < len; i++) {
    const d = data[i] - m;
    v += d * d;
  }
  return sample ? v / (len - 1) : v / len;
};
var StatisticsFunctionLibrary = {
  "StDev.P": {
    description: "Returns the standard deviation of a set of values, corresponding to a population",
    arguments: [{ name: "data" }],
    fn: (...args) => {
      return { type: 3 /* number */, value: Math.sqrt(Variance(FlattenUnboxed(args), false)) };
    }
  },
  "StDev.S": {
    description: "Returns the standard deviation of a set of values, corresponding to a sample of a population",
    arguments: [{ name: "data" }],
    fn: (...args) => {
      return { type: 3 /* number */, value: Math.sqrt(Variance(FlattenUnboxed(args), true)) };
    }
  },
  "Var.P": {
    description: "Returns the variance of a set of values, corresponding to a population",
    arguments: [{ name: "data" }],
    fn: (...args) => {
      return { type: 3 /* number */, value: Variance(FlattenUnboxed(args), false) };
    }
  },
  "Var.S": {
    description: "Returns the variance of a set of values, corresponding to a sample of a population",
    arguments: [{ name: "data" }],
    fn: (...args) => {
      return { type: 3 /* number */, value: Variance(FlattenUnboxed(args), true) };
    }
  },
  Covar: {
    description: "Returns the covariance between two ranges of values",
    arguments: [{
      name: "A"
    }, {
      name: "B"
    }],
    fn: (x, y) => {
      if (!Array.isArray(x) || !Array.isArray(y)) {
        return ValueError();
      }
      if (!Array.isArray(x[0]) || !Array.isArray(y[0])) {
        return ValueError();
      }
      if (x.length !== y.length) {
        return ArgumentError();
      }
      let sum = 0;
      let length = 0;
      const mean = { x: 0, y: 0 };
      const data = { x: [], y: [] };
      for (let j = 0; j < x.length; j++) {
        if (!x[j] || !y[j]) {
          continue;
        }
        if (x[j].length !== y[j].length) {
          return ArgumentError();
        }
        const len = x[j].length;
        length += len;
        for (let i = 0; i < len; i++) {
          mean.x += x[j][i] || 0;
          mean.y += y[j][i] || 0;
          data.x.push(x[j][i] || 0);
          data.y.push(y[j][i] || 0);
        }
      }
      if (length === 0) {
        return NAError();
      }
      mean.x /= length;
      mean.y /= length;
      for (let i = 0; i < length; i++) {
        sum += (data.x[i] - mean.x) * (data.y[i] - mean.y);
      }
      return { type: 3 /* number */, value: sum / length };
    }
  },
  Correl: {
    description: "Returns the correlation between two ranges of values",
    arguments: [{
      name: "A"
    }, {
      name: "B"
    }],
    fn: (x, y) => {
      if (!Array.isArray(x) || !Array.isArray(y)) {
        return ValueError();
      }
      if (!Array.isArray(x[0]) || !Array.isArray(y[0])) {
        return ValueError();
      }
      let rslt = 0;
      let sumProduct = 0;
      let sumX = 0;
      let sumY = 0;
      let sumSquaredX = 0;
      let sumSquaredY = 0;
      let count = 0;
      for (let j = 0; j < x.length; j++) {
        if (!x[j] || !y[j]) {
          continue;
        }
        const len = x[j].length;
        for (let i = 0; i < len; i++) {
          const a = Number(x[j][i]);
          const b = Number(y[j][i]);
          if (isNaN(a) || isNaN(b)) {
            continue;
          }
          sumProduct += a * b;
          sumX += a;
          sumY += b;
          sumSquaredX += a * a;
          sumSquaredY += b * b;
          count++;
        }
      }
      rslt = count * sumProduct - sumX * sumY;
      if (rslt) {
        rslt /= Math.sqrt((count * sumSquaredX - sumX * sumX) * (count * sumSquaredY - sumY * sumY));
      }
      return { type: 3 /* number */, value: rslt };
    }
  },
  GeoMean: {
    description: "Returns the geometric mean of all numeric arguments",
    arguments: [{ boxed: true }],
    fn: (...args) => {
      args = FlattenBoxed(args);
      let count = 0;
      let product = { real: 1, imaginary: 0 };
      let complex = false;
      let negative = false;
      for (const arg of args) {
        if (arg.type === 7 /* complex */) {
          complex = true;
          product = Multiply(product, arg.value);
          count++;
        } else if (arg.type === 3 /* number */) {
          if (arg.value < 0) {
            negative = true;
          }
          count++;
          product.real *= arg.value;
          product.imaginary *= arg.value;
        }
      }
      if (complex) {
        const value = Power(product, { real: 1 / count, imaginary: 0 });
        if (value.imaginary) {
          return { type: 7 /* complex */, value };
        }
        return { type: 3 /* number */, value: value.real };
      } else {
        if (negative) {
          return ValueError();
        }
        return { type: 3 /* number */, value: Math.pow(product.real, 1 / count) };
      }
    }
  },
  Average: {
    description: "Returns the arithmetic mean of all numeric arguments",
    arguments: [{ boxed: true }],
    fn: (...args) => {
      args = FlattenBoxed(args);
      const result = { real: 0, imaginary: 0 };
      let count = 0;
      for (const ref of args) {
        if (ref.type === 6 /* error */) {
          return ref;
        }
        if (ref.type === 3 /* number */) {
          result.real += ref.value;
          count++;
        }
        if (ref.type === 7 /* complex */) {
          result.real += ref.value.real;
          result.imaginary += ref.value.imaginary;
          count++;
        }
      }
      result.real /= count;
      result.imaginary /= count;
      if (result.imaginary) {
        return { type: 7 /* complex */, value: result };
      }
      return { type: 3 /* number */, value: result.real };
    }
  },
  Percentile: {
    description: "Returns the kth percentile value from the range of data",
    arguments: [
      { name: "range" },
      { name: "percentile" }
    ],
    fn: (range, percentile) => {
      const flat = FlattenUnboxed(range).filter((test) => typeof test === "number");
      flat.sort((a, b) => a - b);
      const n = flat.length;
      const factor = Math.pow(10, 8);
      const x = Math.round((1 + (n - 1) * percentile) * factor) / factor;
      const lo = Math.floor(x);
      const hi = Math.ceil(x);
      return { type: 3 /* number */, value: (flat[lo - 1] + flat[hi - 1]) / 2 };
    }
  },
  Median: {
    description: "Returns the median value of the range of data",
    arguments: [
      { name: "range" }
    ],
    fn: (...args) => {
      const flat = FlattenUnboxed(args).filter((test) => typeof test === "number");
      flat.sort((a, b) => a - b);
      const n = flat.length;
      const x = 1 + (n - 1) * 0.5;
      const lo = Math.floor(x);
      const hi = Math.ceil(x);
      return { type: 3 /* number */, value: (flat[lo - 1] + flat[hi - 1]) / 2 };
    }
  }
};
var StatisticsFunctionAliases = {
  Mean: "Average",
  "StDev": "StDev.S",
  "Var": "Var.S"
};

// treb-calculator/src/functions/complex-functions.ts
var ComplexFunctionLibrary = {
  IsComplex: {
    description: "Returns true if the reference is a complex number",
    arguments: [{
      name: "Reference",
      metadata: true
      /* OK with array metadata */
    }],
    fn: ApplyAsArray((ref) => {
      return {
        type: 4 /* boolean */,
        value: ref?.value && IsComplex(ref.value.value)
      };
    })
  },
  Real: {
    description: "Returns the real part of a complex number",
    arguments: [
      { boxed: true }
    ],
    fn: ApplyAsArray((ref) => {
      if (ref.type === 3 /* number */) {
        return { ...ref };
      }
      if (ref.type === 7 /* complex */) {
        return {
          type: 3 /* number */,
          value: ref.value.real || 0
        };
      }
      if (ref.type === 0 /* undefined */ || ref.type === 2 /* string */ && ref.value === "") {
        return {
          type: 3 /* number */,
          value: 0
        };
      }
      return ValueError();
    })
  },
  Imaginary: {
    description: "Returns the imaginary part of a complex number (as real)",
    arguments: [
      { boxed: true }
    ],
    fn: ApplyAsArray((ref) => {
      if (ref.type === 7 /* complex */) {
        return {
          type: 3 /* number */,
          value: ref.value.imaginary || 0
        };
      }
      if (ref.type === 3 /* number */ || ref.type === 0 /* undefined */ || ref.type === 2 /* string */ && ref.value === "") {
        return {
          type: 3 /* number */,
          value: 0
        };
      }
      return ValueError();
    })
  },
  Conjugate: {
    description: "Returns the conjugate of a complex number",
    arguments: [
      { boxed: true }
    ],
    fn: ApplyAsArray((arg) => {
      if (arg.type === 7 /* complex */) {
        return {
          type: 7 /* complex */,
          value: {
            real: arg.value.real,
            imaginary: -arg.value.imaginary
          }
        };
      } else if (arg.type === 3 /* number */ || arg.type === 0 /* undefined */ || !arg.value) {
        return {
          type: 3 /* number */,
          value: arg.value || 0
        };
      } else {
        return ValueError();
      }
    })
  },
  Arg: {
    description: "Returns the principal argument of a complex number (in radians)",
    arguments: [
      { boxed: true }
    ],
    fn: ApplyAsArray((ref) => {
      if (ref.type === 7 /* complex */) {
        return {
          type: 3 /* number */,
          value: Math.atan2(ref.value.imaginary, ref.value.real)
        };
      }
      if (ref.type === 3 /* number */ || ref.type === 0 /* undefined */ || ref.type === 2 /* string */ && ref.value === "") {
        return {
          type: 3 /* number */,
          value: Math.atan2(0, ref.value || 0)
          // this is clumsy now because typing has _improved_
        };
      }
      return ValueError();
    })
  },
  Rectangular: {
    description: "Converts a complex number in polar form to rectangular form",
    arguments: [
      { name: "r" },
      { name: "\u03B8 in radians" }
    ],
    fn: (r = 0, theta = 0) => {
      return {
        type: 7 /* complex */,
        value: {
          real: r * Math.cos(theta),
          imaginary: r * Math.sin(theta)
        }
      };
    }
  },
  Complex: {
    description: "Ensures that the given value will be treated as a complex number",
    arguments: [
      { boxed: true }
    ],
    // FIXME: this should use flatten? not sure
    fn: ApplyAsArray((a) => {
      if (a.type === 7 /* complex */) {
        return a;
      }
      if (a.type === 3 /* number */ || a.type === 0 /* undefined */ || !a.value) {
        return {
          type: 7 /* complex */,
          value: {
            imaginary: 0,
            real: a.value || 0
          }
        };
      }
      return ValueError();
    })
  },
  /**
   * unfortunately we can't override the log function because the complex
   * log function has a different meaning even when applied to reals, i.e.
   * Log(a + 0i) !== ln(a)
   * 
   * note that Log(0) is undefined -- we need to return an error here, but
   * what error? let's do #VALUE
   * 
   */
  ComplexLog: {
    description: "Returns the principal value Log(z) of a complex number z",
    arguments: [
      { boxed: true }
    ],
    fn: ApplyAsArray((a) => {
      if (a.type === 3 /* number */) {
        if (!a.value) {
          return ValueError();
        }
        a = {
          type: 7 /* complex */,
          value: {
            real: a.value,
            imaginary: 0
          }
        };
      } else if (a.type === 0 /* undefined */ || a.type === 2 /* string */ && a.value === "") {
        return ValueError();
      }
      if (a.type === 7 /* complex */) {
        const polar = RectangularToPolar(a.value);
        const value = {
          real: Math.log(polar.r),
          imaginary: polar.theta
        };
        return value.imaginary ? { type: 7 /* complex */, value } : { type: 3 /* number */, value: value.real };
      }
      return ValueError();
    })
  }
};

// treb-calculator/src/functions/matrix-functions.ts
var ComplexMatrix2 = (input) => {
  let a = [];
  if (input.type === 8 /* array */) {
    a = input.value;
  } else {
    a = [[input.value]];
  }
  const m = a.length;
  const n = m ? a[0].length : 0;
  const array = [];
  if (!m || !n) {
    return { m, n, array };
  }
  for (let i = 0; i < m; i++) {
    const row = [];
    for (let j = 0; j < n; j++) {
      const ref = a[i][j];
      if (ref.type === 7 /* complex */) {
        row.push({ ...ref.value });
      } else if (ref.type === 3 /* number */) {
        row.push({ real: ref.value, imaginary: 0 });
      } else if (ref.type === 0 /* undefined */ || ref.value === "") {
        row.push({ real: 0, imaginary: 0 });
      } else {
        return { m, n, error: true, array: [] };
      }
    }
    array.push(row);
  }
  return { m, n, array };
};
var MatrixFunctionLibrary = {
  MDeterm: {
    description: "Returns the determinant of a matrix",
    arguments: [
      { name: "matrix", boxed: true }
    ],
    fn: (a) => {
      const matrix = ComplexMatrix2(a);
      if (!matrix.array || !matrix.m || !matrix.n || matrix.m !== matrix.n || matrix.error) {
        return ValueError();
      }
      const result = ComplexDeterminant(matrix);
      if (!result) {
        return ValueError();
      }
      return ComplexOrReal(result);
    }
  },
  MInverse: {
    description: "Returns the inverse matrix",
    arguments: [
      { name: "matrix", boxed: true }
    ],
    fn: (a) => {
      const matrix = ComplexMatrix2(a);
      if (!matrix.array || !matrix.m || !matrix.n || matrix.m !== matrix.n || matrix.error) {
        return ValueError();
      }
      const det = ComplexDeterminant(matrix);
      if (det && (det.real === 0 && det?.imaginary === 0)) {
        return ValueError();
      }
      const inverse = MatrixInverse(matrix);
      if (!inverse) {
        return ValueError();
      }
      return {
        type: 8 /* array */,
        value: inverse.map((row) => row.map((value) => ComplexOrReal(value)))
      };
    }
  },
  MMult: {
    description: "Returns the dot product of A and B",
    arguments: [
      { name: "A", boxed: true },
      { name: "B", boxed: true }
    ],
    fn: (a, b) => {
      const A = ComplexMatrix2(a);
      const B = ComplexMatrix2(b);
      if (!A.array || A.error || !B.array || B.error) {
        return ValueError();
      }
      if (A.m !== B.n) {
        return ValueError();
      }
      const product = ComplexProduct(B, A);
      return {
        type: 8 /* array */,
        value: product.map((row) => row.map((value) => ComplexOrReal(value)))
      };
    }
  }
};

// treb-calculator/src/dag/state_leaf_vertex.ts
var StateLeafVertex = class _StateLeafVertex extends SpreadsheetVertex {
  static type = "state-leaf-vertex";
  state_id = 0;
  type = _StateLeafVertex.type;
  // for type guard
  /**
   * leaf vertex defaults to black (i.e. tested) because leaf nodes cannot have 
   * outbound edges. it is still possible to change this, because it's a property 
   * and we can't override the set accessor, but making it an accessor in the 
   * superclass just for this purpose is not worthwhile since regular vertices 
   * should vastly outnumber leaves.
   */
  color = 2 /* black */;
  state_representation = "";
  /**
   * construct the state, compare, and increment the state id if
   * it changes. this is expected to be called from Calculate(), but
   * we can also call it on init if we already know the state.
   *
   * FIXME: what's more expensive, generating this state field or
   * re-rendering a chart with the same data? (...?)
   * especially since it's only called on dirty...
   *
   * what is the case where the depenendency is dirty but state
   * does not change? you type in the same value? (...) or maybe
   * there's a volatile function that doesn't change value (e.g. Today())
   *
   * still, it seems like a waste here. let's test without the state.
   * (meaning just update the flag anytime it's dirty)
   *
   * Actually I think the case is manual recalc, when values don't change
   * (especially true for MC charts).
   *
   * TODO: perf
   */
  UpdateState() {
    const state = JSON.stringify(Array.from(this.edges_in).map((edge) => edge.result));
    if (state !== this.state_representation) {
      this.state_representation = state;
      this.state_id++;
    }
  }
  /** overrides calculate function */
  Calculate(graph) {
    if (!this.dirty)
      return;
    for (const edge of this.edges_in) {
      if (edge.dirty) {
        return;
      }
    }
    this.UpdateState();
    this.dirty = false;
  }
  AddDependent(edge) {
    throw new Error("leaf vertex cannot have dependents");
  }
};

// treb-calculator/src/dag/calculation_leaf_vertex.ts
var CalculationLeafVertex = class _CalculationLeafVertex extends SpreadsheetVertex {
  static type = "calculation-leaf-vertex";
  type = _CalculationLeafVertex.type;
  // for type guard
  address = { row: -1, column: -1 };
  // fake address
  /**
   * this type is currently only used for conditional formatting.
   * but that might change in the future. I want to identify what
   * it's used for so we can selectively prune them when necessary.
   */
  use;
  /** 
   * flag, to reduce unecessary application. work in progress. this
   * indicates that we reached the calculation step. that means either
   * (1) dependencies changed, or (2) we were marked dirty in some global
   * operation, probably a full-recalc. 
   * 
   * (2) is a waste but we're still going to save some cycles here. if you
   * want you could add a state check like the other leaf vertex.
   */
  updated = false;
  /**
   * leaf vertex defaults to black (i.e. tested) because leaf nodes cannot have 
   * outbound edges. it is still possible to change this, because it's a property 
   * and we can't override the set accessor, but making it an accessor in the 
   * superclass just for this purpose is not worthwhile since regular vertices 
   * should vastly outnumber leaves.
   */
  color = 2 /* black */;
  /** overrides calculate function */
  Calculate(graph) {
    if (!this.dirty)
      return;
    for (const edge of this.edges_in) {
      if (edge.dirty) {
        return;
      }
    }
    const result = graph.CalculationCallback.call(graph, this);
    this.result = result.value;
    this.dirty = false;
    this.updated = true;
  }
  AddDependent(edge) {
    throw new Error("leaf vertex cannot have dependents");
  }
};

// treb-calculator/src/calculator.ts
var TranslateSubtotalType = (type) => {
  if (typeof type === "string") {
    type = type.toUpperCase();
    switch (type) {
      case "AVERAGE":
      case "MEAN":
        type = 101;
        break;
      case "COUNT":
        type = 102;
        break;
      case "COUNTA":
        type = 103;
        break;
      case "MAX":
        type = 104;
        break;
      case "MIN":
        type = 105;
        break;
      case "PRODUCT":
        type = 106;
        break;
      case "STDEV":
        type = 107;
        break;
      case "STDEVP":
        type = 108;
        break;
      case "SUM":
        type = 109;
        break;
      case "VAR":
        type = 110;
        break;
      case "VARP":
        type = 111;
        break;
      default:
        type = 0;
        break;
    }
  }
  return type;
};
var default_calculator_options = {
  complex_numbers: "off"
};
var Calculator = class extends Graph {
  constructor(model, calculator_options = {}) {
    super();
    this.model = model;
    this.expression_calculator = new ExpressionCalculator(this.library, this.parser);
    const options = {
      ...default_calculator_options,
      ...calculator_options
    };
    if (options.complex_numbers === "on") {
      for (const key of Object.keys(AltFunctionLibrary)) {
        BaseFunctionLibrary[key] = AltFunctionLibrary[key];
      }
      UseComplex();
    }
    this.UpdateLocale();
    this.library.Register(
      BaseFunctionLibrary,
      TextFunctionLibrary,
      // we split out text functions
      StatisticsFunctionLibrary,
      // also stats (wip)
      FinanceFunctionLibrary,
      // also this (wip)
      InformationFunctionLibrary,
      // etc
      ComplexFunctionLibrary,
      MatrixFunctionLibrary
    );
    for (const key of Object.keys(StatisticsFunctionAliases)) {
      this.library.Alias(key, StatisticsFunctionAliases[key]);
    }
    for (const key of Object.keys(TextFunctionAliases)) {
      this.library.Alias(key, TextFunctionAliases[key]);
    }
    this.library.Register({
      /**
       * this function is here because it checks whether rows are hidden or 
       * not. cell dependencies don't track that, so we need to do it here. 
       * and it needs to be volatile. this is an ugly, ugly function.
       */
      Subtotal: {
        arguments: [
          { name: "type" },
          { name: "range", metadata: true }
        ],
        fn: (type, ...args) => {
          type = TranslateSubtotalType(type);
          if (type > 100) {
            type -= 100;
          }
          if (type < 1 || type > 11) {
            return ArgumentError();
          }
          const flat = FlattenBoxed(args);
          const values = [];
          let counta = 0;
          let sum = 0;
          let sheet;
          for (const entry of flat) {
            const address = entry.value?.address;
            if (!address) {
              return ReferenceError2();
            }
            if (!sheet || sheet.id !== address.sheet_id) {
              if (!address.sheet_id) {
                console.warn("invalid reference in metadata");
                return ReferenceError2();
              }
              sheet = this.model.sheets.Find(address.sheet_id);
              if (!sheet) {
                console.warn("invalid sheet in metadata");
                return ReferenceError2();
              }
            }
            const height = sheet.GetRowHeight(address.row);
            if (!height) {
              continue;
            }
            const entry_value = entry.value?.value;
            if (typeof entry_value === "undefined") {
              continue;
            }
            counta++;
            if (typeof entry_value === "number") {
              sum += entry_value;
              values.push(entry_value);
            }
          }
          let value = 0;
          switch (type) {
            case 1:
              if (values.length === 0) {
                return DivideByZeroError();
              }
              value = sum / values.length;
              break;
            case 2:
              value = values.length;
              break;
            case 3:
              value = counta;
              break;
            case 4:
              if (values.length === 0) {
                return ValueError();
              }
              value = Math.max.apply(0, values);
              break;
            case 5:
              if (values.length === 0) {
                return ValueError();
              }
              value = Math.min.apply(0, values);
              break;
            case 6:
              if (values.length === 0) {
                return ValueError();
              }
              value = 1;
              for (const entry of values) {
                value *= entry;
              }
              break;
            case 7:
              if (values.length < 2) {
                return DivideByZeroError();
              }
              value = Math.sqrt(Variance(values, true));
              break;
            case 8:
              if (values.length === 0) {
                return DivideByZeroError();
              }
              value = Math.sqrt(Variance(values, false));
              break;
            case 9:
              value = sum;
              break;
            case 10:
              if (values.length < 2) {
                return DivideByZeroError();
              }
              value = Variance(values, true);
              break;
            case 11:
              if (values.length === 0) {
                return DivideByZeroError();
              }
              value = Variance(values, false);
              break;
          }
          return {
            type: 3 /* number */,
            value
          };
        }
      },
      /**
       * this function is here so it has access to the parser.
       * this is crazy expensive. is there a way to reduce cost?
       * 
       * we could, in theory, consider that there are only a few
       * valid operations here -- all binary. instead of using a 
       * generic call to the CalculateExpression routine, we could
       * short-cut and call the binary method.
       * 
       * OTOH that makes it more fragile, and might not really 
       * provide that much in the way of savings. still, it would
       * be good if we could somehow cache some of the effort,
       * particularly if the list data changes but not the expression.
       * 
       */
      CountIf: {
        arguments: [
          { name: "range" },
          { name: "criteria" }
        ],
        fn: (range, criteria) => {
          const data = FlattenUnboxed(range);
          if (typeof criteria !== "string") {
            criteria = "=" + (criteria || 0).toString();
          } else {
            criteria = criteria.trim();
            if (!/^[=<>]/.test(criteria)) {
              criteria = "=" + criteria;
            }
          }
          const parse_result = this.parser.Parse("{}" + criteria);
          const expression = parse_result.expression;
          if (parse_result.error || !expression) {
            return ExpressionError();
          }
          if (expression.type !== "binary") {
            return ExpressionError();
          }
          if (expression.left.type !== "array") {
            return ExpressionError();
          }
          expression.left.values = [data];
          const result = this.CalculateExpression(expression);
          if (result.type === 8 /* array */) {
            let count = 0;
            for (const column of result.value) {
              for (const cell of column) {
                if (cell.value) {
                  count++;
                }
              }
            }
            return { type: 3 /* number */, value: count };
          }
          return result;
        }
      },
      /** like indirect, this creates dependencies at calc time */
      Offset: {
        arguments: [
          {
            name: "reference",
            description: "Base reference",
            metadata: true
          },
          {
            name: "rows",
            description: "number of rows to offset"
          },
          {
            name: "columns",
            description: "number of columns to offset"
          },
          {
            name: "height"
          },
          {
            name: "width"
          }
        ],
        return_type: 1 /* reference */,
        volatile: true,
        fn: ((reference, rows = 0, columns = 0, height, width) => {
          if (!reference) {
            return ArgumentError();
          }
          if (reference.type === 8 /* array */) {
            const end_row = typeof height === "number" ? rows + height : void 0;
            const end_column = typeof width === "number" ? columns + width : void 0;
            const result = {
              type: 8 /* array */,
              value: reference.value.slice(rows, end_row).map((row) => row.slice(columns, end_column))
            };
            return result;
          }
          if (!UnionIsMetadata(reference)) {
            console.info("e2", { reference });
            return ReferenceError2();
          }
          const check_result = this.DynamicDependencies(
            reference.value.address,
            this.expression_calculator.context.address,
            true,
            rows,
            columns,
            width,
            height
          );
          if (!check_result) {
            console.info("e1", { check_result });
            return ReferenceError2();
          }
          if (check_result.dirty) {
            const current_vertex = this.GetVertex(this.expression_calculator.context.address, true);
            current_vertex.short_circuit = true;
            return { type: 0 /* undefined */, value: void 0 };
          }
          if (check_result.area) {
            const start = {
              type: "address",
              ...check_result.area.start,
              label: "",
              position: 0,
              // id: parse_result.expression.id,
              id: 0
            };
            const end = {
              type: "address",
              ...check_result.area.end,
              label: "",
              position: 0,
              // id: parse_result.expression.id,
              id: 0
            };
            const expression = check_result.area.count === 1 ? start : {
              type: "range",
              start,
              end,
              label: "",
              position: 0,
              // id: parse_result.expression.id,
              id: 0
            };
            return { type: 5 /* object */, value: expression };
          }
          return ValueError();
        }).bind(this)
      },
      Indirect: {
        arguments: [
          { name: "reference", description: "Cell reference (string)" }
        ],
        return_type: 1 /* reference */,
        volatile: true,
        // necessary?
        fn: ((reference) => {
          if (!reference || typeof reference !== "string") {
            return ArgumentError();
          }
          const parse_result = this.parser.Parse(reference);
          if (parse_result.error || !parse_result.expression || parse_result.expression.type !== "address" && parse_result.expression.type !== "range") {
            return ReferenceError2();
          }
          const check_result = this.DynamicDependencies(
            parse_result.expression,
            this.expression_calculator.context.address
          );
          if (!check_result) {
            return ReferenceError2();
          }
          if (check_result.dirty) {
            const current_vertex = this.GetVertex(this.expression_calculator.context.address, true);
            current_vertex.short_circuit = true;
            return { type: 0 /* undefined */, value: void 0 };
          }
          return { type: 5 /* object */, value: parse_result.expression };
        }).bind(this)
      },
      /**
       * FIXME: there are cases we are not handling
       * 
       * match seems to return either the matching row, in a column set,
       * or matching column, in a row set. you can't search a 2d array.
       * match also supports inexact matching but assumes data is ordered.
       * (TODO).
       * 
       * FIXME: we also need to icase match strings
       * 
       */
      Match: {
        arguments: [
          { name: "value", boxed: true },
          { name: "range", boxed: true },
          { name: "type" }
        ],
        fn: (value, range, type = 0) => {
          if (type) {
            console.warn("inexact match not supported", { value, range, type });
            return NAError();
          } else {
            if (range.type === 8 /* array */) {
              if (range.value.length === 1) {
                const arr = range.value[0];
                for (let i = 0; i < arr.length; i++) {
                  if (value.type == arr[i].type && value.value === arr[i].value) {
                    return { type: 3 /* number */, value: i + 1 };
                  }
                }
              } else {
                for (let i = 0; i < range.value.length; i++) {
                  const arr = range.value[i];
                  if (arr.length !== 1) {
                    return NAError();
                  }
                  if (value.type == arr[0].type && value.value === arr[0].value) {
                    return { type: 3 /* number */, value: i + 1 };
                  }
                }
              }
              return NAError();
            } else {
              if (value.type === range.type && value.value === range.value) {
                return {
                  type: 3 /* number */,
                  value: 1
                };
              }
              return NAError();
            }
          }
          return ArgumentError();
        }
      },
      /**
       * FIXME: there are cases we are not handling
       */
      Index: {
        arguments: [
          { name: "range", boxed: true },
          { name: "row" },
          { name: "column" }
        ],
        volatile: false,
        // FIXME: handle full row, full column calls
        fn: (data, row, column) => {
          if (data && data.type !== 8 /* array */) {
            data = {
              type: 8 /* array */,
              value: [[data]]
            };
          }
          if (row && column) {
            const c = data.value[column - 1];
            if (c) {
              const cell = c[row - 1];
              if (cell) {
                return cell;
              }
            }
          } else if (row) {
            const value = [];
            for (const c of data.value) {
              if (!c[row - 1]) {
                return ArgumentError();
              }
              value.push([c[row - 1]]);
            }
            return {
              type: 8 /* array */,
              value
            };
          } else if (column) {
            const c = data.value[column - 1];
            if (c) {
              return {
                type: 8 /* array */,
                value: [c]
              };
            }
          }
          return ArgumentError();
        }
      },
      /**
       * this one does not have to be here, it's just here because
       * the rest of the reference/lookup functions are here
       */
      Rows: {
        arguments: [
          {
            name: "reference",
            description: "Array or reference"
          }
        ],
        volatile: false,
        fn: (reference) => {
          if (!reference) {
            return ArgumentError();
          }
          if (Array.isArray(reference)) {
            const column = reference[0];
            if (Array.isArray(column)) {
              return { type: 3 /* number */, value: column.length };
            }
            return ValueError();
          }
          return { type: 3 /* number */, value: 1 };
        }
      },
      /**
       * this one does not have to be here, it's just here because
       * the rest of the reference/lookup functions are here
       */
      Columns: {
        arguments: [
          {
            name: "reference",
            description: "Array or reference"
          }
        ],
        volatile: false,
        fn: (reference) => {
          if (!reference) {
            return ArgumentError();
          }
          if (Array.isArray(reference)) {
            return { type: 3 /* number */, value: reference.length };
          }
          return { type: 3 /* number */, value: 1 };
        }
      },
      /** not sure when this one appeared, but it's what I was looking for */
      FormulaText: {
        description: "Returns a formula as a string",
        arguments: [
          { name: "reference", description: "Cell reference", metadata: true }
        ],
        fn: ApplyAsArray((reference) => {
          if (!UnionIsMetadata(reference)) {
            return ReferenceError2();
          }
          const sheet = this.model.sheets.Find(reference.value?.address?.sheet_id || 0);
          if (sheet) {
            const cell = sheet.cells.GetCell(reference.value.address, false);
            return {
              type: 2 /* string */,
              value: cell?.value?.toString() || ""
            };
          }
          return ReferenceError2();
        })
      },
      /**
       * this should be in the 'information' library but it needs reference
       * to the underlying cell (unresolved)
       */
      IsFormula: {
        description: "Returns true if the reference is a formula",
        arguments: [{
          name: "Reference",
          metadata: true
          /* OK with array metadata */
        }],
        fn: ApplyAsArray((ref) => {
          const sheet = this.model.sheets.Find(ref?.value?.address?.sheet_id || 0);
          if (sheet) {
            const cell = sheet.cells.GetCell(ref.value.address, false);
            return {
              type: 4 /* boolean */,
              value: cell?.type === 1 /* formula */
            };
          }
          return {
            type: 4 /* boolean */,
            value: false
          };
        })
      }
    });
  }
  // FIXME: need a way to share/pass parser flags
  // public readonly parser: Parser = new Parser();
  /** localized parser instance. we're sharing. */
  get parser() {
    return this.model.parser;
  }
  library = new FunctionLibrary();
  registered_libraries = {};
  //  protected notifier_id_source = 100;
  //  protected notifiers: InternalNotifierType[] = [];
  // protected graph: Graph = new Graph(); // |null = null;
  // protected status: GraphStatus = GraphStatus.OK;
  /*
  // FIXME: why is this a separate class? [actually is this a composition issue?]
  protected expression_calculator = new ExpressionCalculator(
      this.library,
      this.parser);
    */
  expression_calculator;
  /** the next calculation must do a full rebuild -- set on reset */
  full_rebuild_required = false;
  /**
   * support for co-editing. we need to export calculated values from
   * the leader instance, because things like RAND() and NOW() are 
   * nondeterministic (within reason). 
   * 
   * so the leader does the calculation and then we broadcast calculated
   * values to followers.
   */
  ExportCalculatedValues() {
    const data = {};
    for (const sheet of this.model.sheets.list) {
      const calculated = sheet.cells.toJSON({ calculated_value: true }).data;
      data[sheet.id] = calculated.filter((test) => test.calculated !== void 0);
    }
    return data;
  }
  /**
   * support for co-editing. if we get calculated values from the leader,
   * we need to apply them to cells.
   * 
   * to _see_ the data, you still have to make a couple of calls to repaint
   * and update annotations. see EmbeddedSpreadsheetBase.Recalculate for hints.
   * 
   * note that we're checking for list mismatch in one direction but not the 
   * other direction. should probably check both.
   */
  ApplyCalculatedValues(data) {
    for (const sheet of this.model.sheets.list) {
      const cells = data[sheet.id];
      if (!cells) {
        console.info("mismatch", sheet.id);
      } else {
        for (const cell of cells) {
          sheet.cells.data[cell.row][cell.column].SetCalculatedValue(cell.calculated);
        }
      }
    }
  }
  /**
   * this is a mess [not as bad as it used to be]
   */
  SpreadCallback(vertex, value) {
    if (!vertex.address || !vertex.address.sheet_id) {
      throw new Error("spread callback called without sheet id");
    }
    const cells = this.model.sheets.Find(vertex.address.sheet_id)?.cells;
    if (!cells) {
      throw new Error("spread callback called without cells");
    }
    if (!vertex || !vertex.reference)
      return;
    const area = vertex.reference.area;
    if (area) {
      const rows = area.rows;
      const columns = area.columns;
      if (value.type === 8 /* array */) {
        const values = Transpose2(value.value);
        for (let row = 0; row < rows; row++) {
          if (values[row]) {
            let column = 0;
            for (; column < columns && column < values[row].length; column++) {
              cells.data[row + area.start.row][column + area.start.column].SetCalculatedValue(values[row][column].value, values[row][column].type);
            }
            for (; column < columns; column++) {
              cells.data[row + area.start.row][column + area.start.column].SetCalculatedValue(void 0, 0 /* undefined */);
            }
          } else {
            for (let column = 0; column < columns; column++) {
              cells.data[row + area.start.row][column + area.start.column].SetCalculatedValue(void 0, 0 /* undefined */);
            }
          }
        }
      } else {
        for (let row = 0; row < rows; row++) {
          for (let column = 0; column < columns; column++) {
            cells.data[row + area.start.row][column + area.start.column].SetCalculatedValue(value.value, value.type);
          }
        }
      }
    }
  }
  /**
   * FIXME: for this version, this should be synchronous; the whole thing
   * should run in a worker. should be much faster than context switching
   * every time.
   */
  CalculationCallback(vertex) {
    if (!vertex.address)
      throw new Error("vertex missing address");
    if (vertex.expression_error) {
      return {
        value: UnknownError()
      };
    }
    return this.expression_calculator.Calculate(vertex.expression, vertex.address);
  }
  /**
   * generic function, broken out from the Indirect function. checks dynamic
   * dependency for missing edges, and adds those edges.
   *
   * returns error on bad reference or circular dependency. this method
   * does not set the "short circuit" flag, callers should set as appropriate.
   */
  DynamicDependencies(expression, context, offset = false, offset_rows = 0, offset_columns = 0, resize_rows = 1, resize_columns = 1) {
    let area = this.ResolveExpressionAddress(expression, context);
    if (!area) {
      return void 0;
    }
    let dirty = false;
    let sheet;
    if (expression.type === "address" || expression.type === "range") {
      const address_expression = expression.type === "range" ? expression.start : expression;
      if (address_expression.sheet_id) {
        sheet = this.model.sheets.Find(address_expression.sheet_id);
      } else if (address_expression.sheet) {
        sheet = this.model.sheets.Find(address_expression.sheet);
      }
    }
    if (!sheet && context?.sheet_id) {
      sheet = this.model.sheets.Find(context.sheet_id);
    }
    if (!sheet) {
      throw new Error("missing sheet in dynamic dependencies [b21]");
    }
    area = sheet.RealArea(area);
    const sheet_id = area.start.sheet_id;
    if (offset) {
      area = new Area({
        column: area.start.column + offset_columns,
        row: area.start.row + offset_rows,
        sheet_id: area.start.sheet_id
      }, {
        column: area.start.column + offset_columns + resize_rows - 1,
        row: area.start.row + offset_rows + resize_columns - 1,
        sheet_id: area.end.sheet_id
      });
    }
    for (let row = area.start.row; row <= area.end.row; row++) {
      for (let column = area.start.column; column <= area.end.column; column++) {
        const vertex = this.GetVertex({ row, column, sheet_id }, false);
        if (vertex && vertex.dirty) {
          this.AddEdge({ row, column, sheet_id }, this.expression_calculator.context.address);
          dirty = true;
        }
      }
    }
    return { dirty, area };
  }
  /**
   * if locale has changed in Localization, update local resources.
   * this is necessary because (in chrome) worker doesn't get the system
   * locale properly (also, we might change it via parameter). we used to
   * just drop and reconstruct calculator, but we want to stop doing that
   * as part of supporting dynamic extension.
   */
  UpdateLocale() {
    if (Localization.decimal_separator === ",") {
      this.parser.decimal_mark = "," /* Comma */;
      this.parser.argument_separator = ";" /* Semicolon */;
    } else {
      this.parser.decimal_mark = "." /* Period */;
      this.parser.argument_separator = "," /* Comma */;
    }
  }
  /* * 
   * lookup in function library 
   * 
   * it seems like the only place this is called is within this class, 
   * so we could probably inline and drop this function
   * 
   * @deprecated
   * /
  public GetFunction(name: string): ExtendedFunctionDescriptor {
    return this.library.Get(name);
  }
  */
  /**
   * returns a list of available functions, for AC/tooltips
   * FIXME: categories?
   * FIXME: need to separate annotation functions and sheet functions
   */
  SupportedFunctions() {
    const list = this.library.List();
    const function_list = Object.keys(list).map((key) => {
      let name = list[key].canonical_name;
      if (!name)
        name = key.replace(/_/g, ".");
      return {
        name,
        description: list[key].description,
        arguments: (list[key].arguments || []).map((argument) => {
          return { name: argument.name || "" };
        })
      };
    });
    for (const macro of this.model.macro_functions.values()) {
      function_list.push({
        name: macro.name,
        description: macro.description,
        arguments: (macro.argument_names || []).map((argument) => {
          return { name: argument };
        })
      });
    }
    return function_list;
  }
  /**
   * 
   * @param name 
   * @param map 
   */
  RegisterLibrary(name, map) {
    if (this.registered_libraries[name]) {
      return false;
    }
    this.RegisterFunction(map);
    this.registered_libraries[name] = true;
    return true;
  }
  /**
   * dynamic extension
   */
  RegisterFunction(map) {
    for (const name of Object.keys(map)) {
      const descriptor = map[name];
      const original_function = descriptor.fn;
      descriptor.fn = (...args) => {
        return original_function.apply({
          address: { ...this.expression_calculator.context.address }
        }, args);
      };
      this.library.Register({ [name]: descriptor });
    }
  }
  /**
   * wrap the attachdata function so we can update the expression calculator
   * at the same time (we should unwind this a little bit, it's an artifact
   * of graph being a separate class)
   */
  AttachModel() {
    this.expression_calculator.SetModel(this.model);
  }
  /**
   * wrapper method for calculation
   */
  Calculate(subset) {
    this.AttachModel();
    if (subset && !subset.start.sheet_id) {
      throw new Error("CalculateInternal called with subset w/out sheet ID");
    }
    if (this.full_rebuild_required) {
      subset = void 0;
      this.UpdateAnnotations();
      this.UpdateConditionals();
      this.UpdateConnectedElements();
      this.full_rebuild_required = false;
    }
    this.RebuildGraph(subset);
    try {
      this.Recalculate();
    } catch (err) {
      console.error(err);
      console.info("calculation error trapped");
    }
  }
  /**
   * resets graph and graph status. this is called when structure changes --
   * such as adding or removing sheets -- so we need to preserve notifiers
   * across resets. we need to either add a flag or add a separate method
   * to handle clearing notifiers.
   */
  Reset() {
    this.FlushTree();
    this.AttachModel();
    this.full_rebuild_required = true;
  }
  /**
   * get a list of functions that require decorating with "_xlfn" on
   * export. the embed caller will pass this to the export worker.
   * since we manage functions, we can manage the list.
   * 
   * UPDATE: to support our MC functions (which may need _xll decoration),
   * map to type and then overload as necessary
   * 
   */
  DecoratedFunctionList() {
    const map = {};
    const lib = this.library.List();
    for (const key of Object.keys(lib)) {
      const def = lib[key];
      if (def.xlfn) {
        map[key] = "_xlfn";
      } else if (def.extension) {
        map[key] = "_xll";
      }
    }
    return map;
  }
  /** moved from embedded sheet */
  Evaluate(expression, active_sheet, options = {}, raw_result = false) {
    const current = this.parser.argument_separator;
    const r1c1_state = this.parser.flags.r1c1;
    if (options.argument_separator) {
      if (options.argument_separator === ",") {
        this.parser.argument_separator = "," /* Comma */;
        this.parser.decimal_mark = "." /* Period */;
      } else {
        this.parser.argument_separator = ";" /* Semicolon */;
        this.parser.decimal_mark = "," /* Comma */;
      }
    }
    if (options.r1c1) {
      this.parser.flags.r1c1 = options.r1c1;
    }
    const parse_result = this.parser.Parse(expression);
    this.parser.argument_separator = current;
    this.parser.decimal_mark = current === "," /* Comma */ ? "." /* Period */ : "," /* Comma */;
    this.parser.flags.r1c1 = r1c1_state;
    if (parse_result && parse_result.expression) {
      this.parser.Walk(parse_result.expression, (unit) => {
        if (unit.type === "address" || unit.type === "range") {
          if (unit.type === "address") {
            if (unit.offset_column || unit.offset_row) {
              throw new Error(`Evaluate does not support offset references`);
            }
          } else {
            if (unit.start.offset_column || unit.start.offset_row || unit.end.offset_column || unit.end.offset_row) {
              throw new Error(`Evaluate does not support offset references`);
            }
          }
          this.model.ResolveSheetID(unit, void 0, active_sheet);
        }
        return true;
      });
      const result = this.CalculateExpression(parse_result.expression);
      if (raw_result) {
        return result;
      }
      if (result.type === 8 /* array */) {
        return result.value.map((row) => row.map((value) => value.value));
      } else {
        return result.value;
      }
    }
    if (parse_result.error) {
      throw new Error(parse_result.error);
    }
    throw new Error("invalid expression");
  }
  /**
   * calculate an expression, optionally setting a fake cell address.
   * this may have weird side-effects.
   */
  CalculateExpression(expression, address = { row: -1, column: -1 }, preserve_flags = false) {
    return this.expression_calculator.Calculate(expression, address, preserve_flags).value;
  }
  /**
   * rebuild the graph, and set cells as clean. the vertices need internal
   * references to the calculated value, so that's set via the vertex method.
   *
   * we also need to manage the list of volatile cells, which is normally
   * built as a side-effect of calculation.
   * 
   * UPDATE: optionally recalculate if there are volatile cells. that's used
   * for loading documents.
   */
  RebuildClean(recalculate_if_volatile = false) {
    this.full_rebuild_required = false;
    this.AttachModel();
    this.RebuildGraph();
    this.UpdateAnnotations();
    this.UpdateConditionals();
    this.UpdateConnectedElements();
    this.InitializeGraph();
    if (recalculate_if_volatile && this.volatile_list.length) {
      this.Recalculate();
    }
  }
  /**
   * remove duplicates from list, dropping absolute
   */
  FlattenCellList(list) {
    const map = {};
    const flattened = [];
    for (const entry of list) {
      const address = {
        column: entry.column,
        row: entry.row,
        sheet_id: entry.sheet_id
      };
      const label = Area.CellAddressToLabel(address, true);
      if (map[label]) {
        continue;
      }
      map[label] = label;
      flattened.push(address);
    }
    return flattened;
  }
  /* * remove all notifiers * /
  public RemoveNotifiers(): void {
    for (const internal of this.notifiers) {
      if (internal.vertex) {
        internal.vertex.Reset();
        this.RemoveLeafVertex(internal.vertex);
      }
    }
    this.notifiers = [];
  }
  */
  /* * 
     * remove specified notifier. you can pass the returned ID or the original
     * object used to create it.
     * /
    public RemoveNotifier(notifier: NotifierType|number): void {
  
      let internal: InternalNotifierType|undefined;
  
      this.notifiers = this.notifiers.filter(test => {
        if (test.id === notifier || test === notifier) {
          internal = test;
          return false;
        }
        return true;
      });
  
      if (!internal) {
        // FIXME: error
        console.warn('invalid notifier');
      }
      else {
  
        // remove vertex
        if (internal.vertex) {
          internal.vertex.Reset();
          this.RemoveLeafVertex(internal.vertex);
        }
  
      }
  
    }
    */
  /* *
     * update a notifier or notifiers, or the entire list (default).
     * /
    protected UpdateNotifiers(notifiers: InternalNotifierType|InternalNotifierType[] = this.notifiers): void {
  
      if (!Array.isArray(notifiers)) {
        notifiers = [notifiers];
      }
  
      for (const notifier of notifiers) {
  
        if (notifier.vertex) {
          notifier.vertex.Reset();
        }
        else {
          notifier.vertex = new LeafVertex();
        }
  
        // construct formula (inlining)
  
        const string_reference = notifier.references.map(reference => {
  
          // I don't want to go through strings here... OTOH if we build an 
          // expression manually it's going to be fragile to changes in the
          // parser...
  
          let sheet_name = '';
          let base: ICellAddress;
          let label = '';
  
          if (reference.count === 1) {
            base = reference.start;
            label = Area.CellAddressToLabel(reference.start, false);
          }
          else {
            base = reference.start;
            label = Area.CellAddressToLabel(reference.start, false) + ':' +
                    Area.CellAddressToLabel(reference.end, false);
          }
  
          for (const sheet of this.model.sheets.list) {
            if (sheet.id === base.sheet_id) {
              sheet_name = sheet.name;
              break;
            }
          }
  
          if (!sheet_name) {
            throw new Error('invalid sheet in reference');
          }
  
          if (QuotedSheetNameRegex.test(sheet_name)) {
            return `'${sheet_name}'!${label}`;
          }
  
          return `${sheet_name}!${label}`;
  
        }).join(',');
  
        // the function (here "Notify") is never called. we're using a leaf
        // node, which bypasses the standard calculation system and only updates
        // a state reference when dirty. so here it's just an arbitrary string.
  
        // still, we should use something that's not going to be used elsewhere
        // in the future...
  
        const formula = `=Internal.Notify(${string_reference})`;
        // console.info('f', formula);
  
        // we (theoretically) guarantee that all refeerences are qualified,
        // so we don't need a context (active sheet) for relative references.
        // we can just use model[0]
  
        this.AddLeafVertex(notifier.vertex);
        this.UpdateLeafVertex(notifier.vertex, formula, this.model.sheets.list[0]);
  
        // update state (gets reset?)
  
        notifier.state = notifier.vertex.state_id;
        
      }
    }
    */
  /* *
     * new notification API (testing)
     * /
    public AddNotifier(references: RangeReference|RangeReference[], notifier: NotifierType, context: Sheet): number {
  
      if (!Array.isArray(references)) {
        references = [references];
      }
  
      // even if these are strings we want to properly resolve them so
      // we can store qualified references
     
      const qualified: Area[] = references.map(reference => {
  
        if (typeof reference === 'string') {
          return this.ResolveArea(reference, context).Clone();
        }
        if (IsCellAddress(reference)) {
          return new Area({
              ...reference, 
              sheet_id: reference.sheet_id || context.id,
            });
        }
  
        return new Area({
            ...reference.start, 
            sheet_id: reference.start.sheet_id || context.id,
          }, {
            ...reference.end, 
          });
  
      });
  
      const internal: InternalNotifierType = {
        id: this.notifier_id_source++,
        notifier,
        references: qualified,
        vertex: new LeafVertex(), 
        state: 0,
      };
  
      // update
      this.UpdateNotifiers(internal);
  
      // push to notifications
      this.notifiers.push(internal);
      
      return internal.id;
  
    }
    */
  Unresolve(ref, context, qualified = true, named = true) {
    let range = "";
    const area = IsCellAddress(ref) ? new Area(ref) : new Area(ref.start, ref.end);
    if (named) {
      const named_range = this.model.named_ranges.MatchSelection(area);
      if (named_range) {
        return named_range;
      }
    }
    if (area.count > 1) {
      range = Area.CellAddressToLabel(area.start) + ":" + Area.CellAddressToLabel(area.end);
    } else {
      range = Area.CellAddressToLabel(area.start);
    }
    if (!qualified) {
      return range;
    }
    const sheet_id = area.start.sheet_id || context?.id;
    const sheet_name = this.ResolveSheetName(sheet_id, true);
    return sheet_name ? sheet_name + "!" + range : range;
  }
  /**
   * 
   */
  ResolveSheetName(id, quote = false) {
    const sheet = this.model.sheets.Find(id);
    if (sheet) {
      if (quote && QuotedSheetNameRegex.test(sheet.name)) {
        return `'${sheet.name}'`;
      }
      return sheet.name;
    }
    return void 0;
  }
  RemoveConditional(conditional) {
    if (conditional.type === "expression") {
      const vertex = conditional.internal?.vertex;
      if (vertex) {
        vertex.Reset();
        this.RemoveLeafVertex(vertex);
      }
    }
  }
  RemoveConnectedELement(element) {
    let internal = element.internal;
    if (internal?.vertex) {
      this.RemoveLeafVertex(internal.vertex);
      return true;
    }
    return false;
  }
  UpdateConnectedElements(context) {
    if (!context) {
      context = this.model.sheets.list[0];
    }
    for (const element of this.model.connected_elements.values()) {
      let internal = element.internal;
      if (!internal) {
        internal = {
          vertex: new StateLeafVertex()
        };
        element.internal = internal;
      }
      const vertex = internal.vertex;
      this.AddLeafVertex(vertex);
      this.UpdateLeafVertex(vertex, element.formula, context);
    }
  }
  UpdateConditionals(list, context) {
    if (!list) {
      for (const sheet of this.model.sheets.list) {
        if (sheet.conditional_formats?.length) {
          this.UpdateConditionals(sheet.conditional_formats, sheet);
        }
      }
      return;
    }
    if (!context) {
      throw new Error("invalid call to update conditionals without context");
    }
    if (list && !Array.isArray(list)) {
      list = [list];
    }
    for (const entry of list) {
      let expression = "";
      switch (entry.type) {
        case "cell-match":
          expression = this.Unresolve(entry.area, context, true, false) + " " + entry.expression;
          break;
        case "expression":
          expression = entry.expression;
          break;
        case "duplicate-values":
          expression = `UniqueValues(${this.Unresolve(entry.area, context, true, false)})`;
          if (!entry.unique) {
            expression = `NOT(${expression})`;
          }
          break;
        case "gradient":
          expression = `=Gradient(${[
            this.Unresolve(entry.area, context, true, false),
            entry.min ?? "",
            entry.max ?? ""
          ].join(this.parser.argument_separator)})`;
          break;
        default:
          continue;
      }
      if (!expression) {
        continue;
      }
      if (!entry.internal) {
        entry.internal = {};
      }
      if (!entry.internal.vertex) {
        const vertex2 = new CalculationLeafVertex();
        vertex2.use = "conditional";
        entry.internal.vertex = vertex2;
        let options;
        if (entry.type !== "gradient" && entry.type !== "duplicate-values") {
          options = entry.options;
        }
        const check = this.Evaluate(expression, context, options, true);
        entry.internal.vertex.result = check;
        entry.internal.vertex.updated = true;
      }
      const vertex = entry.internal.vertex;
      this.AddLeafVertex(vertex);
      this.UpdateLeafVertex(vertex, expression, context);
    }
  }
  RemoveAnnotation(annotation) {
    const vertex = annotation.temp.vertex;
    if (!vertex) {
      return;
    }
    vertex.Reset();
    this.RemoveLeafVertex(vertex);
  }
  UpdateAnnotations(list, context) {
    if (!list) {
      for (const sheet of this.model.sheets.list) {
        this.UpdateAnnotations(sheet.annotations, sheet);
      }
      return;
    }
    if (!context) {
      throw new Error("invalid call to UpdateAnnotations with list but no sheet");
    }
    if (typeof list !== "undefined" && !Array.isArray(list)) {
      list = [list];
    }
    for (const entry of list) {
      if (entry.data.formula) {
        if (!entry.temp.vertex) {
          entry.temp.vertex = new StateLeafVertex();
        }
        const vertex = entry.temp.vertex;
        this.AddLeafVertex(vertex);
        this.UpdateLeafVertex(vertex, entry.data.formula, context);
      }
    }
  }
  // --- protected -------------------------------------------------------------
  /**
   * assuming the expression is an address, range, or named range, resolve
   * to an address/area. returns undefined if the expression can't be resolved.
   */
  ResolveExpressionAddress(expr, context) {
    switch (expr.type) {
      case "address":
        if (this.model.ResolveSheetID(expr, context)) {
          return new Area(expr);
        }
        break;
      case "range":
        if (this.model.ResolveSheetID(expr, context)) {
          return new Area(expr.start, expr.end);
        }
        break;
      case "identifier":
        {
          const named_range = this.model.named_ranges.Get(expr.name.toUpperCase());
          if (named_range) {
            return new Area(named_range.start, named_range.end);
          }
        }
        break;
    }
    return void 0;
  }
  NamedRangeToAddressUnit(unit) {
    const normalized = unit.name.toUpperCase();
    const named_range = this.model.named_ranges.Get(normalized);
    if (named_range) {
      if (named_range.count === 1) {
        return this.ConstructAddressUnit(named_range.start, normalized, unit.id, unit.position);
      } else {
        return {
          type: "range",
          start: this.ConstructAddressUnit(named_range.start, normalized, unit.id, unit.position),
          end: this.ConstructAddressUnit(named_range.end, normalized, unit.id, unit.position),
          label: normalized,
          id: unit.id,
          position: unit.position
        };
      }
    }
    return void 0;
  }
  /** named range support */
  ConstructAddressUnit(address, label, id, position) {
    return {
      type: "address",
      row: address.row,
      column: address.column,
      sheet_id: address.sheet_id,
      label,
      id,
      position
    };
  }
  /**
   * rebuild dependencies for a single expression (might be a cell, or an
   * annotation/leaf node). can recurse on elements, so the return value
   * is passed through. the first (outer) call can just leave it blank and
   * use the return value.
   *
   * we're adding the sheet name so that (in mc expression calculator) we
   * can turn address parameters into qualified labels. the normal routine
   * will just use the ID as the name, that's fine, as long as it's unique
   * (which it is).
   *
   * this might cause issues if we ever try to actually resolve from the
   * sheet name, though, so (...)
   */
  RebuildDependencies(unit, relative_sheet_id, relative_sheet_name, dependencies = { addresses: {}, ranges: {} }, context_address) {
    if (!relative_sheet_name) {
      const sheet = this.model.sheets.Find(relative_sheet_id);
      if (sheet) {
        relative_sheet_name = sheet.name;
      }
    }
    switch (unit.type) {
      case "literal":
      case "missing":
      case "operator":
        break;
      case "identifier":
        {
          const normalized = unit.name.toUpperCase();
          if (this.model.named_expressions.has(normalized)) {
            const expr = this.model.named_expressions.get(normalized);
            if (expr) {
              this.RebuildDependencies(expr, relative_sheet_id, relative_sheet_name, dependencies, context_address);
            }
          } else {
            const resolved = this.NamedRangeToAddressUnit(unit);
            if (resolved) {
              if (resolved.type === "address") {
                dependencies.addresses[resolved.label] = resolved;
              } else {
                dependencies.ranges[resolved.label] = resolved;
              }
            }
          }
        }
        break;
      case "structured-reference":
        {
          const resolved = this.model.ResolveStructuredReference(unit, context_address);
          if (resolved) {
            if (resolved.type === "address") {
              dependencies.addresses[resolved.sheet_id + "!" + resolved.label] = resolved;
            } else {
              dependencies.ranges[resolved.label] = resolved;
            }
          }
          const table = this.model.tables.get(unit.table.toLowerCase());
          if (table) {
            const row = context_address.row;
            if (row < table.area.start.row || row > table.area.end.row) {
              break;
            }
            const reference_column = unit.column.toLowerCase();
            let column = -1;
            if (table.columns) {
              for (let i = 0; i < table.columns.length; i++) {
                if (reference_column === table.columns[i]) {
                  column = table.area.start.column + i;
                  break;
                }
              }
            }
            if (column >= 0) {
              const address = {
                label: unit.label,
                type: "address",
                row,
                column,
                sheet_id: table.area.start.sheet_id,
                id: unit.id,
                position: unit.position
              };
              dependencies.addresses[address.sheet_id + "!" + address.label] = address;
            }
          }
        }
        break;
      case "address":
        if (!unit.sheet_id) {
          if (unit.sheet) {
            const sheet = this.model.sheets.Find(unit.sheet);
            if (sheet) {
              unit.sheet_id = sheet.id;
            }
          } else {
            unit.sheet_id = relative_sheet_id;
            unit.sheet = relative_sheet_name;
          }
        }
        if (!unit.sheet_id) {
          console.warn("invalid address in range [9d]");
        } else {
          dependencies.addresses[unit.sheet_id + "!" + unit.label] = unit;
        }
        break;
      case "range":
        if (!unit.start.sheet_id) {
          if (unit.start.sheet) {
            const sheet = this.model.sheets.Find(unit.start.sheet);
            if (sheet) {
              unit.start.sheet_id = sheet.id;
            }
          } else {
            unit.start.sheet_id = relative_sheet_id;
            unit.start.sheet = relative_sheet_name;
          }
        }
        if (!unit.start.sheet_id) {
          console.warn("invalid sheet in range", unit);
        } else {
          dependencies.ranges[unit.start.sheet_id + "!" + unit.start.label + ":" + unit.end.label] = unit;
        }
        break;
      case "unary":
        this.RebuildDependencies(unit.operand, relative_sheet_id, relative_sheet_name, dependencies, context_address);
        break;
      case "binary":
        this.RebuildDependencies(unit.left, relative_sheet_id, relative_sheet_name, dependencies, context_address);
        this.RebuildDependencies(unit.right, relative_sheet_id, relative_sheet_name, dependencies, context_address);
        break;
      case "group":
        unit.elements.forEach((element) => this.RebuildDependencies(element, relative_sheet_id, relative_sheet_name, dependencies, context_address));
        break;
      case "call":
        {
          const args = unit.args.slice(0);
          const func = this.library.Get(unit.name);
          if (func && func.arguments) {
            func.arguments.forEach((descriptor, index) => {
              if (descriptor && descriptor.address) {
                this.RebuildDependencies(args[index], relative_sheet_id, relative_sheet_name, void 0, context_address);
                args[index] = { type: "missing", id: -1 };
              }
            });
          }
          args.forEach((arg) => this.RebuildDependencies(arg, relative_sheet_id, relative_sheet_name, dependencies, context_address));
        }
        break;
    }
    return dependencies;
  }
  UpdateLeafVertex(vertex, formula, context) {
    vertex.Reset();
    const parse_result = this.parser.Parse(formula);
    if (parse_result.expression) {
      const dependencies = this.RebuildDependencies(
        parse_result.expression,
        // this.model.active_sheet.id,
        // this.model.active_sheet.name,
        context.id,
        context.name,
        void 0,
        { row: 0, column: 0 }
        // fake context
      );
      for (const key of Object.keys(dependencies.ranges)) {
        const unit = dependencies.ranges[key];
        const range = new Area(unit.start, unit.end);
        range.Iterate((address) => {
          this.AddLeafVertexEdge(address, vertex);
        });
      }
      for (const key of Object.keys(dependencies.addresses)) {
        const address = dependencies.addresses[key];
        this.AddLeafVertexEdge(address, vertex);
      }
    }
    vertex.expression = parse_result.expression || { type: "missing", id: -1 };
    vertex.expression_error = !parse_result.valid;
  }
  /* *
     * we're passing model here to skip the test on each call
     * 
     * @param unit 
     * @param model 
     * /
    protected ApplyMacroFunctionInternal(
        unit: ExpressionUnit, 
        model: DataModel, 
        name_stack: Array<{[index: string]: ExpressionUnit}>,
      ): ExpressionUnit { 
  
        switch (unit.type) {
  
          case 'identifier':
            if (name_stack[0]) {
              const value = name_stack[0][(unit.name || '').toUpperCase()];
              if (value) {
                return JSON.parse(JSON.stringify(value)) as ExpressionUnit;
              }
            }
            break;
  
          case 'binary':
            unit.left = this.ApplyMacroFunctionInternal(unit.left, model, name_stack);
            unit.right = this.ApplyMacroFunctionInternal(unit.right, model, name_stack);
            break;
    
          case 'unary':
            unit.operand = this.ApplyMacroFunctionInternal(unit.operand, model, name_stack);
            break;
    
          case 'group':
            unit.elements = unit.elements.map(element => this.ApplyMacroFunctionInternal(element, model, name_stack));
            break;
    
          case 'call':
            {
              // do this first, so we can pass through directly
              unit.args = unit.args.map(arg => this.ApplyMacroFunctionInternal(arg, model, name_stack));
  
              const func = this.library.Get(unit.name);
              if (!func) { 
                const macro = model.macro_functions[unit.name.toUpperCase()];
                if (macro && macro.expression) {
  
                  // clone
                  const expression = JSON.parse(JSON.stringify(macro.expression));
  
                  const bound_names: {[index: string]: ExpressionUnit} = {};
  
                  if (macro.argument_names) {
                    for (let i = 0; i < macro.argument_names.length; i++) {
                      const name = macro.argument_names[i].toUpperCase();
            
                      // temp just pass in
                      bound_names[name] = unit.args[i] ? unit.args[i] : {type: 'missing'} as UnitMissing;
                    }
                  }
  
                  // replace arguments
                  name_stack.unshift(bound_names);
                  const replacement = this.ApplyMacroFunctionInternal(expression, model, name_stack);                
                  name_stack.shift();
                  return replacement;
  
                }
              }
            }
  
            break;
  
        }
  
        return unit;
  
    }
  
    protected ApplyMacroFunctions(expression: ExpressionUnit): ExpressionUnit|undefined {
  
      if (!this.model) { return; }
  
      const count = Object.keys(this.model.macro_functions).length;
      if (!count) { return; }
  
      return this.ApplyMacroFunctionInternal(expression, this.model, []);
  
    }
    */
  /** 
   * 
   */
  RebuildGraphCell(cell, address) {
    if (cell.area && cell.area.start.column === address.column && cell.area.start.row === address.row) {
      const { start, end } = cell.area;
      const sheet_id = start.sheet_id || address.sheet_id;
      if (!start.sheet_id) {
        start.sheet_id = sheet_id;
      }
      for (let column = start.column; column <= end.column; column++) {
        for (let row = start.row; row <= end.row; row++) {
          this.ResetInbound({ column, row, sheet_id }, true, false);
        }
      }
      this.SetDirty(address);
      for (let column = start.column; column <= end.column; column++) {
        for (let row = start.row; row <= end.row; row++) {
          if (row === start.row && column === start.column) {
            continue;
          }
          this.AddEdge(start, { ...start, row, column });
        }
      }
    }
    if (cell.type === 1 /* formula */) {
      this.ResetInbound(address, true);
      const parse_result = this.parser.Parse(cell.value);
      if (parse_result.expression) {
        if (parse_result.expression.type === "call") {
          const func = this.library.Get(parse_result.expression.name);
          if (func && (func.render || func.click)) {
            cell.render_function = func.render;
            cell.click_function = func.click;
          }
        }
        const dependencies = this.RebuildDependencies(parse_result.expression, address.sheet_id, "", void 0, address);
        for (const key of Object.keys(dependencies.ranges)) {
          const unit = dependencies.ranges[key];
          const range = new Area(unit.start, unit.end);
          if (range.entire_row || range.entire_column) {
            this.AddArrayEdge(range, address);
          } else {
            range.Iterate((target) => this.AddEdge(target, address));
          }
        }
        for (const key of Object.keys(dependencies.addresses)) {
          const dependency = dependencies.addresses[key];
          this.AddEdge(dependency, address);
        }
      }
      const vertex = this.GetVertex(address, true);
      if (vertex) {
        vertex.expression = parse_result.expression || { type: "missing", id: -1 };
        vertex.expression_error = !parse_result.valid;
      }
    } else if (cell.value !== cell.calculated) {
      this.ResetInbound(address, true, false);
    } else if (cell.type === 0 /* undefined */) {
      this.ResetInbound(address, true, false, true);
    } else {
    }
  }
  /**
   * rebuild the graph; parse expressions, build a dependency map,
   * initialize edges between nodes.
   *
   * FIXME: if we want to compose functions, we could do that here,
   * which might result in some savings [?]
   */
  RebuildGraph(subset) {
    if (subset) {
      if (!subset.start.sheet_id) {
        throw new Error("subset missing sheet id");
      }
      const cells = this.model.sheets.Find(subset.start.sheet_id)?.cells;
      if (cells) {
        for (let row = subset.start.row; row <= subset.end.row; row++) {
          const row_array = cells.data[row];
          if (row_array) {
            for (let column = subset.start.column; column <= subset.end.column; column++) {
              const cell = row_array[column];
              if (cell) {
                this.RebuildGraphCell(cell, { row, column, sheet_id: subset.start.sheet_id });
              }
            }
          }
        }
      }
    } else {
      for (const sheet of this.model.sheets.list || []) {
        const rows = sheet.cells.data.length;
        for (let row = 0; row < rows; row++) {
          const row_array = sheet.cells.data[row];
          if (row_array) {
            const columns = row_array.length;
            for (let column = 0; column < columns; column++) {
              const cell = row_array[column];
              if (cell) {
                this.RebuildGraphCell(cell, { row, column, sheet_id: sheet.id });
              }
            }
          }
        }
      }
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  IsNativeOrTypedArray(val) {
    return Array.isArray(val) || val instanceof Float64Array || val instanceof Float32Array;
  }
  /**
   * check if a cell is volatile. normally this falls out of the calculation,
   * but if we build the graph and set values explicitly, we need to check.
   */
  CheckVolatile(vertex) {
    if (!vertex.expression || vertex.expression_error)
      return false;
    let volatile = false;
    this.parser.Walk(vertex.expression, (unit) => {
      if (unit.type === "call") {
        const func = this.library.Get(unit.name);
        if (func && func.volatile)
          volatile = true;
      }
      return !volatile;
    });
    return volatile;
  }
};

// treb-embed/src/progress-dialog.ts
var Dialog = class {
  // private model: NodeModel;
  model = {};
  layout_element;
  // tslint:disable-next-line:variable-name
  visible_ = false;
  timeout = 0;
  pending_dialog_resoltion = [];
  options_ = {
    type: "initial" /* initial */
  };
  set options(options) {
    if (options.type === "about" /* about */) {
      options.close_box = true;
      options.icon = true;
    }
    if (this.options_.icon !== options.icon) {
      this.model.left.style.display = options.icon ? "block" : "none";
    }
    if (this.options_.close_box !== options.close_box) {
      this.model.close.style.display = options.close_box ? "block" : "none";
    }
    if (this.options_.message !== options.message) {
      this.model.message.textContent = options.message || "";
      this.model.message.style.display = options.message ? "block" : "none";
    }
    if (this.options_.title !== options.title) {
      this.model.title.textContent = options.title || "";
      this.model.title.style.display = options.title ? "block" : "none";
    }
    if (this.options_.type !== options.type) {
      let classes = this.model.dialog.className.replace(/dialog-type-\S+/g, "").trim();
      if (options.type) {
        classes += ` dialog-type-${options.type}`;
      }
      this.model.dialog.className = classes;
      if (options.type === "about") {
        this.model.about.style.display = "block";
      } else {
        this.model.about.style.display = "none";
      }
    }
    this.options_ = options;
  }
  event_handler = (event) => {
    if (event.key === "Escape" || event.key === "Esc") {
      event.stopPropagation();
      event.preventDefault();
      this.visible = false;
    }
  };
  get visible() {
    return this.visible_;
  }
  set visible(value) {
    if (value === this.visible_) {
      return;
    }
    this.visible_ = value;
    if (value) {
      this.layout_element?.setAttribute("dialog", "");
      window.addEventListener("keydown", this.event_handler);
    } else {
      this.layout_element?.removeAttribute("dialog");
      window.removeEventListener("keydown", this.event_handler);
      const tmp = this.pending_dialog_resoltion.slice(0);
      this.pending_dialog_resoltion = [];
      Promise.resolve().then(() => {
        for (const func of tmp) {
          func();
        }
      });
    }
  }
  constructor(parent_node) {
    this.layout_element = parent_node.parentElement;
    const root = this.layout_element?.querySelector(".treb-dialog-mask");
    if (root) {
      const elements = root.querySelectorAll("[data-bind]");
      for (const element of Array.from(elements)) {
        const bind = element.dataset.bind;
        if (bind) {
          this.model[bind] = element;
        }
      }
    }
    if (this.model.about) {
      const html = [`<div>TREB version ${"28.10.4"}`];
      if (true) {
        html.push(`<small>(development build)</small>`);
      }
      html.push(`<small><a target=_blank href='https://treb.app'>http://treb.app</a></small>`);
      this.model.about.innerHTML = html.join("\n");
    }
    this.model.close?.addEventListener("click", (event) => {
      event.stopPropagation();
      event.preventDefault();
      this.HideDialog();
    });
  }
  Update(options, delta = true) {
    if (delta) {
      options = { ...this.options_, ...options };
    }
    this.options = options;
  }
  HideDialog() {
    this.visible = false;
  }
  ShowDialog(options) {
    return new Promise((resolve) => {
      this.pending_dialog_resoltion.push(resolve);
      this.options = options;
      this.visible = true;
      if (this.timeout) {
        window.clearTimeout(this.timeout);
        this.timeout = 0;
      }
      if (options.timeout) {
        this.timeout = window.setTimeout(() => this.HideDialog(), options.timeout);
      }
    });
  }
};

// treb-embed/src/spinner.ts
var Spinner = class {
  constructor(container) {
    this.container = container;
    const DOM = DOMContext.GetInstance(container.ownerDocument);
    this.node = DOM.Div("treb-spinner", container, {
      html: `<div><div></div><div></div><div></div><div></div></div>`
    });
  }
  node;
  visible = false;
  Show() {
    this.node.classList.add("visible");
  }
  Hide() {
    this.node.classList.remove("visible");
  }
};

// treb-embed/src/options.ts
var DefaultOptions = {
  formula_bar: true,
  in_cell_editor: true,
  undo: true,
  scrollbars: true,
  headers: true,
  export: true,
  tab_bar: "auto",
  resizable: true,
  hyperlinks: "_blank",
  max_file_size: 1024 * 92,
  // popout: false,
  // imaginary_value: 'i',
  tint_theme_colors: true,
  // I don't think false options need to be in default?
  // although it's nice to have a clear reference about defaults...
  dnd: false,
  add_tab: false,
  expand_formula_button: false,
  // delete_tab: false,
  // changing default value for expand -> false, it might be
  // useful to disable it but the common expectation is that 
  // spreadsheets can grow.
  expand: true,
  markdown: false,
  spinner: false,
  complex: "off"
};

// treb-charts/src/util.ts
var Util = class {
  /**
   * given a passed range, find the best scale range. count is just a
   * suggestion -- we try to get as close as possible.
   */
  static Scale(min, max, count = 6.5, limit_count, discrete) {
    return Scale(min, max, count, limit_count, discrete);
  }
  static Range(data) {
    let min;
    let max;
    for (const value of data) {
      if (typeof value === "undefined") {
        continue;
      }
      if (typeof min === "undefined" || min > value) {
        min = value;
      }
      if (typeof max === "undefined" || max < value) {
        max = value;
      }
    }
    const range = typeof min === "undefined" || typeof max === "undefined" ? 0 : max - min;
    return { min, max, range };
  }
  static ApplyScale(value, range, scale) {
    return range * (value - scale.min) / (scale.max - scale.min);
  }
  /**
   * flatten. we support holes in data, which means undefined values
   * in arrays, but don't push an empty value at the top level (if
   * that makes sense).
   *
   * @param args
   */
  static Flatten(args) {
    let flat = [];
    if (Array.isArray(args)) {
      for (const element of args) {
        if (Array.isArray(element)) {
          flat = flat.concat(this.Flatten(element));
        } else {
          flat.push(element);
        }
      }
    } else if (typeof args !== "undefined") {
      flat.push(args);
    }
    return flat;
  }
};

// treb-charts/src/chart-utils.ts
var DEFAULT_FORMAT = "#,##0.00";
var ReadSeries = (data) => {
  const series = {
    x: { data: [] },
    y: { data: [] }
  };
  if (data[4] && typeof data[4] === "number") {
    series.index = data[4];
  }
  if (data[5]) {
    series.subtype = data[5].toString();
  }
  if (data[0]) {
    const flat = Util.Flatten(data[0]);
    if (typeof flat[0] === "object") {
      series.label = flat[0]?.value?.toString() || "";
    } else {
      series.label = flat[0].toString();
    }
  }
  for (let i = 1; i < 4; i++) {
    if (data[i] && typeof data[i] === "object" && data[i].key === "metadata") {
      data[i] = {
        type: 8 /* array */,
        value: [data[i]]
      };
    }
  }
  if (!!data[2] && typeof data[2] === "object" && data[2].type === 8 /* array */) {
    const flat = Util.Flatten(data[2].value);
    series.y.data = flat.map((item) => typeof item.value.value === "number" ? item.value.value : void 0);
    if (flat[0].value?.format) {
      series.y.format = flat[0].value?.format;
      const format = NumberFormatCache.Get(series.y.format);
      series.y.labels = series.y.data.map((value) => value === void 0 ? void 0 : format.Format(value));
    }
  }
  if (!!data[1] && typeof data[1] === "object" && data[1].type === 8 /* array */) {
    const flat = Util.Flatten(data[1].value);
    series.x.data = flat.map((item) => typeof item.value.value === "number" ? item.value.value : void 0);
    if (flat[0].value.format) {
      series.x.format = flat[0].value.format;
    }
  }
  const entries = [series.x, series.y];
  if (!!data[3] && typeof data[3] === "object" && data[3].type === 8 /* array */) {
    const flat = Util.Flatten(data[3].value);
    series.z = { data: [] };
    series.z.data = flat.map((item) => typeof item.value.value === "number" ? item.value.value : void 0);
    if (flat[0].value.format) {
      series.z.format = flat[0].value.format;
    }
  }
  for (const subseries of entries) {
    if (subseries.data.length) {
      const values = subseries.data.filter((value) => value || value === 0);
      subseries.range = {
        min: Math.min.apply(0, values),
        max: Math.max.apply(0, values)
      };
    }
  }
  return series;
};
var ArrayToSeries = (array_data) => {
  const series = { x: { data: [] }, y: { data: [] } };
  const flat = Util.Flatten(array_data.value);
  series.y.data = flat.map((item, index) => {
    if (typeof item.value === "number") {
      return item.value;
    }
    if (typeof item.value.value?.real === "number") {
      series.x.data[index] = item.value.value.real;
      return item.value.value.imaginary;
    }
    return typeof item.value.value === "number" ? item.value.value : void 0;
  });
  if (flat[0].value.format) {
    series.y.format = flat[0].value.format || "";
    const format = NumberFormatCache.Get(series.y.format || "");
    series.y.labels = series.y.data.map((value) => value === void 0 ? void 0 : format.Format(value));
  }
  const values = series.y.data.filter((value) => value || value === 0);
  series.y.range = {
    min: Math.min.apply(0, values),
    max: Math.max.apply(0, values)
  };
  if (series.x.data.length) {
    const filtered = series.x.data.filter((test) => typeof test === "number");
    series.x.range = {
      min: Math.min.apply(0, filtered),
      max: Math.max.apply(0, filtered)
    };
    if (flat[0].value.format) {
      series.x.format = flat[0].value.format || "";
      const format = NumberFormatCache.Get(series.x.format || "");
      series.x.labels = series.x.data.map((value) => value === void 0 ? void 0 : format.Format(value));
    }
  }
  return series;
};
var TransformSeriesData = (raw_data, default_x) => {
  if (!raw_data) {
    return [];
  }
  const list = [];
  if (raw_data.type === 5 /* object */) {
    if (raw_data.key === "group") {
      if (Array.isArray(raw_data.value)) {
        for (const [series_index, entry] of raw_data.value.entries()) {
          if (!!entry && typeof entry === "object") {
            if (entry.key === "series") {
              const series = ReadSeries(entry.value);
              if (typeof series.index === "undefined") {
                series.index = series_index + 1;
              }
              list.push(series);
            } else if (entry.type === 8 /* array */) {
              list.push(ArrayToSeries(entry));
            }
          }
        }
      }
    } else if (raw_data.key === "series") {
      const series = ReadSeries(raw_data.value);
      list.push(series);
    }
  } else if (raw_data.type === 8 /* array */) {
    list.push(ArrayToSeries(raw_data));
  }
  let baseline_x;
  let max_y_length = 0;
  if (default_x?.type === 8 /* array */) {
    const values = Util.Flatten(default_x.value);
    let format = "0.00###";
    if (values[0] && values[0].type === 5 /* object */) {
      format = values[0].value.format;
    }
    const data = values.map((x) => {
      if (x.type === 3 /* number */) {
        return x.value;
      }
      if (x.type === 5 /* object */) {
        return x.value.value;
      }
      return void 0;
    });
    const filtered = data.filter((x) => typeof x === "number");
    baseline_x = {
      data,
      format,
      range: {
        min: Math.min.apply(0, filtered),
        max: Math.max.apply(0, filtered)
      }
    };
  }
  for (const entry of list) {
    max_y_length = Math.max(max_y_length, entry.y.data.length);
    if (entry.x.data.length) {
      if (!baseline_x) {
        baseline_x = entry.x;
      }
    }
  }
  if (!baseline_x) {
    baseline_x = {
      data: [],
      range: {
        min: 0,
        max: Math.max(0, max_y_length - 1)
      }
    };
    for (let i = 0; i < max_y_length; i++) {
      baseline_x.data.push(i);
    }
  }
  for (const entry of list) {
    if (!entry.x.data.length) {
      entry.x = baseline_x;
    }
  }
  return list;
};
var CommonData = (series, y_floor, y_ceiling) => {
  let x_format = "";
  let y_format = "";
  for (const entry of series) {
    if (entry.y.format && !y_format) {
      y_format = entry.y.format;
    }
    if (entry.x.format && !x_format) {
      x_format = entry.x.format;
    }
  }
  let legend;
  if (series.some((test) => test.label && test.label.length > 0)) {
    legend = series.map((entry, i) => ({
      label: entry.label || `Series ${i + 1}`,
      index: typeof entry.index === "number" ? entry.index : i + 1
    }));
  }
  const x = series.filter((test) => test.x.range);
  let x_min = Math.min.apply(0, x.map((test) => test.x.range?.min || 0));
  let x_max = Math.max.apply(0, x.map((test) => test.x.range?.max || 0));
  const y = series.filter((test) => test.y.range);
  let y_min = Math.min.apply(0, x.map((test) => test.y.range?.min || 0));
  let y_max = Math.max.apply(0, x.map((test) => test.y.range?.max || 0));
  for (const subseries of series) {
    if (subseries.z) {
      for (const [index, z] of subseries.z.data.entries()) {
        if (typeof z !== "undefined") {
          const x2 = subseries.x.data[index];
          const half = Math.max(0, z / 2);
          if (typeof x2 !== "undefined") {
            x_min = Math.min(x_min, x2 - half);
            x_max = Math.max(x_max, x2 + half);
          }
          const y2 = subseries.y.data[index];
          if (typeof y2 !== "undefined") {
            y_min = Math.min(y_min, y2 - half);
            y_max = Math.max(y_max, y2 + half);
          }
        }
      }
    }
  }
  if (typeof y_floor !== "undefined") {
    y_min = Math.min(y_min, y_floor);
  }
  if (typeof y_ceiling !== "undefined") {
    y_max = Math.max(y_max, y_ceiling);
  }
  const x_scale = Util.Scale(x_min, x_max, 7);
  const y_scale = Util.Scale(y_min, y_max, 7);
  let x_labels;
  let y_labels;
  if (x_format) {
    x_labels = [];
    const format = NumberFormatCache.Get(x_format);
    for (let i = 0; i <= x_scale.count; i++) {
      x_labels.push(format.Format(x_scale.min + i * x_scale.step));
    }
  }
  if (y_format) {
    y_labels = [];
    const format = NumberFormatCache.Get(y_format);
    for (let i = 0; i <= y_scale.count; i++) {
      y_labels.push(format.Format(y_scale.min + i * y_scale.step));
    }
  }
  return {
    x: {
      format: x_format,
      scale: x_scale,
      labels: x_labels
    },
    y: {
      format: y_format,
      scale: y_scale,
      labels: y_labels
    },
    legend
  };
};
var ApplyLabels = (series_list, pattern, category_labels) => {
  for (const series of series_list) {
    const format = {
      x: NumberFormatCache.Get(series.x.format || ""),
      y: NumberFormatCache.Get(series.y.format || "")
    };
    series.y.labels = [];
    for (let i = 0; i < series.y.data.length; i++) {
      const x = category_labels ? category_labels[i] : typeof series.x.data[i] === "number" ? format.x.Format(series.x.data[i]) : "";
      const y = typeof series.y.data[i] === "number" ? format.y.Format(series.y.data[i]) : "";
      series.y.labels[i] = pattern.replace(/\bx\b/g, x).replace(/\by\b/g, y);
    }
  }
};
var CreateBubbleChart = (args) => {
  const series = TransformSeriesData(args[0]);
  const common = CommonData(series);
  const title = args[1]?.toString() || void 0;
  const options = args[2]?.toString() || void 0;
  const chart_data = {
    legend: common.legend,
    type: "bubble",
    series,
    title,
    x_scale: common.x.scale,
    x_labels: common.x.labels,
    y_scale: common.y.scale,
    y_labels: common.y.labels
  };
  return chart_data;
};
var CreateScatterChart = (args, style = "plot") => {
  const series = TransformSeriesData(args[0]);
  const common = CommonData(series);
  const title = args[1]?.toString() || void 0;
  const options = args[2]?.toString() || void 0;
  const chart_data = {
    legend: common.legend,
    style,
    type: "scatter2",
    series,
    // : [{x, y}],
    title,
    x_scale: common.x.scale,
    x_labels: common.x.labels,
    y_scale: common.y.scale,
    y_labels: common.y.labels,
    lines: style === "line",
    // true,
    points: style === "plot"
  };
  if (options) {
    chart_data.markers = /marker/i.test(options);
    chart_data.smooth = /smooth/i.test(options);
    chart_data.data_labels = /labels/i.test(options);
    let match = options.match(/labels="(.*?)"/);
    if (match && chart_data.series) {
      ApplyLabels(chart_data.series, match[1]);
    } else {
      match = options.match(/labels=([^\s\r\n,]+)(?:\W|$)/);
      if (match && chart_data.series) {
        ApplyLabels(chart_data.series, match[1]);
      }
    }
    match = options.match(/class=([\w_-]+)(?:\W|$)/);
    if (match) {
      chart_data.class_name = match[1];
    }
  }
  return chart_data;
};
var CreateColumnChart = (args, type) => {
  const series = TransformSeriesData(args[0]);
  const common = CommonData(series);
  let category_labels;
  if (args[1]) {
    const values = args[1].type === 8 /* array */ ? Util.Flatten(args[1].value) : Util.Flatten(args[1]);
    category_labels = values.map((cell) => {
      if (!cell) {
        return "";
      }
      if (cell.type === 5 /* object */ && cell.value.type === "metadata") {
        if (typeof cell.value.value === "number") {
          const format = NumberFormatCache.Get(cell.value.format || DEFAULT_FORMAT);
          return format.Format(cell.value.value);
        }
        return cell.value.value;
      }
      if (typeof cell.value === "number") {
        const format = NumberFormatCache.Get(cell.format || DEFAULT_FORMAT);
        return format.Format(cell.value);
      }
      return cell.value;
    });
    const count = series.reduce((a, entry) => Math.max(a, entry.y.data.length), 0);
    if (count < category_labels.length) {
      category_labels = category_labels.slice(0, count);
    }
    while (count > category_labels.length) {
      category_labels.push("");
    }
  }
  const title = args[2]?.toString() || void 0;
  const options = args[3]?.toString() || void 0;
  const chart_data = {
    type,
    legend: common.legend,
    // legend_position: LegendPosition.right,
    legend_style: 1 /* marker */,
    series2: series,
    scale: common.y.scale,
    title,
    y_labels: type === "bar" ? category_labels : common.y.labels,
    // swapped
    x_labels: type === "bar" ? common.y.labels : category_labels
    // swapped
  };
  if (options) {
    chart_data.round = /round/i.test(options);
    chart_data.data_labels = /labels/i.test(options);
    let match = options.match(/labels="(.*?)"/);
    if (match && series) {
      ApplyLabels(series, match[1], category_labels);
    } else {
      match = options.match(/labels=([^\s\r\n,]+)(?:\W|$)/);
      if (match && series) {
        ApplyLabels(series, match[1], category_labels);
      }
    }
    match = options.match(/class=([\w_-]+)(?:\W|$)/);
    if (match) {
      chart_data.class_name = match[1];
    }
  }
  return chart_data;
};
var CreateLineChart = (args, type) => {
  const series = TransformSeriesData(args[0], args[1]);
  const common = CommonData(series, 0, 0);
  const title = args[2]?.toString() || void 0;
  const options = args[3]?.toString() || void 0;
  const chart_data = {
    legend: common.legend,
    // style: type, // 'line',
    type: "scatter2",
    series,
    // : [{x, y}],
    title,
    x_scale: common.x.scale,
    x_labels: common.x.labels,
    y_scale: common.y.scale,
    y_labels: common.y.labels,
    lines: true,
    filled: type === "area"
  };
  if (options) {
    chart_data.smooth = /smooth/i.test(options);
    const match = options.match(/class=([\w_-]+)(?:\W|$)/);
    if (match) {
      chart_data.class_name = match[1];
    }
  }
  return chart_data;
};
var CreateDonut = (args, pie_chart = false) => {
  const raw_data = args[0]?.type === 8 /* array */ ? args[0].value : args[0];
  const flat = Util.Flatten(raw_data);
  let data = flat.map((x) => typeof x.value.value === "number" ? x.value.value : void 0);
  const raw_labels = args[1]?.type === 8 /* array */ ? args[1].value : args[1];
  const labels = Util.Flatten(raw_labels).map((label) => {
    if (label && typeof label === "object") {
      const value = label.value?.value;
      if (typeof value === "number" && label.value?.format) {
        return NumberFormatCache.Get(label.value?.format).Format(value);
      } else
        return value ? value.toString() : "";
    } else
      return label ? label.toString() : "";
  });
  data = data.map((check) => {
    if (check < 0) {
      console.warn("pie/donut chart does not support negative values (omitted)");
      return 0;
    }
    return check;
  });
  const title = args[2] || "";
  let sum = 0;
  const slices = data.map((value, i) => {
    if (typeof value !== "undefined")
      sum += value;
    return { value, label: labels[i] || "", index: i + 1, percent: 0 };
  });
  if (sum) {
    for (const slice of slices) {
      slice.percent = (slice.value || 0) / sum;
    }
  }
  const format_pattern = flat.length && flat[0].value?.format ? flat[0].value.format : "";
  const format = NumberFormatCache.Get(format_pattern || DEFAULT_FORMAT);
  const percent_format = NumberFormatCache.Get("percent");
  if (typeof args[4] === "undefined" && args[1]) {
    args[4] = "label";
  }
  const slice_title = args[4] || "";
  if (slice_title) {
    for (const slice of slices) {
      const value = (
        /*NumberFormatCache.Get('general')*/
        format.Format(slice.value || 0)
      );
      const percent = percent_format.Format(slice.percent);
      slice.title = slice_title.replace(/value%/ig, percent_format.Format(slice.value || 0)).replace(/value/ig, value).replace(/percent/ig, percent).replace(/label/ig, slice.label || "").trim();
    }
  }
  const options = (args[3] || "").toString().trim();
  let sort = options.toUpperCase();
  if (sort === "ASC" || sort === "ASCENDING" || sort === "INC") {
    slices.sort((a, b) => {
      return (a.value || 0) - (b.value || 0);
    });
  } else if (sort === "DESC" || sort === "DESCENDING" || sort === "DEC") {
    slices.sort((a, b) => {
      return (b.value || 0) - (a.value || 0);
    });
  } else {
    const match = options.match(/sort=([\w]+)(?:\W|$)/i);
    if (match) {
      sort = match[1];
      if (/^(asc|inc)/i.test(sort)) {
        slices.sort((a, b) => {
          return (a.value || 0) - (b.value || 0);
        });
      } else if (/^(desc|dec)/i.test(sort)) {
        slices.sort((a, b) => {
          return (b.value || 0) - (a.value || 0);
        });
      }
    }
  }
  const chart_data = {
    type: pie_chart ? "pie" : "donut",
    slices,
    title
  };
  if (options) {
    const match = options.match(/class=([_-\w]+)(?:\W|$)/);
    if (match) {
      chart_data.class_name = match[1];
    }
  }
  return chart_data;
};

// treb-charts/src/rectangle.ts
var Area2 = class {
  constructor(left = 0, top = 0, right = 100, bottom = 100) {
    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
  }
  get width() {
    return this.right - this.left;
  }
  get height() {
    return this.bottom - this.top;
  }
  get center() {
    return {
      x: this.left + this.width / 2,
      y: this.top + this.height / 2
    };
  }
};

// treb-charts/src/renderer.ts
var SVGNS2 = "http://www.w3.org/2000/svg";
var SVGNode = (tag, attribute_map = {}, text) => {
  const node = document.createElementNS(SVGNS2, tag);
  for (const key of Object.keys(attribute_map)) {
    if (attribute_map[key] !== void 0) {
      const value = attribute_map[key];
      node.setAttribute(key, Array.isArray(value) ? value.join(" ") : value.toString());
    }
  }
  if (text) {
    node.textContent = text;
  }
  return node;
};
var ChartRenderer = class {
  parent;
  svg_node;
  text_measurement_node;
  container_group;
  group;
  axis_group;
  label_group;
  size = { width: 0, height: 0 };
  bounds = new Area2();
  // public smoothing_factor = 0.2;
  constructor() {
    this.container_group = SVGNode("g");
    this.group = SVGNode("g");
    this.axis_group = SVGNode("g", { class: "axis-group" });
    this.label_group = SVGNode("g", { class: "label-group" });
    this.container_group.appendChild(this.axis_group);
    this.container_group.appendChild(this.group);
    this.container_group.appendChild(this.label_group);
  }
  Initialize(node) {
    this.parent = node;
    this.svg_node = SVGNode("svg", {
      class: "treb-chart"
      // style: 'overflow: hidden; position: relative; width: 100%; height: 100%;'
    });
    this.svg_node.style.overflow = "hidden";
    this.svg_node.style.position = "relative";
    this.svg_node.style.width = "100%";
    this.svg_node.style.height = "100%";
    this.svg_node.appendChild(this.container_group);
    this.parent.appendChild(this.svg_node);
    this.Resize();
  }
  Legend(options) {
    const group = SVGNode("g");
    this.group.appendChild(group);
    const measure = SVGNode("text");
    group.appendChild(measure);
    group.setAttribute("class", "legend");
    const rows = [[]];
    const padding = 10;
    let space = options.area.width;
    let row = 0;
    let max_height = 0;
    const width = options.area.width;
    const marker_width = options.style === 1 /* marker */ ? 14 : 26;
    const metrics = options.labels.map((label, index) => {
      measure.textContent = label.label;
      const text_rect = measure.getBoundingClientRect();
      const text_metrics = { width: text_rect.width, height: text_rect.height };
      const composite = text_metrics.width + marker_width + padding;
      max_height = Math.max(max_height, text_metrics.height);
      if (options.layout === 1 /* vertical */) {
        rows[index] = [index];
      } else {
        if (composite > space) {
          if (rows[row].length === 0) {
            rows[row].push(index);
            row++;
            rows[row] = [];
            space = width;
          } else {
            row++;
            rows[row] = [index];
            space = width - composite;
          }
        } else {
          rows[row].push(index);
          space -= composite;
        }
      }
      return text_metrics;
    });
    group.removeChild(measure);
    let y = max_height;
    let layout = options.layout || 0 /* horizontal */;
    if (layout === 0 /* horizontal */ && rows.every((row2) => row2.length <= 1)) {
      layout = 0 /* horizontal */;
    }
    for (let row2 = 0; row2 < rows.length; row2++) {
      const row_width = rows[row2].reduce((a, x2) => a + metrics[x2].width + marker_width, (rows[row2].length - 1) * padding);
      let h = 0;
      let x = layout === 0 /* horizontal */ ? Math.round((width - row_width) / 2) : Math.round(padding / 2);
      for (let col = 0; col < rows[row2].length; col++) {
        const index = rows[row2][col];
        const text_metrrics = metrics[index];
        const label = options.labels[index];
        const marker_y = y - 1;
        let trident = false;
        if (typeof navigator !== "undefined") {
          trident = /trident/i.test(navigator?.userAgent || "");
        }
        const color = typeof label.index === "number" ? label.index : index + 1;
        group.appendChild(SVGNode("text", {
          "dominant-baseline": "middle",
          x: x + marker_width,
          y,
          dy: trident ? ".3em" : void 0
        }, label.label));
        if (options.style === 1 /* marker */) {
          group.appendChild(SVGNode("rect", {
            class: `series-${color}`,
            x,
            y: marker_y - 4,
            width: 8,
            height: 8
          }));
        } else {
          group.appendChild(SVGNode("rect", {
            class: `series-${color}`,
            x,
            y: marker_y - 1,
            width: marker_width - 3,
            height: 2
          }));
        }
        h = Math.max(h, text_metrrics.height);
        x += text_metrrics.width + marker_width + padding;
      }
      y = Math.round(y + h * 1.1);
    }
    const rect = group.getBoundingClientRect();
    const legend_size = { width: rect.width, height: rect.height + max_height };
    switch (options.position) {
      case 1 /* bottom */:
        group.setAttribute("transform", `translate(${options.area.left}, ${options.area.bottom - legend_size.height})`);
        break;
      case 2 /* left */:
        group.setAttribute("transform", `translate(${options.area.left}, ${options.area.top})`);
        break;
      case 3 /* right */:
        group.setAttribute("transform", `translate(${options.area.right - legend_size.width}, ${options.area.top})`);
        break;
      case 0 /* top */:
      default:
        group.setAttribute("transform", `translate(${options.area.left}, ${options.area.top})`);
    }
    if (options.position === 0 /* top */) {
      options.area.top += legend_size.height || 0;
    } else if (options.position === 3 /* right */) {
      options.area.right -= (legend_size.width || 0) + 8;
    } else if (options.position === 2 /* left */) {
      options.area.left += (legend_size.width || 0) + 8;
    } else {
      options.area.bottom -= legend_size.height || 0;
    }
  }
  Clear(class_name) {
    this.group.textContent = "";
    this.axis_group.textContent = "";
    this.label_group.textContent = "";
    class_name = "treb-chart" + (class_name ? " " + class_name : "");
    this.svg_node.setAttribute("class", class_name);
  }
  Resize() {
    const bounds = this.parent.getBoundingClientRect();
    this.svg_node.setAttribute("width", bounds.width.toString());
    this.svg_node.setAttribute("height", bounds.height.toString());
    this.size = {
      width: bounds.width,
      height: bounds.height
    };
  }
  /**
   * initialize before render. this assumes that document layout/scroll
   * won't change during the render pass, so we can cache some values.
   */
  Prerender() {
    const bounds = this.svg_node.getBoundingClientRect();
    this.bounds.top = bounds.top;
    this.bounds.left = bounds.left;
    this.bounds.right = bounds.right;
    this.bounds.bottom = bounds.bottom;
  }
  /**
   * render title. this method modifies "area" in place -- that's 
   * the style we want to use going forward.
   * 
   * @param title 
   * @param area 
   * @param margin 
   * @param layout 
   */
  RenderTitle(title, area, margin, layout) {
    const text = SVGNode("text", {
      class: "chart-title",
      x: Math.round(area.width / 2)
      // style: 'text-anchor: middle',
    }, title);
    text.style.textAnchor = "middle";
    this.group.appendChild(text);
    const bounds = text.getBoundingClientRect();
    switch (layout) {
      case "bottom":
        text.setAttribute("y", Math.round(area.bottom - bounds.height).toString());
        area.bottom -= bounds.height + margin;
        break;
      default:
        text.setAttribute("y", Math.round(area.top + margin + bounds.height).toString());
        area.top += bounds.height + margin;
        break;
    }
  }
  /**
   * measure a label, optionally with class name(s)
   * 
   * this is silly. you are doing the measurement on a random node and
   * trying to match classes, while you could just do the measurement on
   * the actual node, get actual classes right, and not bother with junk
   * nodes.
   * 
   * FIXME: decprecate
   * 
   */
  MeasureText(label, classes, ceil = false) {
    if (!this.text_measurement_node) {
      this.text_measurement_node = SVGNode("text", { x: "-100px", y: "-100px" });
      this.svg_node.appendChild(this.text_measurement_node);
    }
    if (typeof classes !== "undefined") {
      if (typeof classes === "string") {
        classes = [classes];
      }
      this.text_measurement_node.setAttribute("class", classes.join(" "));
    } else {
      this.text_measurement_node.setAttribute("class", "");
    }
    this.text_measurement_node.textContent = label;
    const bounds = this.text_measurement_node.getBoundingClientRect();
    const metrics = {
      width: bounds.width,
      height: bounds.height,
      // wtf is this?
      y_offset: bounds.height - (this.bounds.top - bounds.top - 100)
    };
    if (ceil) {
      metrics.width = Math.ceil(metrics.width);
      metrics.height = Math.ceil(metrics.height);
      metrics.y_offset = Math.ceil(metrics.y_offset);
    }
    return metrics;
  }
  RenderTicks(area, top, bottom, count, classes) {
    const d = [];
    const step = area.width / count;
    for (let i = 0; i < count; i++) {
      const center = Math.round(area.left + step / 2 + step * i) - 0.5;
      d.push(`M${center} ${top} L${center} ${bottom}`);
    }
    this.group.appendChild(SVGNode("path", { d, class: classes }));
  }
  /*
  public GetAxisNode(): SVGElement {
    if (!this.axis_group) { 
      this.axis_group = SVGNode('g', {class: 'axis-group'});
      this.group.appendChild(this.axis_group);
    }
    return this.axis_group; 
  }
  */
  /** specialization for bar; it's different enough that we want special treatment */
  RenderXAxisBar(area, offset, labels, metrics, classes) {
    const count = labels.length;
    if (!count)
      return;
    const label_buffer = 4;
    const step = offset ? area.width / count : area.width / (count - 1);
    const initial_offset = offset ? step / 2 : 0;
    let increment = 1;
    let repeat = true;
    while (repeat) {
      repeat = false;
      let extent = 0;
      for (let i = 0; i < count; i += increment) {
        const center = Math.round(area.left + initial_offset + step * i);
        const left = center - metrics[i].width / 2;
        if (extent && left <= extent) {
          increment++;
          repeat = true;
          break;
        }
        extent = center + metrics[i].width / 2 + label_buffer;
      }
    }
    for (let i = 0; i < count; i += increment) {
      const x = Math.round(area.left + initial_offset + step * i);
      this.RenderText(this.axis_group, labels[i], "center", { x, y: area.bottom }, classes);
    }
  }
  RenderXAxisTicks(area, offset, count) {
    const step = offset ? area.width / count : area.width / (count - 1);
    const initial_offset = offset ? step / 2 : 0;
    const d = [];
    for (let i = 0; i < count; i++) {
      const center = Math.round(area.left + initial_offset + step * i) + 0.5;
      d.push(`M${center},${area.bottom + 0.5} v${6}`);
    }
    this.axis_group.appendChild(SVGNode("path", { d: d.join(" "), class: "x-axis-tick axis-tick" }));
  }
  /**
   * render x axis labels; skips over labels to prevent overlap
   * 
   * @param offset - move label by 1/2 step width, to center it under columns.
   */
  RenderXAxis(area, offset, labels, metrics, classes) {
    const count = labels.length;
    if (!count)
      return;
    const label_buffer = 4;
    const step = offset ? area.width / count : area.width / (count - 1);
    const initial_offset = offset ? step / 2 : 0;
    let increment = 1;
    let repeat = true;
    const f2 = (labels.length - 1) % 2 === 0;
    const f3 = (labels.length - 1) % 3 === 0;
    while (repeat) {
      repeat = false;
      let extent = 0;
      for (let i = 0; i < count; i += increment) {
        const center = Math.round(area.left + initial_offset + step * i);
        const left = center - metrics[i].width / 2;
        if (extent && left <= extent) {
          increment++;
          repeat = true;
          break;
        }
        extent = center + metrics[i].width / 2 + label_buffer;
      }
    }
    if (increment === 3 && !f3 && f2) {
      increment++;
    }
    for (let i = 0; i < count; i += increment) {
      const x = Math.round(area.left + initial_offset + step * i);
      this.RenderText(this.axis_group, labels[i], "center", { x, y: area.bottom }, classes);
    }
  }
  /** specialization for bar; it's different enough that we want special treatment */
  RenderYAxisBar(area, left, labels, classes) {
    labels = labels.slice(0);
    labels.reverse();
    const count = labels.length;
    if (!count)
      return;
    const step = area.height / count;
    let increment = 1;
    let repeat = true;
    while (repeat) {
      repeat = false;
      let extent = 0;
      for (let i = 0; i < count; i += increment) {
        const label = labels[i];
        const y = Math.round(area.bottom - step * (i + 0.5) + label.metrics.height / 4);
        if (extent && y >= extent) {
          increment++;
          repeat = true;
          break;
        }
        extent = y - label.metrics.height;
      }
    }
    for (let i = 0; i < count; i += increment) {
      const label = labels[i];
      const y = Math.round(area.bottom - step * (i + 0.5) + label.metrics.height / 4);
      this.RenderText(this.axis_group, label.label, "right", { x: left, y }, classes);
    }
  }
  /**
   * render y axis labels; skips over labels to prevent overlap
   */
  RenderYAxis(area, left, labels, classes) {
    const count = labels.length;
    if (!count)
      return;
    const step = area.height / (count - 1);
    let increment = 1;
    let repeat = true;
    while (repeat) {
      repeat = false;
      let extent = 0;
      for (let i = 0; i < count; i += increment) {
        const label = labels[i];
        const y = Math.round(area.bottom - step * i + label.metrics.height / 4);
        if (extent && y >= extent) {
          increment++;
          repeat = true;
          break;
        }
        extent = y - label.metrics.height;
      }
    }
    for (let i = 0; i < count; i += increment) {
      const label = labels[i];
      const y = Math.round(area.bottom - step * i + label.metrics.height / 4);
      this.RenderText(this.axis_group, label.label, "right", { x: left, y }, classes);
    }
  }
  /*
    public ControlPoint(current: Point, previous?: Point, next?: Point, reverse = false): Point {
  
      previous = previous || current;
      next = next || current;
  
      const o = this.LineProperties(previous, next);
      const factor = Math.pow(1 - Math.abs(o.angle) / Math.PI, 2) * this.smoothing_factor;
  
      const angle = o.angle + (reverse ? Math.PI : 0);
      const length = o.length * factor;
  
      const x = current.x + Math.cos(angle) * length;
      const y = current.y + Math.sin(angle) * length;
  
      return { x, y };
  
    }
    */
  LineProperties(a, b) {
    const x = b.x - a.x;
    const y = b.y - a.y;
    return {
      length: Math.sqrt(x * x + y * y),
      angle: Math.atan2(y, x)
    };
  }
  RenderSmoothLine(area, data, fill = false, titles, classes) {
    const group = SVGNode("g");
    const d1 = [];
    const d2 = [];
    const count = data.length;
    const steps = count - 1;
    const step = area.width / count / 2;
    const circles = [];
    const points = data.map((value, i) => {
      if (typeof value === "undefined") {
        return void 0;
      }
      return {
        x: Math.round(area.left + area.width / steps * i),
        y: area.bottom - value
      };
    });
    let segment = [];
    const render_segment = () => {
      if (segment.length < 2) {
        return;
      }
      let line = "";
      const first = segment[0];
      const last = segment[segment.length - 1];
      if (segment.length === 2) {
        line = `${segment[0].x},${segment[0].y} L${segment[1].x},${segment[1].y}`;
      } else if (segment.length > 2) {
        const curve = this.CatmullRomChain(segment);
        line = "" + curve.map((point) => `${point.x},${point.y}`).join(" L");
      }
      if (line) {
        d1.push("M" + line);
        if (fill) {
          d2.push(`M ${first.x},${area.bottom} L ${first.x},${first.y}`);
          d2.push("L" + line);
          d2.push(`L ${last.x},${area.bottom}`);
        }
      }
    };
    for (const point of points) {
      if (!point) {
        render_segment();
        segment = [];
      } else {
        segment.push(point);
      }
    }
    if (segment.length) {
      render_segment();
    }
    if (fill) {
      group.appendChild(SVGNode("path", { class: "fill", d: d2 }));
    }
    group.appendChild(SVGNode("path", { class: "line", d: d1 }));
    if (typeof classes !== "undefined") {
      if (typeof classes === "string") {
        classes = [classes];
      }
      group.setAttribute("class", classes.join(" "));
    }
    this.group.appendChild(group);
    if (titles && circles.length) {
      const circle_group = SVGNode("g");
      for (const circle of circles) {
        const shape = SVGNode("circle", { cx: circle.x, cy: circle.y, r: step });
        shape.addEventListener("mouseenter", (event) => {
          this.parent.setAttribute("title", titles[circle.i] || "");
        });
        shape.addEventListener("mouseleave", (event) => {
          this.parent.setAttribute("title", "");
        });
        circle_group.appendChild(shape);
      }
      circle_group.setAttribute("class", "mouse-layer");
      this.group.appendChild(circle_group);
    }
  }
  RenderLine(area, data, fill = false, titles, classes) {
    const group = SVGNode("g");
    const d1 = [];
    const d2 = [];
    const count = data.length;
    const steps = count - 1;
    const step = area.width / count / 2;
    const circles = [];
    let i = 0;
    let move = true;
    let last_x;
    for (; i < count; i++) {
      const point = data[i];
      if (typeof point === "undefined") {
        move = true;
        if (fill && typeof last_x !== "undefined") {
          d2.push(`L${last_x} ${area.bottom}Z`);
        }
        last_x = void 0;
        continue;
      }
      const x = Math.round(
        /*step*/
        +area.left + area.width / steps * i
      );
      if (move) {
        if (fill) {
          d2.push(`M${x} ${area.bottom} L${x} ${area.bottom - point}`);
        }
        d1.push(`M${x} ${area.bottom - point}`);
      } else {
        d1.push(`L${x} ${area.bottom - point}`);
        d2.push(`L${x} ${area.bottom - point}`);
      }
      circles.push({ x, y: area.bottom - point, i });
      last_x = x;
      move = false;
    }
    if (fill && typeof last_x !== "undefined") {
      d2.push(`L${last_x} ${area.bottom}Z`);
    }
    if (fill) {
      group.appendChild(SVGNode("path", { class: "fill", d: d2 }));
    }
    group.appendChild(SVGNode("path", { class: "line", d: d1 }));
    if (typeof classes !== "undefined") {
      if (typeof classes === "string") {
        classes = [classes];
      }
      group.setAttribute("class", classes.join(" "));
    }
    this.group.appendChild(group);
    if (titles && circles.length) {
      const circle_group = SVGNode("g");
      for (const circle of circles) {
        const shape = SVGNode("circle", { cx: circle.x, cy: circle.y, r: step });
        shape.addEventListener("mouseenter", (event) => {
          this.parent.setAttribute("title", titles[circle.i] || "");
        });
        shape.addEventListener("mouseleave", (event) => {
          this.parent.setAttribute("title", "");
        });
        circle_group.appendChild(shape);
      }
      circle_group.setAttribute("class", "mouse-layer");
      this.group.appendChild(circle_group);
    }
  }
  /**
   * the other RenderGrid function has semantics specifically for area/line.
   * rather than try to shoehorn this in we'll use a different method.
   */
  RenderBarGrid(area, x_count, classes) {
    const d = [];
    const step = area.width / x_count;
    for (let i = 0; i <= x_count; i++) {
      const x = Math.round(area.left + step * i) - 0.5;
      d.push(`M${x} ${area.top} L${x} ${area.bottom}`);
    }
    this.group.appendChild(SVGNode("path", { d, class: classes }));
  }
  RenderGrid(area, y_count, x_count = 0, classes) {
    const d = [];
    let step = area.height / y_count;
    for (let i = 0; i <= y_count; i++) {
      const y = Math.round(area.top + step * i) - 0.5;
      d.push(`M${area.left} ${y} L${area.right} ${y}`);
    }
    step = area.width / (x_count - 1);
    for (let i = 0; i < x_count; i++) {
      const x = Math.round(area.left + step * i) - 0.5;
      d.push(`M${x} ${area.top} L${x} ${area.bottom}`);
    }
    this.group.appendChild(SVGNode("path", { d, class: classes }));
  }
  /* *
     * return the intersection point of two lines (assuming 
     * infinite projection) or undefined if they are parallel
     * /
    public LineIntersection(a1: Point, a2: Point, b1: Point, b2: Point): Point|undefined {
  
      const det = ((a1.x - a2.x) * (b1.y - b2.y) - (a1.y - a2.y) * (b1.x - b2.x));
  
      if (!det) {
        return undefined; // parallel
      }
  
      const t = ((a1.x - b1.x) * (b1.y - b2.y) - (a1.y - b1.y) * (b1.x - b2.x)) / det;
  
      return { x: a1.x + t * (a2.x - a1.x), y: a1.y + t * (a2.y - a1.y) };
  
    }
    */
  MultiplyPoint(point, scalar) {
    return {
      x: point.x * scalar,
      y: point.y * scalar
    };
  }
  AddPoints(a, b) {
    return {
      x: a.x + b.x,
      y: a.y + b.y
    };
  }
  /**
   * algo from
   * https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
   */
  CatmullRomSpline(P, n) {
    let alpha = 0.5;
    alpha = alpha / 2;
    const tj = (ti, Pi, Pj) => {
      const { x: xi, y: yi } = Pi;
      const { x: xj, y: yj } = Pj;
      return ((xj - xi) ** 2 + (yj - yi) ** 2) ** alpha + ti;
    };
    const t0 = 0;
    const t1 = tj(t0, P[0], P[1]);
    const t2 = tj(t1, P[1], P[2]);
    const t3 = tj(t2, P[2], P[3]);
    const step = (t2 - t1) / n;
    const points = [];
    for (let i = 0; i < n; i++) {
      const t = t1 + step * i;
      const A1 = this.AddPoints(
        this.MultiplyPoint(P[0], (t1 - t) / (t1 - t0)),
        this.MultiplyPoint(P[1], (t - t0) / (t1 - t0))
      );
      const A2 = this.AddPoints(
        this.MultiplyPoint(P[1], (t2 - t) / (t2 - t1)),
        this.MultiplyPoint(P[2], (t - t1) / (t2 - t1))
      );
      const A3 = this.AddPoints(
        this.MultiplyPoint(P[2], (t3 - t) / (t3 - t2)),
        this.MultiplyPoint(P[3], (t - t2) / (t3 - t2))
      );
      const B1 = this.AddPoints(
        this.MultiplyPoint(A1, (t2 - t) / (t2 - t0)),
        this.MultiplyPoint(A2, (t - t0) / (t2 - t0))
      );
      const B2 = this.AddPoints(
        this.MultiplyPoint(A2, (t3 - t) / (t3 - t1)),
        this.MultiplyPoint(A3, (t - t1) / (t3 - t1))
      );
      const C = this.AddPoints(
        this.MultiplyPoint(B1, (t2 - t) / (t2 - t1)),
        this.MultiplyPoint(B2, (t - t1) / (t2 - t1))
      );
      points.push(C);
    }
    return points;
  }
  /**
   * NOTE: we are munging the point list here, so don't use it after
   * calling this function or pass in a temp copy
   * 
   * OK so that was rude, we will not munge the list
   */
  CatmullRomChain(original, n = 30) {
    const points = original.slice(0);
    const result = [];
    const len = points.length;
    if (len) {
      let dx = points[len - 1].x - points[len - 2].x;
      let dy = points[len - 1].y - points[len - 2].y;
      points.push({
        x: points[len - 1].x + dx,
        y: points[len - 1].y + dy
      });
      points.push({
        x: points[len - 1].x + dx,
        y: points[len - 1].y + dy
      });
      dx = points[1].x - points[0].x;
      dy = points[1].y - points[0].y;
      points.unshift({
        x: points[0].x - dx,
        y: points[0].y - dy
      });
      for (let i = 0; i < points.length - 4; i++) {
        const subset = points.slice(i, i + 4);
        const step = this.CatmullRomSpline(subset, n);
        result.push(...step);
      }
    }
    return result;
  }
  RenderDataLabels(area, x, y, x_scale, y_scale, data_labels, series_index) {
    const count = Math.max(x.length, y.length);
    const xrange = x_scale.max - x_scale.min || 1;
    const yrange = y_scale.max - y_scale.min || 1;
    for (let i = 0; i < count; i++) {
      const a = x[i];
      const b = y[i];
      if (a !== void 0 && b !== void 0) {
        const point = {
          x: area.left + (a - x_scale.min) / xrange * area.width,
          y: area.bottom - (b - y_scale.min) / yrange * area.height
        };
        const label = data_labels[i];
        if (label) {
          this.label_group.appendChild(SVGNode("circle", { class: "label-target", cx: point.x, cy: point.y, r: 10 }));
          const g = SVGNode("g", { class: "data-label", transform: `translate(${point.x + 10},${point.y})` });
          this.label_group.appendChild(g);
          const circle = SVGNode("circle", {
            cx: -10,
            y: 0,
            r: 5,
            class: `marker-highlight series-${series_index}`
          });
          g.appendChild(circle);
          const text = SVGNode("text", { x: 4, y: 0 }, label);
          g.appendChild(text);
          const bounds = text.getBoundingClientRect();
          const h = bounds.height;
          const w = bounds.width + 8;
          if (w + 15 + point.x >= area.right) {
            g.setAttribute("transform", `translate(${point.x - w - 15},${point.y})`);
            circle.setAttribute("cx", (w + 15).toString());
          }
          const rect = SVGNode("path", { d: `M0,5 h${w} v-${h} h-${w} Z` });
          g.insertBefore(rect, text);
        }
      }
    }
  }
  RenderBubbleSeries(area, series, x_scale, y_scale, classes) {
    const xrange = x_scale.max - x_scale.min || 1;
    const yrange = y_scale.max - y_scale.min || 1;
    const points = [];
    const d = [];
    const areas = [];
    const group = SVGNode("g", { class: classes });
    this.group.appendChild(group);
    if (series.z) {
      for (const [index, z] of series.z.data.entries()) {
        const x = series.x.data[index];
        const y = series.y.data[index];
        if (typeof x !== "undefined" && typeof y !== "undefined" && typeof z !== "undefined" && z > 0) {
          const size_x = z / xrange * area.width;
          const size_y = z / yrange * area.height;
          const size = Math.max(size_x, size_y);
          points.push({
            x: area.left + (x - x_scale.min) / xrange * area.width,
            y: area.bottom - (y - y_scale.min) / yrange * area.height,
            z: size
          });
        }
      }
    }
    {
      for (const point of points) {
        if (point) {
          group.appendChild(SVGNode("circle", { cx: point.x, cy: point.y, r: point.z / 2, class: `point` }));
        }
      }
    }
  }
  RenderScatterSeries(area, x, y, x_scale, y_scale, lines = true, plot_points = false, filled = false, markers = false, smooth = false, classes) {
    const count = Math.max(x.length, y.length);
    const xrange = x_scale.max - x_scale.min || 1;
    const yrange = y_scale.max - y_scale.min || 1;
    const points = [];
    const d = [];
    const areas = [];
    const group = SVGNode("g", { class: classes });
    this.group.appendChild(group);
    for (let i = 0; i < count; i++) {
      const a = x[i];
      const b = y[i];
      if (typeof a === "undefined" || typeof b === "undefined") {
        points.push(void 0);
      } else {
        points.push({
          x: area.left + (a - x_scale.min) / xrange * area.width,
          y: area.bottom - (b - y_scale.min) / yrange * area.height
        });
      }
    }
    if (lines) {
      let segment = [];
      const render_segment = smooth ? () => {
        if (segment.length === 2) {
          return `${segment[0].x},${segment[0].y} L${segment[1].x},${segment[1].y}`;
        } else if (segment.length > 2) {
          const curve = this.CatmullRomChain(segment);
          return curve.map((point) => `${point.x},${point.y}`).join(" L");
        }
        return "";
      } : () => {
        return segment.map((point) => `${point.x},${point.y}`).join(" L");
      };
      for (const point of points) {
        if (!point) {
          if (segment.length >= 2) {
            const line = render_segment();
            d.push("M" + line);
            areas.push(`M${segment[0].x},${area.bottom}L` + line + `L${segment[segment.length - 1].x},${area.bottom}Z`);
          }
          segment = [];
        } else {
          segment.push(point);
        }
      }
      if (segment.length >= 2) {
        const line = render_segment();
        d.push("M" + line);
        areas.push(`M${segment[0].x},${area.bottom}L` + line + `L${segment[segment.length - 1].x},${area.bottom}Z`);
      }
    }
    if (filled) {
      group.appendChild(SVGNode("path", { d: areas, class: "fill" }));
    }
    if (lines) {
      group.appendChild(SVGNode("path", { d, class: "line" }));
    }
    if (plot_points) {
      for (const point of points) {
        if (point) {
          group.appendChild(SVGNode("circle", { cx: point.x, cy: point.y, r: 1, class: "point" }));
        }
      }
    }
    if (markers) {
      for (const point of points) {
        if (point) {
          group.appendChild(SVGNode("circle", { cx: point.x, cy: point.y, r: 3, class: "marker" }));
        }
      }
    }
  }
  RenderPoints(area, x, y, classes) {
    const d = [];
    for (let i = 0; i < x.length; i++) {
      const px = x[i] * area.width + area.left;
      const py = area.bottom - y[i] * area.height;
      d.push(`M${px - 1},${py - 1} L${px + 1},${py + 1}`);
      d.push(`M${px - 1},${py + 1} L${px + 1},${py - 1}`);
    }
    this.group.appendChild(SVGNode("path", { d, class: classes }));
  }
  RenderPoint(cx, cy, classes) {
    this.group.appendChild(SVGNode("circle", { cx, cy, r: 1, class: classes }));
  }
  RenderCalloutLines(lines) {
    const g = SVGNode("g", { class: "callouts" });
    this.label_group.appendChild(g);
    for (const line of lines) {
      g.appendChild(SVGNode("path", {
        d: `M${line.x1},${line.y1} L${line.x2},${line.y2}`,
        class: "callout " + (line.classes || "").trim()
      }));
    }
  }
  RenderRectangle(area, corner_radius, classes, title, label, label_point) {
    let d = "";
    if (corner_radius) {
      if (corner_radius[0] && corner_radius[0] === corner_radius[1] && corner_radius[0] >= area.height) {
        const c = corner_radius[0];
        const b = corner_radius[0] - area.height;
        const a = Math.sqrt(c * c - b * b);
        d = `M${area.left + area.width / 2 - a},${area.bottom} a${c},${c} 0 0 1 ${a * 2},0 z`;
      } else if (corner_radius[1] && corner_radius[1] === corner_radius[2] && corner_radius[1] >= area.width) {
        const c = corner_radius[1];
        const b = corner_radius[1] - area.width;
        const a = Math.sqrt(c * c - b * b);
        d = `M${area.left},${area.top + area.height / 2 - a} a${c},${c} 0 0 1 0,${a * 2} z`;
      } else {
        d = `M${area.left},${area.top + corner_radius[0]} a${corner_radius[0]},${corner_radius[0]} 0 0 1 ${corner_radius[0]},${-corner_radius[0]} h${area.width - corner_radius[0] - corner_radius[1]} a${corner_radius[1]},${corner_radius[1]} 0 0 1 ${corner_radius[1]},${corner_radius[1]} v${area.height - corner_radius[1] - corner_radius[2]} a${corner_radius[2]},${corner_radius[2]} 0 0 1 ${-corner_radius[2]},${corner_radius[2]} h${-area.width + corner_radius[2] + corner_radius[3]} a${corner_radius[3]},${corner_radius[3]} 0 0 1 ${-corner_radius[3]},${-corner_radius[3]} v${-area.height + corner_radius[3] + corner_radius[0]} `;
      }
    } else {
      d = `M${area.left},${area.top} h${area.width} v${area.height} h${-area.width} v${-area.height} `;
    }
    const node = SVGNode("path", {
      d,
      class: classes
    });
    if (title) {
      node.addEventListener("mouseenter", (event) => {
        this.parent.setAttribute("title", title);
      });
      node.addEventListener("mouseleave", (event) => {
        this.parent.setAttribute("title", "");
      });
    }
    this.group.appendChild(node);
    if (label) {
      this.label_group.appendChild(SVGNode("path", { class: "label-target", d }));
      const point = label_point || {
        x: Math.round(area.left + area.width / 2),
        y: Math.round(area.top - 10)
      };
      const g = SVGNode("g", { class: "data-label", transform: `translate(${point.x},${point.y})` });
      this.label_group.appendChild(g);
      const text = SVGNode("text", { x: 0, y: 0 }, label);
      g.appendChild(text);
      const bounds = text.getBoundingClientRect();
      const h = bounds.height;
      const w = bounds.width + 8;
      if (point.y - bounds.height < 4) {
        point.y -= point.y - bounds.height - 4;
        g.setAttribute("transform", `translate(${point.x},${point.y})`);
      }
      text.setAttribute("x", Math.floor(-bounds.width / 2).toString());
      const vertical_padding = Math.ceil(h * 0.125);
      const rect = SVGNode("rect", { rx: 3, x: -w / 2, y: Math.round(-h + vertical_padding * 2 / 3), width: w, height: h + vertical_padding });
      g.insertBefore(rect, text);
    }
  }
  /**
   * render text at point
   */
  RenderText(target, text, align, point, classes) {
    const node = SVGNode("text", { x: point.x, y: point.y, class: classes }, text);
    switch (align) {
      case "right":
        node.style.textAnchor = "end";
        break;
      case "center":
        node.style.textAnchor = "middle";
        break;
      default:
        node.style.textAnchor = "start";
        break;
    }
    (target || this.group).appendChild(node);
  }
  /**
   * render a donut, given a list of slices (as %)
   * @param values
   */
  RenderDonut(slices, center, outer_radius, inner_radius, bounds_area, callouts, classes) {
    let start_angle = -Math.PI / 2;
    let end_angle = 0;
    if (callouts) {
      outer_radius *= 0.8;
      inner_radius *= 0.7;
    }
    const PointOnCircle = (center2, radius, angle) => {
      return [
        Math.cos(angle) * radius + center2.x,
        Math.sin(angle) * radius + center2.y
      ];
    };
    for (const slice of slices) {
      const title = slice.title || "";
      const value = slice.percent;
      const index = slice.index;
      let d = [];
      let half_angle = 0;
      const outer = PointOnCircle.bind(0, center, outer_radius);
      const inner = PointOnCircle.bind(0, center, inner_radius);
      if (value > 0.5) {
        half_angle = start_angle + value / 2 * Math.PI * 2;
        end_angle = start_angle + value * Math.PI * 2;
        const delta1 = half_angle - start_angle;
        const delta2 = end_angle - half_angle;
        d.push(
          `M${outer(start_angle)}`,
          `A${outer_radius},${outer_radius},${delta1},0,1,${outer(half_angle)}`,
          `A${outer_radius},${outer_radius},${delta2},0,1,${outer(end_angle)}`,
          `L${inner(end_angle)}`,
          `A${inner_radius},${inner_radius},${delta2},0,0,${inner(half_angle)}`,
          `A${inner_radius},${inner_radius},${delta1},0,0,${inner(start_angle)}`,
          "Z"
        );
      } else {
        end_angle = start_angle + value * Math.PI * 2;
        half_angle = (end_angle - start_angle) / 2 + start_angle;
        const delta = end_angle - start_angle;
        d.push(
          `M${outer(start_angle)}`,
          `A${outer_radius},${outer_radius},${delta},0,1,${outer(end_angle)}`,
          `L${inner(end_angle)}`,
          `A${inner_radius},${inner_radius},${delta},0,0,${inner(start_angle)}`,
          "Z"
        );
      }
      const node = SVGNode("path", {
        d,
        class: typeof index === "undefined" ? void 0 : `series-${index}`
      });
      if (typeof index !== "undefined") {
        node.setAttribute("data-index", index.toString());
      }
      const donut = SVGNode("g", { class: classes });
      donut.appendChild(node);
      this.group.appendChild(donut);
      if (
        /*callouts &&*/
        value >= 0.05 && title
      ) {
        const length = outer_radius - inner_radius;
        d = [];
        const anchor = PointOnCircle(
          center,
          inner_radius + (outer_radius - inner_radius) / 2 + length,
          half_angle
        );
        d.push(`M${PointOnCircle(center, inner_radius + (outer_radius - inner_radius) / 2, half_angle)}`);
        d.push(`L${anchor}`);
        donut.appendChild(SVGNode("path", { d, class: "callout" }));
        const text_parts = [];
        const callout_label = SVGNode("text", { class: "callout-label" });
        donut.appendChild(callout_label);
        const corrected = half_angle + Math.PI / 2;
        const text = title;
        callout_label.textContent = text;
        let bounds = callout_label.getBoundingClientRect();
        const metrics = {
          width: bounds.width,
          height: bounds.height
        };
        let [x, y] = anchor;
        x += metrics.height / 2 * Math.cos(half_angle);
        y += metrics.height / 4 + metrics.height / 2 * Math.sin(half_angle);
        let try_break = false;
        if (corrected > Math.PI) {
          if (x - metrics.width <= bounds_area.left) {
            try_break = true;
          }
        } else {
          if (x + metrics.width > bounds_area.right) {
            try_break = true;
          }
        }
        const break_regex = /[\s-]/;
        if (try_break && break_regex.test(text)) {
          let break_index = -1;
          let break_value = 1;
          const indices = [];
          for (let i = 0; i < text.length; i++) {
            if (break_regex.test(text[i])) {
              const index_value = Math.abs(0.5 - i / text.length);
              if (index_value < break_value) {
                break_value = index_value;
                break_index = i;
              }
            }
          }
          if (break_index > 0) {
            text_parts.push(text.substr(0, break_index + 1).trim());
            text_parts.push(text.substr(break_index + 1).trim());
          }
        } else {
        }
        if (text_parts.length) {
          let dy = 0;
          let widest = 0;
          const parts = text_parts.map((part) => {
            callout_label.textContent = part;
            bounds = callout_label.getBoundingClientRect();
            const m = {
              width: bounds.width,
              height: bounds.height
            };
            widest = Math.max(widest, m.width);
            return { text: part, metrics: m };
          });
          callout_label.textContent = "";
          for (const part of parts) {
            const tspan = SVGNode("tspan");
            tspan.textContent = part.text;
            const part_x = corrected > Math.PI ? x - (widest - part.metrics.width) / 2 : x + (widest - part.metrics.width) / 2;
            tspan.setAttribute("x", part_x.toString());
            tspan.setAttribute("dy", dy.toString());
            callout_label.appendChild(tspan);
            dy = part.metrics.height;
          }
        } else {
        }
        const text_anchor = corrected > Math.PI ? "end" : "start";
        callout_label.setAttribute("text-anchor", text_anchor);
        callout_label.setAttribute("x", x.toString());
        callout_label.setAttribute("y", y.toString());
        if (typeof index !== "undefined") {
          callout_label.setAttribute("data-index", index.toString());
        }
      }
      start_angle = end_angle;
    }
  }
  /*
  protected PointOnCircle(angle: number, center: Point, radius: number) {
    return [
      Math.cos(angle) * radius + center.x,
      Math.sin(angle) * radius + center.y,
    ];
  }
  */
};

// treb-charts/src/default-chart-renderer.ts
var DefaultChartRenderer = class {
  renderer = new ChartRenderer();
  // not chart-specific, so leave outside (FIXME: layout options?)
  // FIXME: change depending on whether there are y-axis labels
  // FIXME: different for donut charts...
  margin = { top: 0.025, left: 0.05, bottom: 0.025, right: 0.075 };
  Resize(target, data) {
    this.renderer.Resize();
  }
  Initialize(target) {
    this.renderer.Initialize(target);
  }
  /**
   * redraw
   */
  Update(target, chart_data) {
    this.renderer.Resize();
    this.renderer.Prerender();
    this.renderer.Clear(chart_data.class_name);
    const area = new Area2(0, 0, this.renderer.size.width, this.renderer.size.height);
    const chart_margin = {
      top: Math.round(area.height) * this.margin.top,
      bottom: Math.round(area.height) * this.margin.bottom,
      left: Math.round(area.width) * this.margin.left,
      right: Math.round(area.width) * this.margin.right
    };
    const title = chart_data.title;
    if (title) {
      this.renderer.RenderTitle(
        title,
        area,
        chart_margin.top,
        chart_data.title_layout || "top"
      );
    }
    area.top += chart_margin.top;
    area.left += chart_margin.left;
    area.bottom -= chart_margin.bottom;
    area.right -= chart_margin.right;
    if (chart_data.legend && chart_data.legend.length) {
      let default_position = 0 /* top */;
      if (chart_data.title) {
        if (!chart_data.title_layout || chart_data.title_layout === "top") {
          default_position = 1 /* bottom */;
        }
      }
      const position = chart_data.legend_position || default_position;
      this.renderer.Legend({
        labels: chart_data.legend,
        position,
        style: chart_data.legend_style,
        layout: position === 0 /* top */ || position === 1 /* bottom */ ? 0 /* horizontal */ : 1 /* vertical */,
        area
      });
    }
    if (chart_data.type === "histogram" || chart_data.type === "line" || chart_data.type === "area" || chart_data.type === "column" || chart_data.type === "histogram2" || chart_data.type === "bar" || chart_data.type === "scatter2" || chart_data.type === "bubble") {
      let x_metrics = [];
      let max_x_height = 0;
      if (chart_data.x_labels && chart_data.x_labels.length) {
        x_metrics = chart_data.x_labels.map((text) => {
          const metrics = this.renderer.MeasureText(text, ["axis-label", "x-axis-label"], true);
          max_x_height = Math.max(max_x_height, metrics.height);
          return metrics;
        });
      }
      if (chart_data.y_labels && chart_data.y_labels.length) {
        const y_labels = [];
        let max_width = 0;
        let max_height = 0;
        const scale = chart_data.type === "scatter2" || chart_data.type === "bubble" ? chart_data.y_scale : chart_data.scale;
        const count = chart_data.type === "bar" ? chart_data.y_labels.length : (
          /* chart_data. */
          scale.count + 1
        );
        for (let i = 0; i < count; i++) {
          const metrics = this.renderer.MeasureText(chart_data.y_labels[i], ["axis-label", "y-axis-label"]);
          y_labels.push({ label: chart_data.y_labels[i], metrics });
          max_width = Math.max(max_width, metrics.width);
          max_height = Math.max(max_height, metrics.height);
        }
        area.bottom = Math.round(area.bottom - max_height / 2);
        area.top = Math.round(area.top + max_height / 2);
        if (x_metrics.length) {
          area.bottom -= max_x_height + chart_margin.bottom;
        }
        if (chart_data.type === "bar") {
          this.renderer.RenderYAxisBar(area, area.left + max_width, y_labels, ["axis-label", "y-axis-label"]);
        } else {
          this.renderer.RenderYAxis(area, area.left + max_width, y_labels, ["axis-label", "y-axis-label"]);
        }
        area.left += max_width + chart_margin.left;
      }
      if (x_metrics.length && chart_data.x_labels && chart_data.x_labels.length) {
        const tick = chart_data.type === "histogram2";
        const offset_tick = chart_data.type !== "line" && chart_data.type !== "area" && chart_data.type !== "bar" && chart_data.type !== "scatter2" && chart_data.type !== "bubble" && chart_data.type !== "histogram2";
        if (tick) {
          this.renderer.RenderXAxisTicks(area, offset_tick, chart_data.x_labels.length);
        }
        if (chart_data.y_labels) {
          area.bottom += max_x_height + chart_margin.bottom;
        }
        this.renderer.RenderXAxis(
          area,
          offset_tick,
          chart_data.x_labels,
          x_metrics,
          ["axis-label", "x-axis-label"]
        );
        area.bottom -= max_x_height + chart_margin.bottom;
      }
    }
    switch (chart_data.type) {
      case "scatter":
        this.renderer.RenderPoints(area, chart_data.x, chart_data.y, "mc mc-correlation series-1");
        break;
      case "bubble":
        this.renderer.RenderGrid(
          area,
          chart_data.y_scale.count,
          chart_data.x_scale.count + 1,
          // (sigh)
          "chart-grid"
        );
        for (const [index, series] of chart_data.series.entries()) {
          const series_index = typeof series.index === "number" ? series.index : index + 1;
          this.renderer.RenderBubbleSeries(area, series, chart_data.x_scale, chart_data.y_scale, `bubble-chart series-${series_index}`);
        }
        break;
      case "scatter2":
        this.renderer.RenderGrid(
          area,
          chart_data.y_scale.count,
          chart_data.x_scale.count + 1,
          // (sigh)
          "chart-grid"
        );
        if (chart_data.series) {
          for (let i = 0; i < chart_data.series.length; i++) {
            const series = chart_data.series[i];
            let lines = !!chart_data.lines;
            let points = !!chart_data.points;
            if (series.subtype === "plot") {
              points = true;
              lines = false;
            } else if (series.subtype === "line") {
              points = false;
              lines = true;
            }
            const index = typeof series.index === "number" ? series.index : i + 1;
            this.renderer.RenderScatterSeries(
              area,
              series.x.data,
              series.y.data,
              chart_data.x_scale,
              chart_data.y_scale,
              lines,
              points,
              !!chart_data.filled,
              !!chart_data.markers,
              !!chart_data.smooth,
              `scatter-plot series-${index}`
            );
          }
          if (chart_data.data_labels) {
            for (let i = 0; i < chart_data.series.length; i++) {
              const series = chart_data.series[i];
              if (series.y.labels) {
                this.renderer.RenderDataLabels(
                  area,
                  series.x.data,
                  series.y.data,
                  chart_data.x_scale,
                  chart_data.y_scale,
                  series.y.labels,
                  i + 1
                );
              }
            }
          }
        }
        break;
      case "pie":
      case "donut":
        {
          const outer = Math.min(area.height, area.width) / 2 * 0.9;
          const inner = chart_data.type === "pie" ? 0 : outer * 0.8;
          this.renderer.RenderDonut(
            chart_data.slices,
            area.center,
            outer,
            inner,
            area,
            true,
            "donut"
          );
        }
        break;
      case "line":
      case "area":
        {
          const scale = chart_data.scale;
          if (chart_data.series) {
            const points = chart_data.x_scale ? chart_data.x_scale.max : Math.max.apply(0, chart_data.series.map((x) => x.length));
            const func = chart_data.smooth ? this.renderer.RenderSmoothLine : this.renderer.RenderLine;
            this.renderer.RenderGrid(
              area,
              chart_data.scale.count,
              chart_data.x_scale ? chart_data.x_scale.count + 1 : points,
              "chart-grid"
            );
            let series_index = 0;
            for (const series of chart_data.series) {
              const y = series.map((point) => {
                if (typeof point === "undefined") {
                  return void 0;
                }
                return Util.ApplyScale(point, area.height, scale);
              });
              if (y.length < points) {
                for (let i = y.length; i < points; i++) {
                  y.push(void 0);
                }
              }
              const styles = [
                chart_data.type === "area" ? "chart-area" : "chart-line",
                `series-${series_index + 1}`
              ];
              func.call(this.renderer, area, y, chart_data.type === "area", chart_data.titles, styles);
              series_index++;
            }
          }
        }
        break;
      case "bar":
        {
          let corners;
          this.renderer.RenderBarGrid(area, chart_data.scale.count, "chart-grid");
          if (chart_data.series2) {
            let count = 0;
            const series_count = chart_data.series2.length;
            for (const series of chart_data.series2) {
              count = Math.max(count, series.y.data.length);
            }
            const row_height = area.height / count;
            let row_pct = 0.7;
            if (typeof chart_data.space === "number") {
              row_pct = Math.max(0, Math.min(1, 1 - chart_data.space));
            }
            const space = row_height * (1 - row_pct) / 2;
            const height = (row_height - space * 2) / series_count;
            let zero = 0;
            if (chart_data.scale.min < 0) {
              zero = Util.ApplyScale(0, area.width, chart_data.scale);
            }
            if (chart_data.round) {
              const half_height = Math.floor(height / 2);
              corners = [0, half_height, half_height, 0];
            }
            for (let s = 0; s < series_count; s++) {
              const series = chart_data.series2[s];
              const color_index = typeof series.index === "number" ? series.index : s + 1;
              for (let i = 0; i < series.y.data.length; i++) {
                const value = series.y.data[i];
                if (typeof value === "number") {
                  const y = Math.round(area.top + i * row_height + space) + s * height;
                  let x = 0;
                  let width = 0;
                  let negative = false;
                  if (zero) {
                    if (value > 0) {
                      width = Util.ApplyScale(value + chart_data.scale.min, area.width, chart_data.scale);
                      x = area.left + zero;
                    } else {
                      width = Util.ApplyScale(chart_data.scale.min - value, area.width, chart_data.scale);
                      x = area.left + zero - width;
                      negative = true;
                    }
                  } else {
                    width = Util.ApplyScale(value, area.width, chart_data.scale);
                    x = area.left;
                  }
                  const bar_title = void 0;
                  if (width) {
                    this.renderer.RenderRectangle(new Area2(
                      x,
                      y,
                      x + width,
                      y + height
                    ), corners, ["chart-column", `series-${color_index}`], bar_title || void 0);
                  }
                }
              }
            }
          }
        }
        break;
      case "column":
      case "histogram2":
        {
          this.renderer.RenderGrid(area, chart_data.scale.count, 0, "chart-grid");
          if (chart_data.series2) {
            let count = 0;
            const series_count = chart_data.series2.length;
            for (const series of chart_data.series2) {
              count = Math.max(count, series.y.data.length);
            }
            const column_width = area.width / count;
            let column_pct = 0.7;
            if (typeof chart_data.space === "number") {
              column_pct = Math.max(0, Math.min(1, 1 - chart_data.space));
            }
            const space = column_width * (1 - column_pct) / 2;
            const width = (column_width - space * 2) / series_count;
            let zero = 0;
            if (chart_data.scale.min < 0) {
              zero = Util.ApplyScale(0, area.height, chart_data.scale);
            }
            if (chart_data.callouts && chart_data.x_scale) {
              const scale = chart_data.x_scale;
              const lines = chart_data.callouts.map((callout, index) => {
                const x = Math.round(area.left + Util.ApplyScale(callout.value, area.width, scale)) + 0.5;
                return {
                  x1: x,
                  y1: area.bottom - area.height,
                  x2: x,
                  y2: area.bottom,
                  classes: `callout-${index + 1}`
                };
              });
              this.renderer.RenderCalloutLines(lines);
            }
            let corners;
            if (chart_data.round) {
              const half_width = Math.floor(width / 2);
              corners = [half_width, half_width, 0, 0];
            }
            for (let s = 0; s < series_count; s++) {
              const series = chart_data.series2[s];
              const color_index = typeof series.index === "number" ? series.index : s + 1;
              for (let i = 0; i < series.y.data.length; i++) {
                const value = series.y.data[i];
                if (typeof value === "number") {
                  const x = area.left + i * column_width + space + s * width;
                  let height = 0;
                  let y = 0;
                  let negative = false;
                  if (zero) {
                    if (value > 0) {
                      height = Util.ApplyScale(value + chart_data.scale.min, area.height, chart_data.scale);
                      y = area.bottom - height - zero;
                    } else {
                      height = Util.ApplyScale(chart_data.scale.min - value, area.height, chart_data.scale);
                      y = area.bottom - zero;
                      negative = true;
                    }
                  } else {
                    height = Util.ApplyScale(value, area.height, chart_data.scale);
                    y = area.bottom - height;
                  }
                  const bar_title = void 0;
                  if (height) {
                    const label = chart_data.data_labels && !!series.y.labels ? series.y.labels[i] : "";
                    const label_point = {
                      x: Math.round(x + width / 2),
                      y: Math.round(y - 10)
                    };
                    this.renderer.RenderRectangle(new Area2(
                      x,
                      y,
                      x + width,
                      y + height
                    ), corners, ["chart-column", `series-${color_index}`], bar_title || void 0, label, label_point);
                  }
                }
              }
            }
          }
        }
        break;
      case "histogram":
        {
          this.renderer.RenderGrid(area, chart_data.scale.count, 0, "chart-grid");
          const column_width = area.width / chart_data.count;
          const column_pct = chart_data.column_width;
          const space = column_width * (1 - column_pct) / 2;
          for (let i = 0; i < chart_data.count; i++) {
            const x = Math.round(area.left + i * column_width + space);
            const width = column_width - space * 2;
            const height = Util.ApplyScale(chart_data.bins[i], area.height, chart_data.scale);
            const y = area.bottom - height;
            const bar_title = chart_data.titles ? chart_data.titles[i] : void 0;
            this.renderer.RenderRectangle(new Area2(
              x,
              y,
              x + width,
              y + height
            ), void 0, "chart-column series-1", bar_title || void 0);
          }
        }
        break;
    }
  }
};

// treb-charts/src/chart.ts
var Chart = class {
  constructor(renderer = new DefaultChartRenderer()) {
    this.renderer = renderer;
  }
  /** flag indicating we've registered at least once */
  static functions_registered = false;
  // always exists; default null type, no title
  chart_data = { type: "null" };
  node;
  Initialize(node) {
    this.node = node;
    this.renderer.Initialize(node);
  }
  Exec(func, union) {
    const args = union?.value || [];
    switch (func.toLowerCase()) {
      case "column.chart":
        this.chart_data = CreateColumnChart(args, "column");
        break;
      case "bar.chart":
        this.chart_data = CreateColumnChart(args, "bar");
        break;
      case "line.chart":
        this.chart_data = CreateLineChart(args, "line");
        break;
      case "area.chart":
        this.chart_data = CreateLineChart(args, "area");
        break;
      case "donut.chart":
      case "pie.chart":
        this.chart_data = CreateDonut(args, func.toLowerCase() === "pie.chart");
        break;
      case "scatter.plot":
        this.chart_data = CreateScatterChart(args, "plot");
        break;
      case "scatter.line":
        this.chart_data = CreateScatterChart(args, "line");
        break;
      case "bubble.chart":
        this.chart_data = CreateBubbleChart(args);
        break;
      default:
        this.Clear();
        break;
    }
  }
  Clear() {
    this.chart_data = { type: "null" };
  }
  /** pass through */
  Resize() {
    if (this.node) {
      this.renderer.Resize(this.node, this.chart_data);
    }
  }
  /** pass through */
  Update() {
    if (this.node) {
      this.renderer.Update(this.node, this.chart_data);
    }
  }
};

// treb-charts/src/chart-functions.ts
var Identity = (...args) => {
  return {
    type: 5 /* object */,
    value: args,
    key: "arguments"
  };
};
var ChartFunctions = {
  /* new: also helper */
  Group: {
    arguments: [
      { name: "Array...", metadata: true }
    ],
    fn: (...args) => {
      return {
        type: 5 /* object */,
        value: args,
        key: "group"
      };
    }
  },
  /**
   * UPDATE: adding explicit names to Series, for convention. Use the 
   * more general "group" if you just want to group things.
   * 
   * boxing properly as "extended" type
   */
  Series: {
    arguments: [
      { name: "Label" },
      // , metadata: true, },
      { name: "X", metadata: true },
      { name: "Y", metadata: true },
      { name: "Z", metadata: true },
      { name: "index" },
      { name: "subtype" }
    ],
    fn: (...args) => {
      return {
        type: 5 /* object */,
        value: args,
        key: "series"
      };
    }
  },
  "Bar.Chart": {
    arguments: [
      { name: "Data", metadata: true },
      { name: "Categories", metadata: true },
      { name: "ChartTitle" }
    ],
    fn: Identity
  },
  "Line.Chart": {
    arguments: [
      { name: "y", metadata: true },
      { name: "x", metadata: true },
      { name: "ChartTitle" }
    ],
    fn: Identity
  },
  "Area.Chart": {
    arguments: [
      { name: "y", metadata: true },
      { name: "x", metadata: true },
      { name: "ChartTitle" }
    ],
    fn: Identity
  },
  "Pie.Chart": {
    arguments: [
      { name: "Values", metadata: true },
      { name: "Labels" },
      { name: "Title" },
      { name: "Sort" },
      { name: "Label" }
    ],
    fn: Identity
  },
  "Donut.Chart": {
    arguments: [
      { name: "Values", metadata: true },
      { name: "Labels", metadata: true },
      { name: "Title" },
      { name: "Sort" },
      { name: "Label" }
    ],
    fn: Identity
  },
  "Scatter.Line": {
    arguments: [
      { name: "Data", metadata: true },
      { name: "ChartTitle" }
    ],
    fn: Identity
  },
  "Scatter.Plot": {
    arguments: [
      { name: "Data", metadata: true },
      { name: "ChartTitle" }
    ],
    fn: Identity
  },
  "Column.Chart": {
    arguments: [
      { name: "Data", metadata: true },
      { name: "Categories", metadata: true },
      { name: "Chart Title" }
    ],
    fn: Identity
  },
  "Bubble.Chart": {
    arguments: [
      { name: "Data", metadata: true },
      { name: "Chart Title" }
    ],
    fn: Identity
  }
};

// worker:/home/duncan/dev/TREB/treb-export/src/export-worker/index.worker.ts
var index_worker_exports = {};
__export(index_worker_exports, {
  default: () => index_worker_default
});
var index_worker_default = 'var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === "object" || typeof from === "function") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. "__esModule" has not been set), then set\n  // "default" to the CommonJS "module.exports" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// node_modules/base64-js/index.js\nvar require_base64_js = __commonJS({\n  "node_modules/base64-js/index.js"(exports) {\n    "use strict";\n    exports.byteLength = byteLength;\n    exports.toByteArray = toByteArray2;\n    exports.fromByteArray = fromByteArray;\n    var lookup = [];\n    var revLookup = [];\n    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;\n    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";\n    for (i = 0, len = code.length; i < len; ++i) {\n      lookup[i] = code[i];\n      revLookup[code.charCodeAt(i)] = i;\n    }\n    var i;\n    var len;\n    revLookup["-".charCodeAt(0)] = 62;\n    revLookup["_".charCodeAt(0)] = 63;\n    function getLens(b64) {\n      var len2 = b64.length;\n      if (len2 % 4 > 0) {\n        throw new Error("Invalid string. Length must be a multiple of 4");\n      }\n      var validLen = b64.indexOf("=");\n      if (validLen === -1)\n        validLen = len2;\n      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n      return [validLen, placeHoldersLen];\n    }\n    function byteLength(b64) {\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n    function _byteLength(b64, validLen, placeHoldersLen) {\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n    function toByteArray2(b64) {\n      var tmp;\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n      var curByte = 0;\n      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n      var i2;\n      for (i2 = 0; i2 < len2; i2 += 4) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n        arr[curByte++] = tmp >> 16 & 255;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n      }\n      if (placeHoldersLen === 2) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n        arr[curByte++] = tmp & 255;\n      }\n      if (placeHoldersLen === 1) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n      }\n      return arr;\n    }\n    function tripletToBase64(num) {\n      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n    }\n    function encodeChunk(uint8, start, end) {\n      var tmp;\n      var output = [];\n      for (var i2 = start; i2 < end; i2 += 3) {\n        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n        output.push(tripletToBase64(tmp));\n      }\n      return output.join("");\n    }\n    function fromByteArray(uint8) {\n      var tmp;\n      var len2 = uint8.length;\n      var extraBytes = len2 % 3;\n      var parts = [];\n      var maxChunkLength = 16383;\n      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n      }\n      if (extraBytes === 1) {\n        tmp = uint8[len2 - 1];\n        parts.push(\n          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="\n        );\n      } else if (extraBytes === 2) {\n        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n        parts.push(\n          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="\n        );\n      }\n      return parts.join("");\n    }\n  }\n});\n\n// node_modules/fast-xml-parser/src/util.js\nvar require_util = __commonJS({\n  "node_modules/fast-xml-parser/src/util.js"(exports) {\n    "use strict";\n    var nameStartChar = ":A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD";\n    var nameChar = nameStartChar + "\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040";\n    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";\n    var regexName = new RegExp("^" + nameRegexp + "$");\n    var getAllMatches = function(string, regex2) {\n      const matches = [];\n      let match = regex2.exec(string);\n      while (match) {\n        const allmatches = [];\n        allmatches.startIndex = regex2.lastIndex - match[0].length;\n        const len = match.length;\n        for (let index = 0; index < len; index++) {\n          allmatches.push(match[index]);\n        }\n        matches.push(allmatches);\n        match = regex2.exec(string);\n      }\n      return matches;\n    };\n    var isName = function(string) {\n      const match = regexName.exec(string);\n      return !(match === null || typeof match === "undefined");\n    };\n    exports.isExist = function(v) {\n      return typeof v !== "undefined";\n    };\n    exports.isEmptyObject = function(obj) {\n      return Object.keys(obj).length === 0;\n    };\n    exports.merge = function(target, a, arrayMode) {\n      if (a) {\n        const keys = Object.keys(a);\n        const len = keys.length;\n        for (let i = 0; i < len; i++) {\n          if (arrayMode === "strict") {\n            target[keys[i]] = [a[keys[i]]];\n          } else {\n            target[keys[i]] = a[keys[i]];\n          }\n        }\n      }\n    };\n    exports.getValue = function(v) {\n      if (exports.isExist(v)) {\n        return v;\n      } else {\n        return "";\n      }\n    };\n    exports.isName = isName;\n    exports.getAllMatches = getAllMatches;\n    exports.nameRegexp = nameRegexp;\n  }\n});\n\n// node_modules/fast-xml-parser/src/validator.js\nvar require_validator = __commonJS({\n  "node_modules/fast-xml-parser/src/validator.js"(exports) {\n    "use strict";\n    var util = require_util();\n    var defaultOptions = {\n      allowBooleanAttributes: false,\n      //A tag can have attributes without any value\n      unpairedTags: []\n    };\n    exports.validate = function(xmlData, options) {\n      options = Object.assign({}, defaultOptions, options);\n      const tags = [];\n      let tagFound = false;\n      let reachedRoot = false;\n      if (xmlData[0] === "\\uFEFF") {\n        xmlData = xmlData.substr(1);\n      }\n      for (let i = 0; i < xmlData.length; i++) {\n        if (xmlData[i] === "<" && xmlData[i + 1] === "?") {\n          i += 2;\n          i = readPI(xmlData, i);\n          if (i.err)\n            return i;\n        } else if (xmlData[i] === "<") {\n          let tagStartPos = i;\n          i++;\n          if (xmlData[i] === "!") {\n            i = readCommentAndCDATA(xmlData, i);\n            continue;\n          } else {\n            let closingTag = false;\n            if (xmlData[i] === "/") {\n              closingTag = true;\n              i++;\n            }\n            let tagName = "";\n            for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\\n" && xmlData[i] !== "\\r"; i++) {\n              tagName += xmlData[i];\n            }\n            tagName = tagName.trim();\n            if (tagName[tagName.length - 1] === "/") {\n              tagName = tagName.substring(0, tagName.length - 1);\n              i--;\n            }\n            if (!validateTagName(tagName)) {\n              let msg;\n              if (tagName.trim().length === 0) {\n                msg = "Invalid space after \'<\'.";\n              } else {\n                msg = "Tag \'" + tagName + "\' is an invalid name.";\n              }\n              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));\n            }\n            const result = readAttributeStr(xmlData, i);\n            if (result === false) {\n              return getErrorObject("InvalidAttr", "Attributes for \'" + tagName + "\' have open quote.", getLineNumberForPosition(xmlData, i));\n            }\n            let attrStr = result.value;\n            i = result.index;\n            if (attrStr[attrStr.length - 1] === "/") {\n              const attrStrStart = i - attrStr.length;\n              attrStr = attrStr.substring(0, attrStr.length - 1);\n              const isValid = validateAttributeString(attrStr, options);\n              if (isValid === true) {\n                tagFound = true;\n              } else {\n                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n              }\n            } else if (closingTag) {\n              if (!result.tagClosed) {\n                return getErrorObject("InvalidTag", "Closing tag \'" + tagName + "\' doesn\'t have proper closing.", getLineNumberForPosition(xmlData, i));\n              } else if (attrStr.trim().length > 0) {\n                return getErrorObject("InvalidTag", "Closing tag \'" + tagName + "\' can\'t have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));\n              } else {\n                const otg = tags.pop();\n                if (tagName !== otg.tagName) {\n                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n                  return getErrorObject(\n                    "InvalidTag",\n                    "Expected closing tag \'" + otg.tagName + "\' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag \'" + tagName + "\'.",\n                    getLineNumberForPosition(xmlData, tagStartPos)\n                  );\n                }\n                if (tags.length == 0) {\n                  reachedRoot = true;\n                }\n              }\n            } else {\n              const isValid = validateAttributeString(attrStr, options);\n              if (isValid !== true) {\n                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n              }\n              if (reachedRoot === true) {\n                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));\n              } else if (options.unpairedTags.indexOf(tagName) !== -1) {\n              } else {\n                tags.push({ tagName, tagStartPos });\n              }\n              tagFound = true;\n            }\n            for (i++; i < xmlData.length; i++) {\n              if (xmlData[i] === "<") {\n                if (xmlData[i + 1] === "!") {\n                  i++;\n                  i = readCommentAndCDATA(xmlData, i);\n                  continue;\n                } else if (xmlData[i + 1] === "?") {\n                  i = readPI(xmlData, ++i);\n                  if (i.err)\n                    return i;\n                } else {\n                  break;\n                }\n              } else if (xmlData[i] === "&") {\n                const afterAmp = validateAmpersand(xmlData, i);\n                if (afterAmp == -1)\n                  return getErrorObject("InvalidChar", "char \'&\' is not expected.", getLineNumberForPosition(xmlData, i));\n                i = afterAmp;\n              } else {\n                if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n                  return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i));\n                }\n              }\n            }\n            if (xmlData[i] === "<") {\n              i--;\n            }\n          }\n        } else {\n          if (isWhiteSpace(xmlData[i])) {\n            continue;\n          }\n          return getErrorObject("InvalidChar", "char \'" + xmlData[i] + "\' is not expected.", getLineNumberForPosition(xmlData, i));\n        }\n      }\n      if (!tagFound) {\n        return getErrorObject("InvalidXml", "Start tag expected.", 1);\n      } else if (tags.length == 1) {\n        return getErrorObject("InvalidTag", "Unclosed tag \'" + tags[0].tagName + "\'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n      } else if (tags.length > 0) {\n        return getErrorObject("InvalidXml", "Invalid \'" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\\r?\\n/g, "") + "\' found.", { line: 1, col: 1 });\n      }\n      return true;\n    };\n    function isWhiteSpace(char) {\n      return char === " " || char === "	" || char === "\\n" || char === "\\r";\n    }\n    function readPI(xmlData, i) {\n      const start = i;\n      for (; i < xmlData.length; i++) {\n        if (xmlData[i] == "?" || xmlData[i] == " ") {\n          const tagname = xmlData.substr(start, i - start);\n          if (i > 5 && tagname === "xml") {\n            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));\n          } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {\n            i++;\n            break;\n          } else {\n            continue;\n          }\n        }\n      }\n      return i;\n    }\n    function readCommentAndCDATA(xmlData, i) {\n      if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {\n        for (i += 3; i < xmlData.length; i++) {\n          if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {\n            i += 2;\n            break;\n          }\n        }\n      } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {\n        let angleBracketsCount = 1;\n        for (i += 8; i < xmlData.length; i++) {\n          if (xmlData[i] === "<") {\n            angleBracketsCount++;\n          } else if (xmlData[i] === ">") {\n            angleBracketsCount--;\n            if (angleBracketsCount === 0) {\n              break;\n            }\n          }\n        }\n      } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {\n        for (i += 8; i < xmlData.length; i++) {\n          if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {\n            i += 2;\n            break;\n          }\n        }\n      }\n      return i;\n    }\n    var doubleQuote = \'"\';\n    var singleQuote = "\'";\n    function readAttributeStr(xmlData, i) {\n      let attrStr = "";\n      let startChar = "";\n      let tagClosed = false;\n      for (; i < xmlData.length; i++) {\n        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n          if (startChar === "") {\n            startChar = xmlData[i];\n          } else if (startChar !== xmlData[i]) {\n          } else {\n            startChar = "";\n          }\n        } else if (xmlData[i] === ">") {\n          if (startChar === "") {\n            tagClosed = true;\n            break;\n          }\n        }\n        attrStr += xmlData[i];\n      }\n      if (startChar !== "") {\n        return false;\n      }\n      return {\n        value: attrStr,\n        index: i,\n        tagClosed\n      };\n    }\n    var validAttrStrRegxp = new RegExp(`(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\'"])(([\\\\s\\\\S])*?)\\\\5)?`, "g");\n    function validateAttributeString(attrStr, options) {\n      const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n      const attrNames = {};\n      for (let i = 0; i < matches.length; i++) {\n        if (matches[i][1].length === 0) {\n          return getErrorObject("InvalidAttr", "Attribute \'" + matches[i][2] + "\' has no space in starting.", getPositionFromMatch(matches[i]));\n        } else if (matches[i][3] !== void 0 && matches[i][4] === void 0) {\n          return getErrorObject("InvalidAttr", "Attribute \'" + matches[i][2] + "\' is without value.", getPositionFromMatch(matches[i]));\n        } else if (matches[i][3] === void 0 && !options.allowBooleanAttributes) {\n          return getErrorObject("InvalidAttr", "boolean attribute \'" + matches[i][2] + "\' is not allowed.", getPositionFromMatch(matches[i]));\n        }\n        const attrName = matches[i][2];\n        if (!validateAttrName(attrName)) {\n          return getErrorObject("InvalidAttr", "Attribute \'" + attrName + "\' is an invalid name.", getPositionFromMatch(matches[i]));\n        }\n        if (!attrNames.hasOwnProperty(attrName)) {\n          attrNames[attrName] = 1;\n        } else {\n          return getErrorObject("InvalidAttr", "Attribute \'" + attrName + "\' is repeated.", getPositionFromMatch(matches[i]));\n        }\n      }\n      return true;\n    }\n    function validateNumberAmpersand(xmlData, i) {\n      let re = /\\d/;\n      if (xmlData[i] === "x") {\n        i++;\n        re = /[\\da-fA-F]/;\n      }\n      for (; i < xmlData.length; i++) {\n        if (xmlData[i] === ";")\n          return i;\n        if (!xmlData[i].match(re))\n          break;\n      }\n      return -1;\n    }\n    function validateAmpersand(xmlData, i) {\n      i++;\n      if (xmlData[i] === ";")\n        return -1;\n      if (xmlData[i] === "#") {\n        i++;\n        return validateNumberAmpersand(xmlData, i);\n      }\n      let count = 0;\n      for (; i < xmlData.length; i++, count++) {\n        if (xmlData[i].match(/\\w/) && count < 20)\n          continue;\n        if (xmlData[i] === ";")\n          break;\n        return -1;\n      }\n      return i;\n    }\n    function getErrorObject(code, message, lineNumber) {\n      return {\n        err: {\n          code,\n          msg: message,\n          line: lineNumber.line || lineNumber,\n          col: lineNumber.col\n        }\n      };\n    }\n    function validateAttrName(attrName) {\n      return util.isName(attrName);\n    }\n    function validateTagName(tagname) {\n      return util.isName(tagname);\n    }\n    function getLineNumberForPosition(xmlData, index) {\n      const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n      return {\n        line: lines.length,\n        // column number is last line\'s length + 1, because column numbering starts at 1:\n        col: lines[lines.length - 1].length + 1\n      };\n    }\n    function getPositionFromMatch(match) {\n      return match.startIndex + match[1].length;\n    }\n  }\n});\n\n// node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js\nvar require_OptionsBuilder = __commonJS({\n  "node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {\n    var defaultOptions = {\n      preserveOrder: false,\n      attributeNamePrefix: "@_",\n      attributesGroupName: false,\n      textNodeName: "#text",\n      ignoreAttributes: true,\n      removeNSPrefix: false,\n      // remove NS from tag name or attribute name if true\n      allowBooleanAttributes: false,\n      //a tag can have attributes without any value\n      //ignoreRootElement : false,\n      parseTagValue: true,\n      parseAttributeValue: false,\n      trimValues: true,\n      //Trim string values of tag and attributes\n      cdataPropName: false,\n      numberParseOptions: {\n        hex: true,\n        leadingZeros: true,\n        eNotation: true\n      },\n      tagValueProcessor: function(tagName, val2) {\n        return val2;\n      },\n      attributeValueProcessor: function(attrName, val2) {\n        return val2;\n      },\n      stopNodes: [],\n      //nested tags will not be parsed even for errors\n      alwaysCreateTextNode: false,\n      isArray: () => false,\n      commentPropName: false,\n      unpairedTags: [],\n      processEntities: true,\n      htmlEntities: false,\n      ignoreDeclaration: false,\n      ignorePiTags: false,\n      transformTagName: false,\n      transformAttributeName: false,\n      updateTag: function(tagName, jPath, attrs) {\n        return tagName;\n      }\n      // skipEmptyListItem: false\n    };\n    var buildOptions = function(options) {\n      return Object.assign({}, defaultOptions, options);\n    };\n    exports.buildOptions = buildOptions;\n    exports.defaultOptions = defaultOptions;\n  }\n});\n\n// node_modules/fast-xml-parser/src/xmlparser/xmlNode.js\nvar require_xmlNode = __commonJS({\n  "node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module) {\n    "use strict";\n    var XmlNode = class {\n      constructor(tagname) {\n        this.tagname = tagname;\n        this.child = [];\n        this[":@"] = {};\n      }\n      add(key, val2) {\n        if (key === "__proto__")\n          key = "#__proto__";\n        this.child.push({ [key]: val2 });\n      }\n      addChild(node) {\n        if (node.tagname === "__proto__")\n          node.tagname = "#__proto__";\n        if (node[":@"] && Object.keys(node[":@"]).length > 0) {\n          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });\n        } else {\n          this.child.push({ [node.tagname]: node.child });\n        }\n      }\n    };\n    module.exports = XmlNode;\n  }\n});\n\n// node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js\nvar require_DocTypeReader = __commonJS({\n  "node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module) {\n    var util = require_util();\n    function readDocType(xmlData, i) {\n      const entities2 = {};\n      if (xmlData[i + 3] === "O" && xmlData[i + 4] === "C" && xmlData[i + 5] === "T" && xmlData[i + 6] === "Y" && xmlData[i + 7] === "P" && xmlData[i + 8] === "E") {\n        i = i + 9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = "";\n        for (; i < xmlData.length; i++) {\n          if (xmlData[i] === "<" && !comment) {\n            if (hasBody && isEntity(xmlData, i)) {\n              i += 7;\n              [entityName, val, i] = readEntityExp(xmlData, i + 1);\n              if (val.indexOf("&") === -1)\n                entities2[validateEntityName(entityName)] = {\n                  regx: RegExp(`&${entityName};`, "g"),\n                  val\n                };\n            } else if (hasBody && isElement(xmlData, i))\n              i += 8;\n            else if (hasBody && isAttlist(xmlData, i))\n              i += 8;\n            else if (hasBody && isNotation(xmlData, i))\n              i += 9;\n            else if (isComment)\n              comment = true;\n            else\n              throw new Error("Invalid DOCTYPE");\n            angleBracketsCount++;\n            exp = "";\n          } else if (xmlData[i] === ">") {\n            if (comment) {\n              if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {\n                comment = false;\n                angleBracketsCount--;\n              }\n            } else {\n              angleBracketsCount--;\n            }\n            if (angleBracketsCount === 0) {\n              break;\n            }\n          } else if (xmlData[i] === "[") {\n            hasBody = true;\n          } else {\n            exp += xmlData[i];\n          }\n        }\n        if (angleBracketsCount !== 0) {\n          throw new Error(`Unclosed DOCTYPE`);\n        }\n      } else {\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n      }\n      return { entities: entities2, i };\n    }\n    function readEntityExp(xmlData, i) {\n      let entityName2 = "";\n      for (; i < xmlData.length && (xmlData[i] !== "\'" && xmlData[i] !== \'"\'); i++) {\n        entityName2 += xmlData[i];\n      }\n      entityName2 = entityName2.trim();\n      if (entityName2.indexOf(" ") !== -1)\n        throw new Error("External entites are not supported");\n      const startChar = xmlData[i++];\n      let val2 = "";\n      for (; i < xmlData.length && xmlData[i] !== startChar; i++) {\n        val2 += xmlData[i];\n      }\n      return [entityName2, val2, i];\n    }\n    function isComment(xmlData, i) {\n      if (xmlData[i + 1] === "!" && xmlData[i + 2] === "-" && xmlData[i + 3] === "-")\n        return true;\n      return false;\n    }\n    function isEntity(xmlData, i) {\n      if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "N" && xmlData[i + 4] === "T" && xmlData[i + 5] === "I" && xmlData[i + 6] === "T" && xmlData[i + 7] === "Y")\n        return true;\n      return false;\n    }\n    function isElement(xmlData, i) {\n      if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "L" && xmlData[i + 4] === "E" && xmlData[i + 5] === "M" && xmlData[i + 6] === "E" && xmlData[i + 7] === "N" && xmlData[i + 8] === "T")\n        return true;\n      return false;\n    }\n    function isAttlist(xmlData, i) {\n      if (xmlData[i + 1] === "!" && xmlData[i + 2] === "A" && xmlData[i + 3] === "T" && xmlData[i + 4] === "T" && xmlData[i + 5] === "L" && xmlData[i + 6] === "I" && xmlData[i + 7] === "S" && xmlData[i + 8] === "T")\n        return true;\n      return false;\n    }\n    function isNotation(xmlData, i) {\n      if (xmlData[i + 1] === "!" && xmlData[i + 2] === "N" && xmlData[i + 3] === "O" && xmlData[i + 4] === "T" && xmlData[i + 5] === "A" && xmlData[i + 6] === "T" && xmlData[i + 7] === "I" && xmlData[i + 8] === "O" && xmlData[i + 9] === "N")\n        return true;\n      return false;\n    }\n    function validateEntityName(name) {\n      if (util.isName(name))\n        return name;\n      else\n        throw new Error(`Invalid entity name ${name}`);\n    }\n    module.exports = readDocType;\n  }\n});\n\n// node_modules/strnum/strnum.js\nvar require_strnum = __commonJS({\n  "node_modules/strnum/strnum.js"(exports, module) {\n    var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\n    var numRegex = /^([\\-\\+])?(0*)(\\.[0-9]+([eE]\\-?[0-9]+)?|[0-9]+(\\.[0-9]+([eE]\\-?[0-9]+)?)?)$/;\n    if (!Number.parseInt && window.parseInt) {\n      Number.parseInt = window.parseInt;\n    }\n    if (!Number.parseFloat && window.parseFloat) {\n      Number.parseFloat = window.parseFloat;\n    }\n    var consider = {\n      hex: true,\n      leadingZeros: true,\n      decimalPoint: ".",\n      eNotation: true\n      //skipLike: /regex/\n    };\n    function toNumber(str, options = {}) {\n      options = Object.assign({}, consider, options);\n      if (!str || typeof str !== "string")\n        return str;\n      let trimmedStr = str.trim();\n      if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))\n        return str;\n      else if (options.hex && hexRegex.test(trimmedStr)) {\n        return Number.parseInt(trimmedStr, 16);\n      } else {\n        const match = numRegex.exec(trimmedStr);\n        if (match) {\n          const sign = match[1];\n          const leadingZeros = match[2];\n          let numTrimmedByZeros = trimZeros(match[3]);\n          const eNotation = match[4] || match[6];\n          if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")\n            return str;\n          else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")\n            return str;\n          else {\n            const num = Number(trimmedStr);\n            const numStr = "" + num;\n            if (numStr.search(/[eE]/) !== -1) {\n              if (options.eNotation)\n                return num;\n              else\n                return str;\n            } else if (eNotation) {\n              if (options.eNotation)\n                return num;\n              else\n                return str;\n            } else if (trimmedStr.indexOf(".") !== -1) {\n              if (numStr === "0" && numTrimmedByZeros === "")\n                return num;\n              else if (numStr === numTrimmedByZeros)\n                return num;\n              else if (sign && numStr === "-" + numTrimmedByZeros)\n                return num;\n              else\n                return str;\n            }\n            if (leadingZeros) {\n              if (numTrimmedByZeros === numStr)\n                return num;\n              else if (sign + numTrimmedByZeros === numStr)\n                return num;\n              else\n                return str;\n            }\n            if (trimmedStr === numStr)\n              return num;\n            else if (trimmedStr === sign + numStr)\n              return num;\n            return str;\n          }\n        } else {\n          return str;\n        }\n      }\n    }\n    function trimZeros(numStr) {\n      if (numStr && numStr.indexOf(".") !== -1) {\n        numStr = numStr.replace(/0+$/, "");\n        if (numStr === ".")\n          numStr = "0";\n        else if (numStr[0] === ".")\n          numStr = "0" + numStr;\n        else if (numStr[numStr.length - 1] === ".")\n          numStr = numStr.substr(0, numStr.length - 1);\n        return numStr;\n      }\n      return numStr;\n    }\n    module.exports = toNumber;\n  }\n});\n\n// node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js\nvar require_OrderedObjParser = __commonJS({\n  "node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module) {\n    "use strict";\n    var util = require_util();\n    var xmlNode = require_xmlNode();\n    var readDocType = require_DocTypeReader();\n    var toNumber = require_strnum();\n    var regx = "<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)".replace(/NAME/g, util.nameRegexp);\n    var OrderedObjParser = class {\n      constructor(options) {\n        this.options = options;\n        this.currentNode = null;\n        this.tagsNodeStack = [];\n        this.docTypeEntities = {};\n        this.lastEntities = {\n          "apos": { regex: /&(apos|#39|#x27);/g, val: "\'" },\n          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },\n          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },\n          "quot": { regex: /&(quot|#34|#x22);/g, val: \'"\' }\n        };\n        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };\n        this.htmlEntities = {\n          "space": { regex: /&(nbsp|#160);/g, val: " " },\n          // "lt" : { regex: /&(lt|#60);/g, val: "<" },\n          // "gt" : { regex: /&(gt|#62);/g, val: ">" },\n          // "amp" : { regex: /&(amp|#38);/g, val: "&" },\n          // "quot" : { regex: /&(quot|#34);/g, val: "\\"" },\n          // "apos" : { regex: /&(apos|#39);/g, val: "\'" },\n          "cent": { regex: /&(cent|#162);/g, val: "\\xA2" },\n          "pound": { regex: /&(pound|#163);/g, val: "\\xA3" },\n          "yen": { regex: /&(yen|#165);/g, val: "\\xA5" },\n          "euro": { regex: /&(euro|#8364);/g, val: "\\u20AC" },\n          "copyright": { regex: /&(copy|#169);/g, val: "\\xA9" },\n          "reg": { regex: /&(reg|#174);/g, val: "\\xAE" },\n          "inr": { regex: /&(inr|#8377);/g, val: "\\u20B9" }\n        };\n        this.addExternalEntities = addExternalEntities;\n        this.parseXml = parseXml;\n        this.parseTextData = parseTextData;\n        this.resolveNameSpace = resolveNameSpace;\n        this.buildAttributesMap = buildAttributesMap;\n        this.isItStopNode = isItStopNode;\n        this.replaceEntitiesValue = replaceEntitiesValue;\n        this.readStopNodeData = readStopNodeData;\n        this.saveTextToParentTag = saveTextToParentTag;\n        this.addChild = addChild;\n      }\n    };\n    function addExternalEntities(externalEntities) {\n      const entKeys = Object.keys(externalEntities);\n      for (let i = 0; i < entKeys.length; i++) {\n        const ent = entKeys[i];\n        this.lastEntities[ent] = {\n          regex: new RegExp("&" + ent + ";", "g"),\n          val: externalEntities[ent]\n        };\n      }\n    }\n    function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n      if (val2 !== void 0) {\n        if (this.options.trimValues && !dontTrim) {\n          val2 = val2.trim();\n        }\n        if (val2.length > 0) {\n          if (!escapeEntities)\n            val2 = this.replaceEntitiesValue(val2);\n          const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);\n          if (newval === null || newval === void 0) {\n            return val2;\n          } else if (typeof newval !== typeof val2 || newval !== val2) {\n            return newval;\n          } else if (this.options.trimValues) {\n            return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);\n          } else {\n            const trimmedVal = val2.trim();\n            if (trimmedVal === val2) {\n              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);\n            } else {\n              return val2;\n            }\n          }\n        }\n      }\n    }\n    function resolveNameSpace(tagname) {\n      if (this.options.removeNSPrefix) {\n        const tags = tagname.split(":");\n        const prefix = tagname.charAt(0) === "/" ? "/" : "";\n        if (tags[0] === "xmlns") {\n          return "";\n        }\n        if (tags.length === 2) {\n          tagname = prefix + tags[1];\n        }\n      }\n      return tagname;\n    }\n    var attrsRegx = new RegExp(`([^\\\\s=]+)\\\\s*(=\\\\s*([\'"])([\\\\s\\\\S]*?)\\\\3)?`, "gm");\n    function buildAttributesMap(attrStr, jPath, tagName) {\n      if (!this.options.ignoreAttributes && typeof attrStr === "string") {\n        const matches = util.getAllMatches(attrStr, attrsRegx);\n        const len = matches.length;\n        const attrs = {};\n        for (let i = 0; i < len; i++) {\n          const attrName = this.resolveNameSpace(matches[i][1]);\n          let oldVal = matches[i][4];\n          let aName = this.options.attributeNamePrefix + attrName;\n          if (attrName.length) {\n            if (this.options.transformAttributeName) {\n              aName = this.options.transformAttributeName(aName);\n            }\n            if (aName === "__proto__")\n              aName = "#__proto__";\n            if (oldVal !== void 0) {\n              if (this.options.trimValues) {\n                oldVal = oldVal.trim();\n              }\n              oldVal = this.replaceEntitiesValue(oldVal);\n              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n              if (newVal === null || newVal === void 0) {\n                attrs[aName] = oldVal;\n              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {\n                attrs[aName] = newVal;\n              } else {\n                attrs[aName] = parseValue(\n                  oldVal,\n                  this.options.parseAttributeValue,\n                  this.options.numberParseOptions\n                );\n              }\n            } else if (this.options.allowBooleanAttributes) {\n              attrs[aName] = true;\n            }\n          }\n        }\n        if (!Object.keys(attrs).length) {\n          return;\n        }\n        if (this.options.attributesGroupName) {\n          const attrCollection = {};\n          attrCollection[this.options.attributesGroupName] = attrs;\n          return attrCollection;\n        }\n        return attrs;\n      }\n    }\n    var parseXml = function(xmlData) {\n      xmlData = xmlData.replace(/\\r\\n?/g, "\\n");\n      const xmlObj = new xmlNode("!xml");\n      let currentNode = xmlObj;\n      let textData = "";\n      let jPath = "";\n      for (let i = 0; i < xmlData.length; i++) {\n        const ch = xmlData[i];\n        if (ch === "<") {\n          if (xmlData[i + 1] === "/") {\n            const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");\n            let tagName = xmlData.substring(i + 2, closeIndex).trim();\n            if (this.options.removeNSPrefix) {\n              const colonIndex = tagName.indexOf(":");\n              if (colonIndex !== -1) {\n                tagName = tagName.substr(colonIndex + 1);\n              }\n            }\n            if (this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n            if (currentNode) {\n              textData = this.saveTextToParentTag(textData, currentNode, jPath);\n            }\n            const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);\n            if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {\n              throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n            }\n            let propIndex = 0;\n            if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {\n              propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);\n              this.tagsNodeStack.pop();\n            } else {\n              propIndex = jPath.lastIndexOf(".");\n            }\n            jPath = jPath.substring(0, propIndex);\n            currentNode = this.tagsNodeStack.pop();\n            textData = "";\n            i = closeIndex;\n          } else if (xmlData[i + 1] === "?") {\n            let tagData = readTagExp(xmlData, i, false, "?>");\n            if (!tagData)\n              throw new Error("Pi Tag is not closed.");\n            textData = this.saveTextToParentTag(textData, currentNode, jPath);\n            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {\n            } else {\n              const childNode = new xmlNode(tagData.tagName);\n              childNode.add(this.options.textNodeName, "");\n              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {\n                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n              }\n              this.addChild(currentNode, childNode, jPath);\n            }\n            i = tagData.closeIndex + 1;\n          } else if (xmlData.substr(i + 1, 3) === "!--") {\n            const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");\n            if (this.options.commentPropName) {\n              const comment = xmlData.substring(i + 4, endIndex - 2);\n              textData = this.saveTextToParentTag(textData, currentNode, jPath);\n              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);\n            }\n            i = endIndex;\n          } else if (xmlData.substr(i + 1, 2) === "!D") {\n            const result = readDocType(xmlData, i);\n            this.docTypeEntities = result.entities;\n            i = result.i;\n          } else if (xmlData.substr(i + 1, 2) === "![") {\n            const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;\n            const tagExp = xmlData.substring(i + 9, closeIndex);\n            textData = this.saveTextToParentTag(textData, currentNode, jPath);\n            if (this.options.cdataPropName) {\n              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);\n            } else {\n              let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);\n              if (val2 == void 0)\n                val2 = "";\n              currentNode.add(this.options.textNodeName, val2);\n            }\n            i = closeIndex + 2;\n          } else {\n            let result = readTagExp(xmlData, i, this.options.removeNSPrefix);\n            let tagName = result.tagName;\n            const rawTagName = result.rawTagName;\n            let tagExp = result.tagExp;\n            let attrExpPresent = result.attrExpPresent;\n            let closeIndex = result.closeIndex;\n            if (this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n            if (currentNode && textData) {\n              if (currentNode.tagname !== "!xml") {\n                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n              }\n            }\n            const lastTag = currentNode;\n            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {\n              currentNode = this.tagsNodeStack.pop();\n              jPath = jPath.substring(0, jPath.lastIndexOf("."));\n            }\n            if (tagName !== xmlObj.tagname) {\n              jPath += jPath ? "." + tagName : tagName;\n            }\n            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n              let tagContent = "";\n              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {\n                i = result.closeIndex;\n              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {\n                i = result.closeIndex;\n              } else {\n                const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n                if (!result2)\n                  throw new Error(`Unexpected end of ${rawTagName}`);\n                i = result2.i;\n                tagContent = result2.tagContent;\n              }\n              const childNode = new xmlNode(tagName);\n              if (tagName !== tagExp && attrExpPresent) {\n                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);\n              }\n              if (tagContent) {\n                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n              }\n              jPath = jPath.substr(0, jPath.lastIndexOf("."));\n              childNode.add(this.options.textNodeName, tagContent);\n              this.addChild(currentNode, childNode, jPath);\n            } else {\n              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {\n                if (tagName[tagName.length - 1] === "/") {\n                  tagName = tagName.substr(0, tagName.length - 1);\n                  jPath = jPath.substr(0, jPath.length - 1);\n                  tagExp = tagName;\n                } else {\n                  tagExp = tagExp.substr(0, tagExp.length - 1);\n                }\n                if (this.options.transformTagName) {\n                  tagName = this.options.transformTagName(tagName);\n                }\n                const childNode = new xmlNode(tagName);\n                if (tagName !== tagExp && attrExpPresent) {\n                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);\n                }\n                this.addChild(currentNode, childNode, jPath);\n                jPath = jPath.substr(0, jPath.lastIndexOf("."));\n              } else {\n                const childNode = new xmlNode(tagName);\n                this.tagsNodeStack.push(currentNode);\n                if (tagName !== tagExp && attrExpPresent) {\n                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);\n                }\n                this.addChild(currentNode, childNode, jPath);\n                currentNode = childNode;\n              }\n              textData = "";\n              i = closeIndex;\n            }\n          }\n        } else {\n          textData += xmlData[i];\n        }\n      }\n      return xmlObj.child;\n    };\n    function addChild(currentNode, childNode, jPath) {\n      const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);\n      if (result === false) {\n      } else if (typeof result === "string") {\n        childNode.tagname = result;\n        currentNode.addChild(childNode);\n      } else {\n        currentNode.addChild(childNode);\n      }\n    }\n    var replaceEntitiesValue = function(val2) {\n      if (this.options.processEntities) {\n        for (let entityName2 in this.docTypeEntities) {\n          const entity = this.docTypeEntities[entityName2];\n          val2 = val2.replace(entity.regx, entity.val);\n        }\n        for (let entityName2 in this.lastEntities) {\n          const entity = this.lastEntities[entityName2];\n          val2 = val2.replace(entity.regex, entity.val);\n        }\n        if (this.options.htmlEntities) {\n          for (let entityName2 in this.htmlEntities) {\n            const entity = this.htmlEntities[entityName2];\n            val2 = val2.replace(entity.regex, entity.val);\n          }\n        }\n        val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);\n      }\n      return val2;\n    };\n    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n      if (textData) {\n        if (isLeafNode === void 0)\n          isLeafNode = Object.keys(currentNode.child).length === 0;\n        textData = this.parseTextData(\n          textData,\n          currentNode.tagname,\n          jPath,\n          false,\n          currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,\n          isLeafNode\n        );\n        if (textData !== void 0 && textData !== "")\n          currentNode.add(this.options.textNodeName, textData);\n        textData = "";\n      }\n      return textData;\n    }\n    function isItStopNode(stopNodes, jPath, currentTagName) {\n      const allNodesExp = "*." + currentTagName;\n      for (const stopNodePath in stopNodes) {\n        const stopNodeExp = stopNodes[stopNodePath];\n        if (allNodesExp === stopNodeExp || jPath === stopNodeExp)\n          return true;\n      }\n      return false;\n    }\n    function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {\n      let attrBoundary;\n      let tagExp = "";\n      for (let index = i; index < xmlData.length; index++) {\n        let ch = xmlData[index];\n        if (attrBoundary) {\n          if (ch === attrBoundary)\n            attrBoundary = "";\n        } else if (ch === \'"\' || ch === "\'") {\n          attrBoundary = ch;\n        } else if (ch === closingChar[0]) {\n          if (closingChar[1]) {\n            if (xmlData[index + 1] === closingChar[1]) {\n              return {\n                data: tagExp,\n                index\n              };\n            }\n          } else {\n            return {\n              data: tagExp,\n              index\n            };\n          }\n        } else if (ch === "	") {\n          ch = " ";\n        }\n        tagExp += ch;\n      }\n    }\n    function findClosingIndex(xmlData, str, i, errMsg) {\n      const closingIndex = xmlData.indexOf(str, i);\n      if (closingIndex === -1) {\n        throw new Error(errMsg);\n      } else {\n        return closingIndex + str.length - 1;\n      }\n    }\n    function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {\n      const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);\n      if (!result)\n        return;\n      let tagExp = result.data;\n      const closeIndex = result.index;\n      const separatorIndex = tagExp.search(/\\s/);\n      let tagName = tagExp;\n      let attrExpPresent = true;\n      if (separatorIndex !== -1) {\n        tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, "");\n        tagExp = tagExp.substr(separatorIndex + 1);\n      }\n      const rawTagName = tagName;\n      if (removeNSPrefix) {\n        const colonIndex = tagName.indexOf(":");\n        if (colonIndex !== -1) {\n          tagName = tagName.substr(colonIndex + 1);\n          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n        }\n      }\n      return {\n        tagName,\n        tagExp,\n        closeIndex,\n        attrExpPresent,\n        rawTagName\n      };\n    }\n    function readStopNodeData(xmlData, tagName, i) {\n      const startIndex = i;\n      let openTagCount = 1;\n      for (; i < xmlData.length; i++) {\n        if (xmlData[i] === "<") {\n          if (xmlData[i + 1] === "/") {\n            const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);\n            let closeTagName = xmlData.substring(i + 2, closeIndex).trim();\n            if (closeTagName === tagName) {\n              openTagCount--;\n              if (openTagCount === 0) {\n                return {\n                  tagContent: xmlData.substring(startIndex, i),\n                  i: closeIndex\n                };\n              }\n            }\n            i = closeIndex;\n          } else if (xmlData[i + 1] === "?") {\n            const closeIndex = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");\n            i = closeIndex;\n          } else if (xmlData.substr(i + 1, 3) === "!--") {\n            const closeIndex = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");\n            i = closeIndex;\n          } else if (xmlData.substr(i + 1, 2) === "![") {\n            const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;\n            i = closeIndex;\n          } else {\n            const tagData = readTagExp(xmlData, i, ">");\n            if (tagData) {\n              const openTagName = tagData && tagData.tagName;\n              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {\n                openTagCount++;\n              }\n              i = tagData.closeIndex;\n            }\n          }\n        }\n      }\n    }\n    function parseValue(val2, shouldParse, options) {\n      if (shouldParse && typeof val2 === "string") {\n        const newval = val2.trim();\n        if (newval === "true")\n          return true;\n        else if (newval === "false")\n          return false;\n        else\n          return toNumber(val2, options);\n      } else {\n        if (util.isExist(val2)) {\n          return val2;\n        } else {\n          return "";\n        }\n      }\n    }\n    module.exports = OrderedObjParser;\n  }\n});\n\n// node_modules/fast-xml-parser/src/xmlparser/node2json.js\nvar require_node2json = __commonJS({\n  "node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {\n    "use strict";\n    function prettify(node, options) {\n      return compress(node, options);\n    }\n    function compress(arr, options, jPath) {\n      let text;\n      const compressedObj = {};\n      for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const property = propName(tagObj);\n        let newJpath = "";\n        if (jPath === void 0)\n          newJpath = property;\n        else\n          newJpath = jPath + "." + property;\n        if (property === options.textNodeName) {\n          if (text === void 0)\n            text = tagObj[property];\n          else\n            text += "" + tagObj[property];\n        } else if (property === void 0) {\n          continue;\n        } else if (tagObj[property]) {\n          let val2 = compress(tagObj[property], options, newJpath);\n          const isLeaf = isLeafTag(val2, options);\n          if (tagObj[":@"]) {\n            assignAttributes(val2, tagObj[":@"], newJpath, options);\n          } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {\n            val2 = val2[options.textNodeName];\n          } else if (Object.keys(val2).length === 0) {\n            if (options.alwaysCreateTextNode)\n              val2[options.textNodeName] = "";\n            else\n              val2 = "";\n          }\n          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {\n            if (!Array.isArray(compressedObj[property])) {\n              compressedObj[property] = [compressedObj[property]];\n            }\n            compressedObj[property].push(val2);\n          } else {\n            if (options.isArray(property, newJpath, isLeaf)) {\n              compressedObj[property] = [val2];\n            } else {\n              compressedObj[property] = val2;\n            }\n          }\n        }\n      }\n      if (typeof text === "string") {\n        if (text.length > 0)\n          compressedObj[options.textNodeName] = text;\n      } else if (text !== void 0)\n        compressedObj[options.textNodeName] = text;\n      return compressedObj;\n    }\n    function propName(obj) {\n      const keys = Object.keys(obj);\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (key !== ":@")\n          return key;\n      }\n    }\n    function assignAttributes(obj, attrMap, jpath, options) {\n      if (attrMap) {\n        const keys = Object.keys(attrMap);\n        const len = keys.length;\n        for (let i = 0; i < len; i++) {\n          const atrrName = keys[i];\n          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {\n            obj[atrrName] = [attrMap[atrrName]];\n          } else {\n            obj[atrrName] = attrMap[atrrName];\n          }\n        }\n      }\n    }\n    function isLeafTag(obj, options) {\n      const { textNodeName } = options;\n      const propCount = Object.keys(obj).length;\n      if (propCount === 0) {\n        return true;\n      }\n      if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {\n        return true;\n      }\n      return false;\n    }\n    exports.prettify = prettify;\n  }\n});\n\n// node_modules/fast-xml-parser/src/xmlparser/XMLParser.js\nvar require_XMLParser = __commonJS({\n  "node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module) {\n    var { buildOptions } = require_OptionsBuilder();\n    var OrderedObjParser = require_OrderedObjParser();\n    var { prettify } = require_node2json();\n    var validator = require_validator();\n    var XMLParser3 = class {\n      constructor(options) {\n        this.externalEntities = {};\n        this.options = buildOptions(options);\n      }\n      /**\n       * Parse XML dats to JS object \n       * @param {string|Buffer} xmlData \n       * @param {boolean|Object} validationOption \n       */\n      parse(xmlData, validationOption) {\n        if (typeof xmlData === "string") {\n        } else if (xmlData.toString) {\n          xmlData = xmlData.toString();\n        } else {\n          throw new Error("XML data is accepted in String or Bytes[] form.");\n        }\n        if (validationOption) {\n          if (validationOption === true)\n            validationOption = {};\n          const result = validator.validate(xmlData, validationOption);\n          if (result !== true) {\n            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);\n          }\n        }\n        const orderedObjParser = new OrderedObjParser(this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if (this.options.preserveOrder || orderedResult === void 0)\n          return orderedResult;\n        else\n          return prettify(orderedResult, this.options);\n      }\n      /**\n       * Add Entity which is not by default supported by this library\n       * @param {string} key \n       * @param {string} value \n       */\n      addEntity(key, value) {\n        if (value.indexOf("&") !== -1) {\n          throw new Error("Entity value can\'t have \'&\'");\n        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {\n          throw new Error("An entity must be set without \'&\' and \';\'. Eg. use \'#xD\' for \'&#xD;\'");\n        } else if (value === "&") {\n          throw new Error("An entity with value \'&\' is not permitted");\n        } else {\n          this.externalEntities[key] = value;\n        }\n      }\n    };\n    module.exports = XMLParser3;\n  }\n});\n\n// node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js\nvar require_orderedJs2Xml = __commonJS({\n  "node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module) {\n    var EOL = "\\n";\n    function toXml(jArray, options) {\n      let indentation = "";\n      if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n      }\n      return arrToStr(jArray, options, "", indentation);\n    }\n    function arrToStr(arr, options, jPath, indentation) {\n      let xmlStr = "";\n      let isPreviousElementTag = false;\n      for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        if (tagName === void 0)\n          continue;\n        let newJPath = "";\n        if (jPath.length === 0)\n          newJPath = tagName;\n        else\n          newJPath = `${jPath}.${tagName}`;\n        if (tagName === options.textNodeName) {\n          let tagText = tagObj[tagName];\n          if (!isStopNode(newJPath, options)) {\n            tagText = options.tagValueProcessor(tagName, tagText);\n            tagText = replaceEntitiesValue(tagText, options);\n          }\n          if (isPreviousElementTag) {\n            xmlStr += indentation;\n          }\n          xmlStr += tagText;\n          isPreviousElementTag = false;\n          continue;\n        } else if (tagName === options.cdataPropName) {\n          if (isPreviousElementTag) {\n            xmlStr += indentation;\n          }\n          xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n          isPreviousElementTag = false;\n          continue;\n        } else if (tagName === options.commentPropName) {\n          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n          isPreviousElementTag = true;\n          continue;\n        } else if (tagName[0] === "?") {\n          const attStr2 = attr_to_str(tagObj[":@"], options);\n          const tempInd = tagName === "?xml" ? "" : indentation;\n          let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n          piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";\n          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;\n          isPreviousElementTag = true;\n          continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== "") {\n          newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[":@"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n          if (options.suppressUnpairedNode)\n            xmlStr += tagStart + ">";\n          else\n            xmlStr += tagStart + "/>";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n          xmlStr += tagStart + "/>";\n        } else if (tagValue && tagValue.endsWith(">")) {\n          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n          xmlStr += tagStart + ">";\n          if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {\n            xmlStr += indentation + options.indentBy + tagValue + indentation;\n          } else {\n            xmlStr += tagValue;\n          }\n          xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n      }\n      return xmlStr;\n    }\n    function propName(obj) {\n      const keys = Object.keys(obj);\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (!obj.hasOwnProperty(key))\n          continue;\n        if (key !== ":@")\n          return key;\n      }\n    }\n    function attr_to_str(attrMap, options) {\n      let attrStr = "";\n      if (attrMap && !options.ignoreAttributes) {\n        for (let attr in attrMap) {\n          if (!attrMap.hasOwnProperty(attr))\n            continue;\n          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n          attrVal = replaceEntitiesValue(attrVal, options);\n          if (attrVal === true && options.suppressBooleanAttributes) {\n            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n          } else {\n            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;\n          }\n        }\n      }\n      return attrStr;\n    }\n    function isStopNode(jPath, options) {\n      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);\n      for (let index in options.stopNodes) {\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)\n          return true;\n      }\n      return false;\n    }\n    function replaceEntitiesValue(textValue, options) {\n      if (textValue && textValue.length > 0 && options.processEntities) {\n        for (let i = 0; i < options.entities.length; i++) {\n          const entity = options.entities[i];\n          textValue = textValue.replace(entity.regex, entity.val);\n        }\n      }\n      return textValue;\n    }\n    module.exports = toXml;\n  }\n});\n\n// node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js\nvar require_json2xml = __commonJS({\n  "node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module) {\n    "use strict";\n    var buildFromOrderedJs = require_orderedJs2Xml();\n    var defaultOptions = {\n      attributeNamePrefix: "@_",\n      attributesGroupName: false,\n      textNodeName: "#text",\n      ignoreAttributes: true,\n      cdataPropName: false,\n      format: false,\n      indentBy: "  ",\n      suppressEmptyNode: false,\n      suppressUnpairedNode: true,\n      suppressBooleanAttributes: true,\n      tagValueProcessor: function(key, a) {\n        return a;\n      },\n      attributeValueProcessor: function(attrName, a) {\n        return a;\n      },\n      preserveOrder: false,\n      commentPropName: false,\n      unpairedTags: [],\n      entities: [\n        { regex: new RegExp("&", "g"), val: "&amp;" },\n        //it must be on top\n        { regex: new RegExp(">", "g"), val: "&gt;" },\n        { regex: new RegExp("<", "g"), val: "&lt;" },\n        { regex: new RegExp("\'", "g"), val: "&apos;" },\n        { regex: new RegExp(\'"\', "g"), val: "&quot;" }\n      ],\n      processEntities: true,\n      stopNodes: [],\n      // transformTagName: false,\n      // transformAttributeName: false,\n      oneListGroup: false\n    };\n    function Builder(options) {\n      this.options = Object.assign({}, defaultOptions, options);\n      if (this.options.ignoreAttributes || this.options.attributesGroupName) {\n        this.isAttribute = function() {\n          return false;\n        };\n      } else {\n        this.attrPrefixLen = this.options.attributeNamePrefix.length;\n        this.isAttribute = isAttribute;\n      }\n      this.processTextOrObjNode = processTextOrObjNode;\n      if (this.options.format) {\n        this.indentate = indentate;\n        this.tagEndChar = ">\\n";\n        this.newLine = "\\n";\n      } else {\n        this.indentate = function() {\n          return "";\n        };\n        this.tagEndChar = ">";\n        this.newLine = "";\n      }\n    }\n    Builder.prototype.build = function(jObj) {\n      if (this.options.preserveOrder) {\n        return buildFromOrderedJs(jObj, this.options);\n      } else {\n        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {\n          jObj = {\n            [this.options.arrayNodeName]: jObj\n          };\n        }\n        return this.j2x(jObj, 0).val;\n      }\n    };\n    Builder.prototype.j2x = function(jObj, level) {\n      let attrStr = "";\n      let val2 = "";\n      for (let key in jObj) {\n        if (!Object.prototype.hasOwnProperty.call(jObj, key))\n          continue;\n        if (typeof jObj[key] === "undefined") {\n          if (this.isAttribute(key)) {\n            val2 += "";\n          }\n        } else if (jObj[key] === null) {\n          if (this.isAttribute(key)) {\n            val2 += "";\n          } else if (key[0] === "?") {\n            val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;\n          } else {\n            val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;\n          }\n        } else if (jObj[key] instanceof Date) {\n          val2 += this.buildTextValNode(jObj[key], key, "", level);\n        } else if (typeof jObj[key] !== "object") {\n          const attr = this.isAttribute(key);\n          if (attr) {\n            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);\n          } else {\n            if (key === this.options.textNodeName) {\n              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);\n              val2 += this.replaceEntitiesValue(newval);\n            } else {\n              val2 += this.buildTextValNode(jObj[key], key, "", level);\n            }\n          }\n        } else if (Array.isArray(jObj[key])) {\n          const arrLen = jObj[key].length;\n          let listTagVal = "";\n          for (let j = 0; j < arrLen; j++) {\n            const item = jObj[key][j];\n            if (typeof item === "undefined") {\n            } else if (item === null) {\n              if (key[0] === "?")\n                val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;\n              else\n                val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;\n            } else if (typeof item === "object") {\n              if (this.options.oneListGroup) {\n                listTagVal += this.j2x(item, level + 1).val;\n              } else {\n                listTagVal += this.processTextOrObjNode(item, key, level);\n              }\n            } else {\n              listTagVal += this.buildTextValNode(item, key, "", level);\n            }\n          }\n          if (this.options.oneListGroup) {\n            listTagVal = this.buildObjectNode(listTagVal, key, "", level);\n          }\n          val2 += listTagVal;\n        } else {\n          if (this.options.attributesGroupName && key === this.options.attributesGroupName) {\n            const Ks = Object.keys(jObj[key]);\n            const L = Ks.length;\n            for (let j = 0; j < L; j++) {\n              attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);\n            }\n          } else {\n            val2 += this.processTextOrObjNode(jObj[key], key, level);\n          }\n        }\n      }\n      return { attrStr, val: val2 };\n    };\n    Builder.prototype.buildAttrPairStr = function(attrName, val2) {\n      val2 = this.options.attributeValueProcessor(attrName, "" + val2);\n      val2 = this.replaceEntitiesValue(val2);\n      if (this.options.suppressBooleanAttributes && val2 === "true") {\n        return " " + attrName;\n      } else\n        return " " + attrName + \'="\' + val2 + \'"\';\n    };\n    function processTextOrObjNode(object, key, level) {\n      const result = this.j2x(object, level + 1);\n      if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {\n        return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);\n      } else {\n        return this.buildObjectNode(result.val, key, result.attrStr, level);\n      }\n    }\n    Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {\n      if (val2 === "") {\n        if (key[0] === "?")\n          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;\n        else {\n          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;\n        }\n      } else {\n        let tagEndExp = "</" + key + this.tagEndChar;\n        let piClosingChar = "";\n        if (key[0] === "?") {\n          piClosingChar = "?";\n          tagEndExp = "";\n        }\n        if ((attrStr || attrStr === "") && val2.indexOf("<") === -1) {\n          return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;\n        } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {\n          return this.indentate(level) + `<!--${val2}-->` + this.newLine;\n        } else {\n          return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;\n        }\n      }\n    };\n    Builder.prototype.closeTag = function(key) {\n      let closeTag = "";\n      if (this.options.unpairedTags.indexOf(key) !== -1) {\n        if (!this.options.suppressUnpairedNode)\n          closeTag = "/";\n      } else if (this.options.suppressEmptyNode) {\n        closeTag = "/";\n      } else {\n        closeTag = `></${key}`;\n      }\n      return closeTag;\n    };\n    Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {\n      if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {\n        return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;\n      } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {\n        return this.indentate(level) + `<!--${val2}-->` + this.newLine;\n      } else if (key[0] === "?") {\n        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;\n      } else {\n        let textValue = this.options.tagValueProcessor(key, val2);\n        textValue = this.replaceEntitiesValue(textValue);\n        if (textValue === "") {\n          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;\n        } else {\n          return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;\n        }\n      }\n    };\n    Builder.prototype.replaceEntitiesValue = function(textValue) {\n      if (textValue && textValue.length > 0 && this.options.processEntities) {\n        for (let i = 0; i < this.options.entities.length; i++) {\n          const entity = this.options.entities[i];\n          textValue = textValue.replace(entity.regex, entity.val);\n        }\n      }\n      return textValue;\n    };\n    function indentate(level) {\n      return this.options.indentBy.repeat(level);\n    }\n    function isAttribute(name) {\n      if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {\n        return name.substr(this.attrPrefixLen);\n      } else {\n        return false;\n      }\n    }\n    module.exports = Builder;\n  }\n});\n\n// node_modules/fast-xml-parser/src/fxp.js\nvar require_fxp = __commonJS({\n  "node_modules/fast-xml-parser/src/fxp.js"(exports, module) {\n    "use strict";\n    var validator = require_validator();\n    var XMLParser3 = require_XMLParser();\n    var XMLBuilder2 = require_json2xml();\n    module.exports = {\n      XMLParser: XMLParser3,\n      XMLValidator: validator,\n      XMLBuilder: XMLBuilder2\n    };\n  }\n});\n\n// node_modules/uzip/UZIP.js\nvar require_UZIP = __commonJS({\n  "node_modules/uzip/UZIP.js"(exports, module) {\n    var UZIP = {};\n    if (typeof module == "object")\n      module.exports = UZIP;\n    UZIP["parse"] = function(buf, onlyNames) {\n      var rUs = UZIP.bin.readUshort, rUi = UZIP.bin.readUint, o = 0, out = {};\n      var data = new Uint8Array(buf);\n      var eocd = data.length - 4;\n      while (rUi(data, eocd) != 101010256)\n        eocd--;\n      var o = eocd;\n      o += 4;\n      o += 4;\n      var cnu = rUs(data, o);\n      o += 2;\n      var cnt = rUs(data, o);\n      o += 2;\n      var csize = rUi(data, o);\n      o += 4;\n      var coffs = rUi(data, o);\n      o += 4;\n      o = coffs;\n      for (var i = 0; i < cnu; i++) {\n        var sign = rUi(data, o);\n        o += 4;\n        o += 4;\n        o += 4;\n        o += 4;\n        var crc32 = rUi(data, o);\n        o += 4;\n        var csize = rUi(data, o);\n        o += 4;\n        var usize = rUi(data, o);\n        o += 4;\n        var nl = rUs(data, o), el = rUs(data, o + 2), cl = rUs(data, o + 4);\n        o += 6;\n        o += 8;\n        var roff = rUi(data, o);\n        o += 4;\n        o += nl + el + cl;\n        UZIP._readLocal(data, roff, out, csize, usize, onlyNames);\n      }\n      return out;\n    };\n    UZIP._readLocal = function(data, o, out, csize, usize, onlyNames) {\n      var rUs = UZIP.bin.readUshort, rUi = UZIP.bin.readUint;\n      var sign = rUi(data, o);\n      o += 4;\n      var ver = rUs(data, o);\n      o += 2;\n      var gpflg = rUs(data, o);\n      o += 2;\n      var cmpr = rUs(data, o);\n      o += 2;\n      var time = rUi(data, o);\n      o += 4;\n      var crc32 = rUi(data, o);\n      o += 4;\n      o += 8;\n      var nlen = rUs(data, o);\n      o += 2;\n      var elen = rUs(data, o);\n      o += 2;\n      var name = UZIP.bin.readUTF8(data, o, nlen);\n      o += nlen;\n      o += elen;\n      if (onlyNames) {\n        out[name] = { size: usize, csize };\n        return;\n      }\n      var file = new Uint8Array(data.buffer, o);\n      if (false) {\n      } else if (cmpr == 0)\n        out[name] = new Uint8Array(file.buffer.slice(o, o + csize));\n      else if (cmpr == 8) {\n        var buf = new Uint8Array(usize);\n        UZIP.inflateRaw(file, buf);\n        out[name] = buf;\n      } else\n        throw "unknown compression method: " + cmpr;\n    };\n    UZIP.inflateRaw = function(file, buf) {\n      return UZIP.F.inflate(file, buf);\n    };\n    UZIP.inflate = function(file, buf) {\n      var CMF = file[0], FLG = file[1];\n      var CM = CMF & 15, CINFO = CMF >>> 4;\n      return UZIP.inflateRaw(new Uint8Array(file.buffer, file.byteOffset + 2, file.length - 6), buf);\n    };\n    UZIP.deflate = function(data, opts) {\n      if (opts == null)\n        opts = { level: 6 };\n      var off = 0, buf = new Uint8Array(50 + Math.floor(data.length * 1.1));\n      buf[off] = 120;\n      buf[off + 1] = 156;\n      off += 2;\n      off = UZIP.F.deflateRaw(data, buf, off, opts.level);\n      var crc = UZIP.adler(data, 0, data.length);\n      buf[off + 0] = crc >>> 24 & 255;\n      buf[off + 1] = crc >>> 16 & 255;\n      buf[off + 2] = crc >>> 8 & 255;\n      buf[off + 3] = crc >>> 0 & 255;\n      return new Uint8Array(buf.buffer, 0, off + 4);\n    };\n    UZIP.deflateRaw = function(data, opts) {\n      if (opts == null)\n        opts = { level: 6 };\n      var buf = new Uint8Array(50 + Math.floor(data.length * 1.1));\n      var off = UZIP.F.deflateRaw(data, buf, off, opts.level);\n      return new Uint8Array(buf.buffer, 0, off);\n    };\n    UZIP.encode = function(obj, noCmpr) {\n      if (noCmpr == null)\n        noCmpr = false;\n      var tot = 0, wUi = UZIP.bin.writeUint, wUs = UZIP.bin.writeUshort;\n      var zpd = {};\n      for (var p in obj) {\n        var cpr = !UZIP._noNeed(p) && !noCmpr, buf = obj[p], crc = UZIP.crc.crc(buf, 0, buf.length);\n        zpd[p] = { cpr, usize: buf.length, crc, file: cpr ? UZIP.deflateRaw(buf) : buf };\n      }\n      for (var p in zpd)\n        tot += zpd[p].file.length + 30 + 46 + 2 * UZIP.bin.sizeUTF8(p);\n      tot += 22;\n      var data = new Uint8Array(tot), o = 0;\n      var fof = [];\n      for (var p in zpd) {\n        var file = zpd[p];\n        fof.push(o);\n        o = UZIP._writeHeader(data, o, p, file, 0);\n      }\n      var i = 0, ioff = o;\n      for (var p in zpd) {\n        var file = zpd[p];\n        fof.push(o);\n        o = UZIP._writeHeader(data, o, p, file, 1, fof[i++]);\n      }\n      var csize = o - ioff;\n      wUi(data, o, 101010256);\n      o += 4;\n      o += 4;\n      wUs(data, o, i);\n      o += 2;\n      wUs(data, o, i);\n      o += 2;\n      wUi(data, o, csize);\n      o += 4;\n      wUi(data, o, ioff);\n      o += 4;\n      o += 2;\n      return data.buffer;\n    };\n    UZIP._noNeed = function(fn) {\n      var ext = fn.split(".").pop().toLowerCase();\n      return "png,jpg,jpeg,zip".indexOf(ext) != -1;\n    };\n    UZIP._writeHeader = function(data, o, p, obj, t, roff) {\n      var wUi = UZIP.bin.writeUint, wUs = UZIP.bin.writeUshort;\n      var file = obj.file;\n      wUi(data, o, t == 0 ? 67324752 : 33639248);\n      o += 4;\n      if (t == 1)\n        o += 2;\n      wUs(data, o, 20);\n      o += 2;\n      wUs(data, o, 0);\n      o += 2;\n      wUs(data, o, obj.cpr ? 8 : 0);\n      o += 2;\n      wUi(data, o, 0);\n      o += 4;\n      wUi(data, o, obj.crc);\n      o += 4;\n      wUi(data, o, file.length);\n      o += 4;\n      wUi(data, o, obj.usize);\n      o += 4;\n      wUs(data, o, UZIP.bin.sizeUTF8(p));\n      o += 2;\n      wUs(data, o, 0);\n      o += 2;\n      if (t == 1) {\n        o += 2;\n        o += 2;\n        o += 6;\n        wUi(data, o, roff);\n        o += 4;\n      }\n      var nlen = UZIP.bin.writeUTF8(data, o, p);\n      o += nlen;\n      if (t == 0) {\n        data.set(file, o);\n        o += file.length;\n      }\n      return o;\n    };\n    UZIP.crc = {\n      table: function() {\n        var tab = new Uint32Array(256);\n        for (var n = 0; n < 256; n++) {\n          var c = n;\n          for (var k = 0; k < 8; k++) {\n            if (c & 1)\n              c = 3988292384 ^ c >>> 1;\n            else\n              c = c >>> 1;\n          }\n          tab[n] = c;\n        }\n        return tab;\n      }(),\n      update: function(c, buf, off, len) {\n        for (var i = 0; i < len; i++)\n          c = UZIP.crc.table[(c ^ buf[off + i]) & 255] ^ c >>> 8;\n        return c;\n      },\n      crc: function(b, o, l) {\n        return UZIP.crc.update(4294967295, b, o, l) ^ 4294967295;\n      }\n    };\n    UZIP.adler = function(data, o, len) {\n      var a = 1, b = 0;\n      var off = o, end = o + len;\n      while (off < end) {\n        var eend = Math.min(off + 5552, end);\n        while (off < eend) {\n          a += data[off++];\n          b += a;\n        }\n        a = a % 65521;\n        b = b % 65521;\n      }\n      return b << 16 | a;\n    };\n    UZIP.bin = {\n      readUshort: function(buff, p) {\n        return buff[p] | buff[p + 1] << 8;\n      },\n      writeUshort: function(buff, p, n) {\n        buff[p] = n & 255;\n        buff[p + 1] = n >> 8 & 255;\n      },\n      readUint: function(buff, p) {\n        return buff[p + 3] * (256 * 256 * 256) + (buff[p + 2] << 16 | buff[p + 1] << 8 | buff[p]);\n      },\n      writeUint: function(buff, p, n) {\n        buff[p] = n & 255;\n        buff[p + 1] = n >> 8 & 255;\n        buff[p + 2] = n >> 16 & 255;\n        buff[p + 3] = n >> 24 & 255;\n      },\n      readASCII: function(buff, p, l) {\n        var s = "";\n        for (var i = 0; i < l; i++)\n          s += String.fromCharCode(buff[p + i]);\n        return s;\n      },\n      writeASCII: function(data, p, s) {\n        for (var i = 0; i < s.length; i++)\n          data[p + i] = s.charCodeAt(i);\n      },\n      pad: function(n) {\n        return n.length < 2 ? "0" + n : n;\n      },\n      readUTF8: function(buff, p, l) {\n        var s = "", ns;\n        for (var i = 0; i < l; i++)\n          s += "%" + UZIP.bin.pad(buff[p + i].toString(16));\n        try {\n          ns = decodeURIComponent(s);\n        } catch (e) {\n          return UZIP.bin.readASCII(buff, p, l);\n        }\n        return ns;\n      },\n      writeUTF8: function(buff, p, str) {\n        var strl = str.length, i = 0;\n        for (var ci = 0; ci < strl; ci++) {\n          var code = str.charCodeAt(ci);\n          if ((code & 4294967295 - (1 << 7) + 1) == 0) {\n            buff[p + i] = code;\n            i++;\n          } else if ((code & 4294967295 - (1 << 11) + 1) == 0) {\n            buff[p + i] = 192 | code >> 6;\n            buff[p + i + 1] = 128 | code >> 0 & 63;\n            i += 2;\n          } else if ((code & 4294967295 - (1 << 16) + 1) == 0) {\n            buff[p + i] = 224 | code >> 12;\n            buff[p + i + 1] = 128 | code >> 6 & 63;\n            buff[p + i + 2] = 128 | code >> 0 & 63;\n            i += 3;\n          } else if ((code & 4294967295 - (1 << 21) + 1) == 0) {\n            buff[p + i] = 240 | code >> 18;\n            buff[p + i + 1] = 128 | code >> 12 & 63;\n            buff[p + i + 2] = 128 | code >> 6 & 63;\n            buff[p + i + 3] = 128 | code >> 0 & 63;\n            i += 4;\n          } else\n            throw "e";\n        }\n        return i;\n      },\n      sizeUTF8: function(str) {\n        var strl = str.length, i = 0;\n        for (var ci = 0; ci < strl; ci++) {\n          var code = str.charCodeAt(ci);\n          if ((code & 4294967295 - (1 << 7) + 1) == 0) {\n            i++;\n          } else if ((code & 4294967295 - (1 << 11) + 1) == 0) {\n            i += 2;\n          } else if ((code & 4294967295 - (1 << 16) + 1) == 0) {\n            i += 3;\n          } else if ((code & 4294967295 - (1 << 21) + 1) == 0) {\n            i += 4;\n          } else\n            throw "e";\n        }\n        return i;\n      }\n    };\n    UZIP.F = {};\n    UZIP.F.deflateRaw = function(data, out, opos, lvl) {\n      var opts = [\n        /*\n        	 ush good_length; /* reduce lazy search above this match length \n        	 ush max_lazy;    /* do not perform lazy search above this match length \n                ush nice_length; /* quit search above this match length \n        */\n        /*      good lazy nice chain */\n        /* 0 */\n        [0, 0, 0, 0, 0],\n        /* store only */\n        /* 1 */\n        [4, 4, 8, 4, 0],\n        /* max speed, no lazy matches */\n        /* 2 */\n        [4, 5, 16, 8, 0],\n        /* 3 */\n        [4, 6, 16, 16, 0],\n        /* 4 */\n        [4, 10, 16, 32, 0],\n        /* lazy matches */\n        /* 5 */\n        [8, 16, 32, 32, 0],\n        /* 6 */\n        [8, 16, 128, 128, 0],\n        /* 7 */\n        [8, 32, 128, 256, 0],\n        /* 8 */\n        [32, 128, 258, 1024, 1],\n        /* 9 */\n        [32, 258, 258, 4096, 1]\n      ];\n      var opt = opts[lvl];\n      var U = UZIP.F.U, goodIndex = UZIP.F._goodIndex, hash = UZIP.F._hash, putsE = UZIP.F._putsE;\n      var i = 0, pos = opos << 3, cvrd = 0, dlen = data.length;\n      if (lvl == 0) {\n        while (i < dlen) {\n          var len = Math.min(65535, dlen - i);\n          putsE(out, pos, i + len == dlen ? 1 : 0);\n          pos = UZIP.F._copyExact(data, i, len, out, pos + 8);\n          i += len;\n        }\n        return pos >>> 3;\n      }\n      var lits = U.lits, strt = U.strt, prev = U.prev, li = 0, lc = 0, bs = 0, ebits = 0, c = 0, nc = 0;\n      if (dlen > 2) {\n        nc = UZIP.F._hash(data, 0);\n        strt[nc] = 0;\n      }\n      var nmch = 0, nmci = 0;\n      for (i = 0; i < dlen; i++) {\n        c = nc;\n        if (i + 1 < dlen - 2) {\n          nc = UZIP.F._hash(data, i + 1);\n          var ii = i + 1 & 32767;\n          prev[ii] = strt[nc];\n          strt[nc] = ii;\n        }\n        if (cvrd <= i) {\n          if ((li > 14e3 || lc > 26697) && dlen - i > 100) {\n            if (cvrd < i) {\n              lits[li] = i - cvrd;\n              li += 2;\n              cvrd = i;\n            }\n            pos = UZIP.F._writeBlock(i == dlen - 1 || cvrd == dlen ? 1 : 0, lits, li, ebits, data, bs, i - bs, out, pos);\n            li = lc = ebits = 0;\n            bs = i;\n          }\n          var mch = 0;\n          if (i < dlen - 2)\n            mch = UZIP.F._bestMatch(data, i, prev, c, Math.min(opt[2], dlen - i), opt[3]);\n          var len = mch >>> 16, dst = mch & 65535;\n          if (mch != 0) {\n            var len = mch >>> 16, dst = mch & 65535;\n            var lgi = goodIndex(len, U.of0);\n            U.lhst[257 + lgi]++;\n            var dgi = goodIndex(dst, U.df0);\n            U.dhst[dgi]++;\n            ebits += U.exb[lgi] + U.dxb[dgi];\n            lits[li] = len << 23 | i - cvrd;\n            lits[li + 1] = dst << 16 | lgi << 8 | dgi;\n            li += 2;\n            cvrd = i + len;\n          } else {\n            U.lhst[data[i]]++;\n          }\n          lc++;\n        }\n      }\n      if (bs != i || data.length == 0) {\n        if (cvrd < i) {\n          lits[li] = i - cvrd;\n          li += 2;\n          cvrd = i;\n        }\n        pos = UZIP.F._writeBlock(1, lits, li, ebits, data, bs, i - bs, out, pos);\n        li = 0;\n        lc = 0;\n        li = lc = ebits = 0;\n        bs = i;\n      }\n      while ((pos & 7) != 0)\n        pos++;\n      return pos >>> 3;\n    };\n    UZIP.F._bestMatch = function(data, i, prev, c, nice, chain) {\n      var ci = i & 32767, pi = prev[ci];\n      var dif = ci - pi + (1 << 15) & 32767;\n      if (pi == ci || c != UZIP.F._hash(data, i - dif))\n        return 0;\n      var tl = 0, td = 0;\n      var dlim = Math.min(32767, i);\n      while (dif <= dlim && --chain != 0 && pi != ci) {\n        if (tl == 0 || data[i + tl] == data[i + tl - dif]) {\n          var cl = UZIP.F._howLong(data, i, dif);\n          if (cl > tl) {\n            tl = cl;\n            td = dif;\n            if (tl >= nice)\n              break;\n            if (dif + 2 < cl)\n              cl = dif + 2;\n            var maxd = 0;\n            for (var j = 0; j < cl - 2; j++) {\n              var ei = i - dif + j + (1 << 15) & 32767;\n              var li = prev[ei];\n              var curd = ei - li + (1 << 15) & 32767;\n              if (curd > maxd) {\n                maxd = curd;\n                pi = ei;\n              }\n            }\n          }\n        }\n        ci = pi;\n        pi = prev[ci];\n        dif += ci - pi + (1 << 15) & 32767;\n      }\n      return tl << 16 | td;\n    };\n    UZIP.F._howLong = function(data, i, dif) {\n      if (data[i] != data[i - dif] || data[i + 1] != data[i + 1 - dif] || data[i + 2] != data[i + 2 - dif])\n        return 0;\n      var oi = i, l = Math.min(data.length, i + 258);\n      i += 3;\n      while (i < l && data[i] == data[i - dif])\n        i++;\n      return i - oi;\n    };\n    UZIP.F._hash = function(data, i) {\n      return (data[i] << 8 | data[i + 1]) + (data[i + 2] << 4) & 65535;\n    };\n    UZIP.saved = 0;\n    UZIP.F._writeBlock = function(BFINAL, lits, li, ebits, data, o0, l0, out, pos) {\n      var U = UZIP.F.U, putsF = UZIP.F._putsF, putsE = UZIP.F._putsE;\n      var T, ML, MD, MH, numl, numd, numh, lset, dset;\n      U.lhst[256]++;\n      T = UZIP.F.getTrees();\n      ML = T[0];\n      MD = T[1];\n      MH = T[2];\n      numl = T[3];\n      numd = T[4];\n      numh = T[5];\n      lset = T[6];\n      dset = T[7];\n      var cstSize = ((pos + 3 & 7) == 0 ? 0 : 8 - (pos + 3 & 7)) + 32 + (l0 << 3);\n      var fxdSize = ebits + UZIP.F.contSize(U.fltree, U.lhst) + UZIP.F.contSize(U.fdtree, U.dhst);\n      var dynSize = ebits + UZIP.F.contSize(U.ltree, U.lhst) + UZIP.F.contSize(U.dtree, U.dhst);\n      dynSize += 14 + 3 * numh + UZIP.F.contSize(U.itree, U.ihst) + (U.ihst[16] * 2 + U.ihst[17] * 3 + U.ihst[18] * 7);\n      for (var j = 0; j < 286; j++)\n        U.lhst[j] = 0;\n      for (var j = 0; j < 30; j++)\n        U.dhst[j] = 0;\n      for (var j = 0; j < 19; j++)\n        U.ihst[j] = 0;\n      var BTYPE = cstSize < fxdSize && cstSize < dynSize ? 0 : fxdSize < dynSize ? 1 : 2;\n      putsF(out, pos, BFINAL);\n      putsF(out, pos + 1, BTYPE);\n      pos += 3;\n      var opos = pos;\n      if (BTYPE == 0) {\n        while ((pos & 7) != 0)\n          pos++;\n        pos = UZIP.F._copyExact(data, o0, l0, out, pos);\n      } else {\n        var ltree, dtree;\n        if (BTYPE == 1) {\n          ltree = U.fltree;\n          dtree = U.fdtree;\n        }\n        if (BTYPE == 2) {\n          UZIP.F.makeCodes(U.ltree, ML);\n          UZIP.F.revCodes(U.ltree, ML);\n          UZIP.F.makeCodes(U.dtree, MD);\n          UZIP.F.revCodes(U.dtree, MD);\n          UZIP.F.makeCodes(U.itree, MH);\n          UZIP.F.revCodes(U.itree, MH);\n          ltree = U.ltree;\n          dtree = U.dtree;\n          putsE(out, pos, numl - 257);\n          pos += 5;\n          putsE(out, pos, numd - 1);\n          pos += 5;\n          putsE(out, pos, numh - 4);\n          pos += 4;\n          for (var i = 0; i < numh; i++)\n            putsE(out, pos + i * 3, U.itree[(U.ordr[i] << 1) + 1]);\n          pos += 3 * numh;\n          pos = UZIP.F._codeTiny(lset, U.itree, out, pos);\n          pos = UZIP.F._codeTiny(dset, U.itree, out, pos);\n        }\n        var off = o0;\n        for (var si = 0; si < li; si += 2) {\n          var qb = lits[si], len = qb >>> 23, end = off + (qb & (1 << 23) - 1);\n          while (off < end)\n            pos = UZIP.F._writeLit(data[off++], ltree, out, pos);\n          if (len != 0) {\n            var qc = lits[si + 1], dst = qc >> 16, lgi = qc >> 8 & 255, dgi = qc & 255;\n            pos = UZIP.F._writeLit(257 + lgi, ltree, out, pos);\n            putsE(out, pos, len - U.of0[lgi]);\n            pos += U.exb[lgi];\n            pos = UZIP.F._writeLit(dgi, dtree, out, pos);\n            putsF(out, pos, dst - U.df0[dgi]);\n            pos += U.dxb[dgi];\n            off += len;\n          }\n        }\n        pos = UZIP.F._writeLit(256, ltree, out, pos);\n      }\n      return pos;\n    };\n    UZIP.F._copyExact = function(data, off, len, out, pos) {\n      var p8 = pos >>> 3;\n      out[p8] = len;\n      out[p8 + 1] = len >>> 8;\n      out[p8 + 2] = 255 - out[p8];\n      out[p8 + 3] = 255 - out[p8 + 1];\n      p8 += 4;\n      out.set(new Uint8Array(data.buffer, off, len), p8);\n      return pos + (len + 4 << 3);\n    };\n    UZIP.F.getTrees = function() {\n      var U = UZIP.F.U;\n      var ML = UZIP.F._hufTree(U.lhst, U.ltree, 15);\n      var MD = UZIP.F._hufTree(U.dhst, U.dtree, 15);\n      var lset = [], numl = UZIP.F._lenCodes(U.ltree, lset);\n      var dset = [], numd = UZIP.F._lenCodes(U.dtree, dset);\n      for (var i = 0; i < lset.length; i += 2)\n        U.ihst[lset[i]]++;\n      for (var i = 0; i < dset.length; i += 2)\n        U.ihst[dset[i]]++;\n      var MH = UZIP.F._hufTree(U.ihst, U.itree, 7);\n      var numh = 19;\n      while (numh > 4 && U.itree[(U.ordr[numh - 1] << 1) + 1] == 0)\n        numh--;\n      return [ML, MD, MH, numl, numd, numh, lset, dset];\n    };\n    UZIP.F.getSecond = function(a) {\n      var b = [];\n      for (var i = 0; i < a.length; i += 2)\n        b.push(a[i + 1]);\n      return b;\n    };\n    UZIP.F.nonZero = function(a) {\n      var b = "";\n      for (var i = 0; i < a.length; i += 2)\n        if (a[i + 1] != 0)\n          b += (i >> 1) + ",";\n      return b;\n    };\n    UZIP.F.contSize = function(tree, hst) {\n      var s = 0;\n      for (var i = 0; i < hst.length; i++)\n        s += hst[i] * tree[(i << 1) + 1];\n      return s;\n    };\n    UZIP.F._codeTiny = function(set, tree, out, pos) {\n      for (var i = 0; i < set.length; i += 2) {\n        var l = set[i], rst = set[i + 1];\n        pos = UZIP.F._writeLit(l, tree, out, pos);\n        var rsl = l == 16 ? 2 : l == 17 ? 3 : 7;\n        if (l > 15) {\n          UZIP.F._putsE(out, pos, rst, rsl);\n          pos += rsl;\n        }\n      }\n      return pos;\n    };\n    UZIP.F._lenCodes = function(tree, set) {\n      var len = tree.length;\n      while (len != 2 && tree[len - 1] == 0)\n        len -= 2;\n      for (var i = 0; i < len; i += 2) {\n        var l = tree[i + 1], nxt = i + 3 < len ? tree[i + 3] : -1, nnxt = i + 5 < len ? tree[i + 5] : -1, prv = i == 0 ? -1 : tree[i - 1];\n        if (l == 0 && nxt == l && nnxt == l) {\n          var lz = i + 5;\n          while (lz + 2 < len && tree[lz + 2] == l)\n            lz += 2;\n          var zc = Math.min(lz + 1 - i >>> 1, 138);\n          if (zc < 11)\n            set.push(17, zc - 3);\n          else\n            set.push(18, zc - 11);\n          i += zc * 2 - 2;\n        } else if (l == prv && nxt == l && nnxt == l) {\n          var lz = i + 5;\n          while (lz + 2 < len && tree[lz + 2] == l)\n            lz += 2;\n          var zc = Math.min(lz + 1 - i >>> 1, 6);\n          set.push(16, zc - 3);\n          i += zc * 2 - 2;\n        } else\n          set.push(l, 0);\n      }\n      return len >>> 1;\n    };\n    UZIP.F._hufTree = function(hst, tree, MAXL) {\n      var list = [], hl = hst.length, tl = tree.length, i = 0;\n      for (i = 0; i < tl; i += 2) {\n        tree[i] = 0;\n        tree[i + 1] = 0;\n      }\n      for (i = 0; i < hl; i++)\n        if (hst[i] != 0)\n          list.push({ lit: i, f: hst[i] });\n      var end = list.length, l2 = list.slice(0);\n      if (end == 0)\n        return 0;\n      if (end == 1) {\n        var lit = list[0].lit, l2 = lit == 0 ? 1 : 0;\n        tree[(lit << 1) + 1] = 1;\n        tree[(l2 << 1) + 1] = 1;\n        return 1;\n      }\n      list.sort(function(a2, b2) {\n        return a2.f - b2.f;\n      });\n      var a = list[0], b = list[1], i0 = 0, i1 = 1, i2 = 2;\n      list[0] = { lit: -1, f: a.f + b.f, l: a, r: b, d: 0 };\n      while (i1 != end - 1) {\n        if (i0 != i1 && (i2 == end || list[i0].f < list[i2].f)) {\n          a = list[i0++];\n        } else {\n          a = list[i2++];\n        }\n        if (i0 != i1 && (i2 == end || list[i0].f < list[i2].f)) {\n          b = list[i0++];\n        } else {\n          b = list[i2++];\n        }\n        list[i1++] = { lit: -1, f: a.f + b.f, l: a, r: b };\n      }\n      var maxl = UZIP.F.setDepth(list[i1 - 1], 0);\n      if (maxl > MAXL) {\n        UZIP.F.restrictDepth(l2, MAXL, maxl);\n        maxl = MAXL;\n      }\n      for (i = 0; i < end; i++)\n        tree[(l2[i].lit << 1) + 1] = l2[i].d;\n      return maxl;\n    };\n    UZIP.F.setDepth = function(t, d) {\n      if (t.lit != -1) {\n        t.d = d;\n        return d;\n      }\n      return Math.max(UZIP.F.setDepth(t.l, d + 1), UZIP.F.setDepth(t.r, d + 1));\n    };\n    UZIP.F.restrictDepth = function(dps, MD, maxl) {\n      var i = 0, bCost = 1 << maxl - MD, dbt = 0;\n      dps.sort(function(a, b) {\n        return b.d == a.d ? a.f - b.f : b.d - a.d;\n      });\n      for (i = 0; i < dps.length; i++)\n        if (dps[i].d > MD) {\n          var od = dps[i].d;\n          dps[i].d = MD;\n          dbt += bCost - (1 << maxl - od);\n        } else\n          break;\n      dbt = dbt >>> maxl - MD;\n      while (dbt > 0) {\n        var od = dps[i].d;\n        if (od < MD) {\n          dps[i].d++;\n          dbt -= 1 << MD - od - 1;\n        } else\n          i++;\n      }\n      for (; i >= 0; i--)\n        if (dps[i].d == MD && dbt < 0) {\n          dps[i].d--;\n          dbt++;\n        }\n      if (dbt != 0)\n        console.log("debt left");\n    };\n    UZIP.F._goodIndex = function(v, arr) {\n      var i = 0;\n      if (arr[i | 16] <= v)\n        i |= 16;\n      if (arr[i | 8] <= v)\n        i |= 8;\n      if (arr[i | 4] <= v)\n        i |= 4;\n      if (arr[i | 2] <= v)\n        i |= 2;\n      if (arr[i | 1] <= v)\n        i |= 1;\n      return i;\n    };\n    UZIP.F._writeLit = function(ch, ltree, out, pos) {\n      UZIP.F._putsF(out, pos, ltree[ch << 1]);\n      return pos + ltree[(ch << 1) + 1];\n    };\n    UZIP.F.inflate = function(data, buf) {\n      var u8 = Uint8Array;\n      if (data[0] == 3 && data[1] == 0)\n        return buf ? buf : new u8(0);\n      var F = UZIP.F, bitsF = F._bitsF, bitsE = F._bitsE, decodeTiny = F._decodeTiny, makeCodes = F.makeCodes, codes2map = F.codes2map, get17 = F._get17;\n      var U = F.U;\n      var noBuf = buf == null;\n      if (noBuf)\n        buf = new u8(data.length >>> 2 << 3);\n      var BFINAL = 0, BTYPE = 0, HLIT = 0, HDIST = 0, HCLEN = 0, ML = 0, MD = 0;\n      var off = 0, pos = 0;\n      var lmap, dmap;\n      while (BFINAL == 0) {\n        BFINAL = bitsF(data, pos, 1);\n        BTYPE = bitsF(data, pos + 1, 2);\n        pos += 3;\n        if (BTYPE == 0) {\n          if ((pos & 7) != 0)\n            pos += 8 - (pos & 7);\n          var p8 = (pos >>> 3) + 4, len = data[p8 - 4] | data[p8 - 3] << 8;\n          if (noBuf)\n            buf = UZIP.F._check(buf, off + len);\n          buf.set(new u8(data.buffer, data.byteOffset + p8, len), off);\n          pos = p8 + len << 3;\n          off += len;\n          continue;\n        }\n        if (noBuf)\n          buf = UZIP.F._check(buf, off + (1 << 17));\n        if (BTYPE == 1) {\n          lmap = U.flmap;\n          dmap = U.fdmap;\n          ML = (1 << 9) - 1;\n          MD = (1 << 5) - 1;\n        }\n        if (BTYPE == 2) {\n          HLIT = bitsE(data, pos, 5) + 257;\n          HDIST = bitsE(data, pos + 5, 5) + 1;\n          HCLEN = bitsE(data, pos + 10, 4) + 4;\n          pos += 14;\n          var ppos = pos;\n          for (var i = 0; i < 38; i += 2) {\n            U.itree[i] = 0;\n            U.itree[i + 1] = 0;\n          }\n          var tl = 1;\n          for (var i = 0; i < HCLEN; i++) {\n            var l = bitsE(data, pos + i * 3, 3);\n            U.itree[(U.ordr[i] << 1) + 1] = l;\n            if (l > tl)\n              tl = l;\n          }\n          pos += 3 * HCLEN;\n          makeCodes(U.itree, tl);\n          codes2map(U.itree, tl, U.imap);\n          lmap = U.lmap;\n          dmap = U.dmap;\n          pos = decodeTiny(U.imap, (1 << tl) - 1, HLIT + HDIST, data, pos, U.ttree);\n          var mx0 = F._copyOut(U.ttree, 0, HLIT, U.ltree);\n          ML = (1 << mx0) - 1;\n          var mx1 = F._copyOut(U.ttree, HLIT, HDIST, U.dtree);\n          MD = (1 << mx1) - 1;\n          makeCodes(U.ltree, mx0);\n          codes2map(U.ltree, mx0, lmap);\n          makeCodes(U.dtree, mx1);\n          codes2map(U.dtree, mx1, dmap);\n        }\n        while (true) {\n          var code = lmap[get17(data, pos) & ML];\n          pos += code & 15;\n          var lit = code >>> 4;\n          if (lit >>> 8 == 0) {\n            buf[off++] = lit;\n          } else if (lit == 256) {\n            break;\n          } else {\n            var end = off + lit - 254;\n            if (lit > 264) {\n              var ebs = U.ldef[lit - 257];\n              end = off + (ebs >>> 3) + bitsE(data, pos, ebs & 7);\n              pos += ebs & 7;\n            }\n            var dcode = dmap[get17(data, pos) & MD];\n            pos += dcode & 15;\n            var dlit = dcode >>> 4;\n            var dbs = U.ddef[dlit], dst = (dbs >>> 4) + bitsF(data, pos, dbs & 15);\n            pos += dbs & 15;\n            if (noBuf)\n              buf = UZIP.F._check(buf, off + (1 << 17));\n            while (off < end) {\n              buf[off] = buf[off++ - dst];\n              buf[off] = buf[off++ - dst];\n              buf[off] = buf[off++ - dst];\n              buf[off] = buf[off++ - dst];\n            }\n            off = end;\n          }\n        }\n      }\n      return buf.length == off ? buf : buf.slice(0, off);\n    };\n    UZIP.F._check = function(buf, len) {\n      var bl = buf.length;\n      if (len <= bl)\n        return buf;\n      var nbuf = new Uint8Array(Math.max(bl << 1, len));\n      nbuf.set(buf, 0);\n      return nbuf;\n    };\n    UZIP.F._decodeTiny = function(lmap, LL, len, data, pos, tree) {\n      var bitsE = UZIP.F._bitsE, get17 = UZIP.F._get17;\n      var i = 0;\n      while (i < len) {\n        var code = lmap[get17(data, pos) & LL];\n        pos += code & 15;\n        var lit = code >>> 4;\n        if (lit <= 15) {\n          tree[i] = lit;\n          i++;\n        } else {\n          var ll = 0, n = 0;\n          if (lit == 16) {\n            n = 3 + bitsE(data, pos, 2);\n            pos += 2;\n            ll = tree[i - 1];\n          } else if (lit == 17) {\n            n = 3 + bitsE(data, pos, 3);\n            pos += 3;\n          } else if (lit == 18) {\n            n = 11 + bitsE(data, pos, 7);\n            pos += 7;\n          }\n          var ni = i + n;\n          while (i < ni) {\n            tree[i] = ll;\n            i++;\n          }\n        }\n      }\n      return pos;\n    };\n    UZIP.F._copyOut = function(src, off, len, tree) {\n      var mx = 0, i = 0, tl = tree.length >>> 1;\n      while (i < len) {\n        var v = src[i + off];\n        tree[i << 1] = 0;\n        tree[(i << 1) + 1] = v;\n        if (v > mx)\n          mx = v;\n        i++;\n      }\n      while (i < tl) {\n        tree[i << 1] = 0;\n        tree[(i << 1) + 1] = 0;\n        i++;\n      }\n      return mx;\n    };\n    UZIP.F.makeCodes = function(tree, MAX_BITS) {\n      var U = UZIP.F.U;\n      var max_code = tree.length;\n      var code, bits, n, i, len;\n      var bl_count = U.bl_count;\n      for (var i = 0; i <= MAX_BITS; i++)\n        bl_count[i] = 0;\n      for (i = 1; i < max_code; i += 2)\n        bl_count[tree[i]]++;\n      var next_code = U.next_code;\n      code = 0;\n      bl_count[0] = 0;\n      for (bits = 1; bits <= MAX_BITS; bits++) {\n        code = code + bl_count[bits - 1] << 1;\n        next_code[bits] = code;\n      }\n      for (n = 0; n < max_code; n += 2) {\n        len = tree[n + 1];\n        if (len != 0) {\n          tree[n] = next_code[len];\n          next_code[len]++;\n        }\n      }\n    };\n    UZIP.F.codes2map = function(tree, MAX_BITS, map) {\n      var max_code = tree.length;\n      var U = UZIP.F.U, r15 = U.rev15;\n      for (var i = 0; i < max_code; i += 2)\n        if (tree[i + 1] != 0) {\n          var lit = i >> 1;\n          var cl = tree[i + 1], val2 = lit << 4 | cl;\n          var rest = MAX_BITS - cl, i0 = tree[i] << rest, i1 = i0 + (1 << rest);\n          while (i0 != i1) {\n            var p0 = r15[i0] >>> 15 - MAX_BITS;\n            map[p0] = val2;\n            i0++;\n          }\n        }\n    };\n    UZIP.F.revCodes = function(tree, MAX_BITS) {\n      var r15 = UZIP.F.U.rev15, imb = 15 - MAX_BITS;\n      for (var i = 0; i < tree.length; i += 2) {\n        var i0 = tree[i] << MAX_BITS - tree[i + 1];\n        tree[i] = r15[i0] >>> imb;\n      }\n    };\n    UZIP.F._putsE = function(dt, pos, val2) {\n      val2 = val2 << (pos & 7);\n      var o = pos >>> 3;\n      dt[o] |= val2;\n      dt[o + 1] |= val2 >>> 8;\n    };\n    UZIP.F._putsF = function(dt, pos, val2) {\n      val2 = val2 << (pos & 7);\n      var o = pos >>> 3;\n      dt[o] |= val2;\n      dt[o + 1] |= val2 >>> 8;\n      dt[o + 2] |= val2 >>> 16;\n    };\n    UZIP.F._bitsE = function(dt, pos, length) {\n      return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8) >>> (pos & 7) & (1 << length) - 1;\n    };\n    UZIP.F._bitsF = function(dt, pos, length) {\n      return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8 | dt[(pos >>> 3) + 2] << 16) >>> (pos & 7) & (1 << length) - 1;\n    };\n    UZIP.F._get17 = function(dt, pos) {\n      return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8 | dt[(pos >>> 3) + 2] << 16) >>> (pos & 7);\n    };\n    UZIP.F._get25 = function(dt, pos) {\n      return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8 | dt[(pos >>> 3) + 2] << 16 | dt[(pos >>> 3) + 3] << 24) >>> (pos & 7);\n    };\n    UZIP.F.U = function() {\n      var u16 = Uint16Array, u32 = Uint32Array;\n      return {\n        next_code: new u16(16),\n        bl_count: new u16(16),\n        ordr: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n        of0: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],\n        exb: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],\n        ldef: new u16(32),\n        df0: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],\n        dxb: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],\n        ddef: new u32(32),\n        flmap: new u16(512),\n        fltree: [],\n        fdmap: new u16(32),\n        fdtree: [],\n        lmap: new u16(32768),\n        ltree: [],\n        ttree: [],\n        dmap: new u16(32768),\n        dtree: [],\n        imap: new u16(512),\n        itree: [],\n        //rev9 : new u16(  512)\n        rev15: new u16(1 << 15),\n        lhst: new u32(286),\n        dhst: new u32(30),\n        ihst: new u32(19),\n        lits: new u32(15e3),\n        strt: new u16(1 << 16),\n        prev: new u16(1 << 15)\n      };\n    }();\n    (function() {\n      var U = UZIP.F.U;\n      var len = 1 << 15;\n      for (var i = 0; i < len; i++) {\n        var x = i;\n        x = (x & 2863311530) >>> 1 | (x & 1431655765) << 1;\n        x = (x & 3435973836) >>> 2 | (x & 858993459) << 2;\n        x = (x & 4042322160) >>> 4 | (x & 252645135) << 4;\n        x = (x & 4278255360) >>> 8 | (x & 16711935) << 8;\n        U.rev15[i] = (x >>> 16 | x << 16) >>> 17;\n      }\n      function pushV(tgt, n, sv) {\n        while (n-- != 0)\n          tgt.push(0, sv);\n      }\n      for (var i = 0; i < 32; i++) {\n        U.ldef[i] = U.of0[i] << 3 | U.exb[i];\n        U.ddef[i] = U.df0[i] << 4 | U.dxb[i];\n      }\n      pushV(U.fltree, 144, 8);\n      pushV(U.fltree, 255 - 143, 9);\n      pushV(U.fltree, 279 - 255, 7);\n      pushV(U.fltree, 287 - 279, 8);\n      UZIP.F.makeCodes(U.fltree, 9);\n      UZIP.F.codes2map(U.fltree, 9, U.flmap);\n      UZIP.F.revCodes(U.fltree, 9);\n      pushV(U.fdtree, 32, 5);\n      UZIP.F.makeCodes(U.fdtree, 5);\n      UZIP.F.codes2map(U.fdtree, 5, U.fdmap);\n      UZIP.F.revCodes(U.fdtree, 5);\n      pushV(U.itree, 19, 0);\n      pushV(U.ltree, 286, 0);\n      pushV(U.dtree, 30, 0);\n      pushV(U.ttree, 320, 0);\n    })();\n  }\n});\n\n// treb-export/src/export2.ts\nvar Base64JS2 = __toESM(require_base64_js());\n\n// treb-export/src/column-width.ts\nvar MaximumDigitWidth = 7;\nvar PixelsToColumnWidth = (pixels) => {\n  const characters = Math.floor((pixels - 5) / MaximumDigitWidth * 100 + 0.5) / 100;\n  const column_width = Math.floor((characters * MaximumDigitWidth + 5) / MaximumDigitWidth * 256) / 256;\n  return column_width;\n};\nvar ColumnWidthToPixels = (width) => {\n  const pixels = Math.floor((256 * width + Math.floor(128 / MaximumDigitWidth)) / 256 * MaximumDigitWidth);\n  return pixels;\n};\n\n// treb-export/src/template-2.ts\nvar template = "UEsDBAoAAAAAAAAAIQBi7p1okAQAAJAEAAATAAAAW0NvbnRlbnRfVHlwZXNdLnhtbDw/eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9IlVURi04IiBzdGFuZGFsb25lPSJ5ZXMiPz4NCjxUeXBlcyB4bWxucz0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3BhY2thZ2UvMjAwNi9jb250ZW50LXR5cGVzIj48RGVmYXVsdCBFeHRlbnNpb249InJlbHMiIENvbnRlbnRUeXBlPSJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtcGFja2FnZS5yZWxhdGlvbnNoaXBzK3htbCIvPjxEZWZhdWx0IEV4dGVuc2lvbj0ieG1sIiBDb250ZW50VHlwZT0iYXBwbGljYXRpb24veG1sIi8+PE92ZXJyaWRlIFBhcnROYW1lPSIveGwvd29ya2Jvb2sueG1sIiBDb250ZW50VHlwZT0iYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXQubWFpbit4bWwiLz48T3ZlcnJpZGUgUGFydE5hbWU9Ii94bC93b3Jrc2hlZXRzL3NoZWV0MS54bWwiIENvbnRlbnRUeXBlPSJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC53b3Jrc2hlZXQreG1sIi8+PE92ZXJyaWRlIFBhcnROYW1lPSIveGwvdGhlbWUvdGhlbWUxLnhtbCIgQ29udGVudFR5cGU9ImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC50aGVtZSt4bWwiLz48T3ZlcnJpZGUgUGFydE5hbWU9Ii94bC9zdHlsZXMueG1sIiBDb250ZW50VHlwZT0iYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc3R5bGVzK3htbCIvPjxPdmVycmlkZSBQYXJ0TmFtZT0iL3hsL3NoYXJlZFN0cmluZ3MueG1sIiBDb250ZW50VHlwZT0iYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hhcmVkU3RyaW5ncyt4bWwiLz48T3ZlcnJpZGUgUGFydE5hbWU9Ii9kb2NQcm9wcy9jb3JlLnhtbCIgQ29udGVudFR5cGU9ImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1wYWNrYWdlLmNvcmUtcHJvcGVydGllcyt4bWwiLz48T3ZlcnJpZGUgUGFydE5hbWU9Ii9kb2NQcm9wcy9hcHAueG1sIiBDb250ZW50VHlwZT0iYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LmV4dGVuZGVkLXByb3BlcnRpZXMreG1sIi8+PC9UeXBlcz5QSwMECgAAAAAAAAAhALVVMCNMAgAATAIAAAsAAABfcmVscy8ucmVsczw/eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9IlVURi04IiBzdGFuZGFsb25lPSJ5ZXMiPz4NCjxSZWxhdGlvbnNoaXBzIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvcGFja2FnZS8yMDA2L3JlbGF0aW9uc2hpcHMiPjxSZWxhdGlvbnNoaXAgSWQ9InJJZDMiIFR5cGU9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvZXh0ZW5kZWQtcHJvcGVydGllcyIgVGFyZ2V0PSJkb2NQcm9wcy9hcHAueG1sIi8+PFJlbGF0aW9uc2hpcCBJZD0icklkMiIgVHlwZT0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3BhY2thZ2UvMjAwNi9yZWxhdGlvbnNoaXBzL21ldGFkYXRhL2NvcmUtcHJvcGVydGllcyIgVGFyZ2V0PSJkb2NQcm9wcy9jb3JlLnhtbCIvPjxSZWxhdGlvbnNoaXAgSWQ9InJJZDEiIFR5cGU9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvb2ZmaWNlRG9jdW1lbnQiIFRhcmdldD0ieGwvd29ya2Jvb2sueG1sIi8+PC9SZWxhdGlvbnNoaXBzPlBLAwQKAAAAAAAAACEAunCeZsoGAADKBgAADwAAAHhsL3dvcmtib29rLnhtbDw/eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9IlVURi04IiBzdGFuZGFsb25lPSJ5ZXMiPz4NCjx3b3JrYm9vayB4bWxucz0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3NwcmVhZHNoZWV0bWwvMjAwNi9tYWluIiB4bWxuczpyPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzIiB4bWxuczptYz0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL21hcmt1cC1jb21wYXRpYmlsaXR5LzIwMDYiIG1jOklnbm9yYWJsZT0ieDE1IHhyIHhyNiB4cjEwIHhyMiIgeG1sbnM6eDE1PSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9zcHJlYWRzaGVldG1sLzIwMTAvMTEvbWFpbiIgeG1sbnM6eHI9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3NwcmVhZHNoZWV0bWwvMjAxNC9yZXZpc2lvbiIgeG1sbnM6eHI2PSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9zcHJlYWRzaGVldG1sLzIwMTYvcmV2aXNpb242IiB4bWxuczp4cjEwPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9zcHJlYWRzaGVldG1sLzIwMTYvcmV2aXNpb24xMCIgeG1sbnM6eHIyPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9zcHJlYWRzaGVldG1sLzIwMTUvcmV2aXNpb24yIj48ZmlsZVZlcnNpb24gYXBwTmFtZT0ieGwiIGxhc3RFZGl0ZWQ9IjciIGxvd2VzdEVkaXRlZD0iNyIgcnVwQnVpbGQ9IjIxMTI2Ii8+PHdvcmtib29rUHIgZGVmYXVsdFRoZW1lVmVyc2lvbj0iMTY2OTI1Ii8+PG1jOkFsdGVybmF0ZUNvbnRlbnQgeG1sbnM6bWM9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9tYXJrdXAtY29tcGF0aWJpbGl0eS8yMDA2Ij48bWM6Q2hvaWNlIFJlcXVpcmVzPSJ4MTUiPjx4MTVhYzphYnNQYXRoIHVybD0iSDpcVFJFQlx0cmViLWV4cG9ydFx0ZW1wbGF0ZVwiIHhtbG5zOngxNWFjPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9zcHJlYWRzaGVldG1sLzIwMTAvMTEvYWMiLz48L21jOkNob2ljZT48L21jOkFsdGVybmF0ZUNvbnRlbnQ+PHhyOnJldmlzaW9uUHRyIHJldklETGFzdFNhdmU9IjAiIGRvY3VtZW50SWQ9Ijhfe0Q4NThGOUY3LTBEOTItNEFFNC04QTQyLTQ4MENCMzU5QjYyRH0iIHhyNjpjb2F1dGhWZXJzaW9uTGFzdD0iNDAiIHhyNjpjb2F1dGhWZXJzaW9uTWF4PSI0MCIgeHIxMDp1aWRMYXN0U2F2ZT0iezAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMH0iLz48Ym9va1ZpZXdzPjx3b3JrYm9va1ZpZXcgeFdpbmRvdz0iMCIgeVdpbmRvdz0iMCIgd2luZG93V2lkdGg9IjI0NTcwIiB3aW5kb3dIZWlnaHQ9IjExMTMwIiB4cjI6dWlkPSJ7REU0RTdEMzUtNDkyRC00MEQ3LTk5MjUtNDY0N0Y1ODdFMURFfSIvPjwvYm9va1ZpZXdzPjxzaGVldHM+PHNoZWV0IG5hbWU9IlNoZWV0MSIgc2hlZXRJZD0iMSIgcjppZD0icklkMSIvPjwvc2hlZXRzPjxjYWxjUHIgY2FsY0lkPSIxOTEwMjkiLz48ZXh0THN0PjxleHQgdXJpPSJ7MTQwQTcwOTQtMEUzNS00ODkyLTg0MzItQzREMkU1N0VERUI1fSIgeG1sbnM6eDE1PSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9zcHJlYWRzaGVldG1sLzIwMTAvMTEvbWFpbiI+PHgxNTp3b3JrYm9va1ByIGNoYXJ0VHJhY2tpbmdSZWZCYXNlPSIxIi8+PC9leHQ+PC9leHRMc3Q+PC93b3JrYm9vaz5QSwMECgAAAAAAAAAhAIE+lJe6AgAAugIAABoAAAB4bC9fcmVscy93b3JrYm9vay54bWwucmVsczw/eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9IlVURi04IiBzdGFuZGFsb25lPSJ5ZXMiPz4NCjxSZWxhdGlvbnNoaXBzIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvcGFja2FnZS8yMDA2L3JlbGF0aW9uc2hpcHMiPjxSZWxhdGlvbnNoaXAgSWQ9InJJZDMiIFR5cGU9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvc3R5bGVzIiBUYXJnZXQ9InN0eWxlcy54bWwiLz48UmVsYXRpb25zaGlwIElkPSJySWQyIiBUeXBlPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3RoZW1lIiBUYXJnZXQ9InRoZW1lL3RoZW1lMS54bWwiLz48UmVsYXRpb25zaGlwIElkPSJySWQxIiBUeXBlPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3dvcmtzaGVldCIgVGFyZ2V0PSJ3b3Jrc2hlZXRzL3NoZWV0MS54bWwiLz48UmVsYXRpb25zaGlwIElkPSJySWQ0IiBUeXBlPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3NoYXJlZFN0cmluZ3MiIFRhcmdldD0ic2hhcmVkU3RyaW5ncy54bWwiLz48L1JlbGF0aW9uc2hpcHM+UEsDBAoAAAAAAAAAIQACrURzpAMAAKQDAAAYAAAAeGwvd29ya3NoZWV0cy9zaGVldDEueG1sPD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/Pg0KPHdvcmtzaGVldCB4bWxucz0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3NwcmVhZHNoZWV0bWwvMjAwNi9tYWluIiB4bWxuczpyPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzIiB4bWxuczptYz0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL21hcmt1cC1jb21wYXRpYmlsaXR5LzIwMDYiIG1jOklnbm9yYWJsZT0ieDE0YWMgeHIgeHIyIHhyMyIgeG1sbnM6eDE0YWM9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3NwcmVhZHNoZWV0bWwvMjAwOS85L2FjIiB4bWxuczp4cj0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvc3ByZWFkc2hlZXRtbC8yMDE0L3JldmlzaW9uIiB4bWxuczp4cjI9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3NwcmVhZHNoZWV0bWwvMjAxNS9yZXZpc2lvbjIiIHhtbG5zOnhyMz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvc3ByZWFkc2hlZXRtbC8yMDE2L3JldmlzaW9uMyIgeHI6dWlkPSJ7MEQ4RTVDQTItNUM5RS00RDRCLTk0QzUtRjM1QzA0MUYzOUJEfSI+PGRpbWVuc2lvbiByZWY9IkExIi8+PHNoZWV0Vmlld3M+PHNoZWV0VmlldyB0YWJTZWxlY3RlZD0iMSIgd29ya2Jvb2tWaWV3SWQ9IjAiLz48L3NoZWV0Vmlld3M+PHNoZWV0Rm9ybWF0UHIgZGVmYXVsdFJvd0hlaWdodD0iMTUiIHgxNGFjOmR5RGVzY2VudD0iMC4yNSIvPjxzaGVldERhdGEvPjxwYWdlTWFyZ2lucyBsZWZ0PSIwLjciIHJpZ2h0PSIwLjciIHRvcD0iMC43NSIgYm90dG9tPSIwLjc1IiBoZWFkZXI9IjAuMyIgZm9vdGVyPSIwLjMiLz48L3dvcmtzaGVldD5QSwMECgAAAAAAAAAhAMEXEL7GIAAAxiAAABMAAAB4bC90aGVtZS90aGVtZTEueG1sPD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/Pg0KPGE6dGhlbWUgeG1sbnM6YT0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL2RyYXdpbmdtbC8yMDA2L21haW4iIG5hbWU9Ik9mZmljZSBUaGVtZSI+PGE6dGhlbWVFbGVtZW50cz48YTpjbHJTY2hlbWUgbmFtZT0iT2ZmaWNlIj48YTpkazE+PGE6c3lzQ2xyIHZhbD0id2luZG93VGV4dCIgbGFzdENscj0iMDAwMDAwIi8+PC9hOmRrMT48YTpsdDE+PGE6c3lzQ2xyIHZhbD0id2luZG93IiBsYXN0Q2xyPSJGRkZGRkYiLz48L2E6bHQxPjxhOmRrMj48YTpzcmdiQ2xyIHZhbD0iNDQ1NDZBIi8+PC9hOmRrMj48YTpsdDI+PGE6c3JnYkNsciB2YWw9IkU3RTZFNiIvPjwvYTpsdDI+PGE6YWNjZW50MT48YTpzcmdiQ2xyIHZhbD0iNDQ3MkM0Ii8+PC9hOmFjY2VudDE+PGE6YWNjZW50Mj48YTpzcmdiQ2xyIHZhbD0iRUQ3RDMxIi8+PC9hOmFjY2VudDI+PGE6YWNjZW50Mz48YTpzcmdiQ2xyIHZhbD0iQTVBNUE1Ii8+PC9hOmFjY2VudDM+PGE6YWNjZW50ND48YTpzcmdiQ2xyIHZhbD0iRkZDMDAwIi8+PC9hOmFjY2VudDQ+PGE6YWNjZW50NT48YTpzcmdiQ2xyIHZhbD0iNUI5QkQ1Ii8+PC9hOmFjY2VudDU+PGE6YWNjZW50Nj48YTpzcmdiQ2xyIHZhbD0iNzBBRDQ3Ii8+PC9hOmFjY2VudDY+PGE6aGxpbms+PGE6c3JnYkNsciB2YWw9IjA1NjNDMSIvPjwvYTpobGluaz48YTpmb2xIbGluaz48YTpzcmdiQ2xyIHZhbD0iOTU0RjcyIi8+PC9hOmZvbEhsaW5rPjwvYTpjbHJTY2hlbWU+PGE6Zm9udFNjaGVtZSBuYW1lPSJPZmZpY2UiPjxhOm1ham9yRm9udD48YTpsYXRpbiB0eXBlZmFjZT0iQ2FsaWJyaSBMaWdodCIgcGFub3NlPSIwMjBGMDMwMjAyMDIwNDAzMDIwNCIvPjxhOmVhIHR5cGVmYWNlPSIiLz48YTpjcyB0eXBlZmFjZT0iIi8+PGE6Zm9udCBzY3JpcHQ9IkpwYW4iIHR5cGVmYWNlPSLmuLjjgrTjgrfjg4Pjgq8gTGlnaHQiLz48YTpmb250IHNjcmlwdD0iSGFuZyIgdHlwZWZhY2U9IuunkeydgCDqs6DrlJUiLz48YTpmb250IHNjcmlwdD0iSGFucyIgdHlwZWZhY2U9Iuetiee6vyBMaWdodCIvPjxhOmZvbnQgc2NyaXB0PSJIYW50IiB0eXBlZmFjZT0i5paw57Sw5piO6auUIi8+PGE6Zm9udCBzY3JpcHQ9IkFyYWIiIHR5cGVmYWNlPSJUaW1lcyBOZXcgUm9tYW4iLz48YTpmb250IHNjcmlwdD0iSGViciIgdHlwZWZhY2U9IlRpbWVzIE5ldyBSb21hbiIvPjxhOmZvbnQgc2NyaXB0PSJUaGFpIiB0eXBlZmFjZT0iVGFob21hIi8+PGE6Zm9udCBzY3JpcHQ9IkV0aGkiIHR5cGVmYWNlPSJOeWFsYSIvPjxhOmZvbnQgc2NyaXB0PSJCZW5nIiB0eXBlZmFjZT0iVnJpbmRhIi8+PGE6Zm9udCBzY3JpcHQ9Ikd1anIiIHR5cGVmYWNlPSJTaHJ1dGkiLz48YTpmb250IHNjcmlwdD0iS2htciIgdHlwZWZhY2U9Ik1vb2xCb3JhbiIvPjxhOmZvbnQgc2NyaXB0PSJLbmRhIiB0eXBlZmFjZT0iVHVuZ2EiLz48YTpmb250IHNjcmlwdD0iR3VydSIgdHlwZWZhY2U9IlJhYXZpIi8+PGE6Zm9udCBzY3JpcHQ9IkNhbnMiIHR5cGVmYWNlPSJFdXBoZW1pYSIvPjxhOmZvbnQgc2NyaXB0PSJDaGVyIiB0eXBlZmFjZT0iUGxhbnRhZ2VuZXQgQ2hlcm9rZWUiLz48YTpmb250IHNjcmlwdD0iWWlpaSIgdHlwZWZhY2U9Ik1pY3Jvc29mdCBZaSBCYWl0aSIvPjxhOmZvbnQgc2NyaXB0PSJUaWJ0IiB0eXBlZmFjZT0iTWljcm9zb2Z0IEhpbWFsYXlhIi8+PGE6Zm9udCBzY3JpcHQ9IlRoYWEiIHR5cGVmYWNlPSJNViBCb2xpIi8+PGE6Zm9udCBzY3JpcHQ9IkRldmEiIHR5cGVmYWNlPSJNYW5nYWwiLz48YTpmb250IHNjcmlwdD0iVGVsdSIgdHlwZWZhY2U9IkdhdXRhbWkiLz48YTpmb250IHNjcmlwdD0iVGFtbCIgdHlwZWZhY2U9IkxhdGhhIi8+PGE6Zm9udCBzY3JpcHQ9IlN5cmMiIHR5cGVmYWNlPSJFc3RyYW5nZWxvIEVkZXNzYSIvPjxhOmZvbnQgc2NyaXB0PSJPcnlhIiB0eXBlZmFjZT0iS2FsaW5nYSIvPjxhOmZvbnQgc2NyaXB0PSJNbHltIiB0eXBlZmFjZT0iS2FydGlrYSIvPjxhOmZvbnQgc2NyaXB0PSJMYW9vIiB0eXBlZmFjZT0iRG9rQ2hhbXBhIi8+PGE6Zm9udCBzY3JpcHQ9IlNpbmgiIHR5cGVmYWNlPSJJc2tvb2xhIFBvdGEiLz48YTpmb250IHNjcmlwdD0iTW9uZyIgdHlwZWZhY2U9Ik1vbmdvbGlhbiBCYWl0aSIvPjxhOmZvbnQgc2NyaXB0PSJWaWV0IiB0eXBlZmFjZT0iVGltZXMgTmV3IFJvbWFuIi8+PGE6Zm9udCBzY3JpcHQ9IlVpZ2giIHR5cGVmYWNlPSJNaWNyb3NvZnQgVWlnaHVyIi8+PGE6Zm9udCBzY3JpcHQ9Ikdlb3IiIHR5cGVmYWNlPSJTeWxmYWVuIi8+PGE6Zm9udCBzY3JpcHQ9IkFybW4iIHR5cGVmYWNlPSJBcmlhbCIvPjxhOmZvbnQgc2NyaXB0PSJCdWdpIiB0eXBlZmFjZT0iTGVlbGF3YWRlZSBVSSIvPjxhOmZvbnQgc2NyaXB0PSJCb3BvIiB0eXBlZmFjZT0iTWljcm9zb2Z0IEpoZW5nSGVpIi8+PGE6Zm9udCBzY3JpcHQ9IkphdmEiIHR5cGVmYWNlPSJKYXZhbmVzZSBUZXh0Ii8+PGE6Zm9udCBzY3JpcHQ9Ikxpc3UiIHR5cGVmYWNlPSJTZWdvZSBVSSIvPjxhOmZvbnQgc2NyaXB0PSJNeW1yIiB0eXBlZmFjZT0iTXlhbm1hciBUZXh0Ii8+PGE6Zm9udCBzY3JpcHQ9Ik5rb28iIHR5cGVmYWNlPSJFYnJpbWEiLz48YTpmb250IHNjcmlwdD0iT2xjayIgdHlwZWZhY2U9Ik5pcm1hbGEgVUkiLz48YTpmb250IHNjcmlwdD0iT3NtYSIgdHlwZWZhY2U9IkVicmltYSIvPjxhOmZvbnQgc2NyaXB0PSJQaGFnIiB0eXBlZmFjZT0iUGhhZ3NwYSIvPjxhOmZvbnQgc2NyaXB0PSJTeXJuIiB0eXBlZmFjZT0iRXN0cmFuZ2VsbyBFZGVzc2EiLz48YTpmb250IHNjcmlwdD0iU3lyaiIgdHlwZWZhY2U9IkVzdHJhbmdlbG8gRWRlc3NhIi8+PGE6Zm9udCBzY3JpcHQ9IlN5cmUiIHR5cGVmYWNlPSJFc3RyYW5nZWxvIEVkZXNzYSIvPjxhOmZvbnQgc2NyaXB0PSJTb3JhIiB0eXBlZmFjZT0iTmlybWFsYSBVSSIvPjxhOmZvbnQgc2NyaXB0PSJUYWxlIiB0eXBlZmFjZT0iTWljcm9zb2Z0IFRhaSBMZSIvPjxhOmZvbnQgc2NyaXB0PSJUYWx1IiB0eXBlZmFjZT0iTWljcm9zb2Z0IE5ldyBUYWkgTHVlIi8+PGE6Zm9udCBzY3JpcHQ9IlRmbmciIHR5cGVmYWNlPSJFYnJpbWEiLz48L2E6bWFqb3JGb250PjxhOm1pbm9yRm9udD48YTpsYXRpbiB0eXBlZmFjZT0iQ2FsaWJyaSIgcGFub3NlPSIwMjBGMDUwMjAyMDIwNDAzMDIwNCIvPjxhOmVhIHR5cGVmYWNlPSIiLz48YTpjcyB0eXBlZmFjZT0iIi8+PGE6Zm9udCBzY3JpcHQ9IkpwYW4iIHR5cGVmYWNlPSLmuLjjgrTjgrfjg4Pjgq8iLz48YTpmb250IHNjcmlwdD0iSGFuZyIgdHlwZWZhY2U9IuunkeydgCDqs6DrlJUiLz48YTpmb250IHNjcmlwdD0iSGFucyIgdHlwZWZhY2U9Iuetiee6vyIvPjxhOmZvbnQgc2NyaXB0PSJIYW50IiB0eXBlZmFjZT0i5paw57Sw5piO6auUIi8+PGE6Zm9udCBzY3JpcHQ9IkFyYWIiIHR5cGVmYWNlPSJBcmlhbCIvPjxhOmZvbnQgc2NyaXB0PSJIZWJyIiB0eXBlZmFjZT0iQXJpYWwiLz48YTpmb250IHNjcmlwdD0iVGhhaSIgdHlwZWZhY2U9IlRhaG9tYSIvPjxhOmZvbnQgc2NyaXB0PSJFdGhpIiB0eXBlZmFjZT0iTnlhbGEiLz48YTpmb250IHNjcmlwdD0iQmVuZyIgdHlwZWZhY2U9IlZyaW5kYSIvPjxhOmZvbnQgc2NyaXB0PSJHdWpyIiB0eXBlZmFjZT0iU2hydXRpIi8+PGE6Zm9udCBzY3JpcHQ9IktobXIiIHR5cGVmYWNlPSJEYXVuUGVuaCIvPjxhOmZvbnQgc2NyaXB0PSJLbmRhIiB0eXBlZmFjZT0iVHVuZ2EiLz48YTpmb250IHNjcmlwdD0iR3VydSIgdHlwZWZhY2U9IlJhYXZpIi8+PGE6Zm9udCBzY3JpcHQ9IkNhbnMiIHR5cGVmYWNlPSJFdXBoZW1pYSIvPjxhOmZvbnQgc2NyaXB0PSJDaGVyIiB0eXBlZmFjZT0iUGxhbnRhZ2VuZXQgQ2hlcm9rZWUiLz48YTpmb250IHNjcmlwdD0iWWlpaSIgdHlwZWZhY2U9Ik1pY3Jvc29mdCBZaSBCYWl0aSIvPjxhOmZvbnQgc2NyaXB0PSJUaWJ0IiB0eXBlZmFjZT0iTWljcm9zb2Z0IEhpbWFsYXlhIi8+PGE6Zm9udCBzY3JpcHQ9IlRoYWEiIHR5cGVmYWNlPSJNViBCb2xpIi8+PGE6Zm9udCBzY3JpcHQ9IkRldmEiIHR5cGVmYWNlPSJNYW5nYWwiLz48YTpmb250IHNjcmlwdD0iVGVsdSIgdHlwZWZhY2U9IkdhdXRhbWkiLz48YTpmb250IHNjcmlwdD0iVGFtbCIgdHlwZWZhY2U9IkxhdGhhIi8+PGE6Zm9udCBzY3JpcHQ9IlN5cmMiIHR5cGVmYWNlPSJFc3RyYW5nZWxvIEVkZXNzYSIvPjxhOmZvbnQgc2NyaXB0PSJPcnlhIiB0eXBlZmFjZT0iS2FsaW5nYSIvPjxhOmZvbnQgc2NyaXB0PSJNbHltIiB0eXBlZmFjZT0iS2FydGlrYSIvPjxhOmZvbnQgc2NyaXB0PSJMYW9vIiB0eXBlZmFjZT0iRG9rQ2hhbXBhIi8+PGE6Zm9udCBzY3JpcHQ9IlNpbmgiIHR5cGVmYWNlPSJJc2tvb2xhIFBvdGEiLz48YTpmb250IHNjcmlwdD0iTW9uZyIgdHlwZWZhY2U9Ik1vbmdvbGlhbiBCYWl0aSIvPjxhOmZvbnQgc2NyaXB0PSJWaWV0IiB0eXBlZmFjZT0iQXJpYWwiLz48YTpmb250IHNjcmlwdD0iVWlnaCIgdHlwZWZhY2U9Ik1pY3Jvc29mdCBVaWdodXIiLz48YTpmb250IHNjcmlwdD0iR2VvciIgdHlwZWZhY2U9IlN5bGZhZW4iLz48YTpmb250IHNjcmlwdD0iQXJtbiIgdHlwZWZhY2U9IkFyaWFsIi8+PGE6Zm9udCBzY3JpcHQ9IkJ1Z2kiIHR5cGVmYWNlPSJMZWVsYXdhZGVlIFVJIi8+PGE6Zm9udCBzY3JpcHQ9IkJvcG8iIHR5cGVmYWNlPSJNaWNyb3NvZnQgSmhlbmdIZWkiLz48YTpmb250IHNjcmlwdD0iSmF2YSIgdHlwZWZhY2U9IkphdmFuZXNlIFRleHQiLz48YTpmb250IHNjcmlwdD0iTGlzdSIgdHlwZWZhY2U9IlNlZ29lIFVJIi8+PGE6Zm9udCBzY3JpcHQ9Ik15bXIiIHR5cGVmYWNlPSJNeWFubWFyIFRleHQiLz48YTpmb250IHNjcmlwdD0iTmtvbyIgdHlwZWZhY2U9IkVicmltYSIvPjxhOmZvbnQgc2NyaXB0PSJPbGNrIiB0eXBlZmFjZT0iTmlybWFsYSBVSSIvPjxhOmZvbnQgc2NyaXB0PSJPc21hIiB0eXBlZmFjZT0iRWJyaW1hIi8+PGE6Zm9udCBzY3JpcHQ9IlBoYWciIHR5cGVmYWNlPSJQaGFnc3BhIi8+PGE6Zm9udCBzY3JpcHQ9IlN5cm4iIHR5cGVmYWNlPSJFc3RyYW5nZWxvIEVkZXNzYSIvPjxhOmZvbnQgc2NyaXB0PSJTeXJqIiB0eXBlZmFjZT0iRXN0cmFuZ2VsbyBFZGVzc2EiLz48YTpmb250IHNjcmlwdD0iU3lyZSIgdHlwZWZhY2U9IkVzdHJhbmdlbG8gRWRlc3NhIi8+PGE6Zm9udCBzY3JpcHQ9IlNvcmEiIHR5cGVmYWNlPSJOaXJtYWxhIFVJIi8+PGE6Zm9udCBzY3JpcHQ9IlRhbGUiIHR5cGVmYWNlPSJNaWNyb3NvZnQgVGFpIExlIi8+PGE6Zm9udCBzY3JpcHQ9IlRhbHUiIHR5cGVmYWNlPSJNaWNyb3NvZnQgTmV3IFRhaSBMdWUiLz48YTpmb250IHNjcmlwdD0iVGZuZyIgdHlwZWZhY2U9IkVicmltYSIvPjwvYTptaW5vckZvbnQ+PC9hOmZvbnRTY2hlbWU+PGE6Zm10U2NoZW1lIG5hbWU9Ik9mZmljZSI+PGE6ZmlsbFN0eWxlTHN0PjxhOnNvbGlkRmlsbD48YTpzY2hlbWVDbHIgdmFsPSJwaENsciIvPjwvYTpzb2xpZEZpbGw+PGE6Z3JhZEZpbGwgcm90V2l0aFNoYXBlPSIxIj48YTpnc0xzdD48YTpncyBwb3M9IjAiPjxhOnNjaGVtZUNsciB2YWw9InBoQ2xyIj48YTpsdW1Nb2QgdmFsPSIxMTAwMDAiLz48YTpzYXRNb2QgdmFsPSIxMDUwMDAiLz48YTp0aW50IHZhbD0iNjcwMDAiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48YTpncyBwb3M9IjUwMDAwIj48YTpzY2hlbWVDbHIgdmFsPSJwaENsciI+PGE6bHVtTW9kIHZhbD0iMTA1MDAwIi8+PGE6c2F0TW9kIHZhbD0iMTAzMDAwIi8+PGE6dGludCB2YWw9IjczMDAwIi8+PC9hOnNjaGVtZUNscj48L2E6Z3M+PGE6Z3MgcG9zPSIxMDAwMDAiPjxhOnNjaGVtZUNsciB2YWw9InBoQ2xyIj48YTpsdW1Nb2QgdmFsPSIxMDUwMDAiLz48YTpzYXRNb2QgdmFsPSIxMDkwMDAiLz48YTp0aW50IHZhbD0iODEwMDAiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48L2E6Z3NMc3Q+PGE6bGluIGFuZz0iNTQwMDAwMCIgc2NhbGVkPSIwIi8+PC9hOmdyYWRGaWxsPjxhOmdyYWRGaWxsIHJvdFdpdGhTaGFwZT0iMSI+PGE6Z3NMc3Q+PGE6Z3MgcG9zPSIwIj48YTpzY2hlbWVDbHIgdmFsPSJwaENsciI+PGE6c2F0TW9kIHZhbD0iMTAzMDAwIi8+PGE6bHVtTW9kIHZhbD0iMTAyMDAwIi8+PGE6dGludCB2YWw9Ijk0MDAwIi8+PC9hOnNjaGVtZUNscj48L2E6Z3M+PGE6Z3MgcG9zPSI1MDAwMCI+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiPjxhOnNhdE1vZCB2YWw9IjExMDAwMCIvPjxhOmx1bU1vZCB2YWw9IjEwMDAwMCIvPjxhOnNoYWRlIHZhbD0iMTAwMDAwIi8+PC9hOnNjaGVtZUNscj48L2E6Z3M+PGE6Z3MgcG9zPSIxMDAwMDAiPjxhOnNjaGVtZUNsciB2YWw9InBoQ2xyIj48YTpsdW1Nb2QgdmFsPSI5OTAwMCIvPjxhOnNhdE1vZCB2YWw9IjEyMDAwMCIvPjxhOnNoYWRlIHZhbD0iNzgwMDAiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48L2E6Z3NMc3Q+PGE6bGluIGFuZz0iNTQwMDAwMCIgc2NhbGVkPSIwIi8+PC9hOmdyYWRGaWxsPjwvYTpmaWxsU3R5bGVMc3Q+PGE6bG5TdHlsZUxzdD48YTpsbiB3PSI2MzUwIiBjYXA9ImZsYXQiIGNtcGQ9InNuZyIgYWxnbj0iY3RyIj48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiLz48L2E6c29saWRGaWxsPjxhOnByc3REYXNoIHZhbD0ic29saWQiLz48YTptaXRlciBsaW09IjgwMDAwMCIvPjwvYTpsbj48YTpsbiB3PSIxMjcwMCIgY2FwPSJmbGF0IiBjbXBkPSJzbmciIGFsZ249ImN0ciI+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9InBoQ2xyIi8+PC9hOnNvbGlkRmlsbD48YTpwcnN0RGFzaCB2YWw9InNvbGlkIi8+PGE6bWl0ZXIgbGltPSI4MDAwMDAiLz48L2E6bG4+PGE6bG4gdz0iMTkwNTAiIGNhcD0iZmxhdCIgY21wZD0ic25nIiBhbGduPSJjdHIiPjxhOnNvbGlkRmlsbD48YTpzY2hlbWVDbHIgdmFsPSJwaENsciIvPjwvYTpzb2xpZEZpbGw+PGE6cHJzdERhc2ggdmFsPSJzb2xpZCIvPjxhOm1pdGVyIGxpbT0iODAwMDAwIi8+PC9hOmxuPjwvYTpsblN0eWxlTHN0PjxhOmVmZmVjdFN0eWxlTHN0PjxhOmVmZmVjdFN0eWxlPjxhOmVmZmVjdExzdC8+PC9hOmVmZmVjdFN0eWxlPjxhOmVmZmVjdFN0eWxlPjxhOmVmZmVjdExzdC8+PC9hOmVmZmVjdFN0eWxlPjxhOmVmZmVjdFN0eWxlPjxhOmVmZmVjdExzdD48YTpvdXRlclNoZHcgYmx1clJhZD0iNTcxNTAiIGRpc3Q9IjE5MDUwIiBkaXI9IjU0MDAwMDAiIGFsZ249ImN0ciIgcm90V2l0aFNoYXBlPSIwIj48YTpzcmdiQ2xyIHZhbD0iMDAwMDAwIj48YTphbHBoYSB2YWw9IjYzMDAwIi8+PC9hOnNyZ2JDbHI+PC9hOm91dGVyU2hkdz48L2E6ZWZmZWN0THN0PjwvYTplZmZlY3RTdHlsZT48L2E6ZWZmZWN0U3R5bGVMc3Q+PGE6YmdGaWxsU3R5bGVMc3Q+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9InBoQ2xyIi8+PC9hOnNvbGlkRmlsbD48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiPjxhOnRpbnQgdmFsPSI5NTAwMCIvPjxhOnNhdE1vZCB2YWw9IjE3MDAwMCIvPjwvYTpzY2hlbWVDbHI+PC9hOnNvbGlkRmlsbD48YTpncmFkRmlsbCByb3RXaXRoU2hhcGU9IjEiPjxhOmdzTHN0PjxhOmdzIHBvcz0iMCI+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiPjxhOnRpbnQgdmFsPSI5MzAwMCIvPjxhOnNhdE1vZCB2YWw9IjE1MDAwMCIvPjxhOnNoYWRlIHZhbD0iOTgwMDAiLz48YTpsdW1Nb2QgdmFsPSIxMDIwMDAiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48YTpncyBwb3M9IjUwMDAwIj48YTpzY2hlbWVDbHIgdmFsPSJwaENsciI+PGE6dGludCB2YWw9Ijk4MDAwIi8+PGE6c2F0TW9kIHZhbD0iMTMwMDAwIi8+PGE6c2hhZGUgdmFsPSI5MDAwMCIvPjxhOmx1bU1vZCB2YWw9IjEwMzAwMCIvPjwvYTpzY2hlbWVDbHI+PC9hOmdzPjxhOmdzIHBvcz0iMTAwMDAwIj48YTpzY2hlbWVDbHIgdmFsPSJwaENsciI+PGE6c2hhZGUgdmFsPSI2MzAwMCIvPjxhOnNhdE1vZCB2YWw9IjEyMDAwMCIvPjwvYTpzY2hlbWVDbHI+PC9hOmdzPjwvYTpnc0xzdD48YTpsaW4gYW5nPSI1NDAwMDAwIiBzY2FsZWQ9IjAiLz48L2E6Z3JhZEZpbGw+PC9hOmJnRmlsbFN0eWxlTHN0PjwvYTpmbXRTY2hlbWU+PC9hOnRoZW1lRWxlbWVudHM+PGE6b2JqZWN0RGVmYXVsdHMvPjxhOmV4dHJhQ2xyU2NoZW1lTHN0Lz48YTpleHRMc3Q+PGE6ZXh0IHVyaT0iezA1QTRDMjVDLTA4NUUtNDM0MC04NUEzLUE1NTMxRTUxMERCMn0iPjx0aG0xNTp0aGVtZUZhbWlseSB4bWxuczp0aG0xNT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvdGhlbWVtbC8yMDEyL21haW4iIG5hbWU9Ik9mZmljZSBUaGVtZSIgaWQ9Ins2MkY5MzlCNi05M0FGLTREQjgtOUM2Qi1ENkM3REZEQzU4OUZ9IiB2aWQ9Ins0QTNDNDZFOC02MUNDLTQ2MDMtQTU4OS03NDIyQTQ3QThFNEF9Ii8+PC9hOmV4dD48L2E6ZXh0THN0PjwvYTp0aGVtZT5QSwMECgAAAAAAAAAhAHmhgGxSBgAAUgYAAA0AAAB4bC9zdHlsZXMueG1sPD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/Pg0KPHN0eWxlU2hlZXQgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9zcHJlYWRzaGVldG1sLzIwMDYvbWFpbiIgeG1sbnM6bWM9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9tYXJrdXAtY29tcGF0aWJpbGl0eS8yMDA2IiBtYzpJZ25vcmFibGU9IngxNGFjIHgxNnIyIHhyIiB4bWxuczp4MTRhYz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvc3ByZWFkc2hlZXRtbC8yMDA5LzkvYWMiIHhtbG5zOngxNnIyPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9zcHJlYWRzaGVldG1sLzIwMTUvMDIvbWFpbiIgeG1sbnM6eHI9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3NwcmVhZHNoZWV0bWwvMjAxNC9yZXZpc2lvbiI+PGZvbnRzIGNvdW50PSIxIiB4MTRhYzprbm93bkZvbnRzPSIxIj48Zm9udD48c3ogdmFsPSIxMSIvPjxjb2xvciB0aGVtZT0iMSIvPjxuYW1lIHZhbD0iQ2FsaWJyaSIvPjxmYW1pbHkgdmFsPSIyIi8+PHNjaGVtZSB2YWw9Im1pbm9yIi8+PC9mb250PjwvZm9udHM+PGZpbGxzIGNvdW50PSIyIj48ZmlsbD48cGF0dGVybkZpbGwgcGF0dGVyblR5cGU9Im5vbmUiLz48L2ZpbGw+PGZpbGw+PHBhdHRlcm5GaWxsIHBhdHRlcm5UeXBlPSJncmF5MTI1Ii8+PC9maWxsPjwvZmlsbHM+PGJvcmRlcnMgY291bnQ9IjEiPjxib3JkZXI+PGxlZnQvPjxyaWdodC8+PHRvcC8+PGJvdHRvbS8+PGRpYWdvbmFsLz48L2JvcmRlcj48L2JvcmRlcnM+PGNlbGxTdHlsZVhmcyBjb3VudD0iMSI+PHhmIG51bUZtdElkPSIwIiBmb250SWQ9IjAiIGZpbGxJZD0iMCIgYm9yZGVySWQ9IjAiLz48L2NlbGxTdHlsZVhmcz48Y2VsbFhmcyBjb3VudD0iMSI+PHhmIG51bUZtdElkPSIwIiBmb250SWQ9IjAiIGZpbGxJZD0iMCIgYm9yZGVySWQ9IjAiIHhmSWQ9IjAiLz48L2NlbGxYZnM+PGNlbGxTdHlsZXMgY291bnQ9IjEiPjxjZWxsU3R5bGUgbmFtZT0iTm9ybWFsIiB4ZklkPSIwIiBidWlsdGluSWQ9IjAiLz48L2NlbGxTdHlsZXM+PGR4ZnMgY291bnQ9IjAiLz48dGFibGVTdHlsZXMgY291bnQ9IjAiIGRlZmF1bHRUYWJsZVN0eWxlPSJUYWJsZVN0eWxlTWVkaXVtMiIgZGVmYXVsdFBpdm90U3R5bGU9IlBpdm90U3R5bGVMaWdodDE2Ii8+PGV4dExzdD48ZXh0IHVyaT0ie0VCNzlERUYyLTgwQjgtNDNlNS05NUJELTU0Q0JEREY5MDIwQ30iIHhtbG5zOngxND0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvc3ByZWFkc2hlZXRtbC8yMDA5LzkvbWFpbiI+PHgxNDpzbGljZXJTdHlsZXMgZGVmYXVsdFNsaWNlclN0eWxlPSJTbGljZXJTdHlsZUxpZ2h0MSIvPjwvZXh0PjxleHQgdXJpPSJ7OTI2MEE1MTAtRjMwMS00NmE4LTg2MzUtRjUxMkQ2NEJFNUY1fSIgeG1sbnM6eDE1PSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9zcHJlYWRzaGVldG1sLzIwMTAvMTEvbWFpbiI+PHgxNTp0aW1lbGluZVN0eWxlcyBkZWZhdWx0VGltZWxpbmVTdHlsZT0iVGltZVNsaWNlclN0eWxlTGlnaHQxIi8+PC9leHQ+PC9leHRMc3Q+PC9zdHlsZVNoZWV0PlBLAwQKAAAAAAAAACEA0IywC4EAAACBAAAAFAAAAHhsL3NoYXJlZFN0cmluZ3MueG1sPD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/Pg0KPHNzdCB4bWxucz0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3NwcmVhZHNoZWV0bWwvMjAwNi9tYWluIi8+UEsDBAoAAAAAAAAAIQDcCx83XQIAAF0CAAARAAAAZG9jUHJvcHMvY29yZS54bWw8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJVVEYtOCIgc3RhbmRhbG9uZT0ieWVzIj8+DQo8Y3A6Y29yZVByb3BlcnRpZXMgeG1sbnM6Y3A9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9wYWNrYWdlLzIwMDYvbWV0YWRhdGEvY29yZS1wcm9wZXJ0aWVzIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOmRjdGVybXM9Imh0dHA6Ly9wdXJsLm9yZy9kYy90ZXJtcy8iIHhtbG5zOmRjbWl0eXBlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvIiB4bWxuczp4c2k9Imh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hLWluc3RhbmNlIj48ZGM6Y3JlYXRvcj5kdW5jYW48L2RjOmNyZWF0b3I+PGNwOmxhc3RNb2RpZmllZEJ5PmR1bmNhbjwvY3A6bGFzdE1vZGlmaWVkQnk+PGRjdGVybXM6Y3JlYXRlZCB4c2k6dHlwZT0iZGN0ZXJtczpXM0NEVEYiPjIwMTktMDEtMzFUMTY6NDg6MDNaPC9kY3Rlcm1zOmNyZWF0ZWQ+PGRjdGVybXM6bW9kaWZpZWQgeHNpOnR5cGU9ImRjdGVybXM6VzNDRFRGIj4yMDE5LTAxLTMxVDE2OjQ4OjI4WjwvZGN0ZXJtczptb2RpZmllZD48L2NwOmNvcmVQcm9wZXJ0aWVzPlBLAwQKAAAAAAAAACEAYUkJEBEDAAARAwAAEAAAAGRvY1Byb3BzL2FwcC54bWw8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJVVEYtOCIgc3RhbmRhbG9uZT0ieWVzIj8+DQo8UHJvcGVydGllcyB4bWxucz0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvZXh0ZW5kZWQtcHJvcGVydGllcyIgeG1sbnM6dnQ9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L2RvY1Byb3BzVlR5cGVzIj48QXBwbGljYXRpb24+TWljcm9zb2Z0IEV4Y2VsPC9BcHBsaWNhdGlvbj48RG9jU2VjdXJpdHk+MDwvRG9jU2VjdXJpdHk+PFNjYWxlQ3JvcD5mYWxzZTwvU2NhbGVDcm9wPjxIZWFkaW5nUGFpcnM+PHZ0OnZlY3RvciBzaXplPSIyIiBiYXNlVHlwZT0idmFyaWFudCI+PHZ0OnZhcmlhbnQ+PHZ0Omxwc3RyPldvcmtzaGVldHM8L3Z0Omxwc3RyPjwvdnQ6dmFyaWFudD48dnQ6dmFyaWFudD48dnQ6aTQ+MTwvdnQ6aTQ+PC92dDp2YXJpYW50PjwvdnQ6dmVjdG9yPjwvSGVhZGluZ1BhaXJzPjxUaXRsZXNPZlBhcnRzPjx2dDp2ZWN0b3Igc2l6ZT0iMSIgYmFzZVR5cGU9Imxwc3RyIj48dnQ6bHBzdHI+U2hlZXQxPC92dDpscHN0cj48L3Z0OnZlY3Rvcj48L1RpdGxlc09mUGFydHM+PENvbXBhbnk+PC9Db21wYW55PjxMaW5rc1VwVG9EYXRlPmZhbHNlPC9MaW5rc1VwVG9EYXRlPjxTaGFyZWREb2M+ZmFsc2U8L1NoYXJlZERvYz48SHlwZXJsaW5rc0NoYW5nZWQ+ZmFsc2U8L0h5cGVybGlua3NDaGFuZ2VkPjxBcHBWZXJzaW9uPjE2LjAzMDA8L0FwcFZlcnNpb24+PC9Qcm9wZXJ0aWVzPlBLAQIUAAoAAAAAAAAAIQBi7p1okAQAAJAEAAATAAAAAAAAAAAAAAAAAAAAAABbQ29udGVudF9UeXBlc10ueG1sUEsBAhQACgAAAAAAAAAhALVVMCNMAgAATAIAAAsAAAAAAAAAAAAAAAAAwQQAAF9yZWxzLy5yZWxzUEsBAhQACgAAAAAAAAAhALpwnmbKBgAAygYAAA8AAAAAAAAAAAAAAAAANgcAAHhsL3dvcmtib29rLnhtbFBLAQIUAAoAAAAAAAAAIQCBPpSXugIAALoCAAAaAAAAAAAAAAAAAAAAAC0OAAB4bC9fcmVscy93b3JrYm9vay54bWwucmVsc1BLAQIUAAoAAAAAAAAAIQACrURzpAMAAKQDAAAYAAAAAAAAAAAAAAAAAB8RAAB4bC93b3Jrc2hlZXRzL3NoZWV0MS54bWxQSwECFAAKAAAAAAAAACEAwRcQvsYgAADGIAAAEwAAAAAAAAAAAAAAAAD5FAAAeGwvdGhlbWUvdGhlbWUxLnhtbFBLAQIUAAoAAAAAAAAAIQB5oYBsUgYAAFIGAAANAAAAAAAAAAAAAAAAAPA1AAB4bC9zdHlsZXMueG1sUEsBAhQACgAAAAAAAAAhANCMsAuBAAAAgQAAABQAAAAAAAAAAAAAAAAAbTwAAHhsL3NoYXJlZFN0cmluZ3MueG1sUEsBAhQACgAAAAAAAAAhANwLHzddAgAAXQIAABEAAAAAAAAAAAAAAAAAID0AAGRvY1Byb3BzL2NvcmUueG1sUEsBAhQACgAAAAAAAAAhAGFJCRARAwAAEQMAABAAAAAAAAAAAAAAAAAArD8AAGRvY1Byb3BzL2FwcC54bWxQSwUGAAAAAAoACgCAAgAA60IAAAAA";\n\n// treb-base-types/src/area.ts\nvar IsCellAddress = (obj) => {\n  return obj !== null && typeof obj === "object" && "row" in obj && "column" in obj;\n};\nvar Area = class _Area {\n  // }, IterableIterator<ICellAddress> {\n  // tslint:disable-next-line:variable-name\n  start_;\n  // tslint:disable-next-line:variable-name\n  end_;\n  /**\n   *\n   * @param start\n   * @param end\n   * @param normalize: calls the normalize function\n   */\n  constructor(start, end = start, normalize = false) {\n    this.end_ = this.PatchNull(end);\n    this.start_ = this.PatchNull(start);\n    if (normalize)\n      this.Normalize();\n  }\n  static FromColumn(column) {\n    return new _Area({ row: Infinity, column });\n  }\n  static FromRow(row) {\n    return new _Area({ row, column: Infinity });\n  }\n  static ColumnToLabel(c) {\n    let s = String.fromCharCode(65 + c % 26);\n    while (c > 25) {\n      c = Math.floor(c / 26) - 1;\n      s = String.fromCharCode(65 + c % 26) + s;\n    }\n    return s;\n  }\n  static CellAddressToLabel(address, sheet_id = false) {\n    const prefix = sheet_id ? `${address.sheet_id || 0}!` : "";\n    return prefix + (address.absolute_column ? "$" : "") + this.ColumnToLabel(address.column) + (address.absolute_row ? "$" : "") + (address.row + 1);\n  }\n  /**\n   * merge two areas and return a new area.\n   * UPDATE to support arbitrary arguments\n   */\n  static Join(base, ...args) {\n    const area = new _Area(base.start, base.end);\n    for (const arg of args) {\n      if (arg) {\n        area.ConsumeAddress(arg.start);\n        area.ConsumeAddress(arg.end);\n      }\n    }\n    return area;\n  }\n  /**\n   * creates an area that expands the original area in all directions\n   * (except at the top/left edges)\n   */\n  static Bleed(area, length = 1) {\n    return new _Area({\n      row: Math.max(0, area.start.row - length),\n      column: Math.max(0, area.start.column - length),\n      sheet_id: area.start.sheet_id\n    }, {\n      row: area.end.row + length,\n      column: area.end.column + length\n    });\n  }\n  /**\n   * adjust an area in response to an insert/delete operation.\n   * I noticed we were doing this in several places. moved here to unify.\n   * \n   * @param source - the starting area. we\'ll create a new object to return\n   * (we will not mutate in place)\n   */\n  static PatchArea(source, options) {\n    const { before_column, column_count, before_row, row_count } = options;\n    let area = new _Area(source.start, source.end);\n    const sheet_id = source.start.sheet_id;\n    if (column_count && before_column <= area.end.column) {\n      if (column_count > 0) {\n        if (before_column <= area.start.column) {\n          area.Shift(0, column_count);\n        } else if (before_column > area.start.column && before_column <= area.end.column) {\n          area.ConsumeAddress({ row: area.end.row, column: area.end.column + column_count });\n        } else {\n          console.warn(`AA X case 1`, before_column, column_count, JSON.stringify(area));\n        }\n      } else if (column_count < 0) {\n        if (before_column - column_count <= area.start.column) {\n          area.Shift(0, column_count);\n        } else if (before_column <= area.start.column && before_column - column_count > area.end.column) {\n          return false;\n        } else if (before_column <= area.start.column) {\n          const last_column = before_column - column_count - 1;\n          area = new _Area({\n            row: area.start.row,\n            column: last_column + 1 + column_count,\n            sheet_id\n          }, {\n            row: area.end.row,\n            column: area.end.column + column_count\n          });\n        } else if (before_column <= area.end.column) {\n          const last_column = before_column - column_count - 1;\n          if (last_column >= area.end.column) {\n            area = new _Area({\n              row: area.start.row,\n              column: area.start.column,\n              sheet_id\n            }, {\n              row: area.end.row,\n              column: before_column - 1\n            });\n          } else {\n            area = new _Area({\n              row: area.start.row,\n              column: area.start.column,\n              sheet_id\n            }, {\n              row: area.end.row,\n              column: area.start.column + area.columns + column_count - 1\n            });\n          }\n        } else {\n          console.warn(`AA X case 2`, before_column, column_count, JSON.stringify(area));\n        }\n      }\n    }\n    if (row_count && before_row <= area.end.row) {\n      if (row_count > 0) {\n        if (before_row <= area.start.row) {\n          area.Shift(row_count, 0);\n        } else if (before_row > area.start.row && before_row <= area.end.row) {\n          area.ConsumeAddress({ row: area.end.row + row_count, column: area.end.column });\n        } else {\n          console.warn(`AA X case 3`, before_row, row_count, JSON.stringify(area));\n        }\n      } else if (row_count < 0) {\n        if (before_row - row_count <= area.start.row) {\n          area.Shift(row_count, 0);\n        } else if (before_row <= area.start.row && before_row - row_count > area.end.row) {\n          return false;\n        } else if (before_row <= area.start.row) {\n          const last_row = before_row - row_count - 1;\n          area = new _Area({\n            column: area.start.column,\n            row: last_row + 1 + row_count,\n            sheet_id\n          }, {\n            column: area.end.column,\n            row: area.end.row + row_count\n          });\n        } else if (before_row <= area.end.row) {\n          const last_row = before_row - row_count - 1;\n          if (last_row >= area.end.row) {\n            area = new _Area({\n              column: area.start.column,\n              row: area.start.row,\n              sheet_id\n            }, {\n              column: area.end.column,\n              row: before_row - 1\n            });\n          } else {\n            area = new _Area({\n              column: area.start.column,\n              row: area.start.row,\n              sheet_id\n            }, {\n              column: area.end.column,\n              row: area.start.row + area.rows + row_count - 1\n            });\n          }\n        } else {\n          console.warn(`AA X case 4`, before_row, row_count, JSON.stringify(area));\n        }\n      }\n    }\n    return area;\n  }\n  /** accessor returns a _copy_ of the start address */\n  get start() {\n    return { ...this.start_ };\n  }\n  /** accessor */\n  set start(value) {\n    this.start_ = value;\n  }\n  /** accessor returns a _copy_ of the end address */\n  get end() {\n    return { ...this.end_ };\n  }\n  /** accessor */\n  set end(value) {\n    this.end_ = value;\n  }\n  /** returns number of rows, possibly infinity */\n  get rows() {\n    if (this.start_.row === Infinity || this.end_.row === Infinity)\n      return Infinity;\n    return this.end_.row - this.start_.row + 1;\n  }\n  /** returns number of columns, possibly infinity */\n  get columns() {\n    if (this.start_.column === Infinity || this.end_.column === Infinity)\n      return Infinity;\n    return this.end_.column - this.start_.column + 1;\n  }\n  /** returns number of cells, possibly infinity */\n  get count() {\n    return this.rows * this.columns;\n  }\n  /** returns flag indicating this is the entire sheet, usually after "select all" */\n  get entire_sheet() {\n    return this.entire_row && this.entire_column;\n  }\n  /** returns flag indicating this range includes infinite rows */\n  get entire_column() {\n    return this.start_.row === Infinity;\n  }\n  /** returns flag indicating this range includes infinite columns */\n  get entire_row() {\n    return this.start_.column === Infinity;\n  }\n  PatchNull(address) {\n    const copy = { ...address };\n    if (copy.row === null) {\n      copy.row = Infinity;\n    }\n    if (copy.column === null) {\n      copy.column = Infinity;\n    }\n    return copy;\n  }\n  SetSheetID(id) {\n    this.start_.sheet_id = id;\n  }\n  Normalize() {\n    const start = { ...this.start_ };\n    const end = { ...this.end_ };\n    if (start.row === Infinity || end.row === Infinity) {\n      start.row = end.row = Infinity;\n    } else if (start.row > end.row) {\n      start.row = this.end_.row;\n      start.absolute_row = this.end_.absolute_row;\n      end.row = this.start_.row;\n      end.absolute_row = this.start_.absolute_row;\n    }\n    if (start.column === Infinity || end.column === Infinity) {\n      start.column = end.column = Infinity;\n    } else if (start.column > end.column) {\n      start.column = this.end_.column;\n      start.absolute_column = this.end_.absolute_column;\n      end.column = this.start_.column;\n      end.absolute_column = this.start_.absolute_column;\n    }\n    this.start_ = start;\n    this.end_ = end;\n  }\n  /** returns the top-left cell in the area */\n  TopLeft() {\n    const address = { row: 0, column: 0 };\n    if (!this.entire_row)\n      address.column = this.start.column;\n    if (!this.entire_column)\n      address.row = this.start.row;\n    return address;\n  }\n  /** returns the bottom-right cell in the area */\n  BottomRight() {\n    const address = { row: 0, column: 0 };\n    if (!this.entire_row)\n      address.column = this.end.column;\n    if (!this.entire_column)\n      address.row = this.end.row;\n    return address;\n  }\n  ContainsRow(row) {\n    return this.entire_column || row >= this.start_.row && row <= this.end_.row;\n  }\n  ContainsColumn(column) {\n    return this.entire_row || column >= this.start_.column && column <= this.end_.column;\n  }\n  Contains(address) {\n    return (this.entire_column || address.row >= this.start_.row && address.row <= this.end_.row) && (this.entire_row || address.column >= this.start_.column && address.column <= this.end_.column);\n  }\n  /**\n   * returns true if this area completely contains the argument area\n   * (also if areas are ===, as a side effect). note that this returns\n   * true if A contains B, but not vice-versa\n   */\n  ContainsArea(area) {\n    return this.start.column <= area.start.column && this.end.column >= area.end.column && this.start.row <= area.start.row && this.end.row >= area.end.row;\n  }\n  /**\n   * returns true if there\'s an intersection. note that this won\'t work\n   * if there are infinities -- needs real area ?\n   */\n  Intersects(area) {\n    return !(area.start.column > this.end.column || this.start.column > area.end.column || area.start.row > this.end.row || this.start.row > area.end.row);\n  }\n  Equals(area) {\n    return area.start_.row === this.start_.row && area.start_.column === this.start_.column && area.end_.row === this.end_.row && area.end_.column === this.end_.column;\n  }\n  Clone() {\n    return new _Area(this.start, this.end);\n  }\n  Array() {\n    if (this.entire_column || this.entire_row)\n      throw new Error("can\'t convert infinite area to array");\n    const array = new Array(this.rows * this.columns);\n    const sheet_id = this.start_.sheet_id;\n    let index = 0;\n    for (let row = this.start_.row; row <= this.end_.row; row++) {\n      for (let column = this.start_.column; column <= this.end_.column; column++) {\n        array[index++] = { row, column, sheet_id };\n      }\n    }\n    return array;\n  }\n  get left() {\n    const area = new _Area(this.start_, this.end_);\n    area.end_.column = area.start_.column;\n    return area;\n  }\n  get right() {\n    const area = new _Area(this.start_, this.end_);\n    area.start_.column = area.end_.column;\n    return area;\n  }\n  get top() {\n    const area = new _Area(this.start_, this.end_);\n    area.end_.row = area.start_.row;\n    return area;\n  }\n  get bottom() {\n    const area = new _Area(this.start_, this.end_);\n    area.start_.row = area.end_.row;\n    return area;\n  }\n  /** shifts range in place */\n  Shift(rows, columns) {\n    this.start_.row += rows;\n    this.start_.column += columns;\n    this.end_.row += rows;\n    this.end_.column += columns;\n    return this;\n  }\n  /** Resizes range in place so that it includes the given address */\n  ConsumeAddress(addr) {\n    if (!this.entire_row) {\n      if (addr.column < this.start_.column)\n        this.start_.column = addr.column;\n      if (addr.column > this.end_.column)\n        this.end_.column = addr.column;\n    }\n    if (!this.entire_column) {\n      if (addr.row < this.start_.row)\n        this.start_.row = addr.row;\n      if (addr.row > this.end_.row)\n        this.end_.row = addr.row;\n    }\n  }\n  /** Resizes range in place so that it includes the given area (merge) */\n  ConsumeArea(area) {\n    this.ConsumeAddress(area.start);\n    this.ConsumeAddress(area.end);\n  }\n  /** resizes range in place (updates end) */\n  Resize(rows, columns) {\n    this.end_.row = this.start_.row + rows - 1;\n    this.end_.column = this.start_.column + columns - 1;\n    return this;\n  }\n  Iterate(f) {\n    if (this.entire_column || this.entire_row) {\n      console.warn(`don\'t iterate infinite area`);\n      return;\n    }\n    for (let c = this.start_.column; c <= this.end_.column; c++) {\n      for (let r = this.start_.row; r <= this.end_.row; r++) {\n        f({ column: c, row: r, sheet_id: this.start_.sheet_id });\n      }\n    }\n  }\n  /* *\n     * testing: we may have to polyfill for IE11, or just not use it at\n     * all, depending on support level... but it works OK (kind of a clumsy\n     * implementation though).\n     *\n     * as it turns out we don\'t really use iteration that much (I thought\n     * we did) so it\'s probably not worth the polyfill...\n     *\n     * /\n    public next(): IteratorResult<ICellAddress> {\n  \n      // sanity\n  \n      if (this.entire_column || this.entire_row) {\n        console.warn(\'don\\\'t iterate over infinte range\');\n        return { value: undefined, done: true };\n      }\n  \n      // return current, unless it\'s OOB; if so, advance\n  \n      if (this.iterator_index.column > this.end.column) {\n        this.iterator_index.column = this.start_.column;\n        this.iterator_index.row++;\n  \n        if (this.iterator_index.row > this.end.row) {\n          this.ResetIterator();\n          return { value: undefined, done: true };\n        }\n  \n      }\n  \n      const result = { value: { ...this.iterator_index }, done: false };\n      this.iterator_index.column++;\n  \n      return result;\n    }\n  \n    public [Symbol.iterator](): IterableIterator <ICellAddress> {\n      return this;\n    }\n    */\n  /**\n   * returns the range in A1-style spreadsheet addressing. if the\n   * entire sheet is selected, returns nothing (there\'s no way to\n   * express that in A1 notation). returns the row numbers for entire\n   * columns and vice-versa for rows.\n   */\n  get spreadsheet_label() {\n    let s;\n    if (this.entire_sheet)\n      return "";\n    if (this.entire_column) {\n      s = _Area.ColumnToLabel(this.start_.column);\n      s += ":" + _Area.ColumnToLabel(this.end_.column);\n      return s;\n    }\n    if (this.entire_row) {\n      s = String(this.start_.row + 1);\n      s += ":" + (this.end_.row + 1);\n      return s;\n    }\n    s = _Area.CellAddressToLabel(this.start_);\n    if (this.columns > 1 || this.rows > 1)\n      return s + ":" + _Area.CellAddressToLabel(this.end_);\n    return s;\n  }\n  /**\n   * FIXME: is this different than what would be returned if\n   * we just used the default json serializer? (...)\n   * \n   * NOTE: we could return just the start if size === 1. if\n   * you pass an undefined to the Area class ctor it will reuse\n   * the start.\n   * \n   */\n  toJSON() {\n    return {\n      start: { ...this.start_ },\n      end: { ...this.end_ }\n    };\n  }\n  /*\n  private ResetIterator() {\n    this.iterator_index = {\n      row: this.start_.row,\n      column: this.start_.column,\n      sheet_id: this.start_.sheet_id,\n    };\n  }\n  */\n};\n\n// treb-base-types/src/value-type.ts\nvar IsComplex = (value) => {\n  return typeof value === "object" && !!value && typeof value.real === "number" && typeof value.imaginary === "number";\n};\nvar IsDimensionedQuantity = (value) => {\n  return typeof value === "object" && !!value && typeof value.value === "number" && typeof value.unit === "string";\n};\nvar ValueTypeList = [\n  "undefined",\n  "formula",\n  "string",\n  "number",\n  "boolean",\n  "object",\n  "error",\n  "complex",\n  "array",\n  "dimensioned_quantity"\n];\nvar GetValueType = (value) => {\n  switch (typeof value) {\n    case "undefined":\n      return 0 /* undefined */;\n    case "number":\n      return 3 /* number */;\n    case "boolean":\n      return 4 /* boolean */;\n    case "object":\n      if (value === null) {\n        return 0 /* undefined */;\n      } else if (IsComplex(value)) {\n        return 7 /* complex */;\n      } else if (IsDimensionedQuantity(value)) {\n        return 9 /* dimensioned_quantity */;\n      }\n      return 5 /* object */;\n    case "string":\n      if (value[0] === "=") {\n        return 1 /* formula */;\n      }\n      return 2 /* string */;\n    default:\n      return 6 /* error */;\n  }\n};\n\n// treb-base-types/src/cell.ts\nvar Cell = class {\n  // --- static methods -------------------------------------------------------\n  static StringToColumn(s) {\n    let index = 0;\n    s = s.toUpperCase();\n    for (let i = 0; i < s.length; i++) {\n      index *= 26;\n      index += s.charCodeAt(i) - 64;\n    }\n    return index - 1;\n  }\n  /*\n    public static FormulaDependencies(formula: string): Area[] {\n  \n      const dependencies = [];\n  \n      if (!formula) return []; // also matches ""\n      if (formula.trim()[0] !== \'=\') return [];\n  \n      const results = parser.Parse(formula);\n  \n      for (const key of Object.keys(results.dependencies.addresses)){\n        const address = results.dependencies.addresses[key];\n        dependencies.push(new Area(address));\n      }\n  \n      for (const key of Object.keys(results.dependencies.ranges)){\n        const range = results.dependencies.ranges[key];\n        dependencies.push(new Area(range.start, range.end, true));\n      }\n  \n      // dedupe (...)\n  \n      return dependencies;\n  \n    }\n    */\n  /*\n    public static GetValueType(value: unknown): ValueType {\n  \n      switch (typeof value){\n        \n        case \'undefined\':\n          return ValueType.undefined;\n  \n        case \'number\':\n          return ValueType.number;\n  \n        case \'boolean\':\n          return ValueType.boolean;\n  \n        case \'object\':\n          if (value === null) {\n            return ValueType.undefined;\n          }\n          return ValueType.object;\n  \n        case \'string\':\n          if (value[0] === \'=\') {\n            return ValueType.formula;\n          }\n          return ValueType.string;\n  \n        default: // function or symbol\n          return ValueType.error;\n  \n      }\n    }\n    */\n  // --- class fields ---------------------------------------------------------\n  // the basic value, which can be omitted (in the case of an array cell)\n  value;\n  // any;\n  // the value type, js intrinics plus a special type for formula\n  type = 0 /* undefined */;\n  // the calculated value, returned from calculation service\n  calculated;\n  // |FunctionError; // any;\n  // the calculated type. we\'re separating calculation from rendering, since\n  // we may calculate values that we don\'t need to render.\n  calculated_type;\n  // the value formatted as a string, for display. this is separate from the\n  // calculated value, because the renderer might still need to check the\n  // value in the case of negative color or value-based styling.\n  formatted;\n  /**\n   * rendered type may be different than value type: could be a function\n   * returns a number, or an error. rendering an empty value should result\n   * in a string, so you can test on this type -- it should never be 0\n   * (or undefined) if the cell has been rendered.\n   * \n   * NOTE: no one really uses this. it\'s only read in two places -- one in\n   * grid to check if it\'s a number and we want to format as % (which seems \n   * wrong anyway, because what if it\'s a function?) -- and in sheet, as a \n   * flag indicating we have already rendered it (it gets flushed on change).\n   * \n   * so we could maybe remove it or switch to a boolean or something... is \n   * boolean any smaller than number?\n   */\n  rendered_type;\n  // style is an index into the style dictionary, not the actual style\n  // data (FIXME: if style is an object, this would just be a pointer, so\n  // why not just use a reference?)\n  // style:number = 0;\n  style;\n  /** if this cell is part of an array, pointer to the area. */\n  area;\n  /**\n   * if this cell is merged, pointer to the area\n   */\n  merge_area;\n  /** this cell is part of a table */\n  table;\n  /**\n   * opaque data for cell rendering, we can cache some data\n   * that\'s reused frequently (is that wasting space?)\n   *\n   * render data will be flushed any time there is any change to\n   * the cell data or style.\n   *\n   * UPDATE: renderer data is no longer flushed. we set a dirty flag.\n   */\n  renderer_data;\n  /**\n   * step 1: invert flag (dirty -> clean)\n   */\n  render_clean = [];\n  note;\n  /**\n   * moving hyperlink in here, as a cell property. hyperlink will not be\n   * removed on value change, but will be removed on clear/delete.\n   */\n  hyperlink;\n  /* flag indicates do not paint */\n  editing;\n  /** \n   * TODO: add a return value which affects control flow. default/falsy should\n   * behave as now, for backwards compatibility; but it should be possible to\n   * return a value that says "don\'t exit the standard rendering process"\n   * \n   * UPDATE: return value now means "I have handled this", so if you paint you\n   * should return true. that\'s a breaking change but we should get help from\n   * tooling.\n   */\n  render_function;\n  // (options: RenderFunctionOptions) => RenderFunctionResult;\n  click_function;\n  // (options: ClickFunctionOptions) => ClickFunctionResult;\n  /** \n   * moving locked property to style. not because it\'s properly a style,\n   * or not properly a property of cell, but rather because that will allow\n   * us to cascade the property over areas.\n   */\n  /** not editable */\n  // public locked?: boolean;\n  validation;\n  // --- class methods --------------------------------------------------------\n  constructor(value, value_type) {\n    if (typeof value !== "undefined")\n      this.Set(value, value_type);\n  }\n  /** type guard */\n  ValueIsNumber() {\n    return this.type === 3 /* number */;\n  }\n  /** type guard */\n  ValueIsFormula() {\n    return this.type === 1 /* formula */;\n  }\n  /** type guard */\n  ValueIsBoolean() {\n    return this.type === 4 /* boolean */;\n  }\n  /** type guard */\n  ValueIsComplex() {\n    return this.type === 7 /* complex */;\n  }\n  ///\n  /** flush style information and things that rely on it (formatted value) */\n  FlushStyle() {\n    this.formatted = this.rendered_type = this.style = void 0;\n    this.render_clean = [];\n  }\n  /** flush array information */\n  FlushArray() {\n    this.area = void 0;\n  }\n  /** flush cached data: formatted and calculated */\n  FlushCache() {\n    this.calculated = this.calculated_type = this.formatted = this.rendered_type = this.render_function = this.click_function = void 0;\n    this.render_clean = [];\n  }\n  Reset() {\n    this.type = 0 /* undefined */;\n    this.value = this.note = this.hyperlink = this.formatted = this.rendered_type = this.style = this.calculated = this.calculated_type = this.area = this.renderer_data = this.render_function = this.click_function = void 0;\n    this.render_clean = [];\n  }\n  Set(value, type = GetValueType(value)) {\n    this.value = value;\n    this.type = type;\n    this.formatted = this.rendered_type = this.style = this.calculated = this.calculated_type = this.render_function = this.click_function = this.area = void 0;\n    this.render_clean = [];\n  }\n  /** \n   * sets calculated value and flushes cached value \n   */\n  SetCalculatedValue(value, type = GetValueType(value)) {\n    if (value === void 0) {\n      value = 0;\n      type = 3 /* number */;\n    }\n    if (this.calculated === value) {\n      return;\n    }\n    this.calculated = value;\n    this.calculated_type = type;\n    this.formatted = this.rendered_type = void 0;\n    this.render_clean = [];\n  }\n  /* *\n     * composite method for setting value or error, based on value\n     * not used? (...)\n     * /\n    public SetCalculatedValueOrError(value: any, type?: ValueType): void {\n  \n      console.info("SCVE", value, type);\n  \n      if (typeof type === \'undefined\') {\n        if (typeof value === \'object\' && value.error) {\n          type = ValueType.error;\n          value = value.error;\n        }\n        else {\n          type = GetValueType(value);\n        }\n      }\n      if (this.calculated === value) return;\n      this.calculated = value;\n      this.calculated_type = type;\n      this.formatted = this.rendered_type = undefined;\n      this.render_clean = [];\n    }\n    */\n  /**\n   * get value -- calculation result (not formatted) or literal. for\n   * literal strings, we strip leading apostrophes (these are used to\n   * prevent parsing of literal strings that look like other things).\n   */\n  GetValue() {\n    if (this.calculated_type)\n      return this.calculated;\n    if (typeof this.value === "string" && this.value[0] === "\'") {\n      return this.value.slice(1);\n    }\n    return this.value;\n  }\n  /* *\n     * new version of GetValue that preserves errors. for non-errors this\n     * behaves identically to the original GetValue. for errors, returns\n     * an error object {error: string};\n     * /\n    public GetValue2(): CellValue | {error: CellValue} {\n      if (this.calculated_type) {\n        return (this.calculated_type === ValueType.error) ?\n          { error: this.calculated } : this.calculated;\n      }\n      // if (this.type === ValueType.string &&\n      //    this.value && this.value[0] === \'\\\'\') return this.value.slice(1);\n      if (typeof this.value === \'string\' && this.value[0] === \'\\\'\') { return this.value.slice(1); } // @see GetValue\n  \n      return this.value;\n    }\n    */\n  /* *\n     * we have an issue where a reference to an empty cell winds up returning\n     * a string, goes into a numerical calculation, and slows everything down.\n     *\n     * this is kind of a corner case. it\'s not that there\'s a reference to an\n     * empty cell -- that works OK. there\'s a reference to a cell, which is\n     * itself a reference to an empty cell. that\'s why it\'s a function, which\n     * is being returned as a string.\n     *\n     * in this case because it\'s the function value, I think returning 0 is ok.\n     * BUT, it still might make sense to return undefined.\n     * /\n    public GetValue3(): CellValue|{error: string} { // |FunctionError {\n  \n      // so... what is this? shouldn\'t this be an object? (...)\n     \n      if (this.calculated_type) {\n        return (this.calculated_type === ValueType.error) ?\n          { error: this.calculated as string } : this.calculated;\n      }\n  \n      if (this.type === ValueType.formula) {\n        // formula, but no calc type... undefined or zero? (...)\n        return 0; // undefined;\n      }\n      // if (this.type === ValueType.string &&\n      //    this.value && this.value[0] === \'\\\'\') return this.value.slice(1);\n      if (typeof this.value === \'string\' && this.value[0] === \'\\\'\') { return this.value.slice(1); } // @see GetValue\n  \n      return this.value;\n    }\n    */\n  /**\n   * this function follows the rule of GetValue3, which is: if the type\n   * is a function but there is no calculated value, then return 0.\n   */\n  GetValue4() {\n    if (this.calculated_type) {\n      return {\n        type: this.calculated_type,\n        value: this.calculated\n      };\n    }\n    if (this.type === 1 /* formula */) {\n      return {\n        type: 3 /* number */,\n        value: 0\n      };\n    }\n    return {\n      type: this.type,\n      value: typeof this.value === "string" && this.value[0] === "\'" ? this.value.slice(1) : this.value\n      // @see GetValue \n    };\n  }\n  /**\n   * set note. set undefined to clear.\n   */\n  SetNote(note) {\n    this.note = note;\n    this.render_clean = [];\n  }\n  /** sets error (FIXME: error type) */\n  SetCalculationError(err = "ERR") {\n    this.SetCalculatedValue(err, 6 /* error */);\n  }\n  SetArray(area) {\n    this.type = 0 /* undefined */;\n    this.value = this.formatted = this.rendered_type = this.style = this.hyperlink = // note?\n    this.calculated = this.calculated_type = void 0;\n    this.area = area;\n    this.render_clean = [];\n  }\n  SetArrayHead(area, value) {\n    this.type = GetValueType(value);\n    this.value = value;\n    this.formatted = this.rendered_type = this.style = this.calculated = this.calculated_type = void 0;\n    this.area = area;\n    this.render_clean = [];\n  }\n};\n\n// treb-base-types/src/cells.ts\nvar IsFlatData = (test) => {\n  return !test.cells;\n};\nvar IsFlatDataArray = (test) => {\n  return !!test[0] && IsFlatData(test[0]);\n};\nvar IsNestedRowArray = (test) => {\n  return !!test[0] && test[0].row !== void 0;\n};\nvar ValueTypeMap = ValueTypeList.map((key, index) => ({ [key]: index })).reduce((set, value) => ({ ...set, ...value }), {});\nvar Cells = class {\n  /** switching to row-major */\n  data = [];\n  // tslint:disable-next-line:variable-name\n  rows_ = 0;\n  // tslint:disable-next-line:variable-name\n  columns_ = 0;\n  get rows() {\n    return this.rows_;\n  }\n  get columns() {\n    return this.columns_;\n  }\n  /**\n   * the sheet wants to make sure this row exists, probably because it has\n   * a header. so we will update our dimensions to match. we don\'t actually\n   * add data.\n   *\n   * this is not serialized. specific headers aren\'t serialized either, at\n   * the moment, so it\'s sort of irrelevant. if we start serializing headers,\n   * the deserialization routine can call this function to pad out, so we\n   * don\'t need to store it here.\n   */\n  EnsureRow(row) {\n    this.rows_ = Math.max(row + 1, this.rows_);\n  }\n  /** @see EnsureRow */\n  EnsureColumn(column) {\n    this.columns_ = Math.max(column + 1, this.columns_);\n  }\n  /**\n   * this class does none of the validation/correction\n   * required when inserting rows/columns. that should\n   * be done by external logic. this method only does\n   * the mechanical work of inserting rows/columns.\n   */\n  InsertColumns(before = 0, count = 1) {\n    const pre = JSON.parse(JSON.stringify(this.data[13]));\n    this.data = this.data.map((row) => {\n      if (row.length >= before) {\n        const tmp = row.slice(0, before);\n        let index = before + count;\n        const after = row.slice(before);\n        for (let i = 0; i < after.length; i++) {\n          tmp[index++] = after[i];\n        }\n        return tmp;\n      }\n      return row;\n    });\n    this.columns_ += count;\n  }\n  DeleteColumns(index, count = 1) {\n    this.data.forEach((row) => row.splice(index, count));\n    this.columns_ -= count;\n  }\n  DeleteRows(index, count = 1) {\n    this.data.splice(index, count);\n    this.rows_ -= count;\n  }\n  /**\n   * this class does none of the validation/correction\n   * required when inserting rows/columns. that should\n   * be done by external logic. this method only does\n   * the mechanical work of inserting rows/columns.\n   */\n  InsertRows(before = 0, count = 1) {\n    const args = [before, 0, []];\n    for (let i = 1; i < count; i++)\n      args.push([]);\n    Array.prototype.splice.apply(this.data, args);\n    this.rows_ += count;\n  }\n  /**\n   * return the given cell or `undefined`, optionally creating\n   * new cells as necessary\n   *\n   * @param create_new always return a cell\n   */\n  GetCell(address, create_new) {\n    const { row, column } = address;\n    if (!this.data[row]) {\n      if (create_new) {\n        this.data[row] = [];\n        this.rows_ = Math.max(this.rows_, row + 1);\n      } else\n        return void 0;\n    }\n    if (!this.data[row][column]) {\n      if (create_new) {\n        this.data[row][column] = new Cell();\n        this.columns_ = Math.max(this.columns_, column + 1);\n      }\n    }\n    return this.data[row][column];\n  }\n  /**\n     * apply function to range or address. skips empty cells (for now...)\n     * (already have this function, it\'s called "IterateArea". "Apply" is better.)\n     * /\n    public Apply(target: ICellAddress|IArea, func: (cell: Cell) => void): void {\n  \n      if (IsCellAddress(target)) {\n        target = new Area(target);\n      }\n  \n      const start = target.start;\n      const end = target.end;\n  \n      for (let r = start.row; r <= end.row; r++) {\n        if (this.data[r]) {\n          const row = this.data[r];\n          for (let c = start.column; c < end.column; c++) {\n            if (this.data[r][c]) {\n              func.call(undefined, row[c]);\n            }\n          }\n        }\n      }\n  \n    }\n    */\n  /** returns an existing cell or creates a new cell. */\n  EnsureCell(address) {\n    const { row, column } = address;\n    let ref = this.data[row];\n    if (!ref) {\n      this.data[row] = ref = [];\n      this.rows_ = Math.max(this.rows_, row + 1);\n    }\n    let cell = ref[column];\n    if (!cell) {\n      cell = ref[column] = new Cell();\n      this.columns_ = Math.max(this.columns_, column + 1);\n    }\n    return cell;\n  }\n  /**\n   * with the update, we assume the passed-in data is row-major.\n   * when reading an older file, transpose.\n   */\n  FromArray(data = [], transpose = false) {\n    this.data = [];\n    let rows = 0;\n    let columns = 0;\n    if (transpose) {\n      columns = data.length;\n      for (let c = 0; c < columns; c++) {\n        const ref = data[c];\n        rows = Math.max(rows, ref.length);\n        for (let r = 0; r < ref.length; r++) {\n          if (!this.data[r])\n            this.data[r] = [];\n          this.data[r][c] = new Cell(ref[r]);\n        }\n      }\n    } else {\n      rows = data.length;\n      for (let r = 0; r < rows; r++) {\n        const column = [];\n        const ref = data[r];\n        columns = Math.max(columns, ref.length);\n        for (let c = 0; c < ref.length; c++)\n          column[c] = new Cell(ref[c]);\n        this.data[r] = column;\n      }\n    }\n    this.rows_ = rows;\n    this.columns_ = columns;\n  }\n  SerializedTypeToValueType(type) {\n    if (!type) {\n      return void 0;\n    }\n    if (typeof type === "number") {\n      return type;\n    }\n    return ValueTypeMap[type] || void 0;\n  }\n  ValueTypeToSerializedType(type) {\n    return type ? ValueTypeList[type] : void 0;\n  }\n  /**\n   * this method is used for importing legacy data validation types. in those\n   * those we used a numeric enum. we\'re just dropping that altogether (c.f.\n   * ValueType, which we\'re keeping) so we need to translate for backcompat. \n   * it\'s ugly, but it gets us to a better place. we can probably drop at some\n   * point in the future.\n   * \n   * export enum ValidationType {\n   *   List = \'list\',\n   *   Date = \'date\',\n   *   Range = \'range\',\n   *   Number = \'number\',\n   *   Boolean = \'boolean\',\n   * }\n   * \n   */\n  ImportDataValidation(value) {\n    if (typeof value.type === "number") {\n      const types = ["list", "date", "range", "number", "boolean"];\n      value.type = types[value.type];\n      if (!value.type) {\n        return void 0;\n      }\n    }\n    return value;\n  }\n  /**\n   * UPDATE: adding optional style refs, for export\n   */\n  FromJSON(data = [], style_refs) {\n    this.data = [];\n    if (!IsFlatDataArray(data)) {\n      const new_data = [];\n      if (IsNestedRowArray(data)) {\n        for (const block of data) {\n          for (const cell of block.cells) {\n            new_data.push({ ...cell, row: block.row });\n          }\n        }\n      } else {\n        for (const block of data) {\n          for (const cell of block.cells) {\n            new_data.push({ ...cell, column: block.column });\n          }\n        }\n      }\n      data = new_data;\n    }\n    const tables = [];\n    for (const obj of data) {\n      if (!this.data[obj.row])\n        this.data[obj.row] = [];\n      const cell = new Cell(obj.value);\n      if (typeof obj.calculated !== "undefined") {\n        cell.SetCalculatedValue(obj.calculated, this.SerializedTypeToValueType(obj.calculated_type));\n      }\n      if (style_refs) {\n        if (typeof obj.style_ref !== "undefined") {\n          cell.style = style_refs[obj.style_ref];\n        }\n      }\n      if (typeof obj.note !== "undefined") {\n        cell.note = obj.note;\n      }\n      if (typeof obj.hyperlink !== "undefined") {\n        cell.hyperlink = obj.hyperlink;\n      }\n      if (this.data[obj.row][obj.column] && this.data[obj.row][obj.column].area) {\n        cell.area = this.data[obj.row][obj.column].area;\n      }\n      this.data[obj.row][obj.column] = cell;\n      if (obj.area) {\n        const area = new Area(obj.area.start, obj.area.end);\n        for (let row = area.start.row; row <= area.end.row; row++) {\n          for (let column = area.start.column; column <= area.end.column; column++) {\n            if (!this.data[row])\n              this.data[row] = [];\n            if (!this.data[row][column])\n              this.data[row][column] = new Cell();\n            this.data[row][column].area = area;\n          }\n        }\n      }\n      if (obj.table) {\n        tables.push({\n          ...obj.table\n        });\n      }\n      if (obj.merge_area) {\n        const merge_area = new Area(obj.merge_area.start, obj.merge_area.end);\n        for (let row = merge_area.start.row; row <= merge_area.end.row; row++) {\n          for (let column = merge_area.start.column; column <= merge_area.end.column; column++) {\n            if (!this.data[row])\n              this.data[row] = [];\n            if (!this.data[row][column])\n              this.data[row][column] = new Cell();\n            this.data[row][column].merge_area = merge_area;\n          }\n        }\n      }\n      if (obj.validation) {\n        cell.validation = this.ImportDataValidation(obj.validation);\n      }\n    }\n    for (const table of tables) {\n      for (let row = table.area.start.row; row <= table.area.end.row; row++) {\n        for (let column = table.area.start.column; column <= table.area.end.column; column++) {\n          if (!this.data[row])\n            this.data[row] = [];\n          if (!this.data[row][column])\n            this.data[row][column] = new Cell();\n          this.data[row][column].table = table;\n        }\n      }\n    }\n    this.rows_ = this.data.length;\n    this.columns_ = this.data.reduce((max, row) => Math.max(max, row.length), 0);\n  }\n  toJSON(options = {}) {\n    let start_column = 0;\n    let start_row = 0;\n    let end_row = this.data.length - 1;\n    let end_column;\n    if (options.subset) {\n      start_column = options.subset.start.column;\n      start_row = options.subset.start.row;\n      end_row = options.subset.end.row;\n    }\n    const data = [];\n    let last_row = -1;\n    let last_col = -1;\n    const row_keys = {};\n    const column_keys = {};\n    for (let row = start_row; row <= end_row; row++) {\n      if (this.data[row]) {\n        const ref = this.data[row];\n        end_column = ref.length - 1;\n        if (options.subset)\n          end_column = options.subset.end.column;\n        for (let column = start_column; column <= end_column; column++) {\n          const cell = ref[column];\n          const merge_head = cell && cell.merge_area && cell.merge_area.start.row === row && cell.merge_area.start.column === column;\n          const array_head = cell && cell.area && cell.area.start.row === row && cell.area.start.column === column;\n          const table_head = cell && cell.table && cell.table.area.start.row === row && cell.table.area.start.column === column;\n          const is_empty = cell ? cell.type === 2 /* string */ && !cell.value : true;\n          if (cell && (!is_empty || options.preserve_empty_strings) && (merge_head || cell.type || cell.calculated_type && options.expand_arrays || cell.calculated_type && options.calculated_value || cell.note || cell.validation || options.decorated_cells && cell.style && (cell.style.fill || cell.style.border_bottom || cell.style.border_top || cell.style.border_left || cell.style.border_right))) {\n            const obj = { row, column, value: cell.value };\n            if (cell.note) {\n              obj.note = cell.note;\n            }\n            if (cell.hyperlink) {\n              obj.hyperlink = cell.hyperlink;\n            }\n            if (options.preserve_type) {\n              obj.type = this.ValueTypeToSerializedType(cell.type);\n            }\n            if (options.sheet_id)\n              obj.sheet_id = options.sheet_id;\n            if (options.calculated_value && typeof cell.calculated !== "undefined") {\n              obj.calculated = cell.calculated;\n              if (options.preserve_type || cell.calculated_type === 6 /* error */) {\n                obj.calculated_type = this.ValueTypeToSerializedType(cell.calculated_type);\n              }\n            }\n            if (cell.table && table_head) {\n              if (options.tables) {\n                obj.table = JSON.parse(JSON.stringify(cell.table));\n              }\n            }\n            if (cell.area && array_head) {\n              obj.area = cell.area.toJSON();\n            }\n            if (cell.merge_area) {\n              obj.merge_area = cell.merge_area.toJSON();\n            }\n            if (cell.validation) {\n              obj.validation = cell.validation;\n            }\n            if (options.cell_style_refs && options.cell_style_refs[column] && options.cell_style_refs[column][row]) {\n              obj.style_ref = options.cell_style_refs[column][row];\n              options.cell_style_refs[column][row] = 0;\n            }\n            row_keys[row] = row;\n            column_keys[column] = column;\n            last_row = Math.max(row, last_row);\n            last_col = Math.max(column, last_col);\n            data.push(obj);\n          }\n        }\n      }\n    }\n    if (options.nested) {\n      const row_key_map = Object.keys(row_keys);\n      const col_key_map = Object.keys(column_keys);\n      if (row_key_map.length <= col_key_map.length && row_key_map.length) {\n        const cells = {};\n        const new_data = [];\n        for (const element of data) {\n          const { row, ...remainder } = element;\n          if (!cells[element.row])\n            cells[element.row] = [];\n          cells[element.row].push(remainder);\n        }\n        for (const key of row_key_map) {\n          const row = Number(key);\n          new_data.push({ row, cells: cells[row] });\n        }\n        return { data: new_data, rows: last_row, columns: last_col + 1 };\n      } else if (col_key_map.length) {\n        const cells = {};\n        const new_data = [];\n        for (const element of data) {\n          const { column, ...remainder } = element;\n          if (!cells[element.column])\n            cells[element.column] = [];\n          cells[element.column].push(remainder);\n        }\n        for (const key of col_key_map) {\n          const column = Number(key);\n          new_data.push({ column, cells: cells[column] });\n        }\n        return { data: new_data, rows: last_row, columns: last_col + 1 };\n      }\n    }\n    return { data, rows: last_row + 1, columns: last_col + 1 };\n  }\n  GetAll(transpose = false) {\n    return this.GetRange({ row: 0, column: 0 }, { row: this.rows_ - 1, column: this.columns_ - 1 }, transpose);\n  }\n  /** simply cannot make this work with overloads (prove me wrong) */\n  Normalize2(from, to) {\n    if (from.column === Infinity) {\n      from = { ...from, column: 0 };\n    }\n    if (from.row === Infinity) {\n      from = { ...from, row: 0 };\n    }\n    if (to.column === Infinity) {\n      to = { ...to, column: this.columns_ - 1 };\n    }\n    if (to.row === Infinity) {\n      to = { ...to, row: this.rows_ - 1 };\n    }\n    return { from, to };\n  }\n  /** simply cannot make this work with overloads (prove me wrong) */\n  Normalize1(from) {\n    if (from.column === Infinity) {\n      from = { ...from, column: 0 };\n    }\n    if (from.row === Infinity) {\n      from = { ...from, row: 0 };\n    }\n    return from;\n  }\n  /**\n   * get raw values (i.e. not calculated). anything outside of actual\n   * range will be undefined OR not populated. \n   *\n   * to match GetRange, we return a single value in the case of a single cell,\n   * or a matrix.\n   *\n   * NOTE that I\'m not sure this is good behavior. if you\'re going to\n   * return a single value for one cell, you should return a vector for\n   * a single row OR a single column. alternatively, you should always\n   * return a matrix.\n   * \n   * @param from\n   * @param to\n   * @param transpose\n   */\n  RawValue(from, to = from) {\n    ({ from, to } = this.Normalize2(from, to));\n    if (from.row === to.row && from.column === to.column) {\n      if (this.data[from.row] && this.data[from.row][from.column]) {\n        return this.data[from.row][from.column].value;\n      }\n      return void 0;\n    }\n    const result = [];\n    const rows = this.data.slice(from.row, to.row + 1);\n    const start = from.column;\n    const end = to.column + 1;\n    for (const source of rows) {\n      const target = [];\n      for (let column = start, index = 0; column < end; column++, index++) {\n        const cell = source[column];\n        target.push(cell ? cell.value : void 0);\n      }\n      result.push(target);\n    }\n    return result;\n  }\n  /** gets range as values */\n  GetRange(from, to, transpose = false) {\n    if (to) {\n      ({ from, to } = this.Normalize2(from, to));\n    } else {\n      from = this.Normalize1(from);\n    }\n    if (!to || from === to || from.column === to.column && from.row === to.row) {\n      if (this.data[from.row] && this.data[from.row][from.column]) {\n        return this.data[from.row][from.column].GetValue();\n      }\n      return void 0;\n    }\n    const value = [];\n    if (transpose) {\n      for (let c = from.column; c <= to.column; c++) {\n        const column = [];\n        for (let r = from.row; r <= to.row; r++) {\n          if (this.data[r] && this.data[r][c])\n            column.push(this.data[r][c].GetValue());\n          else\n            column.push(void 0);\n        }\n        value.push(column);\n      }\n    } else {\n      for (let r = from.row; r <= to.row; r++) {\n        const row = [];\n        for (let c = from.column; c <= to.column; c++) {\n          if (this.data[r] && this.data[r][c])\n            row.push(this.data[r][c].GetValue());\n          else\n            row.push(void 0);\n        }\n        value.push(row);\n      }\n    }\n    return value;\n  }\n  /* *\n     * updated version of GetRange that preserves errors, by calling\n     * the GetValue2 cell function.\n     * /\n    public GetRange2(from: ICellAddress, to?: ICellAddress, transpose = false) {\n  \n      if (!to || from === to || (from.column === to.column && from.row === to.row )){\n        if (this.data[from.row] && this.data[from.row][from.column]){\n          return this.data[from.row][from.column].GetValue2();\n        }\n        return undefined;\n      }\n  \n      const value = [];\n  \n      if (transpose){\n        for ( let c = from.column; c <= to.column; c++ ){\n          const column = [];\n          for ( let r = from.row; r <= to.row; r++ ){\n            if (this.data[r] && this.data[r][c]) column.push(this.data[r][c].GetValue2());\n            else column.push(undefined);\n          }\n          value.push(column);\n        }\n      }\n      else {\n        for ( let r = from.row; r <= to.row; r++ ){\n          const row = [];\n          for ( let c = from.column; c <= to.column; c++ ){\n            if (this.data[r] && this.data[r][c]) row.push(this.data[r][c].GetValue2());\n            else row.push(undefined);\n          }\n          value.push(row);\n        }\n      }\n  \n      return value;\n  \n    }\n    */\n  GetRange4(from, to = from, transpose = false) {\n    ({ from, to } = this.Normalize2(from, to));\n    if (from.row === to.row && from.column === to.column) {\n      if (this.data[from.row] && this.data[from.row][from.column]) {\n        return this.data[from.row][from.column].GetValue4();\n      }\n      return { value: void 0, type: 0 /* undefined */ };\n    }\n    const value = [];\n    if (transpose) {\n      for (let c = from.column; c <= to.column; c++) {\n        const column = [];\n        for (let r = from.row; r <= to.row; r++) {\n          if (this.data[r] && this.data[r][c])\n            column.push(this.data[r][c].GetValue4());\n          else\n            column.push({ type: 0 /* undefined */ });\n        }\n        value.push(column);\n      }\n    } else {\n      for (let r = from.row; r <= to.row; r++) {\n        const row = [];\n        for (let c = from.column; c <= to.column; c++) {\n          if (this.data[r] && this.data[r][c])\n            row.push(this.data[r][c].GetValue4());\n          else\n            row.push({ type: 0 /* undefined */ });\n        }\n        value.push(row);\n      }\n    }\n    return { type: 8 /* array */, value };\n  }\n  /**\n   * apply function to address/area\n   * @deprecated - use Apply2\n   */\n  Apply(area, f, create_missing_cells = false) {\n    if (IsCellAddress(area)) {\n      area = new Area(area);\n    }\n    if (area.entire_column || area.entire_row) {\n      throw new Error(`don\'t iterate infinite cells`);\n    }\n    const start = area.start;\n    const end = area.end;\n    if (create_missing_cells) {\n      for (let r = start.row; r <= end.row; r++) {\n        if (!this.data[r])\n          this.data[r] = [];\n        const row = this.data[r];\n        for (let c = start.column; c <= end.column; c++) {\n          if (!row[c])\n            row[c] = new Cell();\n          f(row[c], c, r);\n        }\n      }\n    } else {\n      for (let r = start.row; r <= end.row; r++) {\n        if (this.data[r]) {\n          const row = this.data[r];\n          for (let c = start.column; c <= end.column; c++) {\n            if (row[c])\n              f(row[c], c, r);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * apply function to address/area\n   * \n   * this version lets you abort by returning false from the callback function\n   */\n  Apply2(area, func, create_missing_cells = false) {\n    if (IsCellAddress(area)) {\n      area = new Area(area);\n    }\n    if (area.entire_column || area.entire_row) {\n      throw new Error(`don\'t iterate infinite cells`);\n    }\n    const start = area.start;\n    const end = area.end;\n    if (create_missing_cells) {\n      for (let r = start.row; r <= end.row; r++) {\n        if (!this.data[r])\n          this.data[r] = [];\n        const row = this.data[r];\n        for (let c = start.column; c <= end.column; c++) {\n          if (!row[c])\n            row[c] = new Cell();\n          if (!func(row[c], c, r)) {\n            return;\n          }\n        }\n      }\n    } else {\n      for (let r = start.row; r <= end.row; r++) {\n        if (this.data[r]) {\n          const row = this.data[r];\n          for (let c = start.column; c <= end.column; c++) {\n            if (row[c]) {\n              if (!func(row[c], c, r)) {\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * set area. shortcut to reduce overhead. consolidates single value\n   * and array value methods, although the implementation is separate.\n   *\n   * watch out for typed arrays, which do not satisfy Array.isArray\n   * \n   * when would this function get a 1D typed array? can\'t figure that out.\n   * just drop for the time being.\n   * \n   */\n  SetArea(area, values) {\n    if (ArrayBuffer.isView(values)) {\n      throw new Error("ABIV");\n    }\n    if (Array.isArray(values)) {\n      for (let r = area.start.row, i = 0; r <= area.end.row; r++, i++) {\n        if (!this.data[r])\n          this.data[r] = [];\n        const row = this.data[r];\n        if (values[i]) {\n          for (let c = area.start.column, j = 0; c <= area.end.column; c++, j++) {\n            if (!row[c])\n              row[c] = new Cell();\n            row[c].Set(values[i][j]);\n          }\n        }\n      }\n    } else {\n      const value_type = GetValueType(values);\n      for (let r = area.start.row; r <= area.end.row; r++) {\n        if (!this.data[r])\n          this.data[r] = [];\n        const row = this.data[r];\n        for (let c = area.start.column; c <= area.end.column; c++) {\n          if (!row[c])\n            row[c] = new Cell();\n          row[c].Set(values, value_type);\n        }\n      }\n    }\n    this.rows_ = Math.max(this.rows_, area.end.row + 1);\n    this.columns_ = Math.max(this.columns_, area.end.column + 1);\n  }\n  /**\n   * iterates over all cells (using loops) and runs function per-cell.\n   * FIXME: switch to indexing on empty indexes? (...)\n   */\n  IterateAll(func) {\n    for (const row of this.data) {\n      if (row) {\n        for (const cell of row) {\n          if (cell) {\n            func(cell);\n          }\n        }\n      }\n    }\n  }\n  /** moved from sheet, so we can do it non-functional style (for perf) */\n  FlushCellStyles() {\n    for (const row of this.data) {\n      if (row) {\n        for (const cell of row) {\n          if (cell) {\n            cell.FlushStyle();\n          }\n        }\n      }\n    }\n  }\n  /** moved from sheet, so we can do it non-functional style (for perf) */\n  FlushCachedValues() {\n    for (const row of this.data) {\n      if (row) {\n        for (const cell of row) {\n          if (cell) {\n            cell.FlushCache();\n          }\n        }\n      }\n    }\n  }\n};\n\n// treb-base-types/src/localization.ts\nvar Localization = class {\n  static locale = "en-us";\n  // default, for node\n  static decimal_separator = ".";\n  static argument_separator = ",";\n  static grouping_separator = ",";\n  static date_components = {\n    short_days: [\n      "Sun",\n      "Mon",\n      "Tue",\n      "Wed",\n      "Thu",\n      "Fri",\n      "Sat"\n    ],\n    long_days: [\n      "Sunday",\n      "Monday",\n      "Tuesday",\n      "Wednesday",\n      "Thursday",\n      "Friday",\n      "Saturday"\n    ],\n    short_months: [\n      "Jan",\n      "Feb",\n      "Mar",\n      "Apr",\n      "May",\n      "Jun",\n      "Jul",\n      "Aug",\n      "Sep",\n      "Oct",\n      "Nov",\n      "Dec"\n    ],\n    long_months: [\n      "January",\n      "February",\n      "March",\n      "April",\n      "May",\n      "June",\n      "July",\n      "August",\n      "September",\n      "October",\n      "November",\n      "December"\n    ]\n  };\n  /**\n   * update the locale. this will be called on module load (should\n   * be just once), but can be called subsequently to update.\n   *\n   * priority:\n   * (1) function argument\n   * (2) get parameter\n   * (3) navigator.languages[0]\n   * (4) navigator.language\n   *\n   * regarding languages[0] vs language, see\n   * https://stackoverflow.com/a/33204290\n   *\n   * @param locale explicitly set locale\n   */\n  static UpdateLocale(locale) {\n    if (locale) {\n      this.locale = locale;\n    } else if (typeof self !== "undefined") {\n      const location = self?.document?.location;\n      if (location && location.search && /locale=([^?&]+?)(?:\\?|$|&)/.test(location.search)) {\n        const match = location.search.match(/locale=(.*?)(?:\\?|$|&)/);\n        if (match)\n          this.locale = match[1];\n        console.info("override locale", this.locale);\n      } else if (typeof navigator !== "undefined") {\n        if (navigator.languages && navigator.languages[0]) {\n          this.locale = navigator.languages[0];\n        } else {\n          this.locale = navigator.language;\n        }\n      }\n    }\n    if (this.locale === "C") {\n      console.warn("Locale not set, defaulting to en-us");\n      this.locale = "en-us";\n    }\n    const decimal_separator = new Intl.NumberFormat(\n      this.locale,\n      { minimumFractionDigits: 1 }\n    ).format(3.3).replace(/\\d/g, "");\n    this.decimal_separator = decimal_separator === "," ? "," : ".";\n    if (this.decimal_separator === ",") {\n      this.argument_separator = ";";\n      this.grouping_separator = " ";\n    } else {\n      this.argument_separator = ",";\n      this.grouping_separator = ",";\n    }\n    let date = new Date(2e3, 0, 2, 12, 0, 0, 0);\n    this.UpdateDateComponent(0, 0, date);\n    date = new Date(2e3, 1, 7, 12, 0, 0, 0);\n    this.UpdateDateComponent(1, 1, date);\n    date = new Date(2e3, 2, 7, 12, 0, 0, 0);\n    this.UpdateDateComponent(2, 2, date);\n    date = new Date(2e3, 3, 5, 12, 0, 0, 0);\n    this.UpdateDateComponent(3, 3, date);\n    date = new Date(2e3, 4, 4, 12, 0, 0, 0);\n    this.UpdateDateComponent(4, 4, date);\n    date = new Date(2e3, 5, 2, 12, 0, 0, 0);\n    this.UpdateDateComponent(5, 5, date);\n    date = new Date(2e3, 6, 1, 12, 0, 0, 0);\n    this.UpdateDateComponent(6, 6, date);\n    date = new Date(2e3, 7, 1, 12, 0, 0, 0);\n    this.UpdateDateComponent(7, -1, date);\n    date = new Date(2e3, 8, 1, 12, 0, 0, 0);\n    this.UpdateDateComponent(8, -1, date);\n    date = new Date(2e3, 9, 1, 12, 0, 0, 0);\n    this.UpdateDateComponent(9, -1, date);\n    date = new Date(2e3, 10, 1, 12, 0, 0, 0);\n    this.UpdateDateComponent(10, -1, date);\n    date = new Date(2e3, 11, 1, 12, 0, 0, 0);\n    this.UpdateDateComponent(11, -1, date);\n  }\n  static UpdateDateComponent(month_index, day_index, date) {\n    if (day_index >= 0) {\n      this.date_components.short_days[day_index] = date.toLocaleString(this.locale, { weekday: "short" });\n      this.date_components.long_days[day_index] = date.toLocaleString(this.locale, { weekday: "long" });\n    }\n    if (month_index >= 0) {\n      this.date_components.short_months[month_index] = date.toLocaleString(this.locale, { month: "short" });\n      this.date_components.long_months[month_index] = date.toLocaleString(this.locale, { month: "long" });\n    }\n  }\n};\nLocalization.UpdateLocale();\n\n// treb-base-types/src/style.ts\nvar empty_json = JSON.stringify({});\nvar Style = {\n  /**\n   * note that there are no default colors; those should be set\n   * in grid when style is applied. that way the default colors for\n   * border, text and background colors will be theme-dependent and\n   * can change.\n   * \n   * @internal\n   */\n  DefaultProperties: {\n    horizontal_align: "",\n    vertical_align: "",\n    number_format: "General",\n    // \'0.######\',   // use symbolic, e.g. "general"\n    nan: "NaN",\n    font_size: { unit: "pt", value: 10.5 },\n    font_face: "sans-serif",\n    bold: false,\n    // drop "font_"\n    italic: false,\n    // ...\n    underline: false,\n    // ...\n    strike: false,\n    // \n    text: { theme: 1 },\n    border_top: 0,\n    // adding defaults so these prune propery\n    border_left: 0,\n    border_right: 0,\n    border_bottom: 0\n  },\n  /**\n   * this is a utility function for callers that use borders, to\n   * reduce testing and facilitate reusable methods\n   * \n   * @internal\n   */\n  CompositeBorders: (style) => {\n    return {\n      top: {\n        width: style.border_top || 0,\n        color: style.border_top_fill || {}\n      },\n      left: {\n        width: style.border_left || 0,\n        color: style.border_left_fill || {}\n      },\n      right: {\n        width: style.border_right || 0,\n        color: style.border_right_fill || {}\n      },\n      bottom: {\n        width: style.border_bottom || 0,\n        color: style.border_bottom_fill || {}\n      }\n    };\n  },\n  /**\n   * merge. returns a new object, does not update dest in place.\n   * NOTE: if it does not update dest in place, then what would be\n   * the use case for a non-delta merge? (...)\n   * \n   * @internal\n   */\n  Merge: (dest, src, delta = true) => {\n    const properties = delta ? { ...dest, ...src } : { ...src };\n    return JSON.parse(JSON.stringify(properties));\n  },\n  /** @internal */\n  Composite: (list) => {\n    return JSON.parse(JSON.stringify(list.reduce((composite, item) => ({ ...composite, ...item }), {})));\n  },\n  /** @internal */\n  Empty: (style) => {\n    return JSON.stringify(style) === empty_json;\n  },\n  /** \n   * this looks like a type guard, we should switch to a union\n   * type and then add real type guards\n   * \n   * @internal \n   */\n  ValidColor: (color) => {\n    return !!(color && !color.none && (color.text || color.theme || color.theme === 0));\n  },\n  /** @internal */\n  ParseFontSize: (text = "", default_unit = "em") => {\n    const match = text.match(/(-*[\\d.]+)\\s*(\\S*)/);\n    if (match) {\n      const value = Number(match[1]);\n      if (!value || isNaN(value) || value < 0) {\n        return {};\n      }\n      const unit = match[2].toLowerCase() || default_unit;\n      if (unit === "pt" || unit === "em" || unit === "%" || unit === "px") {\n        return {\n          font_size: { unit, value }\n        };\n      }\n    }\n    return {};\n  },\n  /**\n   * returns the font size of the properties argument as a ratio of the \n   * base argument. this is intended to show the relative font size of \n   * a spreadsheet cell; so anything with no value should be "1", and\n   * everything else is relative to that.\n   * \n   * we prefer relative sizes (em, essentially) to fixed sizes because\n   * we may have different base font sizes on different platforms (we do,\n   * in fact, on windows because calibri is too small).\n   * \n   * using relative sizes helps ensure that it looks similar, if not \n   * identical, on different platforms.\n   * \n   * @internal\n   */\n  RelativeFontSize: (properties, base) => {\n    let base_pt = 12;\n    let props_pt = 12;\n    switch (properties.font_size?.unit) {\n      case "pt":\n        if (!properties.font_size.value) {\n          return 1;\n        }\n        props_pt = properties.font_size.value;\n        break;\n      case "px":\n        if (!properties.font_size.value) {\n          return 1;\n        }\n        props_pt = Math.round(properties.font_size.value * 300 / 4) / 100;\n        break;\n      case "em":\n        return properties.font_size.value || 1;\n      case "%":\n        return (properties.font_size.value || 100) / 100;\n      default:\n        return 1;\n    }\n    switch (base.font_size?.unit) {\n      case "pt":\n        if (!base.font_size.value) {\n          return 1;\n        }\n        base_pt = base.font_size.value;\n        break;\n      case "px":\n        if (!base.font_size.value) {\n          return 1;\n        }\n        base_pt = Math.round(base.font_size.value * 300 / 4) / 100;\n        break;\n      default:\n        return 1;\n    }\n    return props_pt / base_pt;\n  },\n  /** @internal */\n  FontSize: (properties, prefer_points = true) => {\n    const value = properties.font_size?.value;\n    switch (properties.font_size?.unit) {\n      case "pt":\n        return (value || 12) + "pt";\n      case "px":\n        if (prefer_points) {\n          const points = Math.round((value || 16) * 300 / 4) / 100;\n          return points + "pt";\n        }\n        return (value || 16) + "px";\n      case "em":\n        return (value || 1) + "em";\n      case "%":\n        return (value || 100) + "%";\n    }\n    return "";\n  },\n  /**\n   * returns a string representation suitable for canvas (or style)\n   */\n  Font: (properties, scale = 1) => {\n    const parts = [];\n    if (properties.bold) {\n      parts.push("bold");\n    }\n    if (properties.italic) {\n      parts.push("italic");\n    }\n    parts.push(((properties.font_size?.value || 0) * scale).toFixed(2) + (properties.font_size?.unit || "pt"));\n    parts.push(properties.font_face || "");\n    return parts.join(" ");\n  }\n};\n\n// treb-export/src/export2.ts\nvar import_fast_xml_parser2 = __toESM(require_fxp());\n\n// treb-export/src/unescape_xml.ts\nvar entities = {\n  "&lt;": "<",\n  "&gt;": ">",\n  "&amp;": "&",\n  "&quot;": \'"\',\n  "&apos;": `\'`\n};\nvar regex = /&\\w+;/g;\nvar ShortVersion = (text) => text.replace(regex, (pattern) => entities[pattern] || pattern);\nvar Unescape = ShortVersion;\n\n// treb-export/src/xml-utils.ts\nvar XMLTagProcessor = (name, value) => Unescape(value);\nvar XMLOptions = {\n  ignoreAttributes: false,\n  attributeNamePrefix: "__",\n  trimValues: false,\n  textNodeName: "text__",\n  tagValueProcessor: XMLTagProcessor,\n  ignoreDeclaration: true\n};\nvar XMLOptions2 = {\n  ignoreAttributes: false,\n  // attrNodeName: \'a$\', // FXP v4\n  attributesGroupName: "a$",\n  attributeNamePrefix: "",\n  textNodeName: "t$",\n  trimValues: false,\n  ignoreDeclaration: true,\n  // arrayMode: false, // this was removed in FXP, but false is default anyway\n  isArray: (tagName, jPath, isLeafNode, isAttribute) => {\n    return /Relationship$/.test(tagName);\n  },\n  tagValueProcessor: XMLTagProcessor\n};\nvar XMLUtils = class {\n  /**\n   * @deprecated\n   * \n   * use the array version. it will run in approximately the same\n   * amount of time for non-array structures, and it\'s safer in the\n   * event you have an array somewhere in the node hierarchy.\n   */\n  static FindChild(root = {}, path) {\n    const elements = path.split("/");\n    for (const element of elements) {\n      root = root[element];\n      if (!root) {\n        return void 0;\n      }\n    }\n    return root;\n  }\n  /** \n   * the aim of this function is to handle the case where we don\'t\n   * know where the arrays are -- any element in the path could be\n   * multiple. for example, the path\n   * \n   * a/b/c\n   * \n   * could be reflected in xml as \n   * \n   * <a>\n   *  <b>\n   *   <c/>\n   *   <c/>\n   *  </b>\n   * </a>\n   * \n   * or it could be\n   * \n   * <a>\n   *  <b>\n   *   <c/>\n   *  </b>\n   *  <b>\n   *   <c/>\n   *  </b>\n   * </a>\n   * \n   * in either case we want both "c" elements.\n   */\n  static FindAll(root = {}, path) {\n    const components = path.split("/");\n    if (components[0] === ".") {\n      components.shift();\n    }\n    if (components[0] === "..") {\n      throw new Error(`invalid path (no access to parent)`);\n    }\n    if (components[0] === "") {\n      throw new Error(`invalid path (no access to root)`);\n    }\n    if (components[0] === "**") {\n      throw new Error("ENOTIMPL");\n    }\n    return this.FindAllTail(root, components);\n  }\n  /**\n   * how hard would it be to support wildcards? ...\n   * basically if you see a wildcard, just treat every element as a \n   * match -- right?\n   */\n  static FindAllTail(root, elements) {\n    if (Array.isArray(root)) {\n      return root.reduce((composite, element) => {\n        return composite.concat(this.FindAllTail(element, elements));\n      }, []);\n    }\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      if (element === "*") {\n        root = Object.keys(root).filter((key) => key !== "a$" && key !== "t$").map((key) => root[key]);\n      } else {\n        root = root[element];\n      }\n      if (!root) {\n        return [];\n      }\n      if (Array.isArray(root)) {\n        if (i === elements.length - 1 || root.length === 0) {\n          return root;\n        }\n        const step = elements.slice(1);\n        return root.reduce((composite, element2) => {\n          return composite.concat(this.FindAllTail(element2, step));\n        }, []);\n      }\n    }\n    return [root];\n  }\n};\n\n// treb-export/src/shared-strings2.ts\nvar SharedStrings = class {\n  strings = [];\n  reverse = {};\n  /** read strings table from (pre-parsed) xml; removes any existing strings */\n  FromXML(xml) {\n    this.strings = [];\n    this.reverse = {};\n    let index = 0;\n    for (const si of XMLUtils.FindAll(xml, "sst/si")) {\n      if (si.t) {\n        let base = "";\n        if (typeof si.t === "string") {\n          base = si.t;\n        } else if (si.t.t$) {\n          base = si.t.t$;\n        }\n        this.strings[index] = base;\n        this.reverse[base] = index;\n      } else if (si.r) {\n        const parts = XMLUtils.FindAll(si.r, "t");\n        const composite = parts.map((part) => {\n          return typeof part === "string" ? part : part.t$ || "";\n        }).join("");\n        this.strings[index] = composite;\n        this.reverse[composite] = index;\n      } else {\n        console.warn(` ** unexpected shared string @ ${index}`);\n        console.info(si);\n      }\n      index++;\n    }\n  }\n  /** return a string by index */\n  Get(index) {\n    return this.strings[index];\n  }\n  /** find existing string or insert, and return index */\n  Ensure(text) {\n    if (text[0] === "\'") {\n      text = text.substring(1);\n    }\n    let index = this.reverse[text];\n    if (typeof index === "number") {\n      return index;\n    }\n    index = this.strings.length;\n    this.strings.push(text);\n    this.reverse[text] = index;\n    return index;\n  }\n};\n\n// treb-export/src/workbook-theme2.ts\nvar Theme = class _Theme {\n  // where is this defined?\n  static color_map = [\n    "lt1",\n    // bg 1\n    "dk1",\n    // text 1\n    "lt2",\n    // bg 2\n    "dk2",\n    // text 2\n    "accent1",\n    "accent2",\n    "accent3",\n    "accent4",\n    "accent5",\n    "accent6",\n    "hlink",\n    "folHlink"\n  ];\n  colors = {};\n  // private dom?: ElementTree.ElementTree;\n  FromXML(xml) {\n    const tag = Object.keys(xml)[0];\n    let namespace = "";\n    const match = tag.toString().match(/^(.*?):/);\n    if (match) {\n      namespace = match[1] + ":";\n    }\n    if (xml[tag] && xml[tag][`${namespace}themeElements`]) {\n      const color_scheme = xml[tag][`${namespace}themeElements`][`${namespace}clrScheme`];\n      for (const name of _Theme.color_map) {\n        const element = color_scheme[`${namespace}${name}`];\n        let value;\n        let type = "rgb";\n        if (element[`${namespace}srgbClr`]) {\n          type = "rgb";\n          value = element[`${namespace}srgbClr`].a$.val || "";\n        } else if (element[`${namespace}sysClr`]) {\n          type = "system";\n          value = element[`${namespace}sysClr`].a$.lastClr || "";\n        }\n        this.colors[name] = { name, value, type };\n      }\n    }\n  }\n};\n\n// treb-format/src/number_format_section.ts\nvar NumberFormatSection = class {\n  /** flag: this is a date format */\n  date_format = false;\n  /** flag: this is the string section, don\'t format numbers */\n  string_format = false;\n  /** flag: this is a fractional format */\n  fraction_format = false;\n  /** flag: time in 12-hour format  */\n  twelve_hour = false;\n  /** fraction: fixed denominator */\n  fraction_denominator = 0;\n  /** fraction includes integer */\n  fraction_integer = true;\n  /** align fraction digits (using ???) [TODO] */\n  fraction_align = 0;\n  /** \n   * fraction denominator digits. we will limit to [1,4] but this can\n   * be zero if there\'s an explicit denominator.\n   */\n  fraction_denominator_digits = 0;\n  /** prepend zeros */\n  integer_min_digits = 0;\n  /** append zeros */\n  decimal_min_digits = 0;\n  /** append decimal digits, but not trailing zeros */\n  decimal_max_digits = 0;\n  /** use grouping (only supports groups of 3, no matter where you put the ,) */\n  grouping = false;\n  /** this is a flag for switching whether we append strings to prefix or suffix */\n  has_number_format = false;\n  /** leading string(s) */\n  prefix = [{ text: "" }];\n  /** trailing string(s) */\n  suffix = [{ text: "" }];\n  /**\n   * thousands scaling (trailing commas in the number format section). we set\n   * to zero for a faster flag if no scaling.\n   */\n  scaling = 0;\n  /** flag indicating percent -- will multiply value by 100 */\n  percent = false;\n  /** flag indicating exponential -- turns numbers in to exp format */\n  exponential = false;\n  /** this is a flag for testing -- we don\'t support multiple * in a format */\n  has_asterisk = false;\n};\n\n// treb-format/src/format_parser.ts\nvar ASTERISK = 42;\nvar UNDERSCORE = 95;\nvar QUESTION_MARK = 63;\nvar ZERO = 48;\nvar PERIOD = 46;\nvar COMMA = 44;\nvar PERCENT = 37;\nvar DOUBLE_QUOTE = 34;\nvar NUMBER_SIGN = 35;\nvar SEMICOLON = 59;\nvar BACKSLASH = 92;\nvar AT = 64;\nvar LEFT_BRACE = 91;\nvar RIGHT_BRACE = 93;\nvar UPPERCASE_E = 69;\nvar LOWERCASE_E = 101;\nvar UPPERCASE_H = 72;\nvar LOWERCASE_H = 104;\nvar UPPERCASE_M = 77;\nvar LOWERCASE_M = 109;\nvar UPPERCASE_S = 83;\nvar LOWERCASE_S = 115;\nvar UPPERCASE_D = 68;\nvar LOWERCASE_D = 100;\nvar UPPERCASE_Y = 89;\nvar LOWERCASE_Y = 121;\nvar UPPERCASE_A = 65;\nvar LOWERCASE_A = 97;\nvar FormatParser = class {\n  static date_pattern = false;\n  static pattern = "";\n  static char_index = 0;\n  static characters = [];\n  static sections = [];\n  static current_section = new NumberFormatSection();\n  static preserve_formatting_characters = false;\n  // true;\n  // FIXME: localization\n  static decimal_mark = PERIOD;\n  static group_separator = COMMA;\n  /**\n   * parser is static (essentially a singleton). state is ephemeral.\n   *\n   * it\'s a little hard to unify parsing for dates and numbers.\n   * luckily we don\'t have to parse that often; only when a format\n   * is created. so we will do some extra work here.\n   */\n  static Parse(pattern) {\n    this.pattern = pattern;\n    this.characters = pattern.split("").map((char) => char.charCodeAt(0));\n    this.char_index = 0;\n    this.current_section = new NumberFormatSection();\n    this.sections = [this.current_section];\n    if (this.ParseDatePattern()) {\n      return this.sections;\n    }\n    this.char_index = 0;\n    this.current_section = new NumberFormatSection();\n    this.sections = [this.current_section];\n    while (this.char_index < this.characters.length) {\n      this.ConsumeChar();\n    }\n    return this.sections;\n  }\n  static ConsumeString() {\n    let text = "";\n    if (this.preserve_formatting_characters) {\n      text += this.pattern[this.char_index];\n    }\n    for (++this.char_index; this.char_index < this.characters.length; this.char_index++) {\n      const char = this.characters[this.char_index];\n      switch (char) {\n        case BACKSLASH:\n          if (this.preserve_formatting_characters) {\n            text += this.pattern[this.char_index];\n          }\n          if (this.char_index + 1 < this.characters.length) {\n            text += this.pattern[++this.char_index];\n          }\n          break;\n        case DOUBLE_QUOTE:\n          if (this.preserve_formatting_characters) {\n            text += this.pattern[this.char_index];\n          }\n          this.char_index++;\n          return text;\n        default:\n          text += this.pattern[this.char_index];\n          break;\n      }\n    }\n    throw new Error("unterminated string");\n  }\n  static ConsumeFormatting() {\n    let text = "";\n    for (++this.char_index; this.char_index < this.characters.length; this.char_index++) {\n      const char = this.characters[this.char_index];\n      switch (char) {\n        case BACKSLASH:\n          throw new Error("invalid escape character in formatting block");\n        case RIGHT_BRACE:\n          this.char_index++;\n          return text;\n        default:\n          text += this.pattern[this.char_index];\n          break;\n      }\n    }\n    throw new Error("unterminated format");\n  }\n  /** \n   * pre-scan for fractional format, check for legal/illegal chars.\n   * fraction format has an optional integer, spaces, then the fractional\n   * part. \n   * \n   * except for the denominator, all characters are represented as # or ?, \n   * but formats seem to be a little forgiving (not sure we have to be). \n   * essentially, should look something like\n   * ```\n   * # ##/##\n   * ? ??/??\n   * #/32\n   * #/64\n   * # #/16\n   * ```\n   */\n  static ScanFractionFormat() {\n    const fraction_regex = /^([#?]+ +){0,1}([#?]+)\\/([#?0-9]+)(?:$|[^#?0-9])/;\n    const text = this.pattern.substr(this.char_index);\n    const match = text.match(fraction_regex);\n    if (!match) {\n      return false;\n    }\n    const len = (match[1] || "").length + match[2].length + match[3].length + 1;\n    this.current_section.fraction_format = true;\n    this.current_section.fraction_integer = !!match[1];\n    const fixed_denominator = Number(match[3]);\n    if (!isNaN(fixed_denominator)) {\n      this.current_section.fraction_denominator = fixed_denominator;\n    }\n    this.current_section.decimal_max_digits = this.current_section.fraction_denominator_digits = match[3].length;\n    this.char_index += len;\n    this.current_section.has_number_format = true;\n    return true;\n  }\n  /**\n   * number format proper contains only the following characters:\n   * +-0#.,\n   * anything else will be ignored\n   * \n   * [UPDATE] fractional number formats can contain spaces and \n   * the / character (in fact they would have to contain that).\n   * \n   */\n  static ConsumeNumberFormat() {\n    let number_part = 0 /* Integer */;\n    for (this.char_index; this.char_index < this.characters.length; this.char_index++) {\n      const char = this.characters[this.char_index];\n      switch (char) {\n        case this.group_separator:\n          {\n            let lookahead_digit = false;\n            for (let i = this.char_index + 1; !lookahead_digit && i < this.characters.length; i++) {\n              const next_char = this.characters[i];\n              if (next_char === this.decimal_mark || next_char === NUMBER_SIGN || next_char === ZERO) {\n                lookahead_digit = true;\n              } else if (next_char !== COMMA) {\n                break;\n              }\n            }\n            if (lookahead_digit) {\n              if (number_part === 1 /* Decimal */) {\n                throw new Error("invalid grouping in decimal part");\n              }\n              this.current_section.grouping = true;\n            } else {\n              this.current_section.scaling = (this.current_section.scaling || 1) * 1e3;\n            }\n          }\n          break;\n        case this.decimal_mark:\n          if (number_part === 1 /* Decimal */) {\n            throw new Error("too many decimal marks");\n          }\n          number_part = 1 /* Decimal */;\n          break;\n        case NUMBER_SIGN:\n          if (number_part === 1 /* Decimal */) {\n            this.current_section.decimal_max_digits++;\n          } else if (this.current_section.integer_min_digits) {\n            this.current_section.integer_min_digits++;\n          }\n          break;\n        case ZERO:\n          if (number_part === 1 /* Decimal */) {\n            this.current_section.decimal_max_digits++;\n            this.current_section.decimal_min_digits = this.current_section.decimal_max_digits;\n          } else {\n            this.current_section.integer_min_digits++;\n          }\n          break;\n        default:\n          return;\n      }\n    }\n  }\n  static AppendCharAsText(advance_pointer = true) {\n    if (this.current_section.has_number_format) {\n      this.current_section.suffix[this.current_section.suffix.length - 1].text += this.pattern[this.char_index];\n    } else {\n      this.current_section.prefix[this.current_section.prefix.length - 1].text += this.pattern[this.char_index];\n    }\n    if (advance_pointer) {\n      this.char_index++;\n    }\n  }\n  static AppendString(text) {\n    if (this.current_section.has_number_format) {\n      this.current_section.suffix[this.current_section.suffix.length - 1].text += text;\n    } else {\n      this.current_section.prefix[this.current_section.prefix.length - 1].text += text;\n    }\n  }\n  static AppendTextPart(part) {\n    if (this.current_section.has_number_format) {\n      this.current_section.suffix.push(part);\n      this.current_section.suffix.push({ text: "" });\n    } else {\n      this.current_section.prefix.push(part);\n      this.current_section.prefix.push({ text: "" });\n    }\n  }\n  static ConsumeChar() {\n    const char = this.characters[this.char_index];\n    if (char === QUESTION_MARK || char === NUMBER_SIGN) {\n      if (!this.current_section.has_number_format && !this.current_section.string_format && this.ScanFractionFormat()) {\n        return;\n      }\n    }\n    switch (char) {\n      case SEMICOLON:\n        this.char_index++;\n        this.current_section = new NumberFormatSection();\n        if (this.sections.length === 3)\n          this.current_section.string_format = true;\n        this.sections.push(this.current_section);\n        break;\n      case AT:\n        this.char_index++;\n        this.AppendTextPart({\n          text: "@",\n          flag: 5 /* literal */\n        });\n        this.current_section.string_format = true;\n        break;\n      case ZERO:\n      case NUMBER_SIGN:\n      case PERIOD:\n      case COMMA:\n        if (!this.current_section.has_number_format && !this.current_section.string_format) {\n          this.ConsumeNumberFormat();\n          this.current_section.has_number_format = true;\n        } else {\n          this.AppendCharAsText();\n        }\n        break;\n      case LEFT_BRACE:\n        this.AppendTextPart({ text: this.ConsumeFormatting(), flag: 6 /* formatting */ });\n        break;\n      case DOUBLE_QUOTE:\n        this.AppendString(this.ConsumeString());\n        break;\n      case QUESTION_MARK:\n        if (this.preserve_formatting_characters) {\n          this.AppendCharAsText();\n        } else {\n          this.AppendTextPart({\n            text: "0",\n            flag: 1 /* hidden */\n          });\n          this.char_index++;\n        }\n        break;\n      case UNDERSCORE:\n        if (this.preserve_formatting_characters) {\n          this.AppendCharAsText();\n        } else {\n          if (++this.char_index >= this.characters.length) {\n            throw new Error("invalid pad character at end");\n          }\n          this.AppendTextPart({\n            text: this.pattern[this.char_index++],\n            flag: 1 /* hidden */\n          });\n        }\n        break;\n      case ASTERISK:\n        if (this.current_section.has_asterisk) {\n          throw new Error(`we don\'t support multiple asterisks`);\n        }\n        if (this.preserve_formatting_characters) {\n          this.AppendCharAsText();\n        } else {\n          if (++this.char_index >= this.characters.length) {\n            throw new Error("invalid pad character at end");\n          }\n          this.AppendTextPart({\n            text: this.pattern[this.char_index++],\n            flag: 2 /* padded */\n          });\n          this.current_section.has_asterisk = true;\n        }\n        break;\n      case LOWERCASE_E:\n      case UPPERCASE_E:\n        if (this.current_section.percent || this.current_section.exponential || this.current_section.string_format) {\n          this.AppendCharAsText();\n        } else {\n          this.current_section.exponential = true;\n          this.char_index++;\n        }\n        break;\n      case PERCENT:\n        if (!this.current_section.exponential && !this.current_section.string_format) {\n          this.current_section.percent = true;\n        }\n        this.AppendCharAsText();\n        break;\n      case BACKSLASH:\n        if (this.preserve_formatting_characters) {\n          this.AppendCharAsText(false);\n        }\n        if (++this.char_index >= this.characters.length) {\n          throw new Error("invalid escape character at end");\n        }\n        this.AppendCharAsText();\n        break;\n      default:\n        this.AppendCharAsText();\n    }\n  }\n  /**\n   * we treat it as a date pattern if there\'s an unquoted date/time letter\n   * (one of [hmsdyHMSDY]). technically mixing date formats and number\n   * formats (#0) is illegal. we will just drop into number formats for those.\n   */\n  static ParseDatePattern() {\n    this.date_pattern = true;\n    while (this.date_pattern && this.char_index < this.pattern.length) {\n      this.DatePatternConsumeChar();\n    }\n    if (this.date_pattern) {\n      this.date_pattern = false;\n      for (const section of this.sections) {\n        for (const part of section.prefix) {\n          if (part.flag && part.flag & (3 /* date_component */ | 4 /* date_component_minutes */)) {\n            this.date_pattern = true;\n          }\n        }\n      }\n    }\n    if (this.date_pattern) {\n      this.sections[0].date_format = true;\n      this.sections[0].prefix.forEach((item, index) => {\n        if (item.flag === 3 /* date_component */ && (item.text === "mm" || item.text === "m")) {\n          if (index) {\n            for (let i = index - 1; i; i--) {\n              const test = this.sections[0].prefix[i];\n              if (test.flag === 3 /* date_component */) {\n                if (/h/i.test(test.text)) {\n                  item.flag = 4 /* date_component_minutes */;\n                  item.text = item.text.toLowerCase();\n                }\n                break;\n              }\n            }\n          }\n          if (index < this.sections[0].prefix.length - 1) {\n            for (let i = index + 1; i < this.sections[0].prefix.length; i++) {\n              const test = this.sections[0].prefix[i];\n              if (test.flag === 3 /* date_component */) {\n                if (/s/i.test(test.text)) {\n                  item.flag = 4 /* date_component_minutes */;\n                  item.text = item.text.toLowerCase();\n                }\n                break;\n              }\n            }\n          }\n        }\n      });\n    }\n    return this.date_pattern;\n  }\n  /**\n   * date parts are repeated sequences (e.g. ddd). we allow\n   * fractional seconds with ss.00.\n   */\n  static ConsumeDatePart() {\n    const initial_char = this.pattern[this.char_index++];\n    const normalized = initial_char.toLowerCase();\n    const part = {\n      text: initial_char,\n      flag: 3 /* date_component */\n    };\n    while (this.pattern[this.char_index] && this.pattern[this.char_index].toLowerCase() === normalized) {\n      part.text += this.pattern[this.char_index++];\n    }\n    if (normalized === "s" && this.pattern[this.char_index] === ".") {\n      part.text += this.pattern[this.char_index++];\n      while (this.pattern[this.char_index] === "0") {\n        part.text += this.pattern[this.char_index++];\n      }\n    }\n    return part;\n  }\n  /**\n   * special patterns for am/pm in date formats\n   */\n  static ConsumeAMPM() {\n    let test = this.pattern.substr(this.char_index, 5);\n    if (test === "am/pm" || test === "AM/PM") {\n      this.char_index += 5;\n      this.sections[0].twelve_hour = true;\n      return { text: test, flag: 3 /* date_component */ };\n    }\n    test = this.pattern.substr(this.char_index, 3);\n    if (test === "a/p" || test === "A/P") {\n      this.char_index += 3;\n      this.sections[0].twelve_hour = true;\n      return { text: test, flag: 3 /* date_component */ };\n    }\n    return void 0;\n  }\n  static DatePatternConsumeChar() {\n    const char = this.characters[this.char_index];\n    switch (char) {\n      case SEMICOLON:\n        this.char_index = this.characters.length;\n        break;\n      case ZERO:\n      case NUMBER_SIGN:\n      case LOWERCASE_E:\n      case UPPERCASE_E:\n      case PERCENT:\n      case AT:\n        this.date_pattern = false;\n        break;\n      case UPPERCASE_H:\n      case LOWERCASE_H:\n      case UPPERCASE_M:\n      case LOWERCASE_M:\n      case UPPERCASE_S:\n      case LOWERCASE_S:\n      case UPPERCASE_D:\n      case LOWERCASE_D:\n      case UPPERCASE_Y:\n      case LOWERCASE_Y:\n        this.AppendTextPart(this.ConsumeDatePart());\n        break;\n      case UPPERCASE_A:\n      case LOWERCASE_A:\n        {\n          const ampm = this.ConsumeAMPM();\n          if (ampm)\n            this.AppendTextPart(ampm);\n          else\n            this.AppendCharAsText();\n        }\n        break;\n      case DOUBLE_QUOTE:\n        this.AppendString(this.ConsumeString());\n        break;\n      case QUESTION_MARK:\n        if (this.preserve_formatting_characters) {\n          this.AppendCharAsText();\n        } else {\n          this.AppendTextPart({\n            text: "0",\n            flag: 1 /* hidden */\n          });\n          this.char_index++;\n        }\n        break;\n      case UNDERSCORE:\n        if (this.preserve_formatting_characters) {\n          this.AppendCharAsText();\n        } else {\n          if (++this.char_index >= this.characters.length) {\n            throw new Error("invalid pad character at end");\n          }\n          this.AppendTextPart({\n            text: this.pattern[this.char_index++],\n            flag: 1 /* hidden */\n          });\n        }\n        break;\n      case ASTERISK:\n        if (this.current_section.has_asterisk) {\n          throw new Error(`we don\'t support multiple asterisks`);\n        }\n        if (this.preserve_formatting_characters) {\n          this.AppendCharAsText();\n        } else {\n          if (++this.char_index >= this.characters.length) {\n            throw new Error("invalid pad character at end");\n          }\n          this.AppendTextPart({\n            text: this.pattern[this.char_index++],\n            flag: 2 /* padded */\n          });\n          this.current_section.has_asterisk = true;\n        }\n        break;\n      case BACKSLASH:\n        if (this.preserve_formatting_characters) {\n          this.AppendCharAsText(false);\n        }\n        if (++this.char_index >= this.characters.length) {\n          throw new Error("invalid escape character at end");\n        }\n        this.AppendCharAsText();\n        break;\n      default:\n        this.AppendCharAsText();\n    }\n  }\n};\n\n// treb-format/src/format.ts\nvar LotusDate = (value) => {\n  if (value >= 60)\n    value--;\n  return new Date(-22090752e5 + 864e5 * value);\n};\nvar UnlotusDate = (value, local = true) => {\n  if (local) {\n    const local_date = new Date(value);\n    const utc_date = /* @__PURE__ */ new Date();\n    utc_date.setUTCMilliseconds(local_date.getUTCMilliseconds());\n    utc_date.setUTCSeconds(local_date.getUTCSeconds());\n    utc_date.setUTCMinutes(local_date.getUTCMinutes());\n    utc_date.setUTCHours(local_date.getHours());\n    utc_date.setUTCDate(local_date.getDate());\n    utc_date.setUTCMonth(local_date.getMonth());\n    utc_date.setUTCFullYear(local_date.getFullYear());\n    value = utc_date.getTime();\n  }\n  value = (value + 22090752e5) / 864e5;\n  if (value >= 60) {\n    value++;\n  }\n  return value;\n};\nvar NumberFormat = class _NumberFormat {\n  static grouping_regexp = /\\d{1,3}(?=(\\d{3})+(?!\\d))/g;\n  static fraction_limits = [9, 99, 999, 9999];\n  /**\n   * this is now exposed so it can be changed, for rendering; some options are \n   * \n   * "i" - regular i, and the default\n   * "\u{1D456}" - mathematical italic small i", U+1D456\n   * "\u200A\u{1D456}" - the same, with a leading hair space (U+200A)\n   */\n  static imaginary_character = "\\u{1D456}";\n  //  \'i\';\n  /**\n   * also for complex rendering, the minus sign. there\'s a unicode \n   * symbol U+2212 which (at least in calibri) is wider than the regular minus \n   * sign/hyphen. I like this but it looks a bit odd if negative numbers are \n   * rendered using the other one.\n   * \n   * "-" - hyphen\n   * "\u2212" - minus\n   */\n  static minus_character = "-";\n  // hyphen\n  // public static minus_character = \'\u2212\'; // minus\n  /** for the "General" format, a magic decimal point */\n  magic_decimal = false;\n  /**\n   * (testing) transformer. this is not rendered or persisted, like magic\n   * decimal it needs to be applied in code. ATM this is only applied in\n   * formatting DQ, but it might turn out to be more universal...\n   * \n   * NOTE that atm this transforms value back into the same type; we don\'t\n   * cross types (at least for now). perhaps we should support that? that\n   * might mean switching in here and removing the "special" format calls\n   * for complex and DQ.\n   */\n  transform_value;\n  // tslint:disable-next-line:variable-name\n  _pattern = "";\n  sections;\n  decimal_zero_regexp = [];\n  // this is a flag for string representation\n  cloned = [];\n  //  NumberFormat.decimal_mark = Localization.decimal_separator;\n  //  if (NumberFormat.decimal_mark === \',\') NumberFormat.grouping_separator = \' \';\n  //  public static decimal_mark: \'.\'|\',\' = Localization.decimal_separator;\n  //  public static grouping_separator = (Localization.decimal_separator === \'.\') ? \',\' : \' \';\n  get pattern() {\n    return this._pattern;\n  }\n  /** flag indicates if this is a date format */\n  get date_format() {\n    return this.sections[0] && this.sections[0].date_format;\n  }\n  constructor(pattern) {\n    this._pattern = pattern;\n    this.sections = FormatParser.Parse(pattern);\n    if (!this.sections.length)\n      this.sections = [];\n    if (!this.sections[0]) {\n      this.sections[0] = new NumberFormatSection();\n    }\n    if (!this.sections[1]) {\n      this.sections[1] = { ...this.sections[0] };\n      this.sections[1].prefix = JSON.parse(JSON.stringify(this.sections[1].prefix));\n      this.sections[1].suffix = JSON.parse(JSON.stringify(this.sections[1].suffix));\n      this.sections[1].prefix.push({ text: "-" });\n      this.cloned[1] = true;\n    }\n    if (!this.sections[2]) {\n      this.sections[2] = { ...this.sections[0] };\n      this.cloned[2] = true;\n    }\n    if (!this.sections[3]) {\n      for (const part of this.sections[0].prefix) {\n        if (part.flag === 5 /* literal */) {\n          this.sections[3] = { ...this.sections[0] };\n          this.sections[3].string_format = true;\n          this.cloned[3] = true;\n          break;\n        }\n      }\n    }\n    this.decimal_zero_regexp = this.sections.map((section) => {\n      if (section.decimal_max_digits > section.decimal_min_digits) {\n        return new RegExp(`0{1,${section.decimal_max_digits - section.decimal_min_digits}}(?:$|e)`);\n      }\n      return void 0;\n    });\n  }\n  /**\n   * render text parts to string\n   * FIXME: move\n   */\n  static FormatPartsAsText(parts, text_width = 0) {\n    let padded = -1;\n    const formatted = parts.map((part, index) => {\n      switch (part.flag) {\n        case 2 /* padded */:\n          padded = index;\n          return part.text;\n        case 1 /* hidden */:\n          return part.text.replace(/./g, " ");\n        case 6 /* formatting */:\n          return "";\n        default:\n          return part.text;\n      }\n    });\n    if (padded >= 0 && text_width) {\n      const total_length = formatted.reduce((a, str, index) => index === padded ? a : a + str.length, 0);\n      let tmp = "";\n      for (let i = 0; i < text_width - total_length; i++) {\n        tmp += formatted[padded];\n      }\n      formatted[padded] = tmp;\n    }\n    return formatted.join("");\n  }\n  /** for decimal only, set an explicit number of digits */\n  SetDecimal(digits) {\n    for (const section of this.sections) {\n      if (!section.fraction_format) {\n        section.decimal_min_digits = digits;\n        section.decimal_max_digits = digits;\n      }\n    }\n  }\n  /** \n   * mutate \n   * UPDATE: for fractional formats, increase the denominator digits\n   *         (doing something weird with fixed denominators...)\n   */\n  IncreaseDecimal() {\n    this.sections.forEach((section) => {\n      if (section.fraction_format) {\n        if (!section.fraction_denominator) {\n          section.fraction_denominator_digits = Math.min(section.fraction_denominator_digits + 1, 4);\n        }\n      } else {\n        section.decimal_min_digits++;\n        section.decimal_max_digits = section.decimal_min_digits;\n      }\n    });\n  }\n  /** \n   * mutate \n   * UPDATE: for fractional formats, decrease the denominator digits\n   *         (doing something weird with fixed denominators...)\n   */\n  DecreaseDecimal() {\n    this.sections.forEach((section) => {\n      if (section.fraction_format) {\n        if (!section.fraction_denominator) {\n          section.fraction_denominator_digits = Math.max(section.fraction_denominator_digits - 1, 1);\n        }\n      } else {\n        section.decimal_min_digits = Math.max(0, section.decimal_min_digits - 1);\n        section.decimal_max_digits = section.decimal_min_digits;\n      }\n    });\n  }\n  /** mutate */\n  AddGrouping() {\n    this.sections.forEach((section) => {\n      section.grouping = true;\n    });\n  }\n  /** mutate */\n  RemoveGrouping() {\n    this.sections.forEach((section) => {\n      section.grouping = false;\n    });\n  }\n  /** mutate */\n  ToggleGrouping() {\n    const grouping = !this.sections[0].grouping;\n    this.sections.forEach((section) => {\n      section.grouping = grouping;\n    });\n  }\n  /**\n   * generates a string representation. we use this because we are (now)\n   * allowing mutation of formats; therefore we need to serialize them back\n   * to the basic format.\n   */\n  toString() {\n    if (this.sections[0].date_format) {\n      return this._pattern;\n    }\n    return this.sections.filter((section, i) => {\n      return !this.cloned[i];\n    }).map((section) => {\n      let nf = "";\n      let i = 0;\n      if (section.fraction_format) {\n        if (section.fraction_integer) {\n          nf += "? ";\n        }\n        let pattern = "";\n        for (let j = 0; j < section.fraction_denominator_digits; j++) {\n          pattern += "#";\n        }\n        nf += pattern;\n        nf += "/";\n        if (section.fraction_denominator) {\n          nf += section.fraction_denominator;\n        } else {\n          nf += pattern;\n        }\n      } else if (section.has_number_format) {\n        for (i = 0; i < section.integer_min_digits; i++) {\n          nf += "0";\n        }\n        if (section.grouping) {\n          if (nf.length < 4)\n            nf = ("####" + nf).slice(-4);\n          nf = nf.replace(/[\\d#]{1,3}(?=([\\d#]{3})+(?![\\d#]))/g, "$&,");\n        }\n        if (section.decimal_max_digits || section.decimal_min_digits) {\n          nf += ".";\n          for (i = 0; i < section.decimal_min_digits; i++) {\n            nf += "0";\n          }\n          for (; i < section.decimal_max_digits; i++) {\n            nf += "#";\n          }\n        }\n        if (section.scaling) {\n          const count = Math.log10(section.scaling) / 3;\n          for (i = 0; i < count; i++) {\n            nf += ",";\n          }\n        }\n        if (section.exponential) {\n          nf += "e";\n        }\n      }\n      return section.prefix.map((part) => {\n        if (part.flag === 1 /* hidden */) {\n          return part.text === "0" ? "?" : "_" + part.text;\n        } else if (part.flag === 2 /* padded */) {\n          return "*" + part.text;\n        } else if (part.flag === 6 /* formatting */) {\n          return "[" + part.text + "]";\n        }\n        return part.text;\n      }).join("") + nf + section.suffix.map((part) => {\n        if (part.flag === 1 /* hidden */) {\n          return part.text === "0" ? "?" : "_" + part.text;\n        } else if (part.flag === 2 /* padded */) {\n          return "*" + part.text;\n        }\n        return part.text;\n      }).join("");\n    }).join(";");\n  }\n  /** also temporary? why not switch in here? */\n  FormatDimensionedQuantity(value) {\n    if (this.transform_value) {\n      const result = this.transform_value(value);\n      if (IsDimensionedQuantity(result)) {\n        value = result;\n      } else if (typeof result === "string") {\n        return result;\n      } else {\n        return this.FormatParts(result);\n      }\n    }\n    const parts = this.FormatParts(value.value || 0);\n    if (value.unit) {\n      parts.push({ text: " " }, {\n        text: value.unit\n      });\n    }\n    return parts;\n  }\n  /** \n   * temporary \n   * \n   * FIXME: merge with FormatParts, use a test to check if it\'s complex?\n   * OTOH that adds a test to every format which is probably wasteful...\n   * although we can check for \'number\' first\n   * \n   */\n  FormatComplex(value) {\n    let imaginary_format = [];\n    let real_format = [];\n    let drop_imaginary_coefficient = false;\n    let has_imaginary_value = !!value.imaginary;\n    if (has_imaginary_value) {\n      imaginary_format = this.FormatParts(value.imaginary);\n      has_imaginary_value = imaginary_format.some((element) => /[1-9]/.test(element.text));\n      if (imaginary_format.length === 1 && this.sections[0].integer_min_digits <= 1 && imaginary_format[0].text === "1") {\n        imaginary_format[0].text = "";\n        drop_imaginary_coefficient = true;\n      } else if (imaginary_format.length === 1 && this.sections[1].integer_min_digits <= 1 && imaginary_format[0].text === "-1") {\n        imaginary_format[0].text = "-";\n        drop_imaginary_coefficient = true;\n      }\n    }\n    let has_real_value = !!value.real;\n    if (has_real_value) {\n      real_format = this.FormatParts(value.real);\n      has_real_value = real_format.some((element) => /[1-9]/.test(element.text));\n    }\n    const parts = [];\n    if (has_real_value || !has_real_value && !has_imaginary_value) {\n      parts.push(...real_format);\n      if (has_imaginary_value) {\n        const i = Math.abs(value.imaginary);\n        parts.push({ text: value.imaginary < 0 ? ` ${_NumberFormat.minus_character} ` : " + " });\n        const reformatted_imaginary = drop_imaginary_coefficient ? [] : this.FormatParts(Math.abs(value.imaginary));\n        parts.push(...reformatted_imaginary, { text: _NumberFormat.imaginary_character });\n      }\n    } else if (has_imaginary_value) {\n      parts.push(...imaginary_format, { text: _NumberFormat.imaginary_character });\n    }\n    return parts;\n  }\n  /**\n   * this method composes the format as a set of parts with various\n   * states. it\'s intended for graphical representation where things\n   * like hidden characters and padding require multiple passes or measurement.\n   */\n  FormatParts(value) {\n    if (typeof value !== "number" && !this.sections[3]) {\n      return [{ text: value.toString() }];\n    }\n    const { parts, section } = this.BaseFormat(value);\n    let text_parts = [];\n    if (section.date_format || section.string_format) {\n      for (const part of parts) {\n        if (typeof part === "string") {\n          text_parts.push({ text: part });\n        } else\n          text_parts.push(part);\n      }\n    } else {\n      if (this.magic_decimal && parts[1] === "") {\n        parts.splice(1, 1);\n      }\n      text_parts = [\n        ...section.prefix.map((text_part) => {\n          return { ...text_part };\n        }),\n        { text: section.has_number_format ? parts.join(Localization.decimal_separator) : "" },\n        ...section.suffix.map((text_part) => {\n          return { ...text_part };\n        })\n      ];\n    }\n    for (let i = 1; i < text_parts.length; i++) {\n      if (text_parts[i].flag === text_parts[i - 1].flag) {\n        text_parts[i].text = text_parts[i - 1].text + text_parts[i].text;\n        text_parts[i - 1].text = "";\n      }\n    }\n    return text_parts.filter((text_part) => text_part.text);\n  }\n  /**\n   * formats a number as text.\n   *\n   * this method will use a single space to replace hidden (leading-underscore)\n   * characters. if a text width is provided, it will use that for padding;\n   * otherwise the padding character (we only allow a single padding character)\n   * is rendered once.\n   *\n   * FIXME: date, string (this is lagging)\n   * UPDATE: unifying, basing this on the text part functionality\n   */\n  Format(value, text_width = 0) {\n    return _NumberFormat.FormatPartsAsText(this.FormatParts(value), text_width);\n  }\n  ZeroPad(text, length) {\n    while (text.length < length)\n      text = "0" + text;\n    return text;\n  }\n  DateFormat(value) {\n    const date = LotusDate(value);\n    const section = this.sections[0];\n    let hours = date.getUTCHours();\n    if (section.twelve_hour) {\n      if (hours > 12)\n        hours -= 12;\n      if (hours === 0)\n        hours = 12;\n    }\n    const parts = section.prefix.map((part) => {\n      if (part.flag === 4 /* date_component_minutes */) {\n        if (part.text === "mm") {\n          return { text: this.ZeroPad(date.getUTCMinutes().toString(), 2) };\n        }\n        return { text: this.ZeroPad(date.getUTCMinutes().toString(), 1) };\n      } else if (part.flag === 3 /* date_component */) {\n        switch (part.text.toLowerCase()) {\n          case "am/pm":\n          case "a/p": {\n            const elements = part.text.split("/");\n            return { text: date.getUTCHours() > 12 ? elements[1] : elements[0] };\n          }\n          case "mmmmm":\n            return { text: Localization.date_components.long_months[date.getUTCMonth()][0] };\n          case "mmmm":\n            if (part.text === "MMMM") {\n              return { text: Localization.date_components.long_months[date.getUTCMonth()].toUpperCase() };\n            }\n            return { text: Localization.date_components.long_months[date.getUTCMonth()] };\n          case "mmm":\n            if (part.text === "MMM") {\n              return { text: Localization.date_components.short_months[date.getUTCMonth()].toUpperCase() };\n            }\n            return { text: Localization.date_components.short_months[date.getUTCMonth()] };\n          case "mm":\n            return { text: this.ZeroPad((date.getUTCMonth() + 1).toString(), 2) };\n          case "m":\n            return { text: this.ZeroPad((date.getUTCMonth() + 1).toString(), 1) };\n          case "ddddd":\n          case "dddd":\n            if (part.text === "DDDDD" || part.text === "DDDD") {\n              return { text: Localization.date_components.long_days[date.getUTCDay()].toUpperCase() };\n            }\n            return { text: Localization.date_components.long_days[date.getUTCDay()] };\n          case "ddd":\n            if (part.text === "DDD") {\n              return { text: Localization.date_components.short_days[date.getUTCDay()].toUpperCase() };\n            }\n            return { text: Localization.date_components.short_days[date.getUTCDay()] };\n          case "dd":\n            return { text: this.ZeroPad(date.getUTCDate().toString(), 2) };\n          case "d":\n            return { text: this.ZeroPad(date.getUTCDate().toString(), 1) };\n          case "yyyy":\n          case "yyy":\n            return { text: date.getUTCFullYear().toString() };\n          case "yy":\n          case "y":\n            return { text: this.ZeroPad((date.getUTCFullYear() % 100).toString(), 2) };\n          case "hh":\n            return { text: this.ZeroPad(hours.toString(), 2) };\n          case "h":\n            return { text: this.ZeroPad(hours.toString(), 1) };\n          case "ss":\n            return { text: this.ZeroPad(date.getUTCSeconds().toString(), 2) };\n          case "s":\n            return { text: this.ZeroPad(date.getUTCSeconds().toString(), 1) };\n        }\n        const match = part.text.match(/^(s+)\\.(0+)$/);\n        if (match) {\n          return {\n            text: this.ZeroPad(date.getUTCSeconds().toString(), match[1].length) + Localization.decimal_separator + (date.getUTCMilliseconds() / 1e3).toFixed(match[2].length).substr(2)\n          };\n        }\n      }\n      return { ...part };\n    });\n    return { parts, section };\n  }\n  StringFormat(value, section) {\n    const parts = [];\n    for (const part of section.prefix) {\n      if (part.flag === 5 /* literal */) {\n        parts.push({ text: value });\n      } else\n        parts.push({ ...part });\n    }\n    return {\n      parts,\n      section\n    };\n  }\n  /*\n    public DecimalAdjustRound(value: number, exp: number) {\n  \n      if (!exp) { return Math.round(value); }\n  \n      value = +value;\n      // exp = +exp;\n  \n      // Shift\n      let values = value.toString().split(\'e\');\n      value = Math.round(+(values[0] + \'e\' + (values[1] ? (+values[1] - exp) : -exp)));\n  \n      // Shift back\n      values = value.toString().split(\'e\');\n      return +(values[0] + \'e\' + (values[1] ? (+values[1] + exp) : exp));\n  \n    }\n    */\n  Round2(value, digits) {\n    const m = Math.pow(10, digits);\n    return Math.round(m * value) / m;\n  }\n  FormatFraction(value, section) {\n    if (section.percent) {\n      value *= 100;\n    }\n    let candidate = {\n      denominator: 1,\n      numerator: Math.round(value),\n      error: Math.abs(Math.round(value) - value)\n    };\n    if (section.fraction_denominator) {\n      candidate.denominator = section.fraction_denominator;\n      candidate.numerator = Math.round(value * candidate.denominator);\n    } else {\n      if (candidate.error) {\n        const limit = _NumberFormat.fraction_limits[section.fraction_denominator_digits - 1] || _NumberFormat.fraction_limits[0];\n        for (let denominator = 2; denominator <= limit; denominator++) {\n          const numerator = Math.round(value * denominator);\n          const error = Math.abs(numerator / denominator - value);\n          if (error < candidate.error) {\n            candidate = {\n              numerator,\n              denominator,\n              error\n            };\n            if (!error) {\n              break;\n            }\n          }\n        }\n      }\n    }\n    const text = [];\n    if (section.fraction_integer) {\n      const integer = Math.floor(candidate.numerator / candidate.denominator);\n      candidate.numerator %= candidate.denominator;\n      if (integer || !candidate.numerator) {\n        text.push(integer.toString());\n        if (candidate.numerator) {\n          text.push(" ");\n        }\n      }\n    } else if (!candidate.numerator) {\n      text.push("0");\n    }\n    if (candidate.numerator) {\n      text.push(candidate.numerator.toString());\n      text.push("/");\n      text.push(candidate.denominator.toString());\n    }\n    return text.join("");\n  }\n  BaseFormat(value) {\n    if (this.sections[0].date_format) {\n      return this.DateFormat(Number(value));\n    }\n    if (typeof value !== "number") {\n      return this.StringFormat(value.toString(), this.sections[3]);\n    }\n    let section = this.sections[0];\n    let zero_regexp = this.decimal_zero_regexp[0];\n    if (value < 0) {\n      section = this.sections[1];\n    }\n    const max_digits = section.percent ? section.decimal_max_digits + 2 : section.decimal_max_digits;\n    const epsilon = Math.pow(10, -max_digits) / 2;\n    let abs_value = Math.abs(value);\n    if (abs_value < epsilon) {\n      section = this.sections[2];\n      zero_regexp = this.decimal_zero_regexp[2];\n    }\n    if (section.scaling) {\n      abs_value /= section.scaling;\n      if (abs_value < epsilon) {\n        section = this.sections[2];\n        zero_regexp = this.decimal_zero_regexp[2];\n      }\n    }\n    if (section.string_format) {\n      return this.StringFormat(value.toString(), section);\n    }\n    let representation = "";\n    if (section.fraction_format) {\n      return { parts: [this.FormatFraction(abs_value, section)], section };\n    }\n    if (section.exponential) {\n      representation = abs_value.toExponential(section.decimal_max_digits);\n    } else {\n      if (section.percent) {\n        abs_value *= 100;\n      }\n      representation = this.Round2(abs_value, section.decimal_max_digits).toFixed(section.decimal_max_digits);\n    }\n    if (zero_regexp) {\n      representation = representation.replace(zero_regexp, "");\n    }\n    const parts = representation.split(".");\n    while (parts[0].length < section.integer_min_digits) {\n      parts[0] = ("0000000000000000" + parts[0]).slice(-section.integer_min_digits);\n    }\n    if (section.integer_min_digits === 0 && parts[0] === "0") {\n      parts[0] = "";\n    }\n    if (section.grouping) {\n      parts[0] = parts[0].replace(_NumberFormat.grouping_regexp, "$&" + Localization.grouping_separator);\n    }\n    return { parts, section };\n  }\n};\n\n// treb-format/src/format_cache.ts\nvar NumberFormatCache = class {\n  /** cache instance */\n  static cache = {};\n  /** special case for the "general" formatter for complex numbers only */\n  static complex_general;\n  /** \n   * this map is for case-insensitive mapping symbolic names to formats. we\n   * want symbolic names with casing, primarily for interop, but we also want\n   * to support icase matching.\n   * \n   * FIXME: is there a better way to do this, with a pattern or something in\n   * the cache?\n   */\n  static symbolc_name_map = {};\n  /** base types, with default names */\n  static base_formats = {\n    Accounting: "_(#,##0.00_);(#,##0.00);-???",\n    Number: "0.00",\n    Integer: "0",\n    Percent: "0.00%",\n    General: "0.######",\n    // for complex we will reduce the number of optional digits\n    Fraction: "# ?/?",\n    Dollar: "$* _(#,##0.00_);$* (#,##0.00);$* -???",\n    Exponential: "0.000e",\n    "Short Date": "mm/dd/yy",\n    "Long Date": "dddd, mmm d yyyy",\n    Timestamp: "mm-dd-yy hh:mm:ss"\n  };\n  /** alias types */\n  static aliases = {\n    Scientific: "Exponential",\n    Percentage: "Percent",\n    Currency: "Dollar"\n    /*\n        // we switched to Uppercase symbolic names to better\n        // match imported files, but we have legacy stuff using\n        // lowercase, so add aliases.\n    \n        accounting: \'Accounting\',\n        number: \'Number\',\n        integer: \'Integer\',\n        percent: \'Percent\',\n        general: \'General\',\n        dollar: \'Dollar\',\n        exponential: \'Exponential\',\n    \n        \'short date\': \'Short Date\',\n        \'long date\': \'Long Date\',\n        timestamp: \'Timestamp\',\n        */\n  };\n  /**\n   * we now have (some) overlay styles for complex. if the flag is set\n   * we will check the complex cache first, and \n   * @param format \n   * @param complex \n   * @returns \n   */\n  static Get(format, complex = false) {\n    if (complex && format === "General") {\n      return this.complex_general;\n    }\n    const canonical_name = this.symbolc_name_map[format.toLowerCase()];\n    let formatter = this.cache[canonical_name || format];\n    if (!formatter) {\n      formatter = new NumberFormat(format);\n      this.cache[format] = formatter;\n    }\n    return formatter;\n  }\n  /** \n   * does anyone use this? (...)\n   */\n  static Equals(a, b) {\n    if (a === b)\n      return true;\n    const fa = this.Get(a);\n    const fb = this.Get(b);\n    return fa.pattern === fb.pattern;\n  }\n  /**\n   * this method is used to translate symbolic formats,\n   * without actually creating a formatter. it\'s a shortcut\n   * we need for exporting to xlsx.\n   *\n   * if the passed format matches a symbolic format, we return\n   * the string representation. if it doesn\'t match any symbolic format,\n   * the string is returned as-is.\n   */\n  static Translate(format) {\n    const mapped = this.symbolc_name_map[format.toLowerCase()];\n    return mapped ? this.cache[mapped].toString() : format;\n  }\n  /**\n   * check if the format (as a number format) matches a local \n   * symbolic name and if so, return that.\n   */\n  static SymbolicName(format) {\n    for (const key of Object.keys(this.base_formats)) {\n      if (format === this.base_formats[key])\n        return key;\n    }\n    return null;\n  }\n  static InitCache() {\n    for (const key of Object.keys(this.base_formats)) {\n      this.cache[key] = new NumberFormat(this.base_formats[key]);\n      this.symbolc_name_map[key.toLowerCase()] = key;\n    }\n    this.cache["General"].magic_decimal = true;\n    this.complex_general = new NumberFormat("0.###");\n    this.complex_general.magic_decimal = true;\n    for (const key of Object.keys(this.aliases)) {\n      this.cache[key] = this.cache[this.aliases[key]];\n      this.symbolc_name_map[key.toLowerCase()] = key;\n    }\n  }\n};\nNumberFormatCache.InitCache();\n\n// treb-format/src/value_parser.ts\nvar this_year = (/* @__PURE__ */ new Date()).getUTCFullYear();\nvar ValueParserType = class {\n  compare_day;\n  compare_month;\n  TestDate(text) {\n    const date_value = Date.parse(text);\n    if (isNaN(date_value)) {\n      return false;\n    }\n    const date = new Date(date_value);\n    const tmp = text.replace(/[\\d\\-\\\\/,.\\s]+/g, " ").toLocaleLowerCase();\n    const components = tmp.split(/\\s+/).map((component) => component.trim()).filter((component) => !!component);\n    if (!components.length) {\n      return date_value;\n    }\n    if (!this.compare_month) {\n      this.compare_month = {};\n      for (let i = 0; i < 12; i++) {\n        this.compare_month[Localization.date_components.long_months[i].toLocaleLowerCase().replace(/\\./, "")] = i;\n        this.compare_month[Localization.date_components.short_months[i].toLocaleLowerCase().replace(/\\./, "")] = i;\n      }\n    }\n    if (!this.compare_day) {\n      this.compare_day = {};\n      for (let i = 0; i < 7; i++) {\n        this.compare_day[Localization.date_components.long_days[i].toLocaleLowerCase().replace(/\\./, "")] = i;\n        this.compare_day[Localization.date_components.short_days[i].toLocaleLowerCase().replace(/\\./, "")] = i;\n      }\n    }\n    let found_month = false;\n    let found_day = false;\n    for (const component of components) {\n      let found = false;\n      for (const [month, value] of Object.entries(this.compare_month)) {\n        if (component === month) {\n          if (found_month) {\n            return false;\n          }\n          if (date.getUTCMonth() !== value) {\n            return false;\n          }\n          found = true;\n          found_month = true;\n        }\n      }\n      if (!found) {\n        for (const [day, value] of Object.entries(this.compare_day)) {\n          if (component === day) {\n            if (found_day) {\n              return false;\n            }\n            if (date.getUTCDay() !== value) {\n              return false;\n            }\n            found = true;\n            found_day = true;\n          }\n        }\n      }\n      if (!found) {\n        return false;\n      }\n    }\n    if (found_day && !found_month) {\n      return false;\n    }\n    return date_value;\n  }\n  /**\n   * parse a string. if it can reasonably be converted to a number,\n   * do that and return the number; otherwise return the original\n   * string. we also return hints as to formatting, which the caller\n   * may use to select a number format.\n   *\n   * remind me why this is better than just using a parser? (...)\n   */\n  TryParse(text = "") {\n    let hints = {};\n    if (text[0] === "\'")\n      return { value: text, type: 2 /* string */ };\n    if (text === "")\n      return { value: text, type: 2 /* string */ };\n    if (text === "NaN")\n      return {\n        value: NaN,\n        type: 3 /* number */,\n        hints: { Nan: true }\n      };\n    let x = text.trim();\n    const currency = x.match(/^[$](.*?)$/);\n    if (currency) {\n      x = currency[1];\n      hints.Currency = true;\n    }\n    const parens = x.match(/^\\((.*?)\\)$/);\n    if (parens) {\n      x = parens[1];\n      hints.Parens = true;\n    }\n    const pct = x.match(/^(.*?)%\\s*$/);\n    if (pct) {\n      x = pct[1];\n      hints.Percent = true;\n    }\n    if (Localization.decimal_separator === ".") {\n      if (/,/.test(x)) {\n        x = x.replace(/,/g, "");\n        hints.Grouping = true;\n      }\n    } else {\n      x = x.replace(/(\\d)\\s+/g, "$1");\n      x = x.replace(/\\./g, "");\n      x = x.replace(/,/, ".");\n    }\n    let num = Number(x);\n    if (null === num || isNaN(num)) {\n      const lc = text.toLowerCase();\n      if (lc === "false")\n        return { value: false, type: 4 /* boolean */ };\n      if (lc === "true")\n        return { value: true, type: 4 /* boolean */ };\n      const date = this.TestDate(text);\n      if (false !== date && !isNaN(date)) {\n        const check = new Date(date);\n        const year = check.getUTCFullYear();\n        if (year >= this_year - 200 && year <= this_year + 200) {\n          hints = { Date: true };\n          if (check.getHours() || check.getMinutes() || check.getSeconds()) {\n            hints.Time = true;\n          }\n          return {\n            value: UnlotusDate(date),\n            type: 3 /* number */,\n            hints\n          };\n        }\n      }\n      return { value: text, type: 2 /* string */ };\n    }\n    if (parens) {\n      num = -num;\n    }\n    if (pct) {\n      const sign = num < 0 ? -1 : 1;\n      const split = (sign * num).toString().split(".");\n      split[0] = ("00" + split[0]).replace(/(\\d\\d)$/, ".$1");\n      num = Number(split.join("")) * sign;\n    }\n    if (/e/.test(text))\n      hints.Exponential = true;\n    return { value: num, type: 3 /* number */, hints };\n  }\n};\nvar ValueParser = new ValueParserType();\n\n// treb-export/src/workbook-style2.ts\nvar default_border = {\n  top: {},\n  left: {},\n  bottom: {},\n  right: {},\n  diagonal: {}\n};\nvar StyleCache = class _StyleCache {\n  /**\n   * thanks to\n   * http://polymathprogrammer.com/2011/02/15/built-in-styles-for-excel-open-xml/\n   */\n  static default_styles = {\n    0: "General",\n    1: "0",\n    2: "0.00",\n    3: "#,##0",\n    4: "#,##0.00",\n    9: "0%",\n    10: "0.00%",\n    11: "0.00E+00",\n    12: "# ?/?",\n    13: "# ??/??",\n    14: "mm-dd-yy",\n    15: "d-mmm-yy",\n    16: "d-mmm",\n    17: "mmm-yy",\n    18: "h:mm AM/PM",\n    19: "h:mm:ss AM/PM",\n    20: "h:mm",\n    21: "h:mm:ss",\n    22: "m/d/yy h:mm",\n    37: "#,##0 ;(#,##0)",\n    38: "#,##0 ;[Red](#,##0)",\n    39: "#,##0.00;(#,##0.00)",\n    40: "#,##0.00;[Red](#,##0.00)",\n    45: "mm:ss",\n    46: "[h]:mm:ss",\n    47: "mmss.0",\n    48: "##0.0E+0",\n    49: "@"\n  };\n  theme = new Theme();\n  cell_xfs = [];\n  fonts = [];\n  borders = [];\n  fills = [];\n  number_formats = [];\n  base_number_format_id = 200;\n  // ?\n  dxf_styles = [];\n  // public dom?: Tree;\n  modified = false;\n  Clamp(value, min, max) {\n    return Math.max(min, Math.min(value, max));\n  }\n  TintColor(base, tint) {\n    let r = parseInt(base.substr(0, 2), 16);\n    let g = parseInt(base.substr(2, 2), 16);\n    let b = parseInt(base.substr(4, 2), 16);\n    if (tint < 0) {\n      r = Math.round(r * tint + r);\n      g = Math.round(g * tint + g);\n      b = Math.round(b * tint + b);\n    } else {\n      r = Math.round((255 - r) * tint + r);\n      g = Math.round((255 - g) * tint + g);\n      b = Math.round((255 - b) * tint + b);\n    }\n    return [r, g, b].map((x) => {\n      const s = this.Clamp(x, 0, 255).toString(16);\n      return s.length < 2 ? "0" + s : s;\n    }).join("");\n  }\n  /// \n  StyleOptionsFromProperties(source) {\n    const composite = (\n      // Style.Composite(list);\n      JSON.parse(JSON.stringify(source))\n    );\n    for (const key of Object.keys(composite)) {\n      if (composite[key] === "none") {\n        delete composite[key];\n      }\n    }\n    const font = {};\n    const fill = { pattern_type: "none" };\n    const border = JSON.parse(JSON.stringify(default_border));\n    const options = {\n      font,\n      border\n    };\n    if (composite.number_format) {\n      options.number_format = {\n        format: NumberFormatCache.Translate(composite.number_format),\n        symbolic_name: composite.number_format\n        // for reference later\n      };\n    }\n    if (composite.font_size?.unit && composite.font_size.value) {\n      if (composite.font_size.unit !== "pt") {\n        console.warn(`can\'t handle non-point font (FIXME)`);\n      } else {\n        font.size = composite.font_size.value;\n      }\n    }\n    if (composite.bold)\n      font.bold = true;\n    if (composite.italic)\n      font.italic = true;\n    if (composite.underline)\n      font.underline = true;\n    if (composite.text) {\n      if (composite.text.text) {\n        font.color_argb = composite.text.text;\n      } else if (typeof composite.text.theme === "number") {\n        font.color_theme = composite.text.theme;\n        if (composite.text.tint) {\n          font.color_tint = composite.text.tint;\n        }\n      }\n    }\n    const TranslateBorder = (src, dest) => {\n      if (src.width) {\n        dest.style = "thin";\n        if (src.color.text) {\n          dest.rgba = src.color.text;\n        } else if (typeof src.color.theme === "number") {\n          dest.theme = src.color.theme;\n          if (src.color.tint) {\n            dest.tint = src.color.tint;\n          }\n        } else {\n          dest.color = 64;\n        }\n      }\n    };\n    const composite_borders = Style.CompositeBorders(composite);\n    TranslateBorder(composite_borders.top, border.top);\n    TranslateBorder(composite_borders.left, border.left);\n    TranslateBorder(composite_borders.right, border.right);\n    TranslateBorder(composite_borders.bottom, border.bottom);\n    switch (composite.vertical_align) {\n      case "top":\n        options.vertical_alignment = "top";\n        break;\n      case "middle":\n        options.vertical_alignment = "center";\n        break;\n    }\n    switch (composite.horizontal_align) {\n      case "center":\n        options.horizontal_alignment = "center";\n        break;\n      case "left":\n        options.horizontal_alignment = "left";\n        break;\n      case "right":\n        options.horizontal_alignment = "right";\n        break;\n    }\n    if (composite.fill) {\n      fill.pattern_type = "solid";\n      if (composite.fill.text) {\n        fill.fg_color = { argb: composite.fill.text };\n        options.fill = fill;\n      } else if (typeof composite.fill.theme === "number") {\n        fill.fg_color = { theme: composite.fill.theme };\n        if (composite.fill.tint) {\n          fill.fg_color.tint = composite.fill.tint;\n        }\n        options.fill = fill;\n      } else {\n      }\n    }\n    if (composite.wrap) {\n      options.wrap = true;\n    }\n    return options;\n  }\n  ///\n  CellXfToStyle(xf) {\n    const props = {};\n    let format_string = _StyleCache.default_styles[xf.number_format];\n    if (!format_string) {\n      for (const candidate of this.number_formats) {\n        if (candidate.id === xf.number_format) {\n          if (candidate.format) {\n            format_string = candidate.format;\n            break;\n          }\n        }\n      }\n    }\n    if (format_string) {\n      const encoding_regex = /\\[\\$(.)-[0-9A-Za-z]{1,4}\\]/g;\n      format_string = format_string.replace(encoding_regex, "$1");\n      const locale_regex = /\\[\\$-[0-9A-Za-z]{1,4}\\]/g;\n      format_string = format_string.replace(locale_regex, "");\n      props.number_format = format_string;\n    }\n    const base_font = this.fonts[0];\n    const font = this.fonts[xf.font || 0];\n    if (font) {\n      if (font.bold)\n        props.bold = true;\n      if (font.italic)\n        props.italic = true;\n      if (font.underline)\n        props.underline = true;\n      if (font.strike)\n        props.strike = true;\n      if (base_font && base_font.size && font.size && base_font.size !== font.size) {\n        props.font_size = {\n          value: 100 * font.size / base_font.size,\n          unit: "%"\n        };\n      }\n      if (font.color_argb) {\n        props.text = {\n          text: "#" + (font.color_argb.length > 6 ? font.color_argb.substr(font.color_argb.length - 6) : font.color_argb)\n        };\n      } else if (typeof font.color_theme === "number") {\n        props.text = { theme: font.color_theme };\n      }\n    }\n    const fill = this.fills[xf.fill || 0];\n    if (fill && fill.pattern_type !== "none") {\n      if (fill.pattern_type === "gray") {\n        const value = Math.round((fill.pattern_gray || 0) / 1e3 * 255);\n        props.fill = { text: `rgb(${value}, ${value}, ${value})` };\n      }\n      if (fill.pattern_type === "solid") {\n        if (fill.fg_color) {\n          if (fill.fg_color.argb) {\n            props.fill = {\n              text: "#" + (fill.fg_color.argb.length > 6 ? fill.fg_color.argb.substr(fill.fg_color.argb.length - 6) : fill.fg_color.argb)\n            };\n          } else if (typeof fill.fg_color.theme === "number") {\n            props.fill = {\n              theme: fill.fg_color.theme\n              // tint: fill.fg_color.tint,\n            };\n            if (fill.fg_color.tint) {\n              props.fill.tint = Math.round(fill.fg_color.tint * 1e3) / 1e3;\n            }\n          }\n        }\n      }\n    }\n    switch (xf.horizontal_alignment) {\n      case "center":\n        props.horizontal_align = "center";\n        break;\n      case "right":\n        props.horizontal_align = "right";\n        break;\n      case "left":\n        props.horizontal_align = "left";\n        break;\n    }\n    switch (xf.vertical_alignment) {\n      case "center":\n        props.vertical_align = "middle";\n        break;\n      case "top":\n        props.vertical_align = "top";\n        break;\n      case "bottom":\n        props.vertical_align = "bottom";\n        break;\n    }\n    if (xf.wrap_text) {\n      props.wrap = true;\n    }\n    const border = this.borders[xf.border || 0];\n    if (border) {\n      if (border.bottom.style) {\n        if (border.bottom.style === "double") {\n          props.border_bottom = 2;\n        } else {\n          props.border_bottom = 1;\n        }\n      }\n      if (border.left.style)\n        props.border_left = 1;\n      if (border.top.style)\n        props.border_top = 1;\n      if (border.right.style)\n        props.border_right = 1;\n    }\n    return props;\n  }\n  /** map all cell xfs to styles; retain order */\n  CellXfToStyles() {\n    return this.cell_xfs.map((xf) => this.CellXfToStyle(xf));\n  }\n  EnsureNumberFormat(number_format) {\n    if (typeof number_format.format === "undefined")\n      return 0;\n    if (number_format.symbolic_name) {\n      if (/^general$/i.test(number_format.symbolic_name)) {\n        return 0;\n      }\n    }\n    for (let i = 0; i < 100; i++) {\n      const check = _StyleCache.default_styles[i];\n      if (check && check === number_format.format) {\n        return i;\n      }\n    }\n    for (const candidate of this.number_formats) {\n      if (candidate.format === number_format.format)\n        return candidate.id || 0;\n    }\n    this.modified = true;\n    const new_format = {\n      id: this.base_number_format_id++,\n      format: number_format.format\n    };\n    this.number_formats.push(new_format);\n    return new_format.id;\n  }\n  CompareBorderEdge(a, b) {\n    return a.color === b.color && a.rgba === b.rgba && a.style === b.style && a.theme === b.theme && a.tint === b.tint;\n  }\n  CompareBorder(a, b) {\n    return this.CompareBorderEdge(a.top, b.top) && this.CompareBorderEdge(a.left, b.left) && this.CompareBorderEdge(a.bottom, b.bottom) && this.CompareBorderEdge(a.right, b.right) && this.CompareBorderEdge(a.diagonal, b.diagonal);\n  }\n  EnsureBorder(border) {\n    for (let i = 0; i < this.borders.length; i++) {\n      const candidate = this.borders[i];\n      if (this.CompareBorder(candidate, border)) {\n        return i;\n      }\n    }\n    this.modified = true;\n    const new_border = JSON.parse(JSON.stringify(border));\n    this.borders.push(new_border);\n    return this.borders.length - 1;\n  }\n  MatchColor(a, b) {\n    if (!a && !b) {\n      return true;\n    }\n    if (!a || !b) {\n      return false;\n    }\n    return a.argb === b.argb && a.indexed === b.indexed && a.theme === b.theme && a.tint === b.tint;\n  }\n  EnsureFill(fill) {\n    for (let i = 0; i < this.fills.length; i++) {\n      const candidate = this.fills[i];\n      if (this.MatchColor(fill.bg_color, candidate.bg_color) && this.MatchColor(fill.fg_color, candidate.fg_color) && fill.pattern_gray === candidate.pattern_gray && fill.pattern_type === candidate.pattern_type) {\n        return i;\n      }\n    }\n    this.modified = true;\n    const new_fill = { ...fill };\n    this.fills.push(new_fill);\n    return this.fills.length - 1;\n  }\n  /**\n   * for the time being we are ignoring font face, family, size, color and\n   * scheme (whatever that is). every font is based on font 0, the default.\n   * we add bold/italic/underline as necessary.\n   */\n  EnsureFont(font) {\n    const composite_font = { ...this.fonts[0], ...font };\n    for (let i = 0; i < this.fonts.length; i++) {\n      const candidate = this.fonts[i];\n      const match = candidate.bold === composite_font.bold && candidate.italic === composite_font.italic && candidate.underline === composite_font.underline && candidate.size === composite_font.size && candidate.strike === composite_font.strike && candidate.color_argb === composite_font.color_argb && candidate.color_theme === composite_font.color_theme && candidate.color_tint === composite_font.color_tint && candidate.family === composite_font.family;\n      if (match) {\n        return i;\n      }\n    }\n    this.modified = true;\n    this.fonts.push(composite_font);\n    return this.fonts.length - 1;\n  }\n  EnsureStyle(options) {\n    const font_index = this.EnsureFont(options.font || {});\n    const border_index = this.EnsureBorder(options.border || default_border);\n    const number_format_index = this.EnsureNumberFormat(options.number_format || {});\n    const fill_index = this.EnsureFill(options.fill || { pattern_type: "none" });\n    for (let i = 0; i < this.cell_xfs.length; i++) {\n      const xf = this.cell_xfs[i];\n      if (xf.font === font_index && xf.fill === fill_index && xf.border === border_index && xf.number_format === number_format_index && !!xf.wrap_text === !!options.wrap && (!options.horizontal_alignment && !xf.horizontal_alignment || options.horizontal_alignment === xf.horizontal_alignment) && (!options.vertical_alignment && !xf.vertical_alignment || options.vertical_alignment === xf.vertical_alignment)) {\n        return i;\n      }\n    }\n    this.modified = true;\n    const new_xf = {\n      font: font_index,\n      fill: fill_index,\n      border: border_index,\n      number_format: number_format_index\n    };\n    if (options.horizontal_alignment) {\n      new_xf.horizontal_alignment = options.horizontal_alignment;\n    }\n    if (options.vertical_alignment) {\n      new_xf.vertical_alignment = options.vertical_alignment;\n    }\n    if (options.wrap) {\n      new_xf.wrap_text = true;\n    }\n    this.cell_xfs.push(new_xf);\n    return this.cell_xfs.length - 1;\n  }\n  FromXML(xml, theme) {\n    const FindAll = XMLUtils.FindAll.bind(XMLUtils, xml);\n    this.theme = theme;\n    let composite = FindAll("styleSheet/numFmts/numFmt");\n    this.number_formats = composite.map((element) => ({\n      id: Number(element.a$?.numFmtId || 0),\n      format: Unescape(element.a$?.formatCode || "")\n    }));\n    composite = FindAll("styleSheet/borders/border");\n    this.borders = composite.map((element) => {\n      const border = JSON.parse(JSON.stringify(default_border));\n      if (element.left) {\n        border.left.style = element.left.a$.style;\n        border.left.color = Number(element.left.color?.a$?.indexed);\n      }\n      if (element.right) {\n        border.right.style = element.right.a$.style;\n        border.right.color = Number(element.right.color?.a$?.indexed);\n      }\n      if (element.top) {\n        border.top.style = element.top.a$.style;\n        border.top.color = Number(element.top.color?.a$?.indexed);\n      }\n      if (element.bottom) {\n        border.bottom.style = element.bottom.a$.style;\n        border.bottom.color = Number(element.bottom.color?.a$?.indexed);\n      }\n      return border;\n    });\n    composite = FindAll("styleSheet/cellXfs/xf");\n    this.cell_xfs = composite.map((element) => {\n      const xf = {\n        number_format: Number(element.a$.numFmtId),\n        font: Number(element.a$.fontId),\n        fill: Number(element.a$.fillId),\n        border: Number(element.a$.borderId),\n        xfid: Number(element.a$.xfId)\n      };\n      if (element.alignment) {\n        xf.horizontal_alignment = element.alignment.a$.horizontal;\n        xf.vertical_alignment = element.alignment.a$.vertical;\n        xf.wrap_text = !!element.alignment.a$.wrapText;\n      }\n      return xf;\n    });\n    const ParseFill = (element) => {\n      const fill = { pattern_type: "none" };\n      if (element.patternFill) {\n        const type = element.patternFill.a$?.patternType;\n        switch (type) {\n          case "none":\n          case void 0:\n            break;\n          case "solid":\n            fill.pattern_type = "solid";\n            if (element.patternFill.fgColor) {\n              fill.fg_color = {\n                theme: element.patternFill.fgColor.a$?.theme ? Number(element.patternFill.fgColor.a$.theme) : void 0,\n                indexed: element.patternFill.fgColor.a$?.indexed ? Number(element.patternFill.fgColor.a$.indexed) : void 0,\n                tint: element.patternFill.fgColor.a$?.tint ? Number(element.patternFill.fgColor.a$.tint) : void 0,\n                argb: element.patternFill.fgColor.a$?.rgb\n              };\n            }\n            break;\n          default: {\n            const match = type?.match(/^gray(\\d+)$/);\n            if (match) {\n              fill.pattern_type = "gray";\n              fill.pattern_gray = Number(match[1]);\n              break;\n            }\n          }\n        }\n      }\n      return fill;\n    };\n    composite = FindAll("styleSheet/fills/fill");\n    this.fills = composite.map(ParseFill);\n    const ParseFont = (element) => {\n      const font = {};\n      font.italic = !!(typeof element.i !== "undefined");\n      font.bold = !!(typeof element.b !== "undefined");\n      font.underline = !!(typeof element.u !== "undefined");\n      font.strike = !!(typeof element.strike !== "undefined");\n      if (element.sz) {\n        font.size = Number(element.sz.a$.val);\n      }\n      if (element.scheme) {\n        font.scheme = element.scheme.a$.val;\n      }\n      if (element.name) {\n        font.name = element.name.a$.val;\n      }\n      if (element.family) {\n        font.family = Number(element.family.a$.val);\n      }\n      if (element.color) {\n        if (element.color.a$?.theme) {\n          font.color_theme = Number(element.color.a$.theme);\n        }\n        if (element.color.a$?.tint) {\n          font.color_tint = Number(element.color.a$.tint);\n        }\n        if (element.color.a$?.rgb) {\n          font.color_argb = element.color.a$.rgb;\n        }\n      }\n      return font;\n    };\n    composite = FindAll("styleSheet/fonts/font");\n    this.fonts = composite.map(ParseFont);\n    const ParseDXFColor = (element) => {\n      const color = {};\n      if (element.a$.rgb) {\n        color.text = "#" + element.a$.rgb.substring(2);\n      } else if (element.a$.theme) {\n        color.theme = Number(element.a$.theme) || 0;\n        if (element.a$.tint) {\n          color.tint = Math.round(element.a$.tint * 1e3) / 1e3;\n        }\n      }\n      return color;\n    };\n    const dxfs = FindAll("styleSheet/dxfs/dxf");\n    this.dxf_styles = dxfs.map((dxf) => {\n      const style = {};\n      if (dxf.font) {\n        style.bold = !!dxf.font.b;\n        style.italic = !!dxf.font.i && dxf.font.i.a$.val !== "0";\n      }\n      if (dxf.font?.color?.a$) {\n        style.text = ParseDXFColor(dxf.font.color);\n      }\n      if (dxf.fill?.patternFill?.bgColor?.a$) {\n        style.fill = ParseDXFColor(dxf.fill.patternFill.bgColor);\n      }\n      return style;\n    });\n  }\n};\n\n// treb-export/src/relationship.ts\nvar AddRel = (map, type, target, mode) => {\n  const index = Object.keys(map).length + 1;\n  const rel = `rId${index}`;\n  map[rel] = { id: rel, type, target, mode };\n  return rel;\n};\n\n// treb-parser/src/parser.ts\nvar QuotedSheetNameRegex = /[\\s-+=<>!()]/;\nvar DOUBLE_QUOTE2 = 34;\nvar SINGLE_QUOTE = 39;\nvar NON_BREAKING_SPACE = 160;\nvar SPACE = 32;\nvar TAB = 9;\nvar CR = 10;\nvar LF = 13;\nvar ZERO2 = 48;\nvar NINE = 57;\nvar PERIOD2 = 46;\nvar PLUS = 43;\nvar MINUS = 45;\nvar OPEN_PAREN = 40;\nvar CLOSE_PAREN = 41;\nvar COMMA2 = 44;\nvar PERCENT2 = 37;\nvar UNDERSCORE2 = 95;\nvar DOLLAR_SIGN = 36;\nvar OPEN_BRACE = 123;\nvar CLOSE_BRACE = 125;\nvar OPEN_SQUARE_BRACKET = 91;\nvar CLOSE_SQUARE_BRACKET = 93;\nvar EXCLAMATION_MARK = 33;\nvar SEMICOLON2 = 59;\nvar HASH = 35;\nvar AT2 = 64;\nvar UC_A = 65;\nvar LC_A = 97;\nvar UC_E = 69;\nvar LC_E = 101;\nvar UC_Z = 90;\nvar LC_Z = 122;\nvar LC_I = 105;\nvar ACCENTED_RANGE_START = 192;\nvar ACCENTED_RANGE_END = 312;\nvar binary_operators_precendence = {\n  "==": 6,\n  "!=": 6,\n  // FIXME: we should not support these (legacy)\n  "<>": 6,\n  "=": 6,\n  // these are the appropriate equality operators for SL\n  "<": 7,\n  ">": 7,\n  "<=": 7,\n  ">=": 7,\n  "+": 9,\n  "-": 9,\n  "&": 9,\n  "*": 10,\n  "/": 10,\n  "^": 11,\n  // highest math op\n  ":": 13\n  // range operator\n};\nvar binary_operators = Object.keys(binary_operators_precendence).sort(\n  (a, b) => b.length - a.length\n);\nvar unary_operators = { "-": 100, "+": 100 };\nvar Parser = class {\n  /**\n   * argument separator. this can be changed prior to parsing/rendering.\n   * FIXME: use an accessor to ensure type, outside of ts?\n   */\n  argument_separator = "," /* Comma */;\n  /**\n   * decimal mark. this can be changed prior to parsing/rendering.\n   * FIXME: use an accessor to ensure type, outside of ts?\n   */\n  decimal_mark = "." /* Period */;\n  /**\n   * unifying flags\n   */\n  flags = {\n    spreadsheet_semantics: true,\n    dimensioned_quantities: false,\n    fractions: true\n  };\n  r1c1_regex = /[rR]((?:\\[[-+]{0,1}\\d+\\]|\\d+))[cC]((?:\\[[-+]{0,1}\\d+\\]|\\d+))$/;\n  /**\n   * internal argument separator, as a number. this is set internally on\n   * parse call, following the argument_separator value.\n   */\n  argument_separator_char = COMMA2;\n  /**\n   * internal decimal mark, as a number.\n   */\n  decimal_mark_char = PERIOD2;\n  /**\n   * imaginary number value. this is "i", except for those EE weirdos who \n   * use "j". although I guess those guys put it in front, so it won\'t really\n   * work anyway... let\'s stick with "i" for now.\n   */\n  imaginary_char = LC_I;\n  /**\n   * imaginary number as text for matching\n   */\n  imaginary_number = "i";\n  /**\n   * internal counter for incrementing IDs\n   */\n  id_counter = 0;\n  expression = "";\n  data = [];\n  index = 0;\n  length = 0;\n  /** success flag */\n  valid = true;\n  /** rolling error state */\n  error_position;\n  /** rolling error state */\n  error;\n  dependencies = {\n    addresses: {},\n    ranges: {}\n  };\n  // referenced addresses -- used to merge ranges/addresses, although I\'m\n  // not sure that\'s actually all that useful\n  address_refcount = {};\n  /**\n   * full list of referenced addresses and ranges. we\'re adding this\n   * to support highlighting, for which we need multiple instances\n   * of a single address. the original dep list was used for graph dependencies,\n   * so we compressed the list.\n   *\n   * FIXME: use a single list, i.e. something like\n   *\n   *   address -> [instance, instance]\n   *\n   * because that\'s a big API change it\'s going to have to wait. for now,\n   * use a second list.\n   *\n   * UPDATE: adding (otherwise unused) tokens, which could be named ranges.\n   * in the future we may pass in a list of names at parse time, and resolve\n   * them; for now we are just listing names.\n   */\n  full_reference_list = [];\n  parser_state = [];\n  /**\n   * save local configuration to a buffer, so it can be restored. we\'re doing\n   * this because in a lot of places we\'re caching parser flagss, changing\n   * them, and then restoring them. that\'s become repetitive, fragile to \n   * changes or new flags, and annoying.\n   * \n   * config is managed in a list with push/pop semantics. we store it as \n   * JSON so there\'s no possibility we\'ll accidentally mutate.\n   * \n   * FIXME: while we\'re at it why not migrate the separators -> flags, so\n   * there\'s a single location for this kind of state? (...TODO)\n   * \n   */\n  Save() {\n    const config = {\n      flags: this.flags,\n      argument_separator: this.argument_separator,\n      decimal_mark: this.decimal_mark\n    };\n    this.parser_state.push(JSON.stringify(config));\n  }\n  /**\n   * restore persisted config\n   * @see Save\n   */\n  Restore() {\n    const json = this.parser_state.shift();\n    if (json) {\n      try {\n        const config = JSON.parse(json);\n        this.flags = config.flags;\n        this.argument_separator = config.argument_separator;\n        this.decimal_mark = config.decimal_mark;\n      } catch (err) {\n        console.error(err);\n      }\n    } else {\n      console.warn("No parser state to restore");\n    }\n  }\n  /**\n   * recursive tree walk.\n   *\n   * @param func function called on each node. for nodes that have children\n   * (operations, calls, groups) return false to skip the subtree, or true to\n   * traverse.\n   */\n  Walk(unit, func) {\n    switch (unit.type) {\n      case "address":\n      case "missing":\n      case "literal":\n      case "complex":\n      case "identifier":\n      case "operator":\n      case "structured-reference":\n        func(unit);\n        return;\n      case "dimensioned":\n        if (func(unit)) {\n          this.Walk(unit.expression, func);\n          this.Walk(unit.unit, func);\n        }\n        return;\n      case "range":\n        if (func(unit)) {\n          this.Walk(unit.start, func);\n          this.Walk(unit.end, func);\n        }\n        return;\n      case "binary":\n        if (func(unit)) {\n          this.Walk(unit.left, func);\n          this.Walk(unit.right, func);\n        }\n        return;\n      case "unary":\n        if (func(unit)) {\n          this.Walk(unit.operand, func);\n        }\n        return;\n      case "group":\n        if (func(unit)) {\n          unit.elements.forEach((element) => this.Walk(element, func));\n        }\n        return;\n      case "call":\n        if (func(unit)) {\n          unit.args.forEach((arg) => this.Walk(arg, func));\n        }\n    }\n  }\n  /** utility: transpose array */\n  Transpose(arr) {\n    const m = arr.length;\n    const transposed = [];\n    let n = 0;\n    for (let i = 0; i < m; i++) {\n      if (Array.isArray(arr[i])) {\n        n = Math.max(n, arr[i].length);\n      }\n    }\n    for (let i = 0; i < n; i++) {\n      transposed[i] = [];\n      for (let j = 0; j < m; j++) {\n        transposed[i][j] = arr[j][i];\n      }\n    }\n    return transposed;\n  }\n  /**\n   * renders the passed expression as a string.\n   * @param unit base expression\n   * @param offset offset for addresses, used to offset relative addresses\n   * (and ranges). this is for copy-and-paste or move operations.\n   * @param missing string to represent missing values (can be \'\', for functions)\n   * \n   * FIXME: we\'re accumulating too many arguments. need to switch to an \n   * options object. do that after the structured reference stuff merges.\n   * \n   */\n  Render(unit, options = {}) {\n    const offset = options.offset || { rows: 0, columns: 0 };\n    const missing = options.missing ?? "(missing)";\n    const {\n      convert_decimal,\n      convert_argument_separator,\n      convert_imaginary_number,\n      long_structured_references,\n      table_name\n    } = options;\n    let separator = this.argument_separator + " ";\n    if (convert_argument_separator === "," /* Comma */) {\n      separator = ", ";\n    } else if (convert_argument_separator === ";" /* Semicolon */) {\n      separator = "; ";\n    }\n    let imaginary_character = this.imaginary_number;\n    if (convert_imaginary_number) {\n      imaginary_character = convert_imaginary_number;\n    }\n    const decimal = convert_decimal === "," /* Comma */ ? "," : ".";\n    const decimal_rex = this.decimal_mark === "," /* Comma */ ? /,/ : /\\./;\n    const decimal_rex_g = this.decimal_mark === "," /* Comma */ ? /,/g : /\\./g;\n    switch (unit.type) {\n      case "address":\n        return this.AddressLabel(unit, offset);\n      case "range":\n        return this.AddressLabel(unit.start, offset) + ":" + this.AddressLabel(unit.end, offset);\n      case "missing":\n        return missing;\n      case "array":\n        return "{" + this.Transpose(unit.values).map((row) => row.map((value) => {\n          if (typeof value === "string") {\n            return \'"\' + value + \'"\';\n          }\n          return value;\n        }).join(", ")).join("; ") + "}";\n      case "binary":\n        return this.Render(unit.left, options) + " " + unit.operator + " " + this.Render(unit.right, options);\n      case "unary":\n        return unit.operator + this.Render(unit.operand, options);\n      case "complex":\n        if (unit.text) {\n          if (convert_decimal) {\n            const text = unit.text;\n            return text.replace(decimal_rex_g, decimal);\n          } else {\n            return unit.text;\n          }\n        } else {\n          let imaginary_text = Math.abs(unit.imaginary).toString();\n          if (convert_decimal === "," /* Comma */ || this.decimal_mark === "," /* Comma */) {\n            imaginary_text = imaginary_text.replace(/\\./, ",");\n          }\n          if (unit.real) {\n            let real_text = unit.real.toString();\n            if (convert_decimal === "," /* Comma */ || this.decimal_mark === "," /* Comma */) {\n              real_text = real_text.replace(/\\./, ",");\n            }\n            const i = Math.abs(unit.imaginary);\n            return `${real_text}${unit.imaginary < 0 ? " - " : " + "}${i === 1 ? "" : imaginary_text}i`;\n          } else if (unit.imaginary === -1) {\n            return `-i`;\n          } else if (unit.imaginary === 1) {\n            return `i`;\n          } else {\n            return `${unit.imaginary < 0 ? "-" : ""}${imaginary_text}i`;\n          }\n        }\n        break;\n      case "literal":\n        if (typeof unit.value === "string") {\n          return \'"\' + unit.value.replace(/"/g, \'""\') + \'"\';\n        } else if (convert_decimal && typeof unit.value === "number") {\n          if (unit.text) {\n            let text = unit.text;\n            if (convert_decimal === "," /* Comma */ && this.decimal_mark === "." /* Period */) {\n              text = text.replace(/,/g, "");\n            }\n            return text.replace(decimal_rex, decimal);\n          } else {\n            return unit.value.toString().replace(/\\./, decimal);\n          }\n        } else if (unit.text)\n          return unit.text;\n        return unit.value.toString();\n      case "identifier":\n        return unit.name;\n      case "operator":\n        return "[" + unit.operator + "]";\n      case "group":\n        if (unit.explicit) {\n          return "(" + unit.elements.map((x) => this.Render(x, options)).join(separator) + ")";\n        } else {\n          return unit.elements.map((x) => this.Render(x, options)).join(separator);\n        }\n      case "call":\n        return unit.name + "(" + unit.args.map((x) => this.Render(x, options)).join(separator) + ")";\n      case "dimensioned":\n        return this.Render(unit.expression) + " " + this.Render(unit.unit);\n      case "structured-reference": {\n        let column = unit.column;\n        if (/[^A-Za-z]/.test(column)) {\n          column = "[" + column + "]";\n        }\n        let table = unit.table;\n        if (!table && long_structured_references && table_name) {\n          table = table_name;\n        }\n        switch (unit.scope) {\n          case "all":\n            return `${table}[[#all],${column}]`;\n          case "row":\n            if (long_structured_references) {\n              return `${table}[[#this row],${column}]`;\n            } else {\n              return `${table}[@${column}]`;\n            }\n          case "column":\n            return `${table}[${column}]`;\n        }\n        throw new Error("unhandled scope in structured reference");\n      }\n    }\n    return "??";\n  }\n  /**\n   * parses expression and returns the root of the parse tree, plus a\n   * list of dependencies (addresses and ranges) found in the expression.\n   *\n   * NOTE that in the new address parsing structure, we will overlap ranges\n   * and addresses (range corners). this is OK because ranges are mapped\n   * to individual address dependencies. it\'s just sloppy (FIXME: refcount?)\n   */\n  Parse(expression) {\n    expression = expression.trim();\n    if (expression[0] === "=") {\n      expression = expression.substr(1).trim();\n    }\n    this.expression = expression;\n    this.data = [];\n    this.length = expression.length;\n    this.index = 0;\n    this.valid = true;\n    this.error_position = void 0;\n    this.error = void 0;\n    this.dependencies.addresses = {};\n    this.dependencies.ranges = {};\n    this.address_refcount = {};\n    this.full_reference_list = [];\n    this.id_counter = 0;\n    switch (this.argument_separator) {\n      case ";" /* Semicolon */:\n        this.argument_separator_char = SEMICOLON2;\n        break;\n      default:\n        this.argument_separator_char = COMMA2;\n        break;\n    }\n    switch (this.decimal_mark) {\n      case "," /* Comma */:\n        this.decimal_mark_char = COMMA2;\n        break;\n      default:\n        this.decimal_mark_char = PERIOD2;\n        break;\n    }\n    for (let i = 0; i < this.length; i++) {\n      this.data[i] = expression.charCodeAt(i);\n    }\n    const expr = this.ParseGeneric();\n    const addresses = {};\n    for (const key of Object.keys(this.dependencies.addresses)) {\n      if (this.address_refcount[key]) {\n        addresses[key] = this.dependencies.addresses[key];\n      }\n    }\n    this.dependencies.addresses = addresses;\n    return {\n      expression: expr || void 0,\n      valid: this.valid,\n      error: this.error,\n      error_position: this.error_position,\n      dependencies: this.dependencies,\n      separator: this.argument_separator,\n      decimal_mark: this.decimal_mark,\n      full_reference_list: this.full_reference_list.slice(0)\n    };\n  }\n  /** generates column label ("A") from column index (0-based) */\n  ColumnLabel(column) {\n    if (column === Infinity) {\n      return "";\n    }\n    let s = String.fromCharCode(65 + column % 26);\n    while (column > 25) {\n      column = Math.floor(column / 26) - 1;\n      s = String.fromCharCode(65 + column % 26) + s;\n    }\n    return s;\n  }\n  /** generates address label ("C3") from address (0-based) */\n  AddressLabel(address, offset) {\n    let column = address.column;\n    if (!address.absolute_column && address.column !== Infinity)\n      column += offset.columns;\n    let row = address.row;\n    if (!address.absolute_row && address.row !== Infinity)\n      row += offset.rows;\n    if (row < 0 || column < 0 || row === Infinity && column === Infinity)\n      return "#REF";\n    let label = "";\n    if (address.sheet) {\n      label = (QuotedSheetNameRegex.test(address.sheet) ? "\'" + address.sheet + "\'" : address.sheet) + "!";\n    }\n    if (row === Infinity) {\n      return label + (address.absolute_column ? "$" : "") + this.ColumnLabel(column);\n    }\n    if (column === Infinity) {\n      return label + (address.absolute_row ? "$" : "") + (row + 1);\n    }\n    return label + (address.absolute_column ? "$" : "") + this.ColumnLabel(column) + (address.absolute_row ? "$" : "") + (row + 1);\n  }\n  /**\n   * base parse routine; may recurse inside parens (either as grouped\n   * operations or in function arguments).\n   *\n   * @param exit exit on specific characters\n   */\n  ParseGeneric(exit = [0]) {\n    let stream = [];\n    for (; this.index < this.length; ) {\n      const unit = this.ParseNext(stream.length === 0);\n      if (typeof unit === "number") {\n        if (exit.some((test) => unit === test)) {\n          break;\n        } else if (unit === OPEN_PAREN) {\n          this.index++;\n          const group = this.ParseGeneric([CLOSE_PAREN]);\n          this.index++;\n          if (group) {\n            stream.push({\n              type: "group",\n              id: this.id_counter++,\n              elements: [group],\n              explicit: true\n            });\n          }\n        } else {\n          const operator = this.ConsumeOperator();\n          if (operator) {\n            stream.push(operator);\n          } else {\n            this.error = `unexpected character [1]: ${String.fromCharCode(unit)}, 0x${unit.toString(16)}`;\n            this.valid = false;\n            this.index++;\n          }\n        }\n      } else {\n        stream.push(unit);\n      }\n    }\n    if (stream.length) {\n      stream = this.BinaryToRange2(stream);\n      if (this.flags.fractions) {\n        const rebuilt = [];\n        const IsInteger = (test) => {\n          return test.type === "literal" && typeof test.value === "number" && test.value % 1 === 0;\n        };\n        let i = 0;\n        for (; i < stream.length - 3; i++) {\n          if (IsInteger(stream[i]) && IsInteger(stream[i + 1]) && (stream[i + 2].type === "operator" && stream[i + 2].operator === "/") && IsInteger(stream[i + 3])) {\n            const a = stream[i];\n            const b = stream[i + 1];\n            const c = stream[i + 3];\n            const f = (a.value < 0 ? -1 : 1) * (b.value / c.value);\n            i += 3;\n            rebuilt.push({\n              id: stream[i].id,\n              type: "literal",\n              text: this.expression.substring(a.position, c.position + 1),\n              value: a.value + f,\n              position: a.position\n            });\n          } else {\n            rebuilt.push(stream[i]);\n          }\n        }\n        for (; i < stream.length; i++) {\n          rebuilt.push(stream[i]);\n        }\n        stream = rebuilt;\n      }\n      stream = stream.map((test) => {\n        if (test.type === "identifier" && test.name === this.imaginary_number) {\n          return {\n            type: "complex",\n            real: 0,\n            imaginary: 1,\n            position: test.position,\n            text: test.name,\n            id: this.id_counter++\n          };\n        }\n        return test;\n      });\n      if (this.flags.dimensioned_quantities) {\n        const rebuilt = [];\n        let unit;\n        for (let i = 0; i < stream.length; i++) {\n          const entry = stream[i];\n          if (!unit) {\n            unit = entry;\n          } else if (entry.type === "identifier" && (unit.type === "literal" || unit.type === "group" || unit.type === "call")) {\n            const identifier = entry;\n            while (stream[i + 1]?.type === "identifier") {\n              identifier.name += " " + stream[++i].name;\n            }\n            rebuilt.push({\n              type: "dimensioned",\n              expression: unit,\n              unit: entry,\n              id: this.id_counter++\n            });\n            unit = void 0;\n          } else {\n            rebuilt.push(unit);\n            unit = entry;\n          }\n        }\n        if (unit) {\n          rebuilt.push(unit);\n        }\n        stream = rebuilt;\n      }\n    }\n    if (stream.length === 0)\n      return null;\n    if (stream.length === 1)\n      return stream[0];\n    return this.BinaryToComplex(this.ArrangeUnits(stream));\n  }\n  /**\n   * helper function, @see BinaryToRange\n   * @param unit \n   * @returns \n   */\n  UnitToAddress(unit) {\n    if (unit.type === "literal") {\n      if (typeof unit.value === "number" && unit.value > 0 && !/\\./.test(unit.text || "")) {\n        return {\n          type: "address",\n          position: unit.position,\n          label: unit.value.toString(),\n          row: unit.value - 1,\n          id: this.id_counter++,\n          column: Infinity\n        };\n      }\n    } else {\n      let sheet;\n      let name = unit.name;\n      const tokens = name.split("!");\n      if (tokens.length > 1) {\n        sheet = tokens.slice(0, tokens.length - 1).join("!");\n        name = name.substr(sheet.length + 1);\n        if (sheet[0] === "\'") {\n          if (sheet.length > 1 && sheet[sheet.length - 1] === "\'") {\n            sheet = sheet.substr(1, sheet.length - 2);\n          } else {\n            return void 0;\n          }\n        }\n      }\n      const absolute = name[0] === "$";\n      name = (absolute ? name.substr(1) : name).toUpperCase();\n      const as_number = Number(name);\n      if (!isNaN(as_number)) {\n        if (as_number > 0 && as_number !== Infinity && !/\\./.test(name)) {\n          return {\n            type: "address",\n            position: unit.position,\n            absolute_row: absolute,\n            label: unit.name,\n            row: as_number - 1,\n            id: this.id_counter++,\n            column: Infinity,\n            sheet\n          };\n        }\n      } else if (/[A-Z]{1,3}/.test(name)) {\n        let column = -1;\n        for (let i = 0; i < name.length; i++) {\n          const char = name[i].charCodeAt(0);\n          column = 26 * (1 + column) + (char - UC_A);\n        }\n        return {\n          type: "address",\n          position: unit.position,\n          absolute_column: absolute,\n          label: unit.name,\n          column,\n          id: this.id_counter++,\n          row: Infinity,\n          sheet\n        };\n      }\n    }\n    return void 0;\n  }\n  /**\n   * rewrite of binary to range. this version operates on the initial stream,\n   * which should be OK because range has the highest precedence so we would\n   * never reorder a range.\n   * \n   * ACTUALLY this will break in the case of \n   * \n   * -15:16 \n   * \n   * (I think that\'s the only case). we can fix that though. this should\n   * not impact the case of `2-15:16`, because in that case the - will look\n   * like an operator and not part of the number. the same goes for a leading\n   * `+` which will get dropped implicitly but has no effect (we might want\n   * to preserve it for consistency though).\n   * \n   * NOTE: that error existed in the old version, too, and this way is perhaps\n   * better for fixing it. we should merge this into main.\n   * \n   * \n   * old version comments:\n   * ---\n   * \n   * converts binary operations with a colon operator to ranges. this also\n   * validates that there are no colon operations with non-address operands\n   * (which is why it\'s called after precendence reordering; colon has the\n   * highest preference). recursive only over binary ops AND unary ops.\n   * \n   * NOTE: there are other legal arguments to a colon operator. specifically:\n   * \n   * (1) two numbers, in either order\n   *\n   * 15:16\n   * 16:16\n   * 16:15\n   *\n   * (2) with one or both optionally having a $\n   *\n   * 15:$16\n   * $16:$16\n   *\n   * (3) two column identifiers, in either order\n   * \n   * A:F\n   * B:A\n   *\n   * (4) and the same with $\n   *\n   * $A:F\n   * $A:$F\n   * \n   * because none of these are legal in any other context, we leave the \n   * default treatment of them UNLESS they are arguments to the colon \n   * operator, in which case we will grab them. that does mean we parse\n   * them twice, but (...)\n   * \n   * FIXME: will need some updated to rendering these, we don\'t have any\n   * handler for rendering infinity\n   */\n  BinaryToRange2(stream) {\n    const result = [];\n    for (let i = 0; i < stream.length; i++) {\n      const a = stream[i];\n      const b = stream[i + 1];\n      const c = stream[i + 2];\n      let range;\n      let label = "";\n      let negative;\n      if (a && b && c && b.type === "operator" && b.operator === ":") {\n        if (a.type === "address" && c.type === "address") {\n          const start_index = a.position + a.label.length;\n          const end_index = c.position;\n          range = {\n            type: "range",\n            id: this.id_counter++,\n            position: a.position,\n            start: a,\n            end: c,\n            label: a.label + this.expression.substring(start_index, end_index) + c.label\n          };\n          label = range.start.label + ":" + range.end.label;\n          this.address_refcount[range.start.label]--;\n          this.address_refcount[range.end.label]--;\n          const positions = [a.position, c.position];\n          this.full_reference_list = this.full_reference_list.filter((test) => {\n            return test.position !== positions[0] && test.position !== positions[1];\n          });\n        } else if ((a.type === "literal" || a.type === "identifier") && (c.type === "literal" || c.type === "identifier")) {\n          let left = this.UnitToAddress(a);\n          if (!left && a.type === "literal" && typeof a.value === "number" && a.value < 0) {\n            const test = {\n              ...a,\n              text: (a.text || "").replace(/^-/, ""),\n              // <- ...sign always in position 0\n              position: a.position + 1,\n              // <- ...advance 1\n              value: -a.value\n              // <- ...invert value\n            };\n            left = this.UnitToAddress(test);\n            if (left) {\n              negative = {\n                type: "operator",\n                operator: "-",\n                position: a.position,\n                id: this.id_counter++\n              };\n            }\n          }\n          const right = this.UnitToAddress(c);\n          if (left && right && (left.column === Infinity && right.column === Infinity || left.row === Infinity && right.row === Infinity)) {\n            label = left.label + ":" + right.label;\n            range = {\n              type: "range",\n              id: this.id_counter++,\n              position: left.position,\n              start: left,\n              end: right,\n              label\n            };\n          }\n        }\n      }\n      if (range) {\n        if (negative) {\n          result.push(negative);\n        }\n        result.push(range);\n        this.dependencies.ranges[label] = range;\n        this.full_reference_list.push(range);\n        i += 2;\n      } else {\n        result.push(a);\n      }\n    }\n    return result;\n  }\n  /**\n   * we\'ve now come full circle. we started with handling ranges as \n   * binary operators; then we added complex composition as a first-pass\n   * function; then we moved ranges to a first-pass function; and now we\'re\n   * moving complex composition to a lower-level restructuring of binary\n   * operations.\n   * \n   * that allows better precedence handling for (potentially) ambiguous\n   * constructions like =B3 * 2 + 3i. we do have parens, so.\n   * \n   * @param unit \n   * @returns \n   */\n  BinaryToComplex(unit) {\n    if (unit.type === "binary") {\n      if ((unit.operator === "+" || unit.operator === "-") && unit.left.type === "literal" && typeof unit.left.value === "number" && unit.right.type === "complex" && !unit.right.composited) {\n        let text = "";\n        text = this.expression.substring(unit.left.position, unit.right.position + (unit.right.text?.length || 0));\n        let imaginary_value = unit.right.imaginary;\n        if (unit.operator === "-") {\n          imaginary_value = -imaginary_value;\n        }\n        return {\n          type: "complex",\n          position: unit.left.position,\n          text,\n          id: this.id_counter++,\n          imaginary: imaginary_value,\n          real: unit.left.value,\n          composited: true\n        };\n      } else {\n        unit.left = this.BinaryToComplex(unit.left);\n        unit.right = this.BinaryToComplex(unit.right);\n      }\n    } else if (unit.type === "unary" && (unit.operator === "-" || unit.operator === "+") && unit.operand.type === "complex" && unit.operand.text === this.imaginary_number) {\n      return {\n        ...unit.operand,\n        position: unit.position,\n        text: this.expression.substring(unit.position, unit.operand.position + (unit.operand.text || "").length),\n        imaginary: unit.operand.imaginary * (unit.operator === "-" ? -1 : 1)\n      };\n    }\n    return unit;\n  }\n  /**\n   * converts binary operations with a colon operator to ranges. this also\n   * validates that there are no colon operations with non-address operands\n   * (which is why it\'s called after precendence reordering; colon has the\n   * highest preference). recursive only over binary ops AND unary ops.\n   * \n   * NOTE: there are other legal arguments to a colon operator. specifically:\n   * \n   * (1) two numbers, in either order\n   *\n   * 15:16\n   * 16:16\n   * 16:15\n   *\n   * (2) with one or both optionally having a $\n   *\n   * 15:$16\n   * $16:$16\n   *\n   * (3) two column identifiers, in either order\n   * \n   * A:F\n   * B:A\n   *\n   * (4) and the same with $\n   *\n   * $A:F\n   * $A:$F\n   * \n   * because none of these are legal in any other context, we leave the \n   * default treatment of them UNLESS they are arguments to the colon \n   * operator, in which case we will grab them. that does mean we parse\n   * them twice, but (...)\n   * \n   * FIXME: will need some updated to rendering these, we don\'t have any\n   * handler for rendering infinity\n   */\n  BinaryToRangeX(unit) {\n    if (unit.type === "binary") {\n      if (unit.operator === ":") {\n        let range;\n        let label = "";\n        if (unit.left.type === "address" && unit.right.type === "address") {\n          const start_index = unit.left.position + unit.left.label.length;\n          const end_index = unit.right.position;\n          range = {\n            type: "range",\n            id: this.id_counter++,\n            position: unit.left.position,\n            start: unit.left,\n            end: unit.right,\n            label: unit.left.label + this.expression.substring(start_index, end_index) + unit.right.label\n          };\n          label = range.start.label + ":" + range.end.label;\n          this.address_refcount[range.start.label]--;\n          this.address_refcount[range.end.label]--;\n          const positions = [unit.left.position, unit.right.position];\n          this.full_reference_list = this.full_reference_list.filter((test) => {\n            return test.position !== positions[0] && test.position !== positions[1];\n          });\n        } else if ((unit.left.type === "literal" || unit.left.type === "identifier") && (unit.right.type === "literal" || unit.right.type === "identifier")) {\n          const left = this.UnitToAddress(unit.left);\n          const right = this.UnitToAddress(unit.right);\n          if (left && right && (left.column === Infinity && right.column === Infinity || left.row === Infinity && right.row === Infinity)) {\n            label = left.label + ":" + right.label;\n            range = {\n              type: "range",\n              id: this.id_counter++,\n              position: unit.left.position,\n              start: left,\n              end: right,\n              label\n            };\n          }\n        }\n        if (range) {\n          this.dependencies.ranges[label] = range;\n          this.full_reference_list.push(range);\n          return range;\n        } else {\n          this.error = `unexpected character: :`;\n          this.valid = false;\n        }\n      }\n      unit.left = this.BinaryToRangeX(unit.left);\n      unit.right = this.BinaryToRangeX(unit.right);\n    }\n    return unit;\n  }\n  /**\n   * reorders operations for precendence\n   */\n  ArrangeUnits(stream) {\n    if (stream.length === 0)\n      return { type: "missing", id: this.id_counter++ };\n    if (stream.length === 1)\n      return stream[0];\n    const stack = [];\n    for (let index = 0; index < stream.length; index++) {\n      let element = stream[index];\n      if (element.type === "operator") {\n        if (stack.length === 0 || stack[stack.length - 1].type === "operator") {\n          if (unary_operators[element.operator]) {\n            const right = this.BinaryToComplex(this.ArrangeUnits(stream.slice(index + 1)));\n            if (!this.valid) {\n              return {\n                type: "group",\n                id: this.id_counter++,\n                elements: stream,\n                explicit: false\n              };\n            }\n            if (right.type === "binary") {\n              right.left = {\n                type: "unary",\n                id: this.id_counter++,\n                operator: element.operator,\n                operand: right.left,\n                position: element.position\n              };\n              element = right;\n            } else {\n              element = {\n                type: "unary",\n                id: this.id_counter++,\n                operator: element.operator,\n                operand: right,\n                position: element.position\n              };\n            }\n            index = stream.length;\n          } else {\n            this.error = `unexpected character [2]: ${element.operator}`;\n            this.error_position = element.position;\n            this.valid = false;\n            return {\n              type: "group",\n              id: this.id_counter++,\n              elements: stream,\n              explicit: false\n            };\n          }\n        } else {\n          stack.push(element);\n          continue;\n        }\n      }\n      if (stack.length < 2) {\n        stack.push(element);\n      } else if (stack[stack.length - 1].type === "operator") {\n        const left = stack[stack.length - 2];\n        const operator_unit = stack[stack.length - 1];\n        const operator = operator_unit.operator;\n        const operation = {\n          type: "binary",\n          id: this.id_counter++,\n          left,\n          operator,\n          position: operator_unit.position,\n          right: element\n        };\n        if (left.type === "binary" && binary_operators_precendence[operator] > binary_operators_precendence[left.operator]) {\n          operation.left = left.left;\n          operation.operator = left.operator;\n          operation.position = left.position;\n          operation.right = {\n            type: "binary",\n            id: this.id_counter++,\n            left: left.right,\n            // <- B\n            right: element,\n            // <- C\n            operator,\n            // <- op2\n            position: operator_unit.position\n          };\n        }\n        stack.splice(-2, 2, operation);\n      } else {\n        this.error = `multiple expressions`;\n        this.error_position = element.position;\n        this.valid = false;\n        return {\n          type: "group",\n          id: this.id_counter++,\n          elements: stream,\n          explicit: false\n        };\n      }\n    }\n    return stack[0];\n  }\n  /**\n   * parses literals and tokens from the stream, ignoring whitespace,\n   * and stopping on unexpected tokens (generally operators or parens).\n   *\n   * @param naked treat -/+ as signs (part of numbers) rather than operators.\n   */\n  ParseNext(naked = true) {\n    this.ConsumeWhiteSpace();\n    const char = this.data[this.index];\n    if (char === DOUBLE_QUOTE2) {\n      return {\n        type: "literal",\n        id: this.id_counter++,\n        position: this.index,\n        value: this.ConsumeString()\n      };\n    } else if (char >= ZERO2 && char <= NINE || char === this.decimal_mark_char) {\n      return this.ConsumeNumber();\n    } else if (char === OPEN_BRACE) {\n      return this.ConsumeArray();\n    } else if (naked && (char === MINUS || char === PLUS)) {\n      const check = this.data[this.index + 1];\n      if (check >= ZERO2 && check <= NINE || check === this.decimal_mark_char) {\n        return this.ConsumeNumber();\n      }\n    } else if (char >= UC_A && char <= UC_Z || char >= LC_A && char <= LC_Z || char === UNDERSCORE2 || char === HASH || // new: only allowed in position 1, always an error\n    char === SINGLE_QUOTE || char === DOLLAR_SIGN || // we used to not allow square brackets to start tokens, because\n    // we only supported them for relative R1C1 references -- hence you\'d\n    // need the R first. but we now allow them for "structured references".\n    char === OPEN_SQUARE_BRACKET || char >= ACCENTED_RANGE_START && char <= ACCENTED_RANGE_END) {\n      return this.ConsumeToken(char);\n    }\n    return char;\n  }\n  ConsumeArray() {\n    const expression = {\n      type: "array",\n      id: this.id_counter++,\n      values: [],\n      position: this.index\n    };\n    this.index++;\n    let row = 0;\n    let column = 0;\n    while (this.index < this.length) {\n      const item = this.ParseNext();\n      const start_position = this.index;\n      if (typeof item === "number") {\n        this.index++;\n        switch (item) {\n          case SEMICOLON2:\n            column++;\n            row = 0;\n            break;\n          case COMMA2:\n            row++;\n            break;\n          case CLOSE_BRACE:\n            return expression;\n          default:\n            if (this.valid) {\n              this.error = `invalid character in array literal`;\n              this.error_position = start_position;\n              this.valid = false;\n            }\n            break;\n        }\n      } else {\n        switch (item.type) {\n          case "literal":\n            if (!expression.values[row]) {\n              expression.values[row] = [];\n            }\n            expression.values[row][column] = item.value;\n            break;\n          default:\n            if (this.valid) {\n              this.error = `invalid value in array literal`;\n              this.error_position = start_position;\n              this.valid = false;\n            }\n            break;\n        }\n      }\n    }\n    return expression;\n  }\n  ConsumeOperator() {\n    for (const operator of binary_operators) {\n      if (this.expression.substr(this.index, operator.length) === operator) {\n        const position = this.index;\n        this.index += operator.length;\n        return {\n          type: "operator",\n          id: this.id_counter++,\n          operator,\n          position\n        };\n      }\n    }\n    return null;\n  }\n  /** consume function arguments, which can be of any type */\n  ConsumeArguments() {\n    this.index++;\n    let argument_index = 0;\n    const args = [];\n    for (; this.index < this.length; ) {\n      const unit = this.ParseGeneric([\n        this.argument_separator_char,\n        CLOSE_PAREN\n      ]);\n      if (null !== unit)\n        args.push(unit);\n      const char = this.data[this.index];\n      if (char === this.argument_separator_char) {\n        this.index++;\n        argument_index++;\n        for (let i = args.length; i < argument_index; i++) {\n          args.push({ type: "missing", id: this.id_counter++ });\n        }\n      } else if (char === CLOSE_PAREN) {\n        this.index++;\n        return args;\n      }\n    }\n    return args;\n  }\n  /**\n   * consume token. also checks for function call, because parens\n   * have a different meaning (grouping/precedence) when they appear\n   * not immediately after a token.\n   *\n   * regarding periods: as long as there\'s no intervening whitespace\n   * or operator, period should be a valid token character. tokens\n   * cannot start with a period.\n   *\n   * NOTE: that\'s true irrespective of decimal mark type.\n   *\n   * you can have tokens (addresses) with single quotes; these are used\n   * to escape sheet names with spaces (which is a bad idea, but hey). this\n   * should only be legal if the token starts with a single quote, and only\n   * for one (closing) quote.\n   * \n   * R1C1 relative notation uses square brackets, like =R2C[-1] or =R[-1]C[-2].\n   * that\'s pretty easy to see. there\'s also regular R1C1, like =R1C1.\n   * \n   * "structured references" use square brackets. they can start with \n   * square brackets -- in that case the table source is implicit (has to\n   * be in the table). otherwise they look like =TableName[@ColumnName]. that\n   * @ is optional and (I think) means don\'t spill.\n   * \n   */\n  ConsumeToken(initial_char) {\n    const token = [initial_char];\n    const position = this.index;\n    let single_quote = initial_char === SINGLE_QUOTE;\n    let square_bracket = 0;\n    let braces = false;\n    if (initial_char === OPEN_SQUARE_BRACKET) {\n      square_bracket = 1;\n      braces = true;\n    }\n    for (++this.index; this.index < this.length; this.index++) {\n      const char = this.data[this.index];\n      if (char >= UC_A && char <= UC_Z || char >= LC_A && char <= LC_Z || char >= ACCENTED_RANGE_START && char <= ACCENTED_RANGE_END || char === UNDERSCORE2 || char === DOLLAR_SIGN || char === PERIOD2 || char === EXCLAMATION_MARK || single_quote || // ((char === SINGLE_QUOTE || char === SPACE) && single_quote) ||\n      char >= ZERO2 && char <= NINE || char === OPEN_SQUARE_BRACKET || square_bracket > 0 && char === CLOSE_SQUARE_BRACKET || char === MINUS && this.flags.r1c1 && square_bracket === 1 || square_bracket > 0 && char === AT2 && this.data[this.index - 1] === OPEN_SQUARE_BRACKET || square_bracket === 1 && (char === COMMA2 || char === SPACE) || square_bracket > 1) {\n        token.push(char);\n        if (char === OPEN_SQUARE_BRACKET) {\n          square_bracket++;\n          braces = true;\n        }\n        if (char === CLOSE_SQUARE_BRACKET) {\n          square_bracket--;\n        }\n        if (char === SINGLE_QUOTE) {\n          single_quote = false;\n        }\n      } else\n        break;\n    }\n    const str = token.map((num) => String.fromCharCode(num)).join("");\n    if (single_quote) {\n      this.error = `unbalanced single quote`;\n      this.error_position = position;\n      this.valid = false;\n      return {\n        type: "identifier",\n        id: this.id_counter++,\n        name: str,\n        position\n      };\n    }\n    if (square_bracket) {\n      this.error = `unbalanced square bracket`;\n      this.error_position = position;\n      this.valid = false;\n      return {\n        type: "identifier",\n        id: this.id_counter++,\n        name: str,\n        position\n      };\n    }\n    if (str.toLowerCase() === "true") {\n      return {\n        type: "literal",\n        id: this.id_counter++,\n        value: true,\n        position\n      };\n    }\n    if (str.toLowerCase() === "false") {\n      return {\n        type: "literal",\n        id: this.id_counter++,\n        value: false,\n        position\n      };\n    }\n    this.ConsumeWhiteSpace();\n    const next_char = this.data[this.index];\n    if (next_char === OPEN_PAREN) {\n      const args = this.ConsumeArguments();\n      return {\n        type: "call",\n        id: this.id_counter++,\n        name: str,\n        args,\n        position\n      };\n    }\n    if (this.flags.spreadsheet_semantics) {\n      const address = this.ConsumeAddress(str, position);\n      if (address)\n        return address;\n      if (braces) {\n        const structured = this.ConsumeStructuredReference(str, position);\n        if (structured) {\n          return structured;\n        }\n      }\n    }\n    const identifier = {\n      type: "identifier",\n      id: this.id_counter++,\n      name: str,\n      position\n    };\n    this.full_reference_list.push(identifier);\n    return identifier;\n  }\n  /**\n   * like ConsumeAddress, look for a structured reference.\n   */\n  ConsumeStructuredReference(token, position) {\n    const index = position;\n    const token_length = token.length;\n    const label = token;\n    let table = "";\n    let i = 0;\n    for (; i < token_length; i++) {\n      if (token[i] === "[") {\n        token = token.substring(i);\n        break;\n      }\n      table += token[i];\n    }\n    if (token[0] !== "[" || token[token.length - 1] !== "]") {\n      return void 0;\n    }\n    token = token.substring(1, token.length - 1);\n    const parts = token.split(",").map((part) => part.trim());\n    let scope = "column";\n    let column = "";\n    if (parts.length > 2) {\n      return void 0;\n    } else if (parts.length === 2) {\n      if (/\\[#this row\\]/i.test(parts[0])) {\n        scope = "row";\n      } else if (/\\[#all\\]/i.test(parts[0])) {\n        scope = "all";\n      }\n      column = parts[1];\n    } else {\n      column = parts[0];\n      if (column[0] === "@") {\n        scope = "row";\n        column = column.substring(1, column.length);\n      }\n    }\n    if (column[0] === "[" && column[column.length - 1] === "]") {\n      column = column.substring(1, column.length - 1);\n    }\n    const reference = {\n      type: "structured-reference",\n      id: this.id_counter++,\n      label,\n      position,\n      scope,\n      column,\n      table\n    };\n    this.full_reference_list.push(reference);\n    return reference;\n  }\n  /**\n   * consumes address. this is outside of the normal parse flow;\n   * we already have a token, here we\'re checking if it\'s an address.\n   *\n   * this used to check for ranges as well, but we now treat ranges as\n   * an operation on two addresses; that supports whitespace between the\n   * tokens.\n   *\n   * FIXME: that means we can now inline the column/row routines, since\n   * they are not called more than once\n   */\n  ConsumeAddress(token, position) {\n    const index = position;\n    const token_length = token.length;\n    let sheet;\n    const tokens = token.split("!");\n    if (tokens.length > 1) {\n      sheet = tokens.slice(0, tokens.length - 1).join("!");\n      position += sheet.length + 1;\n    }\n    if (this.flags.r1c1) {\n      const match = tokens[tokens.length - 1].match(this.r1c1_regex);\n      if (match) {\n        const r1c1 = {\n          type: "address",\n          id: this.id_counter++,\n          label: token,\n          // TODO\n          row: 0,\n          column: 0,\n          // absolute_row: false, // TODO: is this supported?\n          // absolute_column: false, // TODO: is this supported?\n          position: index,\n          sheet,\n          r1c1: true\n        };\n        if (match[1][0] === "[") {\n          r1c1.offset_row = true;\n          r1c1.row = Number(match[1].substring(1, match[1].length - 1));\n        } else {\n          r1c1.row = Number(match[1]) - 1;\n        }\n        if (match[2][0] === "[") {\n          r1c1.offset_column = true;\n          r1c1.column = Number(match[2].substring(1, match[2].length - 1));\n        } else {\n          r1c1.column = Number(match[2]) - 1;\n        }\n        return r1c1;\n      }\n    }\n    const c = this.ConsumeAddressColumn(position);\n    if (!c)\n      return null;\n    position = c.position;\n    const r = this.ConsumeAddressRow(position);\n    if (!r)\n      return null;\n    position = r.position;\n    const label = sheet ? sheet + token.substr(sheet.length, position - index).toUpperCase() : token.substr(0, position - index).toUpperCase();\n    if (sheet && sheet[0] === "\'") {\n      sheet = sheet.substr(1, sheet.length - 2);\n    }\n    const addr = {\n      type: "address",\n      id: this.id_counter++,\n      label,\n      // : token.substr(0, position - index).toUpperCase(),\n      row: r.row,\n      column: c.column,\n      absolute_row: r.absolute,\n      absolute_column: c.absolute,\n      position: index,\n      sheet\n    };\n    if (token_length !== position - index)\n      return null;\n    this.dependencies.addresses[addr.label] = addr;\n    this.address_refcount[addr.label] = (this.address_refcount[addr.label] || 0) + 1;\n    this.full_reference_list.push(addr);\n    return addr;\n  }\n  /**\n   * consumes a row, possibly absolute ($). returns the numeric row\n   * (0-based) and metadata\n   */\n  ConsumeAddressRow(position) {\n    const absolute = this.data[position] === DOLLAR_SIGN;\n    if (absolute)\n      position++;\n    const start = position;\n    let value = 0;\n    for (; ; position++) {\n      const char = this.data[position];\n      if (char >= ZERO2 && char <= NINE) {\n        value *= 10;\n        value += char - ZERO2;\n      } else\n        break;\n    }\n    if (start === position)\n      return false;\n    return { absolute, row: value - 1, position };\n  }\n  /**\n   * consumes a column, possibly absolute ($). returns the numeric\n   * column (0-based) and metadata\n   */\n  ConsumeAddressColumn(position) {\n    let column = -1;\n    let length = 0;\n    const absolute = this.data[position] === DOLLAR_SIGN;\n    if (absolute)\n      position++;\n    for (; ; position++, length++) {\n      if (length >= 4)\n        return false;\n      const char = this.data[position];\n      if (char >= UC_A && char <= UC_Z) {\n        column = 26 * (1 + column) + (char - UC_A);\n      } else if (char >= LC_A && char <= LC_Z) {\n        column = 26 * (1 + column) + (char - LC_A);\n      } else\n        break;\n    }\n    if (column < 0)\n      return false;\n    return { absolute, column, position };\n  }\n  /**\n   * consumes number. supported formats (WIP):\n   *\n   * -3\n   * +3\n   * 100.9\n   * 10.0%\n   * 1e-2.2\n   *\n   * ~1,333,123.22~\n   *\n   * UPDATE: commas (separators) are not acceptable in numbers passed\n   * in formulae, can\'t distinguish between them and function argument\n   * separators.\n   *\n   * regarding the above, a couple of rules:\n   *\n   * 1. +/- is only legal in position 0 or immediately after e/E\n   * 2. only one decimal point is allowed.\n   * 3. any number of separators, in any position, are legal, but\n   *    only before the decimal point.\n   * 4. only one % is allowed, and only in the last position\n   *\n   * NOTE: this is probably going to break on unfinished strings that\n   * end in - or +... if they\'re not treated as operators...\n   *\n   * FIXME: find test cases for that so we can fix it\n   *\n   * UPDATE: exporting original text string for preservation/insertion.\n   * this function now returns a tuple of [value, text].\n   *\n   * UPDATE: we now (at least in a branch) consume complex numbers. the last \n   * element of the return array is a boolean which is set if the value is an \n   * imaginary number. when parsing, we will only see the imaginary part; \n   * we\'ll use a separate step to put complex numbers together.\n   * \n   * \n   */\n  ConsumeNumber() {\n    const starting_position = this.index;\n    let exponent = 0;\n    let negative_exponent = false;\n    let negative = false;\n    let integer = 0;\n    let decimal = 0;\n    let fraction = 0;\n    let state = "integer";\n    let position = 0;\n    let imaginary = false;\n    const start_index = this.index;\n    for (; this.index < this.length; this.index++, position++) {\n      const char = this.data[this.index];\n      if (char === this.decimal_mark_char) {\n        if (state === "integer")\n          state = "fraction";\n        else\n          break;\n      } else if (char === PERCENT2) {\n        integer /= 100;\n        fraction /= 100;\n        this.index++;\n        break;\n      } else if (char === PLUS || char === MINUS) {\n        if (position === 0) {\n          if (char === MINUS)\n            negative = true;\n        } else\n          break;\n      } else if (char === UC_E || char === LC_E) {\n        if (state === "integer" || state === "fraction") {\n          state = "exponent";\n          if (this.index < this.length - 1) {\n            if (this.data[this.index + 1] === PLUS)\n              this.index++;\n            else if (this.data[this.index + 1] === MINUS) {\n              this.index++;\n              negative_exponent = true;\n            }\n          }\n        } else\n          break;\n      } else if (char === this.imaginary_char) {\n        const peek = this.data[this.index + 1];\n        if (peek >= UC_A && peek <= UC_Z || peek >= LC_A && peek <= LC_Z || peek >= ACCENTED_RANGE_START && peek <= ACCENTED_RANGE_END || peek === UNDERSCORE2) {\n          break;\n        }\n        if (state === "integer" || state === "fraction") {\n          this.index++;\n          imaginary = true;\n          break;\n        }\n      } else if (char >= ZERO2 && char <= NINE) {\n        switch (state) {\n          case "integer":\n            integer = integer * 10 + (char - ZERO2);\n            break;\n          case "fraction":\n            fraction = fraction * 10 + (char - ZERO2);\n            decimal++;\n            break;\n          case "exponent":\n            exponent = exponent * 10 + (char - ZERO2);\n            break;\n        }\n      } else\n        break;\n    }\n    let value = integer + fraction / Math.pow(10, decimal);\n    if (state === "exponent") {\n      value = value * Math.pow(10, (negative_exponent ? -1 : 1) * exponent);\n    }\n    if (imaginary) {\n      return {\n        type: "complex",\n        id: this.id_counter++,\n        position: starting_position,\n        imaginary: negative ? -value : value,\n        real: 0,\n        text: this.expression.substring(start_index, this.index) || ""\n      };\n    } else {\n      return {\n        type: "literal",\n        id: this.id_counter++,\n        position: starting_position,\n        value: negative ? -value : value,\n        text: this.expression.substring(start_index, this.index) || ""\n      };\n    }\n  }\n  /**\n   * in spreadsheet language ONLY double-quoted strings are legal. there\n   * are no escape characters, and a backslash is a legal character. to\n   * embed a quotation mark, use "" (double-double quote); that\'s an escaped\n   * double-quote.\n   */\n  ConsumeString() {\n    this.index++;\n    const str = [];\n    for (; this.index < this.length; this.index++) {\n      const char = this.data[this.index];\n      if (char === DOUBLE_QUOTE2) {\n        this.index++;\n        if (this.index >= this.length || this.data[this.index] !== DOUBLE_QUOTE2) {\n          break;\n        }\n      }\n      str.push(char);\n    }\n    return str.map((char) => String.fromCharCode(char)).join("");\n  }\n  /** run through any intervening whitespace */\n  ConsumeWhiteSpace() {\n    for (; this.index < this.length; ) {\n      const char = this.data[this.index];\n      if (char === SPACE || char === TAB || char === CR || char === LF || char === NON_BREAKING_SPACE) {\n        this.index++;\n      } else\n        return;\n    }\n  }\n};\n\n// treb-parser/src/md-parser.ts\nvar MDParser = class _MDParser {\n  static _instance = new _MDParser();\n  constructor() {\n  }\n  static get instance() {\n    return this._instance;\n  }\n  /**\n   * given some formatted text (output of the `Parse` method), return HTML.\n   * FIXME: is this used outside of testing? seems like we\'re wasting bytes.\n   * \n   * also the way this works adds extra tags if you have nested styles. not\n   * an issue if it\'s just for testing though.\n   */\n  HTML(formatted) {\n    const lines = [];\n    for (const line of formatted) {\n      const text = [];\n      for (const element of line) {\n        if (element.pre) {\n          text.push("<pre>");\n        }\n        if (element.emphasis) {\n          text.push("<em>");\n        }\n        if (element.strong) {\n          text.push("<strong>");\n        }\n        if (element.strike) {\n          text.push("<strike>");\n        }\n        text.push(element.text);\n        if (element.strike) {\n          text.push("</strike>");\n        }\n        if (element.strong) {\n          text.push("</strong>");\n        }\n        if (element.emphasis) {\n          text.push("</em>");\n        }\n        if (element.pre) {\n          text.push("</pre>");\n        }\n      }\n      lines.push(text.join(""));\n    }\n    return lines.join("<br/>\\n");\n  }\n  /**\n   * this is a replacement for the Parse() method, if you don\'t actually\n   * want to parse markdown. the aim is to have a unified result format,\n   * even if we\'re not handling md. \n   */\n  Dummy(text = "") {\n    return text.split(/\\n/).map((text2) => [{ text: text2 }]);\n  }\n  /**\n   * given some input text, creates a set of text tokens with \n   * emphasis/strong emphasis applied. splits into lines (the \n   * outer array). whitespace (other than newlines) is preserved.\n   */\n  Parse(text = "") {\n    const tokens = this.Tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      if (token.type === "delimeter") {\n        const preceding = tokens[i - 1];\n        const following = tokens[i + 1];\n        const preceded_by_whitespace = !preceding || preceding.type === "whitespace" || preceding.type === "newline";\n        const preceded_by_punctuation = preceding && preceding.type === "text" && /[^\\w\\d]$/.test(preceding.text);\n        const followed_by_whitespace = !following || following.type === "whitespace" || following.type === "newline";\n        const followed_by_punctuation = following && following.type === "text" && /^[^\\w\\d]/.test(following.text);\n        token.left_flanking = !followed_by_whitespace && (!followed_by_punctuation || preceded_by_whitespace);\n        token.right_flanking = !preceded_by_whitespace && (!preceded_by_punctuation || (followed_by_whitespace || followed_by_punctuation));\n      }\n    }\n    this.ApplyFormatting(tokens);\n    return this.Consolidate(tokens);\n  }\n  /** is this worth a function call? will it get inlined? */\n  IsWhitespace(char) {\n    return char === " " || char === "	";\n  }\n  /** is this worth a function call? will it get inlined? */\n  IsNewline(char) {\n    return char === "\\r" || char === "\\n";\n  }\n  /** is this worth a function call? will it get inlined? */\n  IsDelimeter(char) {\n    return char === "*" || char === "_" || char === "~";\n  }\n  /**\n   * consolidate text with common formatting. splits into lines (newlines are not rendered).\n   */\n  Consolidate(tokens) {\n    const result = [];\n    const format = {};\n    let line = [];\n    let current_token = { type: "text", text: "" };\n    for (const token of tokens) {\n      if (token.type === "newline") {\n        if (current_token.text.length) {\n          line.push(current_token);\n        }\n        current_token = { ...format, text: "", type: "text" };\n        result.push(line);\n        line = [];\n      } else {\n        if (!!format.strong !== !!token.strong || !!format.emphasis !== !!token.emphasis || !!format.strike !== !!token.strike) {\n          format.strong = !!token.strong;\n          format.emphasis = !!token.emphasis;\n          format.strike = !!token.strike;\n          if (current_token.text.length) {\n            line.push(current_token);\n          }\n          current_token = { ...format, text: "", type: "text" };\n        }\n        switch (token.type) {\n          case "text":\n          case "whitespace":\n            current_token.text += token.text;\n            break;\n          case "delimeter":\n            for (let i = 0; i < token.length; i++) {\n              current_token.text += token.char;\n            }\n            break;\n        }\n      }\n    }\n    if (current_token.text.length) {\n      line.push(current_token);\n    }\n    if (line.length) {\n      result.push(line);\n    }\n    return result;\n  }\n  /**\n   *\n   */\n  ApplyFormatting(tokens, open) {\n    let index = 0;\n    const length = tokens.length;\n    for (index = 0; index < length; index++) {\n      const token = tokens[index];\n      if (token.type === "delimeter") {\n        if (open && token.right_flanking && open.char === token.char && token.length > 0) {\n          return { index, token };\n        }\n        if (token.left_flanking) {\n          const result = this.ApplyFormatting(tokens.slice(index + 1), token);\n          if (result.token) {\n            const format = Math.min(result.token.length, token.length);\n            const strike = token.char === "~";\n            const emphasis = !strike && !!(format % 2);\n            const strong = !strike && format >= 2;\n            for (let i = index + 1; i <= index + result.index; i++) {\n              tokens[i].strong = !!tokens[i].strong || strong;\n              tokens[i].emphasis = !!tokens[i].emphasis || emphasis;\n              tokens[i].strike = !!tokens[i].strike || strike;\n            }\n            result.token.length -= format;\n            token.length -= format;\n            if (token.length > 0) {\n              index--;\n            } else {\n              index += result.index;\n            }\n          }\n        }\n      }\n    }\n    return { index };\n  }\n  /**\n   * \n   */\n  Tokenize(text = "") {\n    const tokens = [];\n    const length = text.length;\n    let index = 0;\n    let escape = false;\n    let current_token = "";\n    for (index = 0; index < length; index++) {\n      const char = text[index];\n      if (this.IsWhitespace(char)) {\n        if (current_token) {\n          tokens.push({ type: "text", text: current_token });\n        }\n        let tmp = char;\n        for (; ; ) {\n          const next_char = text[index + 1];\n          if (this.IsWhitespace(next_char)) {\n            tmp += next_char;\n            index++;\n          } else {\n            break;\n          }\n        }\n        tokens.push({\n          type: "whitespace",\n          text: tmp\n        });\n        escape = false;\n        current_token = "";\n      } else if (this.IsNewline(char)) {\n        if (current_token) {\n          tokens.push({ type: "text", text: current_token });\n        }\n        let tmp = char;\n        for (; ; ) {\n          const next_char = text[index + 1];\n          if (this.IsNewline(next_char)) {\n            tmp += next_char;\n            index++;\n          } else {\n            break;\n          }\n        }\n        tokens.push({\n          type: "newline",\n          text: tmp\n        });\n        escape = false;\n        current_token = "";\n      } else if (escape) {\n        current_token += char;\n        escape = false;\n      } else if (this.IsDelimeter(char)) {\n        if (current_token) {\n          tokens.push({ type: "text", text: current_token });\n        }\n        let tmp = char;\n        for (; ; ) {\n          const next_char = text[index + 1];\n          if (next_char === char) {\n            tmp += next_char;\n            index++;\n          } else {\n            break;\n          }\n        }\n        tokens.push({\n          type: "delimeter",\n          text: tmp,\n          char,\n          length: tmp.length\n        });\n        escape = false;\n        current_token = "";\n      } else if (char === "\\\\") {\n        escape = true;\n      } else {\n        current_token += char;\n      }\n    }\n    if (current_token) {\n      tokens.push({ type: "text", text: current_token });\n    }\n    return tokens;\n  }\n};\n\n// treb-export/src/drawing2/chart-template-components2.ts\nvar ref_title = {\n  "c:tx": {\n    "c:strRef": {\n      "c:f": "",\n      // reference: Sheet1!$E$3\n      "c:strCache": {\n        "c:ptCount": {\n          a$: {\n            "val": "1"\n          }\n        },\n        "c:pt": {\n          a$: {\n            "idx": "0"\n          },\n          "c:v": ""\n          // cached value: Fishton Lanier\n        }\n      }\n    }\n  },\n  "c:overlay": {\n    a$: {\n      "val": "0"\n    }\n  },\n  "c:spPr": {\n    "a:noFill": {},\n    "a:ln": {\n      "a:noFill": {}\n    },\n    "a:effectLst": {}\n  },\n  "c:txPr": {\n    "a:bodyPr": {\n      a$: {\n        "rot": "0",\n        "spcFirstLastPara": "1",\n        "vertOverflow": "ellipsis",\n        "vert": "horz",\n        "wrap": "square",\n        "anchor": "ctr",\n        "anchorCtr": "1"\n      }\n    },\n    "a:lstStyle": {},\n    "a:p": {\n      "a:pPr": {\n        "a:defRPr": {\n          a$: {\n            "sz": "1400",\n            "b": "0",\n            "i": "0",\n            "u": "none",\n            "strike": "noStrike",\n            "kern": "1200",\n            "spc": "0",\n            "baseline": "0"\n          },\n          "a:solidFill": {\n            "a:schemeClr": {\n              a$: {\n                "val": "tx1"\n              },\n              "a:lumMod": {\n                a$: {\n                  "val": "65000"\n                }\n              },\n              "a:lumOff": {\n                a$: {\n                  "val": "35000"\n                }\n              }\n            }\n          },\n          "a:latin": {\n            a$: {\n              "typeface": "+mn-lt"\n            }\n          },\n          "a:ea": {\n            a$: {\n              "typeface": "+mn-ea"\n            }\n          },\n          "a:cs": {\n            a$: {\n              "typeface": "+mn-cs"\n            }\n          }\n        }\n      },\n      "a:endParaRPr": {\n        a$: {\n          "lang": "en-US"\n        }\n      }\n    }\n  }\n};\nvar static_title = {\n  "c:tx": {\n    "c:rich": {\n      "a:bodyPr": {\n        a$: {\n          "rot": "0",\n          "spcFirstLastPara": "1",\n          "vertOverflow": "ellipsis",\n          "vert": "horz",\n          "wrap": "square",\n          "anchor": "ctr",\n          "anchorCtr": "1"\n        }\n      },\n      "a:lstStyle": {},\n      "a:p": {\n        "a:pPr": {\n          "a:defRPr": {\n            a$: {\n              "sz": "1400",\n              "b": "0",\n              "i": "0",\n              "u": "none",\n              "strike": "noStrike",\n              "kern": "1200",\n              "spc": "0",\n              "baseline": "0"\n            },\n            "a:solidFill": {\n              "a:schemeClr": {\n                a$: {\n                  "val": "tx1"\n                },\n                "a:lumMod": {\n                  a$: {\n                    "val": "65000"\n                  }\n                },\n                "a:lumOff": {\n                  a$: {\n                    "val": "35000"\n                  }\n                }\n              }\n            },\n            "a:latin": {\n              a$: {\n                "typeface": "+mn-lt"\n              }\n            },\n            "a:ea": {\n              a$: {\n                "typeface": "+mn-ea"\n              }\n            },\n            "a:cs": {\n              a$: {\n                "typeface": "+mn-cs"\n              }\n            }\n          }\n        },\n        "a:r": {\n          "a:rPr": {\n            a$: {\n              "lang": ""\n              // locale: en-US\n            }\n          },\n          "a:t": ""\n          // text: Herbal Metrix\n        }\n      }\n    }\n  },\n  "c:overlay": {\n    a$: {\n      "val": "0"\n    }\n  },\n  "c:spPr": {\n    "a:noFill": {},\n    "a:ln": {\n      "a:noFill": {}\n    },\n    "a:effectLst": {}\n  },\n  "c:txPr": {\n    "a:bodyPr": {\n      a$: {\n        "rot": "0",\n        "spcFirstLastPara": "1",\n        "vertOverflow": "ellipsis",\n        "vert": "horz",\n        "wrap": "square",\n        "anchor": "ctr",\n        "anchorCtr": "1"\n      }\n    },\n    "a:lstStyle": {},\n    "a:p": {\n      "a:pPr": {\n        "a:defRPr": {\n          a$: {\n            "sz": "1400",\n            "b": "0",\n            "i": "0",\n            "u": "none",\n            "strike": "noStrike",\n            "kern": "1200",\n            "spc": "0",\n            "baseline": "0"\n          },\n          "a:solidFill": {\n            "a:schemeClr": {\n              a$: {\n                "val": "tx1"\n              },\n              "a:lumMod": {\n                a$: {\n                  "val": "65000"\n                }\n              },\n              "a:lumOff": {\n                a$: {\n                  "val": "35000"\n                }\n              }\n            }\n          },\n          "a:latin": {\n            a$: {\n              "typeface": "+mn-lt"\n            }\n          },\n          "a:ea": {\n            a$: {\n              "typeface": "+mn-ea"\n            }\n          },\n          "a:cs": {\n            a$: {\n              "typeface": "+mn-cs"\n            }\n          }\n        }\n      },\n      "a:endParaRPr": {\n        a$: {\n          "lang": "en-US"\n        }\n      }\n    }\n  }\n};\nvar chart_template = {\n  "c:chartSpace": {\n    a$: {\n      "xmlns:c": "http://schemas.openxmlformats.org/drawingml/2006/chart",\n      "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main",\n      "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",\n      "xmlns:c16r2": "http://schemas.microsoft.com/office/drawing/2015/06/chart"\n    },\n    "c:date1904": {\n      a$: {\n        "val": "0"\n      }\n    },\n    "c:lang": {\n      a$: {\n        "val": "en-US"\n      }\n    },\n    "c:roundedCorners": {\n      a$: {\n        "val": "0"\n      }\n    },\n    "mc:AlternateContent": {\n      a$: {\n        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006"\n      },\n      "mc:Choice": {\n        a$: {\n          "Requires": "c14",\n          "xmlns:c14": "http://schemas.microsoft.com/office/drawing/2007/8/2/chart"\n        },\n        "c14:style": {\n          a$: {\n            "val": "102"\n          }\n        }\n      },\n      "mc:Fallback": {\n        "c:style": {\n          a$: {\n            "val": "2"\n          }\n        }\n      }\n    },\n    "c:chart": {},\n    "c:spPr": {\n      "a:solidFill": {\n        "a:schemeClr": {\n          a$: {\n            "val": "bg1"\n          }\n        }\n      },\n      "a:ln": {\n        a$: {\n          "w": "9525",\n          "cap": "flat",\n          "cmpd": "sng",\n          "algn": "ctr"\n        },\n        "a:solidFill": {\n          "a:schemeClr": {\n            a$: {\n              "val": "tx1"\n            },\n            "a:lumMod": {\n              a$: {\n                "val": "15000"\n              }\n            },\n            "a:lumOff": {\n              a$: {\n                "val": "85000"\n              }\n            }\n          }\n        },\n        "a:round": {}\n      },\n      "a:effectLst": {}\n    },\n    "c:txPr": {\n      "a:bodyPr": {},\n      "a:lstStyle": {},\n      "a:p": {\n        "a:pPr": {\n          "a:defRPr": {}\n        },\n        "a:endParaRPr": {\n          a$: {\n            "lang": "en-US"\n          }\n        }\n      }\n    },\n    "c:printSettings": {\n      "c:headerFooter": {},\n      "c:pageMargins": {\n        a$: {\n          "b": "0.75",\n          "l": "0.7",\n          "r": "0.7",\n          "t": "0.75",\n          "header": "0.3",\n          "footer": "0.3"\n        }\n      },\n      "c:pageSetup": {}\n    }\n  }\n};\n\n// treb-export/src/drawing2/column-chart-template2.ts\nvar column_series = {\n  "c:idx": {\n    a$: {\n      "val": "0"\n    }\n  },\n  "c:order": {\n    a$: {\n      "val": "0"\n    }\n  },\n  "c:spPr": {\n    "a:solidFill": {\n      "a:schemeClr": {\n        a$: {\n          "val": "accent1"\n        }\n      }\n    },\n    "a:ln": {\n      "a:noFill": {}\n    },\n    "a:effectLst": {}\n  },\n  "c:invertIfNegative": {\n    a$: {\n      "val": "0"\n    }\n  },\n  "c:val": {\n    "c:numRef": {\n      "c:f": ""\n      // ref: \'Sheet1!$B$3:$B$14\'\n    }\n  },\n  "c:extLst": {\n    "c:ext": {\n      a$: {\n        "uri": "{C3380CC4-5D6E-409C-BE32-E72D297353CC}",\n        "xmlns:c16": "http://schemas.microsoft.com/office/drawing/2014/chart"\n      },\n      "c16:uniqueId": {\n        a$: {\n          "val": "{00000000-F52E-47BC-822F-A046A80610BE}"\n        }\n      }\n    }\n  }\n};\nvar column_json = {\n  "c:title": {},\n  "c:autoTitleDeleted": {\n    a$: {\n      "val": "0"\n    }\n  },\n  "c:plotArea": {\n    "c:layout": {},\n    "c:barChart": {\n      "c:barDir": {\n        a$: {\n          "val": "col"\n        }\n      },\n      "c:grouping": {\n        a$: {\n          "val": "clustered"\n        }\n      },\n      "c:varyColors": {\n        a$: {\n          "val": "0"\n        }\n      },\n      "c:ser": [],\n      "c:dLbls": {\n        "c:showLegendKey": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:showVal": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:showCatName": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:showSerName": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:showPercent": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:showBubbleSize": {\n          a$: {\n            "val": "0"\n          }\n        }\n      },\n      "c:gapWidth": {\n        a$: {\n          "val": "219"\n        }\n      },\n      "c:overlap": {\n        a$: {\n          "val": "-27"\n        }\n      },\n      "c:axId": [\n        {\n          a$: {\n            "val": "47003664"\n          }\n        },\n        {\n          a$: {\n            "val": "1789284464"\n          }\n        }\n      ]\n    },\n    "c:catAx": {\n      "c:axId": {\n        a$: {\n          "val": "47003664"\n        }\n      },\n      "c:scaling": {\n        "c:orientation": {\n          a$: {\n            "val": "minMax"\n          }\n        }\n      },\n      "c:delete": {\n        a$: {\n          "val": "0"\n        }\n      },\n      "c:axPos": {\n        a$: {\n          "val": "b"\n        }\n      },\n      "c:majorTickMark": {\n        a$: {\n          "val": "none"\n        }\n      },\n      "c:minorTickMark": {\n        a$: {\n          "val": "none"\n        }\n      },\n      "c:tickLblPos": {\n        a$: {\n          "val": "nextTo"\n        }\n      },\n      "c:spPr": {\n        "a:noFill": {},\n        "a:ln": {\n          a$: {\n            "w": "9525",\n            "cap": "flat",\n            "cmpd": "sng",\n            "algn": "ctr"\n          },\n          "a:solidFill": {\n            "a:schemeClr": {\n              a$: {\n                "val": "tx1"\n              },\n              "a:lumMod": {\n                a$: {\n                  "val": "15000"\n                }\n              },\n              "a:lumOff": {\n                a$: {\n                  "val": "85000"\n                }\n              }\n            }\n          },\n          "a:round": {}\n        },\n        "a:effectLst": {}\n      },\n      "c:txPr": {\n        "a:bodyPr": {\n          a$: {\n            "rot": "-60000000",\n            "spcFirstLastPara": "1",\n            "vertOverflow": "ellipsis",\n            "vert": "horz",\n            "wrap": "square",\n            "anchor": "ctr",\n            "anchorCtr": "1"\n          }\n        },\n        "a:lstStyle": {},\n        "a:p": {\n          "a:pPr": {\n            "a:defRPr": {\n              a$: {\n                "sz": "900",\n                "b": "0",\n                "i": "0",\n                "u": "none",\n                "strike": "noStrike",\n                "kern": "1200",\n                "baseline": "0"\n              },\n              "a:solidFill": {\n                "a:schemeClr": {\n                  a$: {\n                    "val": "tx1"\n                  },\n                  "a:lumMod": {\n                    a$: {\n                      "val": "65000"\n                    }\n                  },\n                  "a:lumOff": {\n                    a$: {\n                      "val": "35000"\n                    }\n                  }\n                }\n              },\n              "a:latin": {\n                a$: {\n                  "typeface": "+mn-lt"\n                }\n              },\n              "a:ea": {\n                a$: {\n                  "typeface": "+mn-ea"\n                }\n              },\n              "a:cs": {\n                a$: {\n                  "typeface": "+mn-cs"\n                }\n              }\n            }\n          },\n          "a:endParaRPr": {\n            a$: {\n              "lang": "en-US"\n            }\n          }\n        }\n      },\n      "c:crossAx": {\n        a$: {\n          "val": "1789284464"\n        }\n      },\n      "c:crosses": {\n        a$: {\n          "val": "autoZero"\n        }\n      },\n      "c:auto": {\n        a$: {\n          "val": "1"\n        }\n      },\n      "c:lblAlgn": {\n        a$: {\n          "val": "ctr"\n        }\n      },\n      "c:lblOffset": {\n        a$: {\n          "val": "100"\n        }\n      },\n      "c:noMultiLvlLbl": {\n        a$: {\n          "val": "0"\n        }\n      }\n    },\n    "c:valAx": {\n      "c:axId": {\n        a$: {\n          "val": "1789284464"\n        }\n      },\n      "c:scaling": {\n        "c:orientation": {\n          a$: {\n            "val": "minMax"\n          }\n        }\n      },\n      "c:delete": {\n        a$: {\n          "val": "0"\n        }\n      },\n      "c:axPos": {\n        a$: {\n          "val": "l"\n        }\n      },\n      "c:majorGridlines": {\n        "c:spPr": {\n          "a:ln": {\n            a$: {\n              "w": "9525",\n              "cap": "flat",\n              "cmpd": "sng",\n              "algn": "ctr"\n            },\n            "a:solidFill": {\n              "a:schemeClr": {\n                a$: {\n                  "val": "tx1"\n                },\n                "a:lumMod": {\n                  a$: {\n                    "val": "15000"\n                  }\n                },\n                "a:lumOff": {\n                  a$: {\n                    "val": "85000"\n                  }\n                }\n              }\n            },\n            "a:round": {}\n          },\n          "a:effectLst": {}\n        }\n      },\n      "c:numFmt": {\n        a$: {\n          "formatCode": "General",\n          "sourceLinked": "1"\n        }\n      },\n      "c:majorTickMark": {\n        a$: {\n          "val": "none"\n        }\n      },\n      "c:minorTickMark": {\n        a$: {\n          "val": "none"\n        }\n      },\n      "c:tickLblPos": {\n        a$: {\n          "val": "nextTo"\n        }\n      },\n      "c:spPr": {\n        "a:noFill": {},\n        "a:ln": {\n          "a:noFill": {}\n        },\n        "a:effectLst": {}\n      },\n      "c:txPr": {\n        "a:bodyPr": {\n          a$: {\n            "rot": "-60000000",\n            "spcFirstLastPara": "1",\n            "vertOverflow": "ellipsis",\n            "vert": "horz",\n            "wrap": "square",\n            "anchor": "ctr",\n            "anchorCtr": "1"\n          }\n        },\n        "a:lstStyle": {},\n        "a:p": {\n          "a:pPr": {\n            "a:defRPr": {\n              a$: {\n                "sz": "900",\n                "b": "0",\n                "i": "0",\n                "u": "none",\n                "strike": "noStrike",\n                "kern": "1200",\n                "baseline": "0"\n              },\n              "a:solidFill": {\n                "a:schemeClr": {\n                  a$: {\n                    "val": "tx1"\n                  },\n                  "a:lumMod": {\n                    a$: {\n                      "val": "65000"\n                    }\n                  },\n                  "a:lumOff": {\n                    a$: {\n                      "val": "35000"\n                    }\n                  }\n                }\n              },\n              "a:latin": {\n                a$: {\n                  "typeface": "+mn-lt"\n                }\n              },\n              "a:ea": {\n                a$: {\n                  "typeface": "+mn-ea"\n                }\n              },\n              "a:cs": {\n                a$: {\n                  "typeface": "+mn-cs"\n                }\n              }\n            }\n          },\n          "a:endParaRPr": {\n            a$: {\n              "lang": "en-US"\n            }\n          }\n        }\n      },\n      "c:crossAx": {\n        a$: {\n          "val": "47003664"\n        }\n      },\n      "c:crosses": {\n        a$: {\n          "val": "autoZero"\n        }\n      },\n      "c:crossBetween": {\n        a$: {\n          "val": "between"\n        }\n      }\n    },\n    "c:spPr": {\n      "a:noFill": {},\n      "a:ln": {\n        "a:noFill": {}\n      },\n      "a:effectLst": {}\n    }\n  },\n  "c:plotVisOnly": {\n    a$: {\n      "val": "1"\n    }\n  },\n  "c:dispBlanksAs": {\n    a$: {\n      "val": "gap"\n    }\n  },\n  "c:extLst": {\n    "c:ext": {\n      a$: {\n        "uri": "{56B9EC1D-385E-4148-901F-78D8002777C0}",\n        "xmlns:c16r3": "http://schemas.microsoft.com/office/drawing/2017/03/chart"\n      },\n      "c16r3:dataDisplayOptions16": {\n        "c16r3:dispNaAsBlank": {\n          a$: {\n            "val": "1"\n          }\n        }\n      }\n    }\n  },\n  "c:showDLblsOverMax": {\n    a$: {\n      "val": "0"\n    }\n  }\n};\n\n// treb-export/src/drawing2/donut-chart-template2.ts\nvar donut_json = {\n  "c:title": {},\n  "c:autoTitleDeleted": {\n    a$: {\n      "val": "0"\n    }\n  },\n  "c:plotArea": {\n    "c:layout": {},\n    "c:doughnutChart": {\n      "c:varyColors": {\n        a$: {\n          "val": "1"\n        }\n      },\n      "c:ser": {\n        "c:idx": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:order": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:dPt": {\n          "c:idx": {\n            a$: {\n              "val": "3"\n            }\n          },\n          "c:bubble3D": {\n            a$: {\n              "val": "0"\n            }\n          },\n          "c:spPr": {\n            "a:solidFill": {\n              "a:schemeClr": {\n                a$: {\n                  "val": "accent4"\n                }\n              }\n            },\n            "a:ln": {\n              a$: {\n                "w": "19050"\n              },\n              "a:solidFill": {\n                "a:schemeClr": {\n                  a$: {\n                    "val": "lt1"\n                  }\n                }\n              }\n            },\n            "a:effectLst": {}\n          },\n          "c:extLst": {\n            "c:ext": {\n              a$: {\n                "uri": "{C3380CC4-5D6E-409C-BE32-E72D297353CC}",\n                "xmlns:c16": "http://schemas.microsoft.com/office/drawing/2014/chart"\n              },\n              "c16:uniqueId": {\n                a$: {\n                  "val": "{00000007-E886-49A6-AE6D-C67D8A27530F}"\n                }\n              }\n            }\n          }\n        },\n        "c:cat": {\n          "c:strRef": {\n            "c:f": ""\n            // ref: \'Sheet1!$E$5:$E$8\'\n          }\n        },\n        "c:val": {\n          "c:numRef": {\n            "c:f": ""\n            // ref: \'Sheet1!$F$5:$F$8\'\n          }\n        },\n        "c:extLst": {\n          "c:ext": {\n            a$: {\n              "uri": "{C3380CC4-5D6E-409C-BE32-E72D297353CC}",\n              "xmlns:c16": "http://schemas.microsoft.com/office/drawing/2014/chart"\n            },\n            "c16:uniqueId": {\n              a$: {\n                "val": "{00000000-3689-4BB4-A84F-05B9F3BBE577}"\n              }\n            }\n          }\n        }\n      },\n      "c:dLbls": {\n        "c:showLegendKey": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:showVal": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:showCatName": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:showSerName": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:showPercent": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:showBubbleSize": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:showLeaderLines": {\n          a$: {\n            "val": "1"\n          }\n        }\n      },\n      "c:firstSliceAng": {\n        a$: {\n          "val": "0"\n        }\n      },\n      "c:holeSize": {\n        a$: {\n          "val": "75"\n        }\n      }\n    },\n    "c:spPr": {\n      "a:noFill": {},\n      "a:ln": {\n        "a:noFill": {}\n      },\n      "a:effectLst": {}\n    }\n  },\n  "c:legend": {\n    "c:legendPos": {\n      a$: {\n        "val": "b"\n      }\n    },\n    "c:overlay": {\n      a$: {\n        "val": "0"\n      }\n    },\n    "c:spPr": {\n      "a:noFill": {},\n      "a:ln": {\n        "a:noFill": {}\n      },\n      "a:effectLst": {}\n    },\n    "c:txPr": {\n      "a:bodyPr": {\n        a$: {\n          "rot": "0",\n          "spcFirstLastPara": "1",\n          "vertOverflow": "ellipsis",\n          "vert": "horz",\n          "wrap": "square",\n          "anchor": "ctr",\n          "anchorCtr": "1"\n        }\n      },\n      "a:lstStyle": {},\n      "a:p": {\n        "a:pPr": {\n          a$: {\n            "rtl": "0"\n          },\n          "a:defRPr": {\n            a$: {\n              "sz": "900",\n              "b": "0",\n              "i": "0",\n              "u": "none",\n              "strike": "noStrike",\n              "kern": "1200",\n              "baseline": "0"\n            },\n            "a:solidFill": {\n              "a:schemeClr": {\n                a$: {\n                  "val": "tx1"\n                },\n                "a:lumMod": {\n                  a$: {\n                    "val": "65000"\n                  }\n                },\n                "a:lumOff": {\n                  a$: {\n                    "val": "35000"\n                  }\n                }\n              }\n            },\n            "a:latin": {\n              a$: {\n                "typeface": "+mn-lt"\n              }\n            },\n            "a:ea": {\n              a$: {\n                "typeface": "+mn-ea"\n              }\n            },\n            "a:cs": {\n              a$: {\n                "typeface": "+mn-cs"\n              }\n            }\n          }\n        },\n        "a:endParaRPr": {\n          a$: {\n            "lang": "en-US"\n          }\n        }\n      }\n    }\n  },\n  "c:plotVisOnly": {\n    a$: {\n      "val": "1"\n    }\n  },\n  "c:dispBlanksAs": {\n    a$: {\n      "val": "gap"\n    }\n  },\n  "c:extLst": {\n    "c:ext": {\n      a$: {\n        "uri": "{56B9EC1D-385E-4148-901F-78D8002777C0}",\n        "xmlns:c16r3": "http://schemas.microsoft.com/office/drawing/2017/03/chart"\n      },\n      "c16r3:dataDisplayOptions16": {\n        "c16r3:dispNaAsBlank": {\n          a$: {\n            "val": "1"\n          }\n        }\n      }\n    }\n  },\n  "c:showDLblsOverMax": {\n    a$: {\n      "val": "0"\n    }\n  }\n};\n\n// treb-export/src/drawing2/scatter-chart-template2.ts\nvar scatter_json = {\n  "c:title": {},\n  "c:autoTitleDeleted": {\n    a$: {\n      "val": "0"\n    }\n  },\n  "c:plotArea": {\n    "c:layout": {},\n    "c:scatterChart": {\n      "c:scatterStyle": {\n        a$: {\n          "val": "lineMarker"\n        }\n      },\n      "c:varyColors": {\n        a$: {\n          "val": "0"\n        }\n      },\n      "c:ser": [],\n      "c:dLbls": {\n        "c:showLegendKey": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:showVal": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:showCatName": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:showSerName": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:showPercent": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:showBubbleSize": {\n          a$: {\n            "val": "0"\n          }\n        }\n      },\n      "c:axId": [\n        {\n          a$: {\n            "val": "2028657983"\n          }\n        },\n        {\n          a$: {\n            "val": "2023395087"\n          }\n        }\n      ]\n    },\n    "c:valAx": [\n      {\n        "c:axId": {\n          a$: {\n            "val": "2028657983"\n          }\n        },\n        "c:scaling": {\n          "c:orientation": {\n            a$: {\n              "val": "minMax"\n            }\n          }\n        },\n        "c:delete": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:axPos": {\n          a$: {\n            "val": "b"\n          }\n        },\n        "c:majorGridlines": {\n          "c:spPr": {\n            "a:ln": {\n              a$: {\n                "w": "9525",\n                "cap": "flat",\n                "cmpd": "sng",\n                "algn": "ctr"\n              },\n              "a:solidFill": {\n                "a:schemeClr": {\n                  a$: {\n                    "val": "tx1"\n                  },\n                  "a:lumMod": {\n                    a$: {\n                      "val": "15000"\n                    }\n                  },\n                  "a:lumOff": {\n                    a$: {\n                      "val": "85000"\n                    }\n                  }\n                }\n              },\n              "a:round": {}\n            },\n            "a:effectLst": {}\n          }\n        },\n        "c:majorTickMark": {\n          a$: {\n            "val": "none"\n          }\n        },\n        "c:minorTickMark": {\n          a$: {\n            "val": "none"\n          }\n        },\n        "c:tickLblPos": {\n          a$: {\n            "val": "nextTo"\n          }\n        },\n        "c:spPr": {\n          "a:noFill": {},\n          "a:ln": {\n            a$: {\n              "w": "9525",\n              "cap": "flat",\n              "cmpd": "sng",\n              "algn": "ctr"\n            },\n            "a:solidFill": {\n              "a:schemeClr": {\n                a$: {\n                  "val": "tx1"\n                },\n                "a:lumMod": {\n                  a$: {\n                    "val": "25000"\n                  }\n                },\n                "a:lumOff": {\n                  a$: {\n                    "val": "75000"\n                  }\n                }\n              }\n            },\n            "a:round": {}\n          },\n          "a:effectLst": {}\n        },\n        "c:txPr": {\n          "a:bodyPr": {\n            a$: {\n              "rot": "-60000000",\n              "spcFirstLastPara": "1",\n              "vertOverflow": "ellipsis",\n              "vert": "horz",\n              "wrap": "square",\n              "anchor": "ctr",\n              "anchorCtr": "1"\n            }\n          },\n          "a:lstStyle": {},\n          "a:p": {\n            "a:pPr": {\n              "a:defRPr": {\n                a$: {\n                  "sz": "900",\n                  "b": "0",\n                  "i": "0",\n                  "u": "none",\n                  "strike": "noStrike",\n                  "kern": "1200",\n                  "baseline": "0"\n                },\n                "a:solidFill": {\n                  "a:schemeClr": {\n                    a$: {\n                      "val": "tx1"\n                    },\n                    "a:lumMod": {\n                      a$: {\n                        "val": "65000"\n                      }\n                    },\n                    "a:lumOff": {\n                      a$: {\n                        "val": "35000"\n                      }\n                    }\n                  }\n                },\n                "a:latin": {\n                  a$: {\n                    "typeface": "+mn-lt"\n                  }\n                },\n                "a:ea": {\n                  a$: {\n                    "typeface": "+mn-ea"\n                  }\n                },\n                "a:cs": {\n                  a$: {\n                    "typeface": "+mn-cs"\n                  }\n                }\n              }\n            },\n            "a:endParaRPr": {\n              a$: {\n                "lang": "en-US"\n              }\n            }\n          }\n        },\n        "c:crossAx": {\n          a$: {\n            "val": "2023395087"\n          }\n        },\n        "c:crosses": {\n          a$: {\n            "val": "autoZero"\n          }\n        },\n        "c:crossBetween": {\n          a$: {\n            "val": "midCat"\n          }\n        }\n      },\n      {\n        "c:axId": {\n          a$: {\n            "val": "2023395087"\n          }\n        },\n        "c:scaling": {\n          "c:orientation": {\n            a$: {\n              "val": "minMax"\n            }\n          }\n        },\n        "c:delete": {\n          a$: {\n            "val": "0"\n          }\n        },\n        "c:axPos": {\n          a$: {\n            "val": "l"\n          }\n        },\n        "c:majorGridlines": {\n          "c:spPr": {\n            "a:ln": {\n              a$: {\n                "w": "9525",\n                "cap": "flat",\n                "cmpd": "sng",\n                "algn": "ctr"\n              },\n              "a:solidFill": {\n                "a:schemeClr": {\n                  a$: {\n                    "val": "tx1"\n                  },\n                  "a:lumMod": {\n                    a$: {\n                      "val": "15000"\n                    }\n                  },\n                  "a:lumOff": {\n                    a$: {\n                      "val": "85000"\n                    }\n                  }\n                }\n              },\n              "a:round": {}\n            },\n            "a:effectLst": {}\n          }\n        },\n        "c:numFmt": {\n          a$: {\n            "formatCode": "0.00",\n            "sourceLinked": "1"\n          }\n        },\n        "c:majorTickMark": {\n          a$: {\n            "val": "none"\n          }\n        },\n        "c:minorTickMark": {\n          a$: {\n            "val": "none"\n          }\n        },\n        "c:tickLblPos": {\n          a$: {\n            "val": "nextTo"\n          }\n        },\n        "c:spPr": {\n          "a:noFill": {},\n          "a:ln": {\n            a$: {\n              "w": "9525",\n              "cap": "flat",\n              "cmpd": "sng",\n              "algn": "ctr"\n            },\n            "a:solidFill": {\n              "a:schemeClr": {\n                a$: {\n                  "val": "tx1"\n                },\n                "a:lumMod": {\n                  a$: {\n                    "val": "25000"\n                  }\n                },\n                "a:lumOff": {\n                  a$: {\n                    "val": "75000"\n                  }\n                }\n              }\n            },\n            "a:round": {}\n          },\n          "a:effectLst": {}\n        },\n        "c:txPr": {\n          "a:bodyPr": {\n            a$: {\n              "rot": "-60000000",\n              "spcFirstLastPara": "1",\n              "vertOverflow": "ellipsis",\n              "vert": "horz",\n              "wrap": "square",\n              "anchor": "ctr",\n              "anchorCtr": "1"\n            }\n          },\n          "a:lstStyle": {},\n          "a:p": {\n            "a:pPr": {\n              "a:defRPr": {\n                a$: {\n                  "sz": "900",\n                  "b": "0",\n                  "i": "0",\n                  "u": "none",\n                  "strike": "noStrike",\n                  "kern": "1200",\n                  "baseline": "0"\n                },\n                "a:solidFill": {\n                  "a:schemeClr": {\n                    a$: {\n                      "val": "tx1"\n                    },\n                    "a:lumMod": {\n                      a$: {\n                        "val": "65000"\n                      }\n                    },\n                    "a:lumOff": {\n                      a$: {\n                        "val": "35000"\n                      }\n                    }\n                  }\n                },\n                "a:latin": {\n                  a$: {\n                    "typeface": "+mn-lt"\n                  }\n                },\n                "a:ea": {\n                  a$: {\n                    "typeface": "+mn-ea"\n                  }\n                },\n                "a:cs": {\n                  a$: {\n                    "typeface": "+mn-cs"\n                  }\n                }\n              }\n            },\n            "a:endParaRPr": {\n              a$: {\n                "lang": "en-US"\n              }\n            }\n          }\n        },\n        "c:crossAx": {\n          a$: {\n            "val": "2028657983"\n          }\n        },\n        "c:crosses": {\n          a$: {\n            "val": "autoZero"\n          }\n        },\n        "c:crossBetween": {\n          a$: {\n            "val": "midCat"\n          }\n        }\n      }\n    ],\n    "c:spPr": {\n      "a:noFill": {},\n      "a:ln": {\n        "a:noFill": {}\n      },\n      "a:effectLst": {}\n    }\n  },\n  "c:plotVisOnly": {\n    a$: {\n      "val": "1"\n    }\n  },\n  "c:dispBlanksAs": {\n    a$: {\n      "val": "gap"\n    }\n  },\n  "c:extLst": {\n    "c:ext": {\n      a$: {\n        "uri": "{56B9EC1D-385E-4148-901F-78D8002777C0}",\n        "xmlns:c16r3": "http://schemas.microsoft.com/office/drawing/2017/03/chart"\n      },\n      "c16r3:dataDisplayOptions16": {\n        "c16r3:dispNaAsBlank": {\n          a$: {\n            "val": "1"\n          }\n        }\n      }\n    }\n  },\n  "c:showDLblsOverMax": {\n    a$: {\n      "val": "0"\n    }\n  }\n};\nvar scatter_series = {\n  "c:spPr": {\n    "a:ln": {\n      a$: {\n        "w": "19050",\n        "cap": "rnd"\n      },\n      "a:solidFill": {\n        "a:schemeClr": {\n          a$: {\n            "val": "accent1"\n          }\n        }\n      },\n      "a:round": {}\n    },\n    "a:effectLst": {}\n  },\n  "c:marker": {\n    "c:symbol": {\n      a$: {\n        "val": "none"\n      }\n    }\n  },\n  // <- \'c:tx\': {},\n  "c:xVal": {\n    "c:numRef": {\n      "c:f": ""\n    }\n  },\n  "c:yVal": {\n    "c:numRef": {\n      "c:f": ""\n    }\n  },\n  "c:smooth": {\n    a$: {\n      "val": "0"\n    }\n  },\n  "c:extLst": {\n    "c:ext": {\n      a$: {\n        "uri": "{C3380CC4-5D6E-409C-BE32-E72D297353CC}",\n        "xmlns:c16": "http://schemas.microsoft.com/office/drawing/2014/chart"\n      },\n      "c16:uniqueId": {\n        a$: {\n          "val": "{00000000-1F6C-44A9-AA4F-6706F20CC72E}"\n        }\n      }\n    }\n  }\n};\n\n// treb-export/src/drawing2/chart2.ts\nvar Chart = class _Chart {\n  constructor(options, index = _Chart.next_chart_index++) {\n    this.options = options;\n    this.index = index;\n  }\n  static next_chart_index = 1;\n  relationships = {};\n  /** set chart title, either static or reference to cell */\n  UpdateChartTitle(chartnode) {\n    const unit = this.options.title || {\n      type: "literal",\n      value: ""\n    };\n    if (unit && unit.type === "literal") {\n      const title = JSON.parse(JSON.stringify(static_title));\n      const AP = title["c:tx"]["c:rich"]["a:p"];\n      AP["a:r"] = {\n        "a:rPr": {\n          a$: {\n            lang: Localization.locale\n          }\n        },\n        "a:t": unit.value\n      };\n      chartnode["c:title"] = title;\n    } else if (unit) {\n      const title = JSON.parse(JSON.stringify(ref_title));\n      title["c:tx"]["c:strRef"]["c:f"] = unit.label;\n      chartnode["c:title"] = title;\n    }\n  }\n  toJSON() {\n    switch (this.options.type) {\n      case "column":\n      case "bar":\n        return this.CreateBarChart();\n      case "scatter":\n      case "scatter2":\n        return this.CreateScatterChart();\n      case "donut":\n        return this.CreateDonutChart();\n      default:\n        console.info("unhandled chart type", this.options.type);\n    }\n    return this.CreateBarChart();\n  }\n  CreateScatterChart() {\n    const template2 = JSON.parse(JSON.stringify(chart_template));\n    const chartspace = template2["c:chartSpace"];\n    const scatter = JSON.parse(JSON.stringify(scatter_json));\n    if (this.options.smooth) {\n      scatter["c:plotArea"]["c:scatterChart"]["c:scatterStyle"].a$.val = "smoothMarker";\n    }\n    chartspace["c:chart"] = scatter;\n    this.UpdateChartTitle(chartspace["c:chart"]);\n    const cser = chartspace["c:chart"]["c:plotArea"]["c:scatterChart"]["c:ser"];\n    let legend = false;\n    for (let i = 0; i < this.options.data.length; i++) {\n      const series = JSON.parse(JSON.stringify(scatter_series));\n      series["c:idx"] = { a$: { val: i.toString() } };\n      series["c:order"] = { a$: { val: i.toString() } };\n      if (this.options.names && this.options.names[i]) {\n        const name = this.options.names[i];\n        switch (name.type) {\n          case "literal":\n            series["c:tx"] = {\n              "c:v": name.value.toString()\n            };\n            legend = true;\n            break;\n          case "range":\n          case "address":\n            series["c:tx"] = {\n              "c:strRef": {\n                "c:f": name.label\n              }\n            };\n            legend = true;\n            break;\n        }\n      }\n      if (i < 6) {\n        series["c:spPr"]["a:ln"]["a:solidFill"]["a:schemeClr"].a$["val"] = `accent${i + 1}`;\n      }\n      series["c:yVal"]["c:numRef"]["c:f"] = this.options.data[i]?.label;\n      if (this.options.labels2 && this.options.labels2[i]) {\n        series["c:xVal"]["c:numRef"]["c:f"] = this.options.labels2[i]?.label;\n      }\n      if (this.options.smooth) {\n        series["c:smooth"] = { a$: { val: 1 } };\n      }\n      cser.push(series);\n    }\n    if (legend) {\n      chartspace["c:chart"]["c:legend"] = {\n        "c:legendPos": { a$: { val: "b" } },\n        "c:overlay": { a$: { val: "0" } }\n      };\n    }\n    return template2;\n  }\n  CreateDonutChart() {\n    const template2 = JSON.parse(JSON.stringify(chart_template));\n    const chartspace = template2["c:chartSpace"];\n    const chart = JSON.parse(JSON.stringify(donut_json));\n    chartspace["c:chart"] = chart;\n    this.UpdateChartTitle(chartspace["c:chart"]);\n    const donut = chart["c:plotArea"]["c:doughnutChart"];\n    if (donut) {\n      donut["c:ser"]["c:cat"]["c:strRef"]["c:f"] = this.options.labels?.label || "";\n      donut["c:ser"]["c:val"]["c:numRef"]["c:f"] = this.options.data[0]?.label || "";\n    }\n    return template2;\n  }\n  CreateBarChart() {\n    const template2 = JSON.parse(JSON.stringify(chart_template));\n    const chartspace = template2["c:chartSpace"];\n    const bar = JSON.parse(JSON.stringify(column_json));\n    chartspace["c:chart"] = bar;\n    this.UpdateChartTitle(chartspace["c:chart"]);\n    const column = bar["c:plotArea"]["c:barChart"];\n    if (column) {\n      const bardir = column["c:barDir"];\n      if (bardir) {\n        bardir.a$.val = this.options.type === "bar" ? "bar" : "col";\n      }\n      const cser = column["c:ser"];\n      for (let i = 0; i < this.options.data.length; i++) {\n        const series = JSON.parse(JSON.stringify(column_series));\n        series["c:idx"] = { a$: { val: i.toString() } };\n        series["c:order"] = { a$: { val: i.toString() } };\n        if (i < 6) {\n          series["c:spPr"]["a:solidFill"]["a:schemeClr"].a$["val"] = `accent${i + 1}`;\n        }\n        if (!i && this.options.labels) {\n          series["c:cat"] = {\n            "c:strRef": {\n              "c:f": this.options.labels.label\n            }\n          };\n        }\n        series["c:val"]["c:numRef"]["c:f"] = this.options.data[i]?.label;\n        cser.push(series);\n      }\n    }\n    return template2;\n  }\n};\n\n// treb-export/src/drawing2/embedded-image.ts\nvar EmbeddedImage = class _EmbeddedImage {\n  constructor(options, index = _EmbeddedImage.next_image_index++) {\n    this.options = options;\n    this.index = index;\n    switch (options.mimetype) {\n      case "svg+xml":\n        this.extension = "svg";\n        break;\n      case "image/png":\n        this.extension = "png";\n        break;\n      case "jpg":\n        this.extension = "jpeg";\n        break;\n      case "svg":\n      case "png":\n      case "jpeg":\n      case "gif":\n        this.extension = options.mimetype;\n        break;\n      default:\n        console.warn("unhandled mime type", options.mimetype);\n        break;\n    }\n  }\n  static next_image_index = 1;\n  extension = "";\n};\n\n// treb-export/src/drawing2/drawing2.ts\nvar pixel_offset = 9525;\nvar Drawing = class _Drawing {\n  constructor(index = _Drawing.next_drawing_index++) {\n    this.index = index;\n  }\n  static next_drawing_index = 1;\n  /** relationship id sheet -> drawing */\n  sheet_drawing_relationship = 0;\n  charts = [];\n  images = [];\n  relationships = {};\n  AddImage(options, anchor) {\n    const image = new EmbeddedImage(options);\n    if (image.extension) {\n      const relationship = AddRel(\n        this.relationships,\n        "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",\n        `../media/image${image.index}.${image.extension}`\n      );\n      this.images.push({ image, relationship, anchor });\n    }\n  }\n  AddChart(options, anchor) {\n    const chart = new Chart(options);\n    const relationship = AddRel(\n      this.relationships,\n      `http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart`,\n      `../charts/chart${chart.index}.xml`\n    );\n    this.charts.push({ chart, anchor, relationship });\n  }\n  CornerToJSON(anchor) {\n    return {\n      "xdr:col": anchor.column,\n      "xdr:colOff": (anchor.column_offset || 0) * pixel_offset,\n      "xdr:row": anchor.row,\n      "xdr:rowOff": (anchor.row_offset || 0) * pixel_offset\n    };\n  }\n  AnchorToJSON(anchor) {\n    return {\n      "xdr:from": { ...this.CornerToJSON(anchor.from) },\n      "xdr:to": { ...this.CornerToJSON(anchor.to) }\n    };\n  }\n  toJSON() {\n    const image_blocks = this.images.map((image) => {\n      const block = {\n        a$: { editAs: "oneCell" },\n        ...this.AnchorToJSON(image.anchor),\n        "xdr:pic": {\n          "xdr:nvPicPr": {\n            "xdr:cNvPr": (\n              /* image.image.extension === \'svg\' ? {\n                a$: { id: image.image.index + 1, name: \'Image \' + image.image.index},\n                \'a:extLst\': {\n                  \'a:ext\': {\n                    a$: { uri: \'{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}\' },\n                    \'a16:creationId\': {\n                      a$: {\n                        \'xmlns:a16\': \'http://schemas.microsoft.com/office/drawing/2014/main\',\n                      },\n                    },\n                  },\n                },\n              } : */\n              {\n                a$: { id: image.image.index + 1, name: "Image " + image.image.index }\n              }\n            ),\n            "xdr:cNvPicPr": {\n              "a:picLocks": {\n                a$: {\n                  noChangeAspect: 1\n                }\n              }\n            }\n          },\n          "xdr:blipFill": {\n            "a:blip": {\n              a$: image.image.extension === "svg" ? {\n                "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships"\n              } : {\n                "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",\n                "r:embed": image.relationship\n              },\n              "a:extLst": {\n                "a:ext": [\n                  {\n                    a$: {\n                      uri: "{28A0092B-C50C-407E-A947-70E740481C1C}"\n                    },\n                    "a14:useLocalDpi": {\n                      a$: {\n                        "xmlns:a14": "http://schemas.microsoft.com/office/drawing/2010/main",\n                        val: 0\n                      }\n                    }\n                  },\n                  image.image.extension === "svg" ? {\n                    a$: {\n                      uri: "{96DAC541-7B7A-43D3-8B79-37D633B846F1}"\n                    },\n                    "asvg:svgBlip": {\n                      a$: {\n                        "xmlns:asvg": "http://schemas.microsoft.com/office/drawing/2016/SVG/main",\n                        "r:embed": image.relationship\n                      }\n                    }\n                  } : void 0\n                ]\n              }\n            },\n            "a:stretch": {\n              "a:fillRect": {}\n            }\n          },\n          "xdr:spPr": {\n            "a:xfrm": {\n              "a:off": {\n                a$: { x: 0, y: 0 }\n              },\n              "a:ext": {\n                a$: { cx: 4057650, cy: 6172200 }\n                // ??\n              }\n            },\n            "a:prstGeom": {\n              a$: { prst: "rect" },\n              "a:avLst": {}\n            }\n          }\n          /* \n                <xdr:nvPicPr>\n                  <xdr:cNvPr id="3" name="Graphic 2">\n                    <a:extLst>\n                      <a:ext uri="{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}">\n                        <a16:creationId xmlns:a16="http://schemas.microsoft.com/office/drawing/2014/main" id="{9BA0B4E8-3DD4-4297-8733-48C3F5D063BA}"/>\n                      </a:ext>\n                    </a:extLst>\n                  </xdr:cNvPr>\n                  <xdr:cNvPicPr>\n                    <a:picLocks noChangeAspect="1"/>\n                  </xdr:cNvPicPr>\n                </xdr:nvPicPr>\n                \n                <xdr:blipFill>\n          \n                      [ this one is svg]\n          \n                  <a:blip xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" r:embed="rId1">\n                    <a:extLst>\n                      <a:ext uri="{28A0092B-C50C-407E-A947-70E740481C1C}">\n                        <a14:useLocalDpi xmlns:a14="http://schemas.microsoft.com/office/drawing/2010/main" val="0"/>\n                      </a:ext>\n                      <a:ext uri="{96DAC541-7B7A-43D3-8B79-37D633B846F1}">\n                        <asvg:svgBlip xmlns:asvg="http://schemas.microsoft.com/office/drawing/2016/SVG/main" r:embed="rId2"/>\n                      </a:ext>\n                    </a:extLst>\n                  </a:blip>\n          \n                      [alt]\n          \n                  <a:blip xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" r:embed="rId3">\n                    <a:extLst>\n                      <a:ext uri="{28A0092B-C50C-407E-A947-70E740481C1C}">\n                        <a14:useLocalDpi xmlns:a14="http://schemas.microsoft.com/office/drawing/2010/main" val="0"/>\n                      </a:ext>\n                    </a:extLst>\n                  </a:blip>\n          \n          \n                  <a:stretch>\n                    <a:fillRect/>\n                  </a:stretch>\n                </xdr:blipFill>\n          \n                <xdr:spPr>\n                  <a:xfrm>\n                    <a:off x="0" y="0"/>\n                    <a:ext cx="4057650" cy="6172200"/>\n                  </a:xfrm>\n                  <a:prstGeom prst="rect">\n                    <a:avLst/>\n                  </a:prstGeom>\n                </xdr:spPr>\n          \n          \n                      */\n        },\n        "xdr:clientData": {}\n      };\n      return block;\n    });\n    const chart_blocks = this.charts.map((chart) => {\n      const block = {\n        ...this.AnchorToJSON(chart.anchor),\n        "xdr:graphicFrame": {\n          a$: { macro: "" },\n          "xdr:nvGraphicFramePr": {\n            "xdr:cNvPr": {\n              a$: { id: chart.chart.index + 1, name: `Chart ${chart.chart.index}` }\n              /*\n              \'a:extLst\': {\n                \'a:ext\': {\n                  a$: { uri: \'{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}\' },\n                  \'a16:creationId\': {\n                    a$: { \'xmlns:a16\': \'http://schemas.microsoft.com/office/drawing/2014/main\' },\n                  },\n                },\n              },\n              */\n            },\n            "xdr:cNvGraphicFramePr": {}\n          },\n          "xdr:xfrm": {\n            "a:off": { a$: { x: 0, y: 0 } },\n            "a:ext": { a$: { cx: 0, cy: 0 } }\n          },\n          "a:graphic": {\n            "a:graphicData": {\n              a$: { uri: "http://schemas.openxmlformats.org/drawingml/2006/chart" },\n              "c:chart": {\n                a$: {\n                  "xmlns:c": "http://schemas.openxmlformats.org/drawingml/2006/chart",\n                  "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",\n                  "r:id": chart.relationship\n                }\n              }\n            }\n          }\n        },\n        "xdr:clientData": {}\n      };\n      return block;\n    });\n    const dom = {\n      "xdr:wsDr": {\n        a$: {\n          "xmlns:xdr": "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing",\n          "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main"\n        },\n        "xdr:twoCellAnchor": [...chart_blocks, ...image_blocks]\n      }\n    };\n    return dom;\n  }\n  /*\n    public GetDrawingXML() {\n      const components: string[] = [`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\\n<xdr:wsDr xmlns:xdr="http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing" xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">`];\n  \n      for (let i = 0; i < this.charts.length; i++) {\n  \n        const index = i + 1;\n        const anchor = this.charts[i].anchor;\n  \n        components.push(\n          `<xdr:twoCellAnchor><xdr:from><xdr:col>${anchor.from.column}</xdr:col><xdr:colOff>${(anchor.from.column_offset || 0) * pixel_offset}</xdr:colOff>`\n          + `<xdr:row>${anchor.from.row}</xdr:row><xdr:rowOff>${(anchor.from.row_offset || 0) * pixel_offset}</xdr:rowOff></xdr:from>`\n          + `<xdr:to><xdr:col>${anchor.to.column}</xdr:col><xdr:colOff>${(anchor.to.column_offset || 0) * pixel_offset}</xdr:colOff>`\n          + `<xdr:row>${anchor.to.row}</xdr:row><xdr:rowOff>${(anchor.to.row_offset || 0) * pixel_offset}</xdr:rowOff></xdr:to>`\n          + `<xdr:graphicFrame macro=""><xdr:nvGraphicFramePr><xdr:cNvPr id="${index + 1}" name="Chart ${index}"><a:extLst><a:ext uri="{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}"><a16:creationId xmlns:a16="http://schemas.microsoft.com/office/drawing/2014/main" id="{9948BDEE-44B2-4E72-83C8-2C9C56F04EAA}"/></a:ext></a:extLst></xdr:cNvPr><xdr:cNvGraphicFramePr/></xdr:nvGraphicFramePr><xdr:xfrm><a:off x="0" y="0"/><a:ext cx="0" cy="0"/></xdr:xfrm><a:graphic><a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/chart"><c:chart xmlns:c="http://schemas.openxmlformats.org/drawingml/2006/chart" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" r:id="rId${index}"/></a:graphicData></a:graphic></xdr:graphicFrame><xdr:clientData/></xdr:twoCellAnchor>`\n        );\n  \n      }\n      components.push(`</xdr:wsDr>`);\n      return components.join(\'\');\n    }\n  \n    public GetDrawingRels() {\n      const components: string[] = [ `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">`];\n  \n      for (let i = 0; i < this.charts.length; i++) {\n        const index = i + 1;\n        const chart = this.charts[i].chart;\n        components.push(\n          `<Relationship Id="rId${index}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart" Target="../charts/chart${chart.index}.xml"/>`);\n      }\n  \n      components.push(`</Relationships>`);\n      return components.join(\'\');\n    }\n    */\n};\n\n// treb-export/src/workbook2.ts\nvar import_fast_xml_parser = __toESM(require_fxp());\n\n// treb-export/src/address-type.ts\nvar is_address = (candidate) => {\n  return "row" in candidate && "col" in candidate;\n};\nvar is_range = (candidate) => {\n  return "from" in candidate && "to" in candidate && is_address(candidate.from) && is_address(candidate.to);\n};\nvar InRange = (range, address) => {\n  return address.sheet === range.sheet && address.row >= range.from.row && address.row <= range.to.row && address.col >= range.from.col && address.col <= range.to.col;\n};\nvar ShiftRange = (range, rows = 0, columns = 0) => {\n  return {\n    from: {\n      row: range.from.row + rows,\n      col: range.from.col + columns,\n      sheet: range.from.sheet\n    },\n    to: {\n      row: range.to.row + rows,\n      col: range.to.col + columns,\n      sheet: range.to.sheet\n    }\n  };\n};\n\n// treb-export/src/workbook-sheet2.ts\nvar Sheet = class {\n  constructor(options = {}) {\n    this.options = options;\n  }\n  path;\n  rels_path;\n  rels = {};\n  sheet_data = {};\n  shared_strings;\n  extent;\n  visible_state;\n  tab_selected = false;\n  default_width = 0;\n  drawings = [];\n  /**\n   * A1 -> {row: 1, col: 1} etc.\n   * in the event of a range, { from: {}, to: {} }\n   */\n  TranslateAddress(s) {\n    s = s.toUpperCase();\n    let m = s.match(/([A-Z]+\\d+):([A-Z]+\\d+)/);\n    if (m) {\n      return {\n        from: this.TranslateAddress(m[1]),\n        to: this.TranslateAddress(m[2])\n      };\n    }\n    let row = 0;\n    let col = 0;\n    m = s.match(/^([A-Z]+)(\\d+)$/);\n    if (m) {\n      row = Number(m[2]);\n      col = 0;\n      const len = m[1].length;\n      for (let i = 0; i < len; i++) {\n        const c = m[1].charCodeAt(i) - 64;\n        col = col * 26 + c;\n      }\n    }\n    return { row, col };\n  }\n  /**\n   * { row: 1, col: 1 } -> A1.\n   * for ranges, {from: {}, to: {}} -> A1:B2\n   */\n  Address(r, absolute = false) {\n    if (is_range(r)) {\n      return this.Address(r.from, absolute) + ":" + this.Address(r.to, absolute);\n    }\n    let c = "";\n    let col = r.col;\n    while (col > 0) {\n      const x = (col - 1) % 26 + 1;\n      c = String.fromCharCode(64 + x) + c;\n      col = (col - x) / 26;\n    }\n    const s = r.sheet ? `\'${r.sheet}\'!` : "";\n    if (absolute) {\n      return `${s}$${c}$${r.row}`;\n    }\n    return s + c + r.row;\n  }\n  /**\n   * convert an address (either style) to BOTH A1 and R1C1\n   */\n  NormalizeAddress(rng) {\n    let a;\n    let rc;\n    if (typeof rng === "string") {\n      a = rng.toUpperCase();\n      rc = this.TranslateAddress(a);\n    } else {\n      rc = rng;\n      a = this.Address(rc);\n    }\n    return { a, rc };\n  }\n  Parse() {\n    const dim = this.sheet_data.worksheet?.dimension?.a$?.ref;\n    const extent = this.TranslateAddress(dim || "");\n    if (is_range(extent)) {\n      this.extent = JSON.parse(JSON.stringify(extent));\n    } else {\n      this.extent = {\n        from: JSON.parse(JSON.stringify(extent)),\n        to: JSON.parse(JSON.stringify(extent))\n      };\n    }\n  }\n};\n\n// treb-export/src/workbook2.ts\nvar xmlparser1 = new import_fast_xml_parser.XMLParser(XMLOptions);\nvar xmlparser2 = new import_fast_xml_parser.XMLParser(XMLOptions2);\nvar ConditionalFormatOperators = {\n  greaterThan: ">",\n  greaterThanOrEquals: ">=",\n  lessThan: "<",\n  lessThanOrEquals: "<=",\n  equal: "=",\n  notEqual: "<>"\n};\nvar Workbook = class {\n  constructor(zip) {\n    this.zip = zip;\n  }\n  xml = {};\n  /** start with an empty strings table, if we load a file we will update it */\n  shared_strings = new SharedStrings();\n  /** document styles */\n  style_cache = new StyleCache();\n  // public temp\n  /** theme */\n  theme = new Theme();\n  /** defined names. these can be ranges or expressions. */\n  defined_names = {};\n  /** the workbook "rels" */\n  rels = {};\n  sheets = [];\n  active_tab = 0;\n  get sheet_count() {\n    return this.sheets.length;\n  }\n  /**\n   * given a path in the zip file, read and parse the rels file\n   */\n  ReadRels(path) {\n    const rels = {};\n    const data = this.zip.Has(path) ? this.zip.Get(path) : "";\n    const xml = xmlparser2.parse(data || "");\n    for (const relationship of xml.Relationships?.Relationship || []) {\n      const id = relationship.a$.Id;\n      rels[id] = {\n        id,\n        type: relationship.a$.Type,\n        target: relationship.a$.Target\n      };\n    }\n    return rels;\n  }\n  Init() {\n    this.rels = this.ReadRels("xl/_rels/workbook.xml.rels");\n    let data = this.zip.Has("xl/sharedStrings.xml") ? this.zip.Get("xl/sharedStrings.xml") : "";\n    let xml = xmlparser2.parse(data || "");\n    this.shared_strings.FromXML(xml);\n    data = this.zip.Get("xl/theme/theme1.xml");\n    xml = xmlparser2.parse(data);\n    this.theme.FromXML(xml);\n    data = this.zip.Get("xl/styles.xml");\n    xml = xmlparser2.parse(data);\n    this.style_cache.FromXML(xml, this.theme);\n    data = this.zip.Get("xl/workbook.xml");\n    xml = xmlparser2.parse(data);\n    this.defined_names = {};\n    const defined_names = XMLUtils.FindAll(xml, "workbook/definedNames/definedName");\n    for (const defined_name of defined_names) {\n      const name = defined_name.a$?.name;\n      const expression = defined_name.t$ || "";\n      if (name && expression) {\n        this.defined_names[name] = expression;\n      }\n    }\n    const workbook_views = XMLUtils.FindAll(xml, "workbook/bookViews/workbookView");\n    if (workbook_views[0]?.a$?.activeTab) {\n      this.active_tab = Number(workbook_views[0].a$.activeTab) || 0;\n    }\n    const composite = XMLUtils.FindAll(xml, "workbook/sheets/sheet");\n    for (const element of composite) {\n      const name = element.a$?.name;\n      if (name) {\n        const state = element.a$.state;\n        const rid = element.a$["r:id"];\n        const worksheet = new Sheet({\n          name,\n          rid,\n          id: Number(element.a$.sheetId)\n        });\n        if (state === "hidden") {\n          worksheet.visible_state = 1 /* hidden */;\n        } else if (state === "veryHidden") {\n          worksheet.visible_state = 2 /* very_hidden */;\n        }\n        worksheet.shared_strings = this.shared_strings;\n        worksheet.path = `xl/${this.rels[rid].target}`;\n        worksheet.rels_path = worksheet.path.replace("worksheets", "worksheets/_rels") + ".rels";\n        data = this.zip.Get(worksheet.path);\n        worksheet.sheet_data = xmlparser2.parse(data || "");\n        worksheet.rels = this.ReadRels(worksheet.rels_path);\n        worksheet.Parse();\n        this.sheets.push(worksheet);\n      }\n    }\n  }\n  ReadTable(reference) {\n    const data = this.zip.Get(reference.replace(/^../, "xl"));\n    if (!data) {\n      return void 0;\n    }\n    const xml = xmlparser2.parse(data);\n    const name = xml.table?.a$?.name || "";\n    const table = {\n      name,\n      display_name: xml.table?.a$?.displayName || name,\n      ref: xml.table?.a$.ref || "",\n      totals_row_shown: Number(xml.table?.a$.totalsRowShown || "0") || 0,\n      totals_row_count: Number(xml.table?.a$.totalsRowCount || "0") || 0\n    };\n    return table;\n  }\n  ReadDrawing(reference) {\n    const data = this.zip.Get(reference.replace(/^../, "xl"));\n    if (!data) {\n      return void 0;\n    }\n    const xml = xmlparser2.parse(data);\n    const drawing_rels = this.ReadRels(reference.replace(/^..\\/drawings/, "xl/drawings/_rels") + ".rels");\n    const results = [];\n    const anchor_nodes = XMLUtils.FindAll(xml, "xdr:wsDr/xdr:twoCellAnchor");\n    const ParseAnchor = (node = {}) => {\n      const anchor = {\n        column: node["xdr:col"] || 0,\n        column_offset: node["xdr:colOff"] || 0,\n        row: node["xdr:row"] || 0,\n        row_offset: node["xdr:rowOff"] || 0\n      };\n      return anchor;\n    };\n    for (const anchor_node of anchor_nodes) {\n      const anchor = {\n        from: ParseAnchor(anchor_node["xdr:from"]),\n        to: ParseAnchor(anchor_node["xdr:to"])\n      };\n      const chart_reference = XMLUtils.FindAll(anchor_node, `xdr:graphicFrame/a:graphic/a:graphicData/c:chart`)[0];\n      if (chart_reference && chart_reference.a$ && chart_reference.a$["r:id"]) {\n        const result = { type: "chart", anchor };\n        const chart_rel = drawing_rels[chart_reference.a$["r:id"]];\n        if (chart_rel && chart_rel.target) {\n          result.chart = this.ReadChart(chart_rel.target);\n        }\n        results.push(result);\n      } else {\n        const media_reference = XMLUtils.FindAll(anchor_node, `xdr:pic/xdr:blipFill/a:blip`)[0];\n        if (media_reference && media_reference.a$["r:embed"]) {\n          const media_rel = drawing_rels[media_reference.a$["r:embed"]];\n          if (media_rel && media_rel.target) {\n            if (/(?:jpg|jpeg|png|gif)$/i.test(media_rel.target)) {\n              const path = media_rel.target.replace(/^\\.\\./, "xl");\n              const filename = path.replace(/^.*\\//, "");\n              const result = {\n                type: "image",\n                anchor,\n                image: this.zip.GetBinary(path),\n                filename\n              };\n              results.push(result);\n            }\n          }\n        }\n      }\n    }\n    return results;\n  }\n  /**\n   * \n   * FIXME: this is using the old options with old structure, just have\n   * not updated it yet\n   */\n  ReadChart(reference) {\n    const data = this.zip.Get(reference.replace(/^../, "xl"));\n    if (!data) {\n      return void 0;\n    }\n    const xml = xmlparser1.parse(data);\n    const result = {\n      type: 0 /* Unknown */\n    };\n    const title_node = XMLUtils.FindChild(xml, "c:chartSpace/c:chart/c:title");\n    if (title_node) {\n      const node2 = XMLUtils.FindChild(title_node, "c:tx/c:strRef/c:f");\n      if (node2) {\n        if (typeof node2 === "string") {\n          result.title = node2;\n        } else if (node2.text__) {\n          result.title = node2.text__;\n        }\n      } else {\n        const nodes = XMLUtils.FindAll(title_node, "c:tx/c:rich/a:p/a:r/a:t");\n        result.title = \'"\' + nodes.join("") + \'"\';\n      }\n    }\n    const ParseSeries = (node2, scatter = false) => {\n      const series = [];\n      let series_nodes = node2["c:ser"] || [];\n      if (!Array.isArray(series_nodes)) {\n        series_nodes = [series_nodes];\n      }\n      for (const series_node of series_nodes) {\n        let index = series.length;\n        const order_node = series_node["c:order"];\n        if (order_node) {\n          index = Number(order_node.__val || 0) || 0;\n        }\n        const series_data = {};\n        let title_node2 = XMLUtils.FindChild(series_node, "c:tx/c:v");\n        if (title_node2) {\n          const title = title_node2;\n          if (title) {\n            series_data.title = `"${title}"`;\n          }\n        } else {\n          title_node2 = XMLUtils.FindChild(series_node, "c:tx/c:strRef/c:f");\n          if (title_node2) {\n            series_data.title = title_node2;\n          }\n        }\n        if (scatter) {\n          const x = XMLUtils.FindChild(series_node, "c:xVal/c:numRef/c:f");\n          if (x) {\n            series_data.categories = x;\n          }\n          const y = XMLUtils.FindChild(series_node, "c:yVal/c:numRef/c:f");\n          if (y) {\n            series_data.values = y;\n          }\n        } else {\n          const value_node = XMLUtils.FindChild(series_node, "c:val/c:numRef/c:f");\n          if (value_node) {\n            series_data.values = value_node;\n          }\n          let cat_node = XMLUtils.FindChild(series_node, "c:cat/c:strRef/c:f");\n          if (!cat_node) {\n            cat_node = XMLUtils.FindChild(series_node, "c:cat/c:numRef/c:f");\n          }\n          if (cat_node) {\n            series_data.categories = cat_node;\n          }\n        }\n        series[index] = series_data;\n      }\n      return series;\n    };\n    let node = XMLUtils.FindChild(xml, "c:chartSpace/c:chart/c:plotArea/c:barChart");\n    if (node) {\n      result.type = 2 /* Bar */;\n      if (node["c:barDir"]) {\n        if (node["c:barDir"].__val === "col") {\n          result.type = 1 /* Column */;\n        }\n      }\n      result.series = ParseSeries(node);\n    }\n    if (!node) {\n      node = XMLUtils.FindChild(xml, "c:chartSpace/c:chart/c:plotArea/c:lineChart");\n      if (node) {\n        result.type = 3 /* Line */;\n        result.series = ParseSeries(node);\n      }\n    }\n    if (!node) {\n      node = XMLUtils.FindChild(xml, "c:chartSpace/c:chart/c:plotArea/c:doughnutChart");\n      if (node) {\n        result.type = 5 /* Donut */;\n        result.series = ParseSeries(node);\n      }\n    }\n    if (!node) {\n      node = XMLUtils.FindChild(xml, "c:chartSpace/c:chart/c:plotArea/c:pieChart");\n      if (node) {\n        result.type = 6 /* Pie */;\n        result.series = ParseSeries(node);\n      }\n    }\n    if (!node) {\n      node = XMLUtils.FindChild(xml, "c:chartSpace/c:chart/c:plotArea/c:scatterChart");\n      if (node) {\n        result.type = 4 /* Scatter */;\n        result.series = ParseSeries(node, true);\n      }\n    }\n    return result;\n  }\n  /** FIXME: accessor */\n  GetNamedRanges() {\n    return this.defined_names;\n  }\n};\n\n// treb-export/src/zip-wrapper.ts\nvar import_uzip = __toESM(require_UZIP());\nvar import_base64_js = __toESM(require_base64_js());\nvar ZipWrapper = class {\n  records;\n  text = /* @__PURE__ */ new Map();\n  constructor(buffer) {\n    this.records = import_uzip.default.parse(buffer);\n  }\n  /**\n   * check if entry exists\n   */\n  Has(path) {\n    return this.text.has(path) || !!this.records?.[path];\n  }\n  /**\n   * nondestructive\n   */\n  ArrayBuffer() {\n    const records = {};\n    if (this.records) {\n      for (const [key, value] of Object.entries(this.records)) {\n        records[key] = new Uint8Array(value);\n      }\n    }\n    const encoder = new TextEncoder();\n    for (const [key, value] of this.text.entries()) {\n      records[key] = encoder.encode(value);\n    }\n    return import_uzip.default.encode(records);\n  }\n  /**\n   * set a binary file. set this directly in the records table, \n   * instead of the text table.\n   */\n  SetBinary(path, data, encoding) {\n    if (encoding === "base64") {\n      const bytes = import_base64_js.default.toByteArray(data);\n      this.records[path] = bytes;\n    } else {\n      throw new Error("unsupported encoding: " + encoding);\n    }\n  }\n  Set(path, text) {\n    this.text.set(path, text);\n    if (!!this.records[path]) {\n      delete this.records[path];\n    }\n  }\n  GetBinary(path) {\n    const data = this.records[path];\n    if (data) {\n      return new Uint8Array(data);\n    }\n    throw new Error("path not in records: " + path);\n  }\n  Get(path) {\n    let text = this.text.get(path);\n    if (text) {\n      return text;\n    }\n    const data = this.records[path];\n    if (data) {\n      text = new TextDecoder().decode(data);\n      this.text.set(path, text);\n      delete this.records[path];\n      return text;\n    }\n    console.info(this);\n    throw new Error("path not in zip file: " + path);\n  }\n};\n\n// treb-export/src/export2.ts\nvar XMLDeclaration = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n`;\nvar Exporter = class {\n  // public zip?: JSZip;\n  zip;\n  xmloptions = {\n    format: true,\n    attributesGroupName: "a$",\n    textNodeName: "t$",\n    ignoreAttributes: false,\n    suppressEmptyNode: true\n    // OK so now I am turning this off altogether. not sure why we\n    // were using it in the first place -- which is a problem, since\n    // there\'s probably something I don\'t know.\n    /*\n        tagValueProcessor: (name: string, a: string) => {\n         \n          // we were including unsafe symbols here, but that was \n          // resulting in double-encoding. not sure why this is \n          // here at all, unless we need it for unicode? in any\n          // event (atm) allowing unsafe symbols is sufficient\n    \n          return a; // ?\n    \n          return (typeof a === \'string\') ? he.encode(a, { useNamedReferences: true, allowUnsafeSymbols: true }) : a;\n        },\n        */\n    // there\'s a "isAttributeValue" for decode, but no option for encode?\n    // we only want to encode \' and "\n    // attrValueProcessor: a => (typeof a === \'string\') ? he.encode(a, { useNamedReferences: true }) : a,\n    // why is this double-encoding? is there arlready implicit encoding? (...)\n    // there must have been a reason we used it in the first place... but I don\'t know what that was.\n    // do we need to encode apostrophes?\n    //    attributeValueProcessor: (name: string, a: string) => (typeof a === \'string\') ? \n    //      a.replace(/"/g, \'&quot;\').replace(/\'/g, \'&apos;\') : a,\n  };\n  // public xmlparser = new xmlparser.j2xParser(this.xmloptions);\n  xmlbuilder1 = new import_fast_xml_parser2.XMLBuilder(this.xmloptions);\n  xmlparser2 = new import_fast_xml_parser2.XMLParser(XMLOptions2);\n  // FIXME: need a way to share/pass parser flags\n  parser = new Parser();\n  decorated_functions = {};\n  /*\n    constructor() {\n  \n    }\n    */\n  /**\n   * init used to load the template file. we added a parameter to\n   * pass in the list of functions that need decoration (_xlfn).\n   * \n   * @param decorated_functions \n   */\n  Init(decorated_functions = {}) {\n    for (const key of Object.keys(decorated_functions)) {\n      this.decorated_functions[key.toLowerCase()] = decorated_functions[key];\n    }\n    const parsed = Base64JS2.toByteArray(template);\n    this.zip = new ZipWrapper(parsed);\n  }\n  WriteRels(rels, path, dump = false) {\n    if (!this.zip) {\n      throw new Error("missing zip");\n    }\n    const keys = Object.keys(rels);\n    const dom = {\n      Relationships: {\n        a$: {\n          xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"\n        },\n        Relationship: keys.map((key) => {\n          const rel = rels[key];\n          const a$ = {\n            Id: rel.id,\n            Target: rel.target,\n            Type: rel.type\n          };\n          if (rel.mode) {\n            a$.TargetMode = rel.mode;\n          }\n          return { a$ };\n        })\n      }\n    };\n    const xml = XMLDeclaration + this.xmlbuilder1.build(dom);\n    if (dump) {\n      console.info(xml);\n    }\n    this.zip.Set(path, xml);\n  }\n  /**\n   * format and write styles\n   */\n  WriteStyleCache(style_cache) {\n    if (!this.zip) {\n      throw new Error("missing zip");\n    }\n    const ColorAttributes = (color) => {\n      const attrs = {};\n      if (color.indexed !== void 0) {\n        attrs.indexed = color.indexed;\n      }\n      if (color.theme !== void 0) {\n        attrs.theme = color.theme;\n      }\n      if (color.tint !== void 0) {\n        attrs.tint = color.tint;\n      }\n      if (color.argb !== void 0) {\n        attrs.rgb = color.argb;\n      }\n      return attrs;\n    };\n    const xfs = style_cache.cell_xfs.map((xf) => {\n      const block = {\n        a$: {\n          numFmtId: xf.number_format,\n          fontId: xf.font,\n          fillId: xf.fill,\n          borderId: xf.border\n        }\n      };\n      if (xf.horizontal_alignment || xf.vertical_alignment || xf.wrap_text) {\n        block.alignment = { a$: {} };\n        if (xf.horizontal_alignment) {\n          block.alignment.a$.horizontal = xf.horizontal_alignment;\n        }\n        if (xf.vertical_alignment) {\n          block.alignment.a$.vertical = xf.vertical_alignment;\n        }\n        if (xf.wrap_text) {\n          block.alignment.a$.wrapText = 1;\n        }\n      }\n      return block;\n    });\n    const BorderColorAttributes = (edge) => {\n      if (edge.color) {\n        return { indexed: edge.color };\n      }\n      if (edge.rgba) {\n        return { rgb: edge.rgba };\n      }\n      if (edge.theme) {\n        const attrs = {\n          theme: edge.theme\n        };\n        if (edge.tint) {\n          attrs.tint = edge.tint;\n        }\n        return attrs;\n      }\n      return void 0;\n    };\n    const borders = style_cache.borders.map((border) => {\n      const block = {\n        left: {},\n        right: {},\n        top: {},\n        bottom: {},\n        diagonal: {}\n      };\n      if (border.top.style) {\n        block.top.a$ = {\n          style: border.top.style\n        };\n        const attrs = BorderColorAttributes(border.top);\n        if (attrs) {\n          block.top.color = { a$: attrs };\n        }\n      }\n      if (border.left.style) {\n        block.left.a$ = {\n          style: border.left.style\n        };\n        const attrs = BorderColorAttributes(border.left);\n        if (attrs) {\n          block.left.color = { a$: attrs };\n        }\n      }\n      if (border.bottom.style) {\n        block.bottom.a$ = {\n          style: border.bottom.style\n        };\n        const attrs = BorderColorAttributes(border.bottom);\n        if (attrs) {\n          block.bottom.color = { a$: attrs };\n        }\n      }\n      if (border.right.style) {\n        block.right.a$ = {\n          style: border.right.style\n        };\n        const attrs = BorderColorAttributes(border.right);\n        if (attrs) {\n          block.right.color = { a$: attrs };\n        }\n      }\n      if (border.diagonal.style) {\n        block.diagonal.a$ = {\n          style: border.diagonal.style\n        };\n        const attrs = BorderColorAttributes(border.diagonal);\n        if (attrs) {\n          block.diagonal.color = { a$: attrs };\n        }\n      }\n      return block;\n    });\n    const fills = style_cache.fills.map((fill) => {\n      const block = {\n        a$: { patternType: fill.pattern_type }\n      };\n      if (fill.pattern_gray !== void 0) {\n        block.a$.patternType = `gray${fill.pattern_gray}`;\n      }\n      if (fill.bg_color) {\n        block.bgColor = { a$: ColorAttributes(fill.bg_color) };\n      }\n      if (fill.fg_color) {\n        block.fgColor = { a$: ColorAttributes(fill.fg_color) };\n      }\n      return { patternFill: block };\n    });\n    const fonts = style_cache.fonts.map((font) => {\n      const block = {};\n      if (font.bold) {\n        block.b = "";\n      }\n      if (font.italic) {\n        block.i = "";\n      }\n      if (font.underline) {\n        block.u = "";\n      }\n      if (font.strike) {\n        block.strike = "";\n      }\n      if (font.size !== void 0) {\n        block.sz = { a$: { val: font.size } };\n      }\n      if (font.family !== void 0) {\n        block.family = { a$: { val: font.family } };\n      }\n      if (font.name !== void 0) {\n        block.name = { a$: { val: font.name } };\n      }\n      if (font.scheme !== void 0) {\n        block.scheme = { a$: { val: font.scheme } };\n      }\n      if (font.color_argb !== void 0) {\n        block.color = { a$: { rgb: font.color_argb } };\n      } else if (font.color_theme !== void 0) {\n        block.color = { a$: { theme: font.color_theme } };\n        if (font.color_tint) {\n          block.color.a$.tint = font.color_tint;\n        }\n      }\n      return block;\n    });\n    const dom = {\n      styleSheet: {\n        a$: {\n          "xmlns": "http://schemas.openxmlformats.org/spreadsheetml/2006/main",\n          "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",\n          "mc:Ignorable": "x14ac x16r2 xr",\n          "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac",\n          "xmlns:x16r2": "http://schemas.microsoft.com/office/spreadsheetml/2015/02/main",\n          "xmlns:xr": "http://schemas.microsoft.com/office/spreadsheetml/2014/revision"\n        }\n      }\n    };\n    if (style_cache.number_formats.length) {\n      dom.styleSheet.numFmts = {\n        a$: { count: style_cache.number_formats.length },\n        numFmt: style_cache.number_formats.map((format) => {\n          return {\n            a$: {\n              numFmtId: format.id,\n              formatCode: format.format\n            }\n          };\n        })\n      };\n    }\n    if (fonts.length) {\n      dom.styleSheet.fonts = {\n        a$: { count: fonts.length },\n        font: fonts\n      };\n    }\n    if (fills.length) {\n      dom.styleSheet.fills = {\n        a$: { count: fills.length },\n        fill: fills\n      };\n    }\n    if (borders.length) {\n      dom.styleSheet.borders = {\n        a$: { count: borders.length },\n        border: borders\n      };\n    }\n    if (xfs.length) {\n      dom.styleSheet.cellXfs = {\n        a$: { count: xfs.length },\n        xf: xfs\n      };\n    }\n    if (style_cache.dxf_styles.length) {\n      const dxf = [];\n      for (const style of style_cache.dxf_styles) {\n        const entry = {};\n        if (style.text || style.bold || style.italic || style.underline) {\n          const font = {};\n          if (style.text) {\n            font.color = { a$: {} };\n            if (style.text.text) {\n              font.color.a$.rgb = `FF` + style.text.text.substring(1);\n            } else if (style.text.theme) {\n              font.color.a$.theme = style.text.theme;\n              if (style.text.tint) {\n                font.color.a$.tint = style.text.tint;\n              }\n            }\n          }\n          if (style.bold) {\n            font.b = {};\n          }\n          if (style.italic) {\n            font.i = {};\n          }\n          if (style.underline) {\n            font.u = {};\n          }\n          if (style.strike) {\n            font.strike = {};\n          }\n          entry.font = font;\n        }\n        if (style.fill) {\n          const color = { a$: {} };\n          if (style.fill.text) {\n            color.a$.rgb = `FF` + style.fill.text.substring(1);\n          } else if (style.fill.theme) {\n            color.a$.theme = style.fill.theme;\n            if (style.fill.tint) {\n              color.a$.tint = style.fill.tint;\n            }\n          }\n          entry.fill = { patternFill: { bgColor: color } };\n        }\n        dxf.push(entry);\n      }\n      if (dxf.length) {\n        dom.styleSheet.dxfs = {\n          a$: { count: dxf.length },\n          dxf\n        };\n      }\n    }\n    const xml = XMLDeclaration + this.xmlbuilder1.build(dom);\n    this.zip?.Set("xl/styles.xml", xml);\n  }\n  /**\n   * format and write shared strings file to the zip archive. this will\n   * replace any existing shared strings file.\n   */\n  WriteSharedStrings(shared_strings) {\n    if (!this.zip) {\n      throw new Error("missing zip");\n    }\n    const dom = {\n      sst: {\n        a$: {\n          "xmlns": "http://schemas.openxmlformats.org/spreadsheetml/2006/main",\n          count: shared_strings.strings.length,\n          uniqueCount: shared_strings.strings.length\n        },\n        si: [\n          ...shared_strings.strings.map((t) => {\n            return { t };\n          })\n        ]\n      }\n    };\n    const xml = XMLDeclaration + this.xmlbuilder1.build(dom);\n    this.zip.Set("xl/sharedStrings.xml", xml);\n  }\n  /**\n     * FIXME: merge with workbook function (put somewhere else)\n     * /\n    public async ReadRels(zip?: JSZip, path = \'\'): Promise<RelationshipMap> {\n  \n      const rels: RelationshipMap = {};\n      const data = await zip?.file(path)?.async(\'text\') as string;\n      //\n      // force array on <Relationship/> elements, but be slack on the rest\n      // (we know they are single elements)\n      //\n      const xml = this.xmlparser2.parse(data || \'\');\n      console.info(path, xml);\n  \n      for (const relationship of xml.Relationships?.Relationship || []) {\n        const id = relationship.a$.Id;\n        rels[id] = {\n          id, \n          type: relationship.a$.Type,\n          target: relationship.a$.Target,\n        };\n      }\n  \n      return rels;\n  \n    }\n    */\n  /**\n   * FIXME: we might not always need this. \n   */\n  SheetStyle(sheet, style_cache) {\n    if (!sheet.sheet_style) {\n      return 0;\n    }\n    const options = style_cache.StyleOptionsFromProperties(sheet.sheet_style);\n    return style_cache.EnsureStyle(options);\n  }\n  RowStyle(sheet, style_cache, row) {\n    const cell_style_refs = sheet.styles || sheet.cell_style_refs || [];\n    const list = [sheet.sheet_style];\n    if (sheet.row_style) {\n      let style = sheet.row_style[row];\n      if (typeof style === "number") {\n        style = cell_style_refs[style];\n        if (style) {\n          list.push(style);\n        }\n      } else if (style) {\n        list.push(style);\n      }\n    }\n    const options = style_cache.StyleOptionsFromProperties(Style.Composite(list));\n    return style_cache.EnsureStyle(options);\n  }\n  ColumnStyle(sheet, style_cache, column) {\n    const cell_style_refs = sheet.styles || sheet.cell_style_refs || [];\n    const list = [sheet.sheet_style];\n    if (sheet.column_style) {\n      let style = sheet.column_style[column];\n      if (typeof style === "number") {\n        style = cell_style_refs[style];\n        if (style) {\n          list.push(style);\n        }\n      } else if (style) {\n        list.push(style);\n      }\n    }\n    const options = style_cache.StyleOptionsFromProperties(Style.Composite(list));\n    return style_cache.EnsureStyle(options);\n  }\n  StyleFromCell(sheet, style_cache, row, column, style = {}) {\n    const cell_style_refs = sheet.styles || sheet.cell_style_refs || [];\n    const list = [sheet.sheet_style];\n    if (sheet.row_pattern && sheet.row_pattern.length) {\n      list.push(sheet.row_pattern[row % sheet.row_pattern.length]);\n    }\n    if (sheet.row_style) {\n      let style2 = sheet.row_style[row];\n      if (typeof style2 === "number") {\n        style2 = cell_style_refs[style2];\n        if (style2) {\n          list.push(style2);\n        }\n      } else if (style2) {\n        list.push(style2);\n      }\n    }\n    if (sheet.column_style) {\n      let style2 = sheet.column_style[column];\n      if (typeof style2 === "number") {\n        style2 = cell_style_refs[style2];\n        if (style2) {\n          list.push(style2);\n        }\n      } else if (style2) {\n        list.push(style2);\n      }\n    }\n    list.push(style);\n    const options = style_cache.StyleOptionsFromProperties(Style.Composite(list));\n    return style_cache.EnsureStyle(options);\n  }\n  /**\n   * for charts we need addresses to be absolute ($)  and ensure there\'s\n   * a sheet name -- use the active sheet if it\'s not explicitly referenced\n   */\n  NormalizeAddress(unit, sheet) {\n    const addresses = unit.type === "address" ? [unit] : [unit.start, unit.end];\n    for (const address of addresses) {\n      address.absolute_row = true;\n      address.absolute_column = true;\n      if (!address.sheet) {\n        address.sheet = sheet.name;\n      }\n    }\n    if (unit.type === "range") {\n      unit.end.sheet = void 0;\n    }\n    unit.label = this.parser.Render(unit);\n    return unit;\n  }\n  /** \n   * new-style annotation layout (kind of a two-cell anchor) to two-cell anchor\n   */\n  AnnotationLayoutToAnchor(layout, sheet) {\n    const address_to_anchor = (corner) => {\n      const width = sheet.column_width && sheet.column_width[corner.address.column] ? sheet.column_width[corner.address.column] : sheet.default_column_width || 100;\n      const height = sheet.row_height && sheet.row_height[corner.address.row] ? sheet.row_height[corner.address.row] : sheet.default_row_height || 20;\n      return {\n        ...corner.address,\n        row_offset: Math.round(corner.offset.y * height),\n        column_offset: Math.round(corner.offset.x * width)\n      };\n    };\n    return {\n      from: address_to_anchor(layout.tl),\n      to: address_to_anchor(layout.br)\n    };\n  }\n  /**\n   * convert a rectangle (pixels) to a two-cell anchor. note that\n   * our offsets are in pixels, they\'ll need to be changed to whatever\n   * the target units are.\n   */\n  AnnotationRectToAnchor(src_rect, sheet) {\n    const anchor = {\n      from: { row: -1, column: -1 },\n      to: { row: -1, column: -1 }\n    };\n    const annotation_rect = {\n      top: 0,\n      left: 0,\n      width: 301,\n      height: 301,\n      ...src_rect\n    };\n    const rect = {\n      ...annotation_rect,\n      // {top, left, width, height}\n      right: annotation_rect.left + annotation_rect.width,\n      bottom: annotation_rect.top + annotation_rect.height\n    };\n    for (let x = 0, column = 0; column < 1e3; column++) {\n      const width = sheet.column_width && sheet.column_width[column] ? sheet.column_width[column] : sheet.default_column_width || 100;\n      if (anchor.from.column < 0 && rect.left <= x + width) {\n        anchor.from.column = column;\n        anchor.from.column_offset = rect.left - x;\n      }\n      if (anchor.to.column < 0 && rect.right <= x + width) {\n        anchor.to.column = column;\n        anchor.to.column_offset = rect.right - x;\n        break;\n      }\n      x += width;\n    }\n    for (let y = 0, row = 0; row < 1e3; row++) {\n      const height = sheet.row_height && sheet.row_height[row] ? sheet.row_height[row] : sheet.default_row_height || 20;\n      if (anchor.from.row < 0 && rect.top <= y + height) {\n        anchor.from.row = row;\n        anchor.from.row_offset = rect.top - y;\n      }\n      if (anchor.to.row < 0 && rect.bottom <= y + height) {\n        anchor.to.row = row;\n        anchor.to.row_offset = rect.bottom - y;\n        break;\n      }\n      y += height;\n    }\n    return anchor;\n  }\n  ParseImages(sheet_source) {\n    const images = [];\n    for (const annotation of sheet_source.annotations || []) {\n      if (annotation.type === "image" && annotation.data?.src) {\n        const src = annotation.data.src;\n        const match = src.match(/^data:image\\/([^;]*?);base64,/);\n        if (match) {\n          const data = src.substr(match[0].length);\n          const mimetype = match[1];\n          const options = {\n            data,\n            mimetype,\n            encoding: "base64"\n          };\n          switch (mimetype) {\n            case "svg+xml":\n            case "webp":\n            case "jpeg":\n            case "jpg":\n            case "image/png":\n            case "png":\n            case "gif":\n              if (annotation.layout) {\n                images.push({\n                  anchor: this.AnnotationLayoutToAnchor(annotation.layout, sheet_source),\n                  options\n                });\n              } else if (annotation.rect) {\n                images.push({\n                  anchor: this.AnnotationRectToAnchor(annotation.rect, sheet_source),\n                  options\n                });\n              } else {\n                console.warn("annotation missing layout");\n              }\n              break;\n            default:\n              console.info("unhandled image type", mimetype);\n              break;\n          }\n        }\n      }\n    }\n    return images;\n  }\n  ParseCharts(sheet_source) {\n    const charts = [];\n    const parse_series = (arg, options, ref) => {\n      if (arg.type === "range") {\n        options.data.push(this.NormalizeAddress(arg, sheet_source));\n      } else if (arg.type === "call") {\n        if (/group/i.test(arg.name)) {\n          for (const value of arg.args || []) {\n            parse_series(value, options, ref ? ref + ` (recurse)` : void 0);\n          }\n        } else if (/series/i.test(arg.name)) {\n          const [label, x, y] = arg.args;\n          if (y && y.type === "range") {\n            options.data.push(this.NormalizeAddress(y, sheet_source));\n            if (label) {\n              if (!options.names) {\n                options.names = [];\n              }\n              if (label.type === "address") {\n                this.NormalizeAddress(label, sheet_source);\n              }\n              if (label.type === "range") {\n                this.NormalizeAddress(label.start, sheet_source);\n                options.names[options.data.length - 1] = label.start;\n              } else {\n                options.names[options.data.length - 1] = label;\n              }\n            }\n            if (!options.labels2) {\n              options.labels2 = [];\n            }\n            if (x && x.type === "range") {\n              options.labels2[options.data.length - 1] = this.NormalizeAddress(x, sheet_source);\n            }\n          } else {\n            console.info("invalid series missing Y", { y, arg, ref });\n          }\n        }\n      }\n    };\n    for (const annotation of sheet_source.annotations || []) {\n      const parse_result = this.parser.Parse(annotation.formula || "");\n      if (parse_result.expression && parse_result.expression.type === "call") {\n        let type = "";\n        switch (parse_result.expression.name.toLowerCase()) {\n          case "line.chart":\n            type = "scatter";\n            break;\n          case "scatter.line":\n            type = "scatter2";\n            break;\n          case "donut.chart":\n            type = "donut";\n            break;\n          case "bar.chart":\n            type = "bar";\n            break;\n          case "column.chart":\n            type = "column";\n            break;\n        }\n        if (type === "column" || type === "donut" || type === "bar" || type === "scatter" || type === "scatter2") {\n          const options = { type, data: [] };\n          const title_index = type === "scatter2" ? 1 : 2;\n          const title_arg = parse_result.expression.args[title_index];\n          if (title_arg && title_arg.type === "literal") {\n            options.title = title_arg;\n          } else if (title_arg && title_arg.type === "address") {\n            options.title = this.NormalizeAddress(title_arg, sheet_source);\n          } else {\n          }\n          if (parse_result.expression.args[0]) {\n            const arg0 = parse_result.expression.args[0];\n            if (type === "scatter2" || type === "bar" || type === "column" || type === "scatter") {\n              parse_series(arg0, options, sheet_source.name);\n            } else if (arg0.type === "range") {\n              options.data.push(this.NormalizeAddress(arg0, sheet_source));\n            } else if (arg0.type === "call" && /group/i.test(arg0.name)) {\n              for (const series of arg0.args) {\n                if (series.type === "range") {\n                  options.data.push(this.NormalizeAddress(series, sheet_source));\n                } else if (series.type === "call" && /series/i.test(series.name)) {\n                  if (series.args[2] && series.args[2].type === "range") {\n                    options.data.push(this.NormalizeAddress(series.args[2], sheet_source));\n                  }\n                }\n              }\n            } else if (arg0.type === "call" && /series/i.test(arg0.name)) {\n              if (arg0.args[2] && arg0.args[2].type === "range") {\n                options.data.push(this.NormalizeAddress(arg0.args[2], sheet_source));\n              }\n            }\n          }\n          if (type !== "scatter2") {\n            if (parse_result.expression.args[1] && parse_result.expression.args[1].type === "range") {\n              options.labels = this.NormalizeAddress(parse_result.expression.args[1], sheet_source);\n            }\n          }\n          if (type === "scatter" && parse_result.expression.args[4] && parse_result.expression.args[4].type === "literal" && parse_result.expression.args[4].value.toString().toLowerCase() === "smooth") {\n            options.smooth = true;\n          } else if (type === "scatter2" && parse_result.expression.args[2]) {\n            if (parse_result.expression.args[2].type === "literal" && /smooth/i.test(parse_result.expression.args[2].value.toString())) {\n              options.smooth = true;\n            }\n          }\n          const rect = annotation.rect;\n          if (annotation.layout) {\n            charts.push({\n              anchor: this.AnnotationLayoutToAnchor(annotation.layout, sheet_source),\n              options\n            });\n          } else if (rect) {\n            charts.push({\n              anchor: this.AnnotationRectToAnchor(rect, sheet_source),\n              options\n            });\n          } else {\n            console.warn("annotation missing layout");\n          }\n        }\n      }\n    }\n    return charts;\n  }\n  FormulaText(text, context) {\n    if (text[0] !== "=") {\n      return text;\n    }\n    const parse_result = this.parser.Parse(text);\n    if (!parse_result.expression) {\n      console.warn("parsing function failed");\n      console.warn(text);\n      return text.substring(1);\n    } else {\n      {\n        this.parser.Walk(parse_result.expression, (unit) => {\n          if (unit.type === "call") {\n            const lc = unit.name.toLowerCase();\n            if (this.decorated_functions[lc]) {\n              unit.name = this.decorated_functions[lc] + "." + unit.name;\n            }\n          }\n          return true;\n        });\n      }\n      const table_name = context.table?.name || "";\n      return this.parser.Render(parse_result.expression, {\n        missing: "",\n        long_structured_references: true,\n        table_name\n      });\n    }\n  }\n  Export(source) {\n    let active_sheet = 0;\n    const sheet_name_map = [];\n    for (let index = 0; index < source.sheet_data.length; index++) {\n      const sheet = source.sheet_data[index];\n      const id = sheet.id || 0;\n      if (id) {\n        sheet_name_map[id] = sheet.name || "";\n      }\n      if (id === source.active_sheet) {\n        active_sheet = index;\n      }\n    }\n    const shared_strings = new SharedStrings();\n    const style_cache = new StyleCache();\n    const theme = new Theme();\n    let data = this.zip?.Get("xl/theme/theme1.xml");\n    theme.FromXML(this.xmlparser2.parse(data || ""));\n    data = this.zip?.Get("xl/styles.xml");\n    style_cache.FromXML(this.xmlparser2.parse(data || ""), theme);\n    Drawing.next_drawing_index = 1;\n    Chart.next_chart_index = 1;\n    const drawings = [];\n    const global_tables = [];\n    for (let sheet_index = 0; sheet_index < source.sheet_data.length; sheet_index++) {\n      const sheet = source.sheet_data[sheet_index];\n      const sheet_rels = {};\n      const sheet_attributes = {\n        "xmlns": "http://schemas.openxmlformats.org/spreadsheetml/2006/main",\n        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",\n        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",\n        "mc:Ignorable": "x14ac xr xr2 xr3",\n        "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac",\n        "xmlns:xr": "http://schemas.microsoft.com/office/spreadsheetml/2014/revision",\n        "xmlns:xr2": "http://schemas.microsoft.com/office/spreadsheetml/2015/revision2",\n        "xmlns:xr3": "http://schemas.microsoft.com/office/spreadsheetml/2016/revision3",\n        "xr:uid": "{D37933E2-499F-4789-8D13-194E11B743FC}"\n      };\n      const default_row_height = sheet.default_row_height ? sheet.default_row_height / 20 * 15 : 15;\n      const dom = {\n        worksheet: {\n          a$: {\n            ...sheet_attributes\n          },\n          dimension: {\n            a$: {\n              ref: "A1"\n            }\n          },\n          sheetViews: {\n            sheetView: {\n              a$: {\n                // tabSelected: (sheet_index === active_sheet ? 1 : 0),\n                workbookViewId: 0\n              }\n            }\n          },\n          sheetFormatPr: {\n            a$: default_row_height === 15 ? {\n              "x14ac:dyDescent": 0.25\n            } : {\n              defaultRowHeight: default_row_height,\n              customHeight: 1,\n              "x14ac:dyDescent": 0.25\n            }\n          },\n          cols: {},\n          sheetData: {},\n          mergeCells: {\n            a$: { count: 0 }\n          },\n          dataValidations: {},\n          hyperlinks: {},\n          conditionalFormatting: {},\n          pageMargins: {\n            a$: {\n              left: 0.7,\n              right: 0.7,\n              top: 0.75,\n              bottom: 0.75,\n              header: 0.3,\n              footer: 0.3\n            }\n          },\n          drawing: {},\n          tableParts: {\n            a$: {\n              count: 0\n            }\n          },\n          extLst: {\n            ext: {\n              a$: {\n                uri: "{05C60535-1F16-4fd2-B633-F4F36F0B64E0}",\n                "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"\n              }\n            }\n          }\n        }\n      };\n      const cell_style_refs = sheet.styles || sheet.cell_style_refs || [];\n      const cells = new Cells();\n      cells.FromJSON(sheet.data, cell_style_refs);\n      for (const entry of sheet.cell_styles) {\n        const cell = cells.EnsureCell(entry);\n        if (!cell.style) {\n          cell.style = cell_style_refs[entry.ref];\n        }\n      }\n      const extent = {\n        start: { row: cells.rows + 1, column: cells.columns + 1 },\n        end: { row: cells.rows + 1, column: cells.columns + 1 }\n      };\n      const sheet_data = { row: [] };\n      const hyperlinks = [];\n      const sparklines = [];\n      const merges = [];\n      const tables = [];\n      const validations = [];\n      const column_style_map = [];\n      const sheet_style = this.SheetStyle(sheet, style_cache);\n      for (let r = 0; r < cells.data.length; r++) {\n        const row_style = this.RowStyle(sheet, style_cache, r);\n        if (cells.data[r] && cells.data[r].length) {\n          if (r < extent.start.row) {\n            extent.start.row = r;\n          }\n          const span = { start: -1, end: -1 };\n          const row = [];\n          for (let c = 0; c < cells.data[r].length; c++) {\n            if (!column_style_map[c]) {\n              column_style_map[c] = this.ColumnStyle(sheet, style_cache, c);\n            }\n            const cell = cells.data[r][c];\n            if (cell) {\n              if (cell.table && cell.table.area.start.row === r && cell.table.area.start.column === c) {\n                const area = new Area(cell.table.area.start, cell.table.area.end);\n                const global_count = global_tables.length + 1;\n                const path = `../tables/table${global_count}.xml`;\n                const columns = [];\n                for (let i = 0; i < area.columns; i++) {\n                  const header = cells.data[r][c + i];\n                  let value = "";\n                  if (header.type !== 2 /* string */) {\n                    if (typeof header.calculated !== "undefined") {\n                      value = header.calculated.toString();\n                    } else if (typeof header.value !== "undefined") {\n                      value = header.value.toString();\n                    }\n                    header.type = 2 /* string */;\n                    header.value = value;\n                  } else {\n                    value = header.value || "";\n                  }\n                  if (!value) {\n                    value = `Column${i + 1}`;\n                  }\n                  let proposed = value;\n                  let success = false;\n                  let index = 1;\n                  while (!success) {\n                    success = true;\n                    inner_loop:\n                      for (const check of columns) {\n                        if (check.toLowerCase() === proposed.toLowerCase()) {\n                          success = false;\n                          proposed = `${value}${++index}`;\n                          break inner_loop;\n                        }\n                      }\n                  }\n                  header.value = proposed;\n                  columns.push(proposed);\n                }\n                let footers = void 0;\n                if (cell.table.totals_row) {\n                  footers = [];\n                  for (let i = 0; i < area.columns; i++) {\n                    const footer = cells.data[area.end.row][area.start.column + i];\n                    if (footer.type) {\n                      if (footer.type === 1 /* formula */) {\n                        footers[i] = {\n                          type: "formula",\n                          value: (footer.value || "").toString().substring(1)\n                        };\n                      } else {\n                        if (footer.type !== 2 /* string */) {\n                          footer.type = 2 /* string */;\n                          footer.value = footer.value?.toString() || "";\n                        }\n                        footers[i] = {\n                          type: "label",\n                          value: footer.value\n                        };\n                      }\n                    }\n                  }\n                }\n                const description = {\n                  rel: AddRel(\n                    sheet_rels,\n                    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/table",\n                    path\n                  ),\n                  index: global_count,\n                  ref: area.spreadsheet_label,\n                  name: `Table${global_count}`,\n                  display_name: `Table${global_count}`,\n                  totals_row_shown: 0,\n                  totals_row_count: cell.table?.totals_row ? 1 : 0,\n                  columns,\n                  footers\n                };\n                if (cell.table.totals_row) {\n                  const filter_area = new Area(area.start, {\n                    row: area.end.row - 1,\n                    column: area.end.column\n                  });\n                  description.filterRef = filter_area.spreadsheet_label;\n                }\n                tables.push(description);\n                global_tables.push(description);\n              }\n              if (cell.merge_area && cell.merge_area.start.row === r && cell.merge_area.start.column === c) {\n                merges.push(new Area(cell.merge_area.start, cell.merge_area.end));\n              }\n              if (cell.hyperlink) {\n                const rel = AddRel(\n                  sheet_rels,\n                  "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",\n                  cell.hyperlink,\n                  "External"\n                );\n                hyperlinks.push({\n                  rel,\n                  target: cell.hyperlink,\n                  address: { row: r, column: c }\n                });\n              }\n              if (cell.validation && (cell.validation.type === "list" /* List */ || cell.validation.type === "range" /* Range */)) {\n                validations.push({\n                  address: { row: r, column: c },\n                  validation: cell.validation\n                });\n              }\n              if (cell.type === 1 /* formula */ && /^=?sparkline\\./i.test(cell.value)) {\n                sparklines.push({\n                  address: { row: r, column: c },\n                  formula: cell.value,\n                  style: cell.style\n                });\n                continue;\n              }\n              if (c < extent.start.column) {\n                extent.start.column = c;\n              }\n              if (span.start < 0) {\n                span.start = c;\n              }\n              span.end = c;\n              const s = this.StyleFromCell(sheet, style_cache, r, c, cell.style);\n              if (cell.type === 0 /* undefined */) {\n                if (row_style && s === row_style || !row_style && (column_style_map[c] && s === column_style_map[c])) {\n                  continue;\n                }\n              }\n              let v = void 0;\n              let t;\n              let f;\n              switch (cell.type) {\n                case 1 /* formula */:\n                  f = this.FormulaText(cell.value, cell);\n                  switch (cell.calculated_type) {\n                    case 2 /* string */:\n                      v = cell.calculated;\n                      t = "str";\n                      break;\n                    case 3 /* number */:\n                      v = cell.calculated;\n                      break;\n                    case 4 /* boolean */:\n                      v = cell.calculated ? 1 : 0;\n                      t = "b";\n                      break;\n                  }\n                  break;\n                case 2 /* string */:\n                  v = shared_strings.Ensure(cell.value);\n                  t = "s";\n                  break;\n                case 3 /* number */:\n                  v = cell.value;\n                  break;\n                case 4 /* boolean */:\n                  v = cell.value ? 1 : 0;\n                  t = "b";\n                  break;\n              }\n              if (cell.area && cell.area.start.row === r && cell.area.start.column === c) {\n                if (typeof f === "string") {\n                  f = {\n                    t$: f,\n                    a$: {\n                      t: "array",\n                      ref: cell.area.spreadsheet_label\n                    }\n                  };\n                }\n              }\n              const element = {\n                a$: {\n                  r: Area.CellAddressToLabel({ row: r, column: c })\n                  // t,\n                  // s,\n                }\n                // v,\n              };\n              if (t !== void 0) {\n                element.a$.t = t;\n              }\n              if (s !== void 0) {\n                element.a$.s = s;\n              }\n              if (f !== void 0) {\n                element.f = f;\n              }\n              if (v !== void 0) {\n                element.v = v;\n              }\n              row.push(element);\n            }\n          }\n          if (row.length || row_style && row_style !== sheet_style) {\n            const row_data = {\n              a$: {\n                r: r + 1,\n                spans: `${span.start + 1}:${span.end + 1}`\n                // this works out to 0:0 for an empty row, will that work?\n              },\n              c: row\n            };\n            if (sheet.row_height && typeof sheet.row_height[r] === "number" && sheet.row_height[r] !== sheet.default_row_height) {\n              row_data.a$.customHeight = 1;\n              row_data.a$.ht = sheet.row_height[r] * 3 / 4;\n            }\n            if (row_style && row_style !== sheet_style) {\n              row_data.a$.s = row_style;\n              row_data.a$.customFormat = 1;\n            }\n            sheet_data.row.push(row_data);\n          }\n        }\n      }\n      const column_entries = [];\n      if (sheet.default_column_width) {\n        dom.worksheet.sheetFormatPr.a$.defaultColWidth = // sheet.default_column_width * one_hundred_pixels / 100;\n        PixelsToColumnWidth(sheet.default_column_width);\n      }\n      for (let c = 0; c < sheet.columns; c++) {\n        const entry = { index: c };\n        if (sheet.column_width && sheet.default_column_width && typeof sheet.column_width[c] === "number" && sheet.column_width[c] !== sheet.default_column_width) {\n          entry.width = // sheet.column_width[c] * one_hundred_pixels / 100;\n          PixelsToColumnWidth(sheet.column_width[c]);\n        }\n        let style = column_style_map[c];\n        if (style && style !== sheet_style) {\n          entry.style = style;\n        }\n        if (entry.style !== void 0 || entry.width !== void 0) {\n          column_entries[c] = entry;\n        }\n      }\n      if (column_entries.length || sheet_style) {\n        const filled = [];\n        const default_column_width = PixelsToColumnWidth(sheet.default_column_width || 90);\n        {\n          let start_index = 0;\n          for (const entry of column_entries) {\n            if (!entry) {\n              continue;\n            }\n            if (sheet_style && entry.index > start_index + 1) {\n              filled.push({\n                a$: {\n                  min: start_index + 1,\n                  max: entry.index,\n                  style: sheet_style,\n                  width: default_column_width\n                }\n              });\n            }\n            const a$ = {\n              min: entry.index + 1,\n              max: entry.index + 1\n            };\n            if (entry.style === void 0) {\n              a$.style = sheet_style;\n            } else {\n              a$.style = entry.style;\n            }\n            if (entry.width !== void 0) {\n              a$.width = entry.width;\n              a$.customWidth = 1;\n            } else {\n              a$.width = default_column_width;\n            }\n            filled.push({ a$ });\n            start_index = entry.index;\n          }\n          if (sheet_style && start_index < 16384) {\n            filled.push({\n              a$: {\n                min: start_index + 1,\n                max: 16384,\n                style: sheet_style,\n                width: default_column_width\n              }\n            });\n          }\n          dom.worksheet.cols.col = filled;\n        }\n      } else {\n        delete dom.worksheet.cols;\n      }\n      if (validations.length) {\n        dom.worksheet.dataValidations = {\n          a$: { count: validations.length },\n          dataValidation: validations.map((validation) => {\n            const entry = {\n              a$: {\n                type: "list",\n                allowBlank: 1,\n                showInputMessage: 1,\n                showErrorMessage: 1,\n                sqref: new Area(validation.address).spreadsheet_label\n              }\n            };\n            if (validation.validation.type === "range" /* Range */) {\n              const range = {\n                id: 0,\n                type: "range",\n                label: "",\n                position: 0,\n                start: { ...validation.validation.area.start, absolute_column: true, absolute_row: true, id: 0, label: "", position: 0, type: "address" },\n                end: { ...validation.validation.area.end, absolute_column: true, absolute_row: true, id: 0, label: "", position: 0, type: "address" }\n              };\n              if (typeof validation.validation.area.start.sheet_id !== "undefined") {\n                range.start.sheet = sheet_name_map[validation.validation.area.start.sheet_id];\n              }\n              entry.formula1 = this.parser.Render(range);\n            } else if (validation.validation.type === "list" /* List */) {\n              entry.formula1 = `"${validation.validation.list.join(",")}"`;\n            }\n            return entry;\n          })\n        };\n      } else {\n        delete dom.worksheet.dataValidations;\n      }\n      if (tables.length) {\n        dom.worksheet.tableParts.a$.count = tables.length;\n        dom.worksheet.tableParts.tablePart = tables.map((table) => {\n          return {\n            a$: {\n              "r:id": table.rel || ""\n            }\n          };\n        });\n      } else {\n        delete dom.worksheet.tableParts;\n      }\n      for (const table of tables) {\n        const totals_attributes = {};\n        if (table.totals_row_count) {\n          totals_attributes.totalsRowCount = 1;\n        }\n        const tableColumns = {\n          a$: {\n            count: (table.columns || []).length\n          },\n          tableColumn: []\n          /*\n          tableColumn: (table.columns||[]).map((column, index) => ({\n            a$: {\n              id: index + 1,\n              // \'xr3:uid\': GUID(),\n              name: column || (\'Column\' + (index + 1)),\n            },\n          })),\n          */\n        };\n        if (table.columns) {\n          for (let i = 0; i < table.columns.length; i++) {\n            const column = table.columns[i];\n            const footer = (table.footers || [])[i];\n            const obj = {\n              a$: {\n                id: i + 1,\n                name: column || `Column${i + 1}`\n              }\n            };\n            if (footer) {\n              if (footer.type === "label") {\n                obj.a$.totalsRowLabel = footer.value;\n              } else if (footer.type === "formula") {\n                obj.a$.totalsRowFunction = "custom";\n                obj.totalsRowFormula = footer.value;\n              }\n            }\n            tableColumns.tableColumn.push(obj);\n          }\n        }\n        const table_dom = {\n          table: {\n            a$: {\n              xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",\n              "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",\n              "mc:Ignorable": "xr xr3",\n              "xmlns:xr": "http://schemas.microsoft.com/office/spreadsheetml/2014/revision",\n              "xmlns:xr3": "http://schemas.microsoft.com/office/spreadsheetml/2016/revision3",\n              id: table.index || 0,\n              // \'xr:uid\': \'{676B775D-AA84-41B6-8450-8515A94D2D7B}\',\n              name: table.name,\n              displayName: table.display_name,\n              ...totals_attributes,\n              ref: table.ref\n              // \'xr:uid\': GUID(),\n            },\n            autoFilter: {\n              a$: {\n                ref: table.filterRef || table.ref\n                // \'xr:uid\': GUID(),\n              }\n            },\n            tableColumns,\n            tableStyleInfo: {\n              a$: {\n                name: "TableStyleMedium2",\n                showFirstColumn: 0,\n                showLastColumn: 0,\n                showRowStripes: 1,\n                showColumnStripes: 0\n              }\n            }\n          }\n        };\n        const xml2 = XMLDeclaration + this.xmlbuilder1.build(table_dom);\n        this.zip?.Set(`xl/tables/table${table.index}.xml`, xml2);\n      }\n      if (sheet.conditional_formats?.length) {\n        const conditionalFormatting = [];\n        let priority_index = 1;\n        const reverse_operator_map = {};\n        const operator_list = Object.entries(ConditionalFormatOperators).map((entry) => {\n          reverse_operator_map[entry[1]] = entry[0];\n          return entry[1];\n        });\n        operator_list.sort((a, b) => b.length - a.length);\n        for (const format of sheet.conditional_formats) {\n          let dxf_index = 0;\n          if (format.type !== "gradient") {\n            dxf_index = style_cache.dxf_styles.length;\n            style_cache.dxf_styles.push(format.style);\n          }\n          switch (format.type) {\n            case "cell-match":\n              {\n                let operator = "";\n                let formula = "";\n                for (const test of operator_list) {\n                  if (new RegExp("^" + test + "\\\\s").test(format.expression)) {\n                    operator = reverse_operator_map[test];\n                    formula = format.expression.substring(test.length).trim();\n                    break;\n                  }\n                }\n                if (operator) {\n                  conditionalFormatting.push({\n                    a$: { sqref: new Area(format.area.start, format.area.end).spreadsheet_label },\n                    cfRule: {\n                      a$: { type: "cellIs", dxfId: dxf_index, operator, priority: priority_index++ },\n                      formula\n                    }\n                  });\n                }\n              }\n              break;\n            case "expression":\n              conditionalFormatting.push({\n                a$: { sqref: new Area(format.area.start, format.area.end).spreadsheet_label },\n                cfRule: {\n                  a$: { type: "expression", dxfId: dxf_index, priority: priority_index++ },\n                  formula: format.expression\n                }\n              });\n              break;\n            case "duplicate-values":\n              conditionalFormatting.push({\n                a$: { sqref: new Area(format.area.start, format.area.end).spreadsheet_label },\n                cfRule: {\n                  a$: { type: format.unique ? "uniqueValues" : "duplicateValues", dxfId: dxf_index, priority: priority_index++ }\n                }\n              });\n              break;\n            case "gradient":\n              {\n                let cfvo = [];\n                let color = [];\n                for (const stop of format.stops) {\n                  if (stop.value === 0) {\n                    cfvo.push({ a$: { type: "min" } });\n                  } else if (stop.value === 1) {\n                    cfvo.push({ a$: { type: "max" } });\n                  } else {\n                    cfvo.push({ a$: { type: "percentile", val: stop.value * 100 } });\n                  }\n                  const stop_color = { a$: {} };\n                  if (stop.color.text) {\n                    stop_color.a$.rgb = "FF" + stop.color.text.substring(1);\n                  } else if (stop.color.theme) {\n                    stop_color.a$.theme = stop.color.theme;\n                    stop_color.a$.tint = stop.color.tint || void 0;\n                  }\n                  color.push(stop_color);\n                }\n                const generated = {\n                  a$: { sqref: new Area(format.area.start, format.area.end).spreadsheet_label },\n                  cfRule: {\n                    a$: { type: "colorScale", priority: priority_index++ },\n                    colorScale: {\n                      cfvo,\n                      color\n                    }\n                  }\n                };\n                conditionalFormatting.push(generated);\n              }\n              break;\n          }\n        }\n        if (conditionalFormatting.length) {\n          dom.worksheet.conditionalFormatting = conditionalFormatting.length > 1 ? conditionalFormatting : conditionalFormatting[0];\n        } else {\n          delete dom.worksheet.conditionalFormatting;\n        }\n      } else {\n        delete dom.worksheet.conditionalFormatting;\n      }\n      if (merges.length) {\n        dom.worksheet.mergeCells.a$.count = merges.length;\n        dom.worksheet.mergeCells.mergeCell = merges.map((merge) => {\n          return {\n            a$: { ref: merge.spreadsheet_label }\n          };\n        });\n      } else {\n        delete dom.worksheet.mergeCells;\n      }\n      if (hyperlinks.length) {\n        dom.worksheet.hyperlinks.hyperlink = hyperlinks.map((link) => {\n          return {\n            a$: {\n              "r:id": link.rel,\n              ref: new Area(link.address).spreadsheet_label,\n              "xr:uid": "{0C6B7792-7EA0-4932-BF15-D49C453C565D}"\n            }\n          };\n        });\n      } else {\n        delete dom.worksheet.hyperlinks;\n      }\n      if (sparklines.length) {\n        dom.worksheet.extLst.ext["x14:sparklineGroups"] = {\n          a$: {\n            "xmlns:xm": "http://schemas.microsoft.com/office/excel/2006/main"\n          },\n          "x14:sparklineGroup": sparklines.map((sparkline) => {\n            const result = this.parser.Parse(sparkline.formula);\n            let source2 = "";\n            if (result.expression && result.expression.type === "call" && result.expression.args.length > 0) {\n              const arg = result.expression.args[0];\n              if (arg.type === "range" || arg.type === "address") {\n                const start = arg.type === "range" ? arg.start : arg;\n                if (!start.sheet) {\n                  if (typeof start.sheet_id !== "undefined") {\n                    start.sheet = sheet_name_map[start.sheet_id];\n                  } else {\n                    start.sheet = sheet.name;\n                  }\n                }\n                source2 = this.parser.Render(arg);\n              }\n            }\n            const a$ = {\n              displayEmptyCellsAs: "gap"\n            };\n            if (/column/i.test(sparkline.formula)) {\n              a$.type = "column";\n            }\n            return {\n              a$,\n              "x14:colorSeries": { a$: { rgb: "FF376092" } },\n              "x14:sparklines": {\n                "x14:sparkline": {\n                  "xm:f": source2,\n                  "xm:sqref": new Area(sparkline.address).spreadsheet_label\n                }\n              }\n            };\n          })\n        };\n      } else {\n        delete dom.worksheet.extLst;\n      }\n      dom.worksheet.sheetData = sheet_data;\n      const charts = this.ParseCharts(sheet);\n      const images = this.ParseImages(sheet);\n      if (charts.length || images.length) {\n        const drawing = new Drawing();\n        for (const chart of charts) {\n          drawing.AddChart(chart.options, chart.anchor);\n        }\n        for (const image of images) {\n          drawing.AddImage(image.options, image.anchor);\n        }\n        for (const { image } of drawing.images) {\n          if (image.options.data) {\n            this.zip?.SetBinary(\n              `xl/media/image${image.index}.${image.extension}`,\n              image.options.data,\n              image.options.encoding\n            );\n          }\n        }\n        for (const { chart } of drawing.charts) {\n          const dom2 = chart.toJSON();\n          const xml3 = XMLDeclaration + this.xmlbuilder1.build(dom2);\n          this.zip?.Set(`xl/charts/chart${chart.index}.xml`, xml3);\n          this.WriteRels(chart.relationships, `xl/charts/_rels/chart${chart.index}.xml.rels`);\n        }\n        this.WriteRels(drawing.relationships, `xl/drawings/_rels/drawing${drawing.index}.xml.rels`);\n        const xml2 = XMLDeclaration + this.xmlbuilder1.build(drawing.toJSON());\n        this.zip?.Set(`xl/drawings/drawing${drawing.index}.xml`, xml2);\n        drawings.push(drawing);\n        const drawing_rel = AddRel(\n          sheet_rels,\n          `http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing`,\n          `../drawings/drawing${drawing.index}.xml`\n        );\n        dom.worksheet.drawing = {\n          a$: {\n            "r:id": drawing_rel\n          }\n        };\n      } else {\n        delete dom.worksheet.drawing;\n      }\n      dom.worksheet.dimension.a$.ref = new Area(extent.start, extent.end).spreadsheet_label;\n      const xml = XMLDeclaration + this.xmlbuilder1.build(dom);\n      this.zip?.Set(`xl/worksheets/sheet${sheet_index + 1}.xml`, xml);\n      if (Object.keys(sheet_rels).length) {\n        this.WriteRels(sheet_rels, `xl/worksheets/_rels/sheet${sheet_index + 1}.xml.rels`);\n      }\n    }\n    this.WriteSharedStrings(shared_strings);\n    this.WriteStyleCache(style_cache);\n    const workbook_rels = {};\n    AddRel(workbook_rels, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles", "styles.xml");\n    AddRel(workbook_rels, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme", "theme/theme1.xml");\n    AddRel(workbook_rels, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings", "sharedStrings.xml");\n    const worksheet_rels_map = source.sheet_data.map((sheet, index) => AddRel(\n      workbook_rels,\n      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",\n      `worksheets/sheet${index + 1}.xml`\n    ));\n    this.WriteRels(workbook_rels, `xl/_rels/workbook.xml.rels`);\n    let definedNames = { definedName: [] };\n    if (source.named_ranges) {\n      const keys = Object.keys(source.named_ranges);\n      for (const key of keys) {\n        let sheet_name = "";\n        const area = new Area(source.named_ranges[key].start, source.named_ranges[key].end);\n        area.start.absolute_column = area.start.absolute_row = true;\n        area.end.absolute_column = area.end.absolute_row = true;\n        if (area.start.sheet_id) {\n          for (const sheet of source.sheet_data) {\n            if (sheet.id === area.start.sheet_id) {\n              sheet_name = sheet.name || "";\n              break;\n            }\n          }\n        }\n        if (sheet_name) {\n          if (QuotedSheetNameRegex.test(sheet_name)) {\n            sheet_name = `\'${sheet_name}\'`;\n          }\n          sheet_name += "!";\n        }\n        definedNames.definedName.push({\n          a$: { name: key },\n          t$: sheet_name + area.spreadsheet_label\n        });\n      }\n    }\n    if (source.named_expressions) {\n      for (const entry of source.named_expressions) {\n        definedNames.definedName.push({\n          a$: { name: entry.name },\n          t$: entry.expression\n        });\n      }\n    }\n    if (!definedNames.definedName.length) {\n      definedNames = void 0;\n    }\n    const workbook_dom = {\n      workbook: {\n        a$: {\n          "xmlns": "http://schemas.openxmlformats.org/spreadsheetml/2006/main",\n          "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",\n          "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",\n          "mc:Ignorable": "x15 xr xr6 xr10 xr2",\n          "xmlns:x15": "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main",\n          "xmlns:xr": "http://schemas.microsoft.com/office/spreadsheetml/2014/revision",\n          "xmlns:xr6": "http://schemas.microsoft.com/office/spreadsheetml/2016/revision6",\n          "xmlns:xr10": "http://schemas.microsoft.com/office/spreadsheetml/2016/revision10",\n          "xmlns:xr2": "http://schemas.microsoft.com/office/spreadsheetml/2015/revision2"\n        },\n        workbookPr: {\n          a$: {\n            defaultThemeVersion: "166925"\n          }\n        },\n        bookViews: {\n          workbookView: {\n            a$: {\n              activeTab: active_sheet || 0\n            }\n          }\n        },\n        sheets: {\n          sheet: source.sheet_data.map((sheet, index) => {\n            const a$ = {\n              name: sheet.name || `Sheet${index + 1}`,\n              sheetId: index + 1,\n              "r:id": worksheet_rels_map[index]\n            };\n            if (sheet.visible === false) {\n              a$.state = "hidden";\n            }\n            return { a$ };\n          })\n        },\n        definedNames\n      }\n    };\n    const workbook_xml = XMLDeclaration + this.xmlbuilder1.build(workbook_dom);\n    this.zip?.Set(`xl/workbook.xml`, workbook_xml);\n    const extensions = {};\n    for (const drawing of drawings) {\n      for (const image of drawing.images) {\n        switch (image.image.extension) {\n          case "gif":\n          case "png":\n          case "jpeg":\n            extensions[image.image.extension] = "image/" + image.image.extension;\n            break;\n          case "svg":\n            extensions["svg"] = "image/svg+xml";\n            break;\n        }\n      }\n    }\n    const content_types_dom = {\n      Types: {\n        a$: {\n          "xmlns": "http://schemas.openxmlformats.org/package/2006/content-types"\n        },\n        Default: [\n          { a$: { Extension: "rels", ContentType: "application/vnd.openxmlformats-package.relationships+xml" } },\n          { a$: { Extension: "xml", ContentType: "application/xml" } },\n          ...Object.keys(extensions).map((key) => ({\n            a$: { Extension: key, ContentType: extensions[key] }\n          }))\n        ],\n        Override: [\n          { a$: { PartName: "/xl/workbook.xml", ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" } },\n          // sheets\n          ...source.sheet_data.map((sheet, index) => {\n            return { a$: {\n              ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",\n              PartName: `/xl/worksheets/sheet${index + 1}.xml`\n            } };\n          }),\n          // charts and drawings\n          ...drawings.reduce((a, drawing) => {\n            return a.concat([\n              ...drawing.charts.map((chart) => {\n                return { a$: {\n                  ContentType: "application/vnd.openxmlformats-officedocument.drawingml.chart+xml",\n                  PartName: `/xl/charts/chart${chart.chart.index}.xml`\n                } };\n              }),\n              { a$: {\n                ContentType: "application/vnd.openxmlformats-officedocument.drawing+xml",\n                PartName: `/xl/drawings/drawing${drawing.index}.xml`\n              } }\n            ]);\n          }, []),\n          { a$: { PartName: "/xl/theme/theme1.xml", ContentType: "application/vnd.openxmlformats-officedocument.theme+xml" } },\n          { a$: { PartName: "/xl/styles.xml", ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml" } },\n          { a$: { PartName: "/xl/sharedStrings.xml", ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml" } },\n          // tables\n          ...global_tables.map((table) => {\n            return { a$: {\n              ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml",\n              PartName: `/xl/tables/table${table.index || 0}.xml`\n            } };\n          }),\n          { a$: { PartName: "/docProps/core.xml", ContentType: "application/vnd.openxmlformats-package.core-properties+xml" } },\n          { a$: { PartName: "/docProps/app.xml", ContentType: "application/vnd.openxmlformats-officedocument.extended-properties+xml" } }\n        ]\n      }\n    };\n    const content_types_xml = XMLDeclaration + this.xmlbuilder1.build(content_types_dom);\n    this.zip?.Set(`[Content_Types].xml`, content_types_xml);\n  }\n  ArrayBuffer() {\n    if (!this.zip) {\n      throw new Error("missing zip");\n    }\n    return this.zip.ArrayBuffer();\n  }\n  Blob() {\n    if (!this.zip) {\n      throw new Error("missing zip");\n    }\n    const buffer = this.zip.ArrayBuffer();\n    return new Blob([buffer], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });\n  }\n  /* * zip -> binary string * /\n    public async AsBinaryString(compression_level?: number) {\n      if (!this.zip) {\n        throw new Error(\'missing zip\');\n      }\n      const opts: JSZip.JSZipGeneratorOptions = { type: \'binarystring\' };\n      if (typeof compression_level !== \'undefined\') {\n        opts.compression = \'DEFLATE\';\n        opts.compressionOptions = {level: compression_level };\n      }\n      const output = await this.zip.generateAsync(opts);\n      return output;\n    }\n  \n    /* * zip -> blob * /\n    public async AsBlob(compression_level?: number) {\n      if (!this.zip) {\n        throw new Error(\'missing zip\');\n      }\n      const opts: JSZip.JSZipGeneratorOptions = { type: \'blob\' };\n      if (typeof compression_level !== \'undefined\') {\n        opts.compression = \'DEFLATE\';\n        opts.compressionOptions = {level: compression_level };\n      }\n      const output = await this.zip.generateAsync(opts);\n      return output;\n    }\n    */\n};\n\n// treb-export/src/import2.ts\nvar import_base64_js2 = __toESM(require_base64_js());\nvar Importer = class {\n  // FIXME: need a way to share/pass parser flags\n  parser = new Parser();\n  workbook;\n  // public archive?: JSZip;\n  zip;\n  Init(data) {\n    this.zip = new ZipWrapper(data);\n    this.workbook = new Workbook(this.zip);\n    this.workbook.Init();\n  }\n  /** FIXME: accessor */\n  SheetCount() {\n    return this.workbook?.sheet_count || 0;\n  }\n  ParseCell(sheet, element, shared_formulae, arrays, merges, links, validations) {\n    const address_attr = element.a$?.r;\n    if (!address_attr) {\n      console.warn("cell missing address");\n      return void 0;\n    }\n    const address = sheet.TranslateAddress(address_attr);\n    if (is_range(address)) {\n      console.warn("cell has range address");\n      return void 0;\n    }\n    let value;\n    let type = "undefined";\n    let calculated_value;\n    let calculated_type = "undefined";\n    if (element.a$?.t && element.a$.t === "s") {\n      type = "string";\n      if (typeof element.v !== void 0) {\n        const index = Number(element.v);\n        if (!isNaN(index) && sheet.shared_strings) {\n          value = sheet.shared_strings.Get(index) || "";\n          if (value[0] === "=") {\n            value = "\'" + value;\n          }\n        }\n      }\n    } else {\n      if (typeof element.f !== "undefined") {\n        type = "formula";\n        const formula = (typeof element.f === "string" ? element.f : element.f.t$) || "";\n        if (formula) {\n          value = "=" + formula.replace(/^_xll\\./g, "");\n          const parse_result = this.parser.Parse(formula);\n          if (parse_result.expression) {\n            this.parser.Walk(parse_result.expression, (unit) => {\n              if (unit.type === "call" && /^_xll\\./.test(unit.name)) {\n                unit.name = unit.name.substr(5);\n              }\n              return true;\n            });\n            value = "=" + this.parser.Render(parse_result.expression, { missing: "" });\n          }\n          if (typeof element.f !== "string") {\n            if (element.f.a$?.t === "shared" && element.f.a$.si) {\n              shared_formulae[element.f.a$.si] = {\n                row: address.row - 1,\n                column: address.col - 1,\n                formula: value,\n                parse_result: this.parser.Parse(value)\n              };\n            }\n          }\n        } else if (typeof element.f !== "string" && element.f.a$?.t === "shared" && element.f.a$.si) {\n          const f = shared_formulae[element.f.a$.si];\n          if (f) {\n            if (f.parse_result.expression) {\n              value = "=" + this.parser.Render(f.parse_result.expression, {\n                offset: {\n                  rows: address.row - 1 - f.row,\n                  columns: address.col - 1 - f.column\n                },\n                missing: ""\n              });\n            } else\n              value = f.formula;\n          } else {\n          }\n        }\n        if (typeof element.f !== "string" && element.f.a$?.t === "array") {\n          const translated = sheet.TranslateAddress(element.f.a$.ref || "");\n          if (is_range(translated)) {\n            arrays.push(ShiftRange(translated, -1, -1));\n          }\n        }\n        if (typeof element.v !== "undefined") {\n          const num = Number(element.v.toString());\n          if (!isNaN(num)) {\n            calculated_type = "number";\n            calculated_value = num;\n          } else {\n            calculated_type = "string";\n            calculated_value = element.v.toString();\n          }\n        }\n      } else if (typeof element.v !== "undefined") {\n        const num = Number(element.v.toString());\n        if (!isNaN(num)) {\n          type = "number";\n          value = num;\n        } else {\n          type = "string";\n          value = element.v.toString();\n        }\n      }\n    }\n    const shifted = { row: address.row - 1, col: address.col - 1 };\n    for (const array of arrays) {\n      if (InRange(array, shifted) && (shifted.row !== array.from.row || shifted.col !== array.from.col)) {\n        calculated_type = type;\n        calculated_value = value;\n        value = void 0;\n        type = "undefined";\n      }\n    }\n    const result = {\n      row: shifted.row,\n      column: shifted.col,\n      value,\n      type\n    };\n    if (typeof calculated_value !== "undefined") {\n      result.calculated_type = calculated_type;\n      result.calculated = calculated_value;\n    }\n    if (element.a$?.s) {\n      result.style_ref = Number(element.a$.s);\n    }\n    for (const link of links) {\n      if (link.address.row === address.row && link.address.col === address.col) {\n        result.hyperlink = link.reference;\n      }\n    }\n    for (const validation of validations) {\n      if (validation.address.row === shifted.row && validation.address.column === shifted.col) {\n        result.validation = validation.validation;\n        break;\n      }\n    }\n    for (const range of merges) {\n      if (InRange(range, shifted)) {\n        result.merge_area = {\n          start: {\n            row: range.from.row,\n            column: range.from.col\n          },\n          end: {\n            row: range.to.row,\n            column: range.to.col\n          }\n        };\n      }\n    }\n    for (const range of arrays) {\n      if (InRange(range, shifted)) {\n        result.area = {\n          start: {\n            row: range.from.row,\n            column: range.from.col\n          },\n          end: {\n            row: range.to.row,\n            column: range.to.col\n          }\n        };\n      }\n    }\n    return result;\n  }\n  AddressToArea(address) {\n    const area = is_address(address) ? {\n      start: { row: address.row - 1, column: address.col - 1 },\n      end: { row: address.row - 1, column: address.col - 1 }\n    } : {\n      start: { row: address.from.row - 1, column: address.from.col - 1 },\n      end: { row: address.to.row - 1, column: address.to.col - 1 }\n    };\n    return area;\n  }\n  ParseConditionalFormat(address, rule) {\n    const area = this.AddressToArea(address);\n    const operators = ConditionalFormatOperators;\n    switch (rule.a$.type) {\n      case "duplicateValues":\n      case "uniqueValues":\n        let style = {};\n        if (rule.a$.dxfId) {\n          const index = Number(rule.a$.dxfId);\n          if (!isNaN(index)) {\n            style = this.workbook?.style_cache.dxf_styles[index] || {};\n          }\n        }\n        return {\n          type: "duplicate-values",\n          area,\n          style,\n          unique: rule.a$.type === "uniqueValues"\n        };\n      case "cellIs":\n        if (rule.a$.operator && rule.formula) {\n          let style2 = {};\n          if (rule.a$.dxfId) {\n            const index = Number(rule.a$.dxfId);\n            if (!isNaN(index)) {\n              style2 = this.workbook?.style_cache.dxf_styles[index] || {};\n            }\n          }\n          const operator = operators[rule.a$.operator || ""];\n          if (!operator) {\n            console.info("unhandled cellIs operator:", rule.a$.operator);\n          } else {\n            return {\n              type: "cell-match",\n              expression: operator + " " + rule.formula,\n              area,\n              style: style2\n            };\n          }\n        }\n        break;\n      case "expression":\n        if (rule.formula) {\n          let style2 = {};\n          if (rule.a$.dxfId) {\n            const index = Number(rule.a$.dxfId);\n            if (!isNaN(index)) {\n              style2 = this.workbook?.style_cache.dxf_styles[index] || {};\n            }\n          }\n          return {\n            type: "expression",\n            expression: rule.formula,\n            area,\n            style: style2\n          };\n        }\n        break;\n      case "colorScale":\n        if (rule.colorScale && Array.isArray(rule.colorScale.cfvo) && Array.isArray(rule.colorScale.color)) {\n          const stops = [];\n          for (const [index, entry] of rule.colorScale.cfvo.entries()) {\n            let value = 0;\n            let color = {};\n            const color_element = rule.colorScale.color[index];\n            if (color_element.a$.rgb) {\n              color.text = "#" + color_element.a$.rgb.substring(2);\n            } else if (color_element.a$.theme) {\n              color.theme = Number(color_element.a$.theme) || 0;\n              if (color_element.a$.tint) {\n                color.tint = Math.round(color_element.a$.tint * 1e3) / 1e3;\n              }\n            }\n            switch (entry.a$.type) {\n              case "min":\n                value = 0;\n                break;\n              case "max":\n                value = 1;\n                break;\n              case "percentile":\n                value = (Number(entry.a$.val) || 0) / 100;\n                break;\n            }\n            stops.push({ color, value });\n          }\n          return {\n            type: "gradient",\n            stops,\n            color_space: "RGB",\n            area\n          };\n        } else {\n          console.info("unexpected colorScale", { rule });\n        }\n        break;\n      default:\n        console.info("unhandled cf type:", { rule });\n    }\n    return void 0;\n  }\n  GetSheet(index = 0) {\n    if (!this.workbook) {\n      throw new Error("missing workbook");\n    }\n    const sheet = this.workbook.sheets[index];\n    const data = [];\n    const shared_formulae = {};\n    const arrays = [];\n    const merges = [];\n    const conditional_formats = [];\n    const links = [];\n    const validations = [];\n    const annotations = [];\n    const FindAll = XMLUtils.FindAll.bind(XMLUtils, sheet.sheet_data);\n    const conditional_formatting = FindAll("worksheet/conditionalFormatting");\n    for (const element of conditional_formatting) {\n      if (element.a$?.sqref) {\n        const area = sheet.TranslateAddress(element.a$.sqref);\n        if (element.cfRule) {\n          const rules = Array.isArray(element.cfRule) ? element.cfRule : [element.cfRule];\n          for (const rule of rules) {\n            const format = this.ParseConditionalFormat(area, rule);\n            if (format) {\n              conditional_formats.push(format);\n            }\n          }\n        }\n      }\n    }\n    const merge_cells = FindAll("worksheet/mergeCells/mergeCell");\n    for (const element of merge_cells) {\n      if (element.a$.ref) {\n        const merge = sheet.TranslateAddress(element.a$.ref);\n        if (is_range(merge)) {\n          merges.push(ShiftRange(merge, -1, -1));\n        }\n      }\n    }\n    const validation_entries = FindAll("worksheet/dataValidations/dataValidation");\n    for (const entry of validation_entries) {\n      const type = entry.a$?.type;\n      const ref = entry.a$?.sqref;\n      const formula = entry.formula1;\n      if (ref && formula && type === "list") {\n        let address;\n        let validation;\n        let parse_result = this.parser.Parse(ref);\n        if (parse_result.expression) {\n          if (parse_result.expression.type === "address") {\n            address = parse_result.expression;\n          } else if (parse_result.expression.type === "range") {\n            address = parse_result.expression.start;\n          }\n        }\n        parse_result = this.parser.Parse(formula);\n        if (parse_result.expression) {\n          if (parse_result.expression.type === "range") {\n            validation = {\n              type: "range" /* Range */,\n              area: parse_result.expression\n            };\n          } else if (parse_result.expression.type === "literal") {\n            validation = {\n              type: "list" /* List */,\n              list: parse_result.expression.value.toString().split(/,/).map((value) => {\n                const tmp = this.parser.Parse(value);\n                if (tmp.expression?.type === "group" && /\\s/.test(value)) {\n                  return value;\n                }\n                if (tmp.expression?.type === "literal") {\n                  return tmp.expression.value;\n                }\n                if (tmp.expression?.type === "identifier") {\n                  return tmp.expression.name;\n                }\n                return void 0;\n              })\n            };\n          }\n        }\n        if (address && validation) {\n          validations.push({ address, validation });\n        }\n      }\n    }\n    const hyperlinks = FindAll("worksheet/hyperlinks/hyperlink");\n    for (const child of hyperlinks) {\n      let address = sheet.TranslateAddress(child.a$?.ref || "");\n      if (is_range(address)) {\n        address = address.from;\n      }\n      let text = "";\n      let reference = "";\n      if (child.a$ && child.a$["r:id"]) {\n        text = "remote link";\n        const relationship = sheet.rels[child.a$["r:id"]];\n        if (relationship) {\n          reference = relationship.target || "";\n        }\n      } else {\n        reference = child.__location || "";\n        text = child.__display || "";\n      }\n      links.push({ address, reference, text });\n    }\n    let default_row_height = 21;\n    let default_column_width = 100;\n    const sheet_format = sheet.sheet_data.worksheet?.sheetFormatPr;\n    if (sheet_format) {\n      if (sheet_format.a$?.defaultColWidth) {\n        const width = Number(sheet_format.a$.defaultColWidth);\n        if (!isNaN(width)) {\n          default_column_width = ColumnWidthToPixels(width);\n        }\n      }\n      if (sheet_format.a$?.defaultRowHeight) {\n        const height = Number(sheet_format.a$.defaultRowHeight);\n        if (!isNaN(height)) {\n          default_row_height = Math.round(height * 4 / 3);\n        }\n      }\n    }\n    const row_heights = [];\n    const outline = [];\n    const rows = FindAll("worksheet/sheetData/row");\n    for (const row of rows) {\n      const row_index = row.a$?.r ? Number(row.a$.r) : 1;\n      let height = default_row_height;\n      if (row.a$?.ht) {\n        const num = Number(row.a$.ht);\n        if (!isNaN(num)) {\n          height = Math.round(num * 4 / 3);\n        }\n      }\n      if (row.a$?.outlineLevel) {\n        const num = Number(row.a$.outlineLevel);\n        if (!isNaN(num)) {\n          outline[row_index - 1] = num;\n        }\n      }\n      if (height !== default_row_height) {\n        row_heights[row_index - 1] = height;\n      }\n      let cells = row.c || [];\n      if (!Array.isArray(cells)) {\n        cells = [cells];\n      }\n      for (const element of cells) {\n        const cell = this.ParseCell(sheet, element, shared_formulae, arrays, merges, links, validations);\n        if (cell) {\n          data.push(cell);\n        }\n      }\n    }\n    const column_styles = [];\n    let default_column_style = -1;\n    const column_widths = [];\n    const columns = FindAll("worksheet/cols/col");\n    for (const child of columns) {\n      const min = Number(child.a$?.min);\n      const max = Number(child.a$?.max);\n      if (child.a$?.style) {\n        const style = Number(child.a$.style);\n        if (!isNaN(min) && !isNaN(max) && !isNaN(style)) {\n          if (sheet.extent && max >= sheet.extent.to.col || max - min > 100) {\n            default_column_style = style;\n          } else {\n            for (let i = min; i <= max; i++) {\n              column_styles[i] = style;\n            }\n          }\n        }\n      }\n      if (child.a$?.customWidth) {\n        let width = Number(child.a$.width);\n        if (!isNaN(min) && !isNaN(max) && !isNaN(width)) {\n          if (max === 16384) {\n          } else {\n            width = ColumnWidthToPixels(width);\n            for (let i = min; i <= max; i++)\n              column_widths[i - 1] = width;\n          }\n        }\n      }\n    }\n    const table_references = FindAll("worksheet/tableParts/tablePart");\n    for (const child of table_references) {\n      const rel = child.a$ ? child.a$["r:id"] : void 0;\n      if (rel) {\n        let reference = "";\n        const relationship = sheet.rels[rel];\n        if (relationship) {\n          reference = relationship.target || "";\n          const description = this.workbook.ReadTable(reference);\n          if (description) {\n            const ref = sheet.TranslateAddress(description.ref);\n            const area = is_address(ref) ? {\n              start: { row: ref.row - 1, column: ref.col - 1 },\n              end: { row: ref.row - 1, column: ref.col - 1 }\n            } : {\n              start: { row: ref.from.row - 1, column: ref.from.col - 1 },\n              end: { row: ref.to.row - 1, column: ref.to.col - 1 }\n            };\n            for (const cell of data) {\n              if (cell.row === area.start.row && cell.column === area.start.column) {\n                cell.table = {\n                  area,\n                  name: description.name,\n                  totals_row: !!description.totals_row_count\n                  // NOTE: column headers are added on first load, we don\'t \n                  // read them from here. not super efficient but we do it\n                  // that way for regular loads as well\n                };\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n    const drawings = FindAll("worksheet/drawing");\n    const chart_descriptors = [];\n    const image_descriptors = [];\n    for (const child of drawings) {\n      const rel = child.a$ ? child.a$["r:id"] : void 0;\n      if (rel) {\n        let reference = "";\n        const relationship = sheet.rels[rel];\n        if (relationship) {\n          reference = relationship.target || "";\n        }\n        if (reference) {\n          const drawing = this.workbook.ReadDrawing(reference);\n          if (drawing && drawing.length) {\n            for (const entry of drawing) {\n              switch (entry.type) {\n                case "chart":\n                  chart_descriptors.push(entry);\n                  break;\n                case "image":\n                  image_descriptors.push(entry);\n                  break;\n              }\n            }\n          }\n        }\n      }\n    }\n    const AnchorToCorner = (anchor) => {\n      const result2 = {\n        address: {\n          row: anchor.row,\n          column: anchor.column\n        },\n        offset: {\n          x: 0,\n          // anchor.column_offset || 0, // FIXME: scale\n          y: 0\n          // anchor.row_offset || 0,    // FIXME: scale\n        }\n      };\n      if (anchor.row_offset) {\n        let row_height = row_heights[anchor.row];\n        if (row_height === void 0) {\n          row_height = default_row_height;\n        }\n        result2.offset.y = anchor.row_offset / 9525 / row_height;\n      }\n      if (anchor.column_offset) {\n        let column_width = column_widths[anchor.column];\n        if (column_width === void 0) {\n          column_width = default_column_width;\n        }\n        result2.offset.x = anchor.column_offset / 9525 / column_width;\n      }\n      return result2;\n    };\n    for (const descriptor of image_descriptors) {\n      if (descriptor && descriptor.image) {\n        const layout = {\n          tl: AnchorToCorner(descriptor.anchor.from),\n          br: AnchorToCorner(descriptor.anchor.to)\n        };\n        let type = "image";\n        const data2 = import_base64_js2.default.fromByteArray(descriptor.image);\n        let imagetype = "";\n        if (descriptor.filename) {\n          if (/jpe*g$/i.test(descriptor.filename)) {\n            imagetype = "jpeg";\n          } else if (/png$/i.test(descriptor.filename)) {\n            imagetype = "png";\n          } else if (/gif$/i.test(descriptor.filename)) {\n            imagetype = "gif";\n          }\n        }\n        if (imagetype && data2) {\n          const src = "data:image/" + imagetype + ";base64," + data2;\n          annotations.push({\n            layout,\n            type,\n            data: { src }\n          });\n        }\n      }\n    }\n    for (const descriptor of chart_descriptors) {\n      if (descriptor && descriptor.chart) {\n        const layout = {\n          tl: AnchorToCorner(descriptor.anchor.from),\n          br: AnchorToCorner(descriptor.anchor.to)\n        };\n        let type;\n        const args = [];\n        let func = "";\n        const series = descriptor.chart?.series;\n        switch (descriptor.chart.type) {\n          case 4 /* Scatter */:\n            type = "treb-chart";\n            func = "Scatter.Line";\n            if (series && series.length) {\n              args[0] = `Group(${series.map((s) => `Series(${s.title || ""},${s.categories || ""},${s.values || ""})` || "").join(", ")})`;\n            }\n            args[1] = descriptor.chart.title;\n            break;\n          case 5 /* Donut */:\n          case 6 /* Pie */:\n            func = descriptor.chart.type === 5 /* Donut */ ? "Donut.Chart" : "Pie.Chart";\n            type = "treb-chart";\n            if (series && series[0]) {\n              args[0] = series[0].values;\n              args[1] = series[0]?.categories || "";\n            }\n            args[2] = descriptor.chart.title;\n            break;\n          case 2 /* Bar */:\n          case 1 /* Column */:\n          case 3 /* Line */:\n            args[2] = descriptor.chart.title;\n            type = "treb-chart";\n            switch (descriptor.chart.type) {\n              case 2 /* Bar */:\n                func = "Bar.Chart";\n                break;\n              case 1 /* Column */:\n                func = "Column.Chart";\n                break;\n              default:\n                func = "Line.Chart";\n            }\n            if (series) {\n              if (series.length > 1) {\n                args[0] = `Group(${series.map((s) => `Series(${s.title || ""},,${s.values || ""})` || "").join(", ")})`;\n              } else if (series.length === 1) {\n                if (series[0].title) {\n                  args[0] = `Series(${series[0].title || ""},,${series[0].values || ""})`;\n                } else {\n                  args[0] = series[0].values;\n                }\n              }\n              args[1] = series[0]?.categories || "";\n            }\n            break;\n        }\n        const formula = `=${func}(${args.join(", ")})`;\n        if (type && formula) {\n          annotations.push({\n            layout,\n            type,\n            formula\n          });\n        }\n      }\n    }\n    const ext = FindAll("worksheet/extLst/ext");\n    for (const entry of ext) {\n      let prefix = "";\n      for (const key of Object.keys(entry?.a$ || {})) {\n        const match = key.match(/^xmlns:(.*)$/);\n        if (match) {\n          prefix = match[1];\n          break;\n        }\n      }\n      const groups = XMLUtils.FindAll(entry, `${prefix}:sparklineGroups/${prefix}:sparklineGroup`);\n      for (const group of groups) {\n        let func = "Sparkline.line";\n        let reference = "";\n        let source = "";\n        if (group.a$?.type === "column") {\n          func = "Sparkline.column";\n        }\n        const sparklines = XMLUtils.FindAll(group, `${prefix}:sparklines/${prefix}:sparkline`);\n        for (const sparkline of sparklines) {\n          for (const key of Object.keys(sparkline)) {\n            if (/:f$/.test(key)) {\n              source = sparkline[key];\n            } else if (/:sqref$/.test(key)) {\n              reference = sparkline[key];\n            }\n          }\n        }\n        if (source && reference) {\n          const constructed_function = `=${func}(${source})`;\n          const translated = sheet.TranslateAddress(reference);\n          if (is_address(translated)) {\n            const result2 = {\n              row: translated.row - 1,\n              column: translated.col - 1,\n              value: constructed_function,\n              type: "formula"\n              // ValueType.formula,\n            };\n            let matched = false;\n            for (const element of data) {\n              if (element.row === result2.row && element.column === result2.column) {\n                matched = true;\n                element.type = "formula";\n                element.value = constructed_function;\n                break;\n              }\n            }\n            if (!matched) {\n              data.push(result2);\n            }\n          }\n        }\n      }\n    }\n    const result = {\n      name: sheet.options.name,\n      cells: data,\n      default_column_width,\n      column_widths,\n      row_heights,\n      annotations,\n      conditional_formats,\n      styles: this.workbook?.style_cache?.CellXfToStyles() || []\n    };\n    if (outline.length) {\n      result.outline = outline;\n    }\n    if (sheet.visible_state === 1 /* hidden */ || sheet.visible_state === 2 /* very_hidden */) {\n      result.hidden = true;\n    }\n    if (default_column_style >= 0) {\n      result.sheet_style = default_column_style;\n    }\n    if (column_styles.length) {\n      result.column_styles = column_styles;\n    }\n    return result;\n  }\n};\n\n// treb-export/src/export-worker/export-worker.ts\nvar ctx = self;\nvar exporter = new Exporter();\nvar ExportSheets = (data) => {\n  if (data.sheet) {\n    exporter.Init(data.decorated || []);\n    exporter.Export(data.sheet);\n    ctx.postMessage({ status: "complete", blob: exporter.Blob() });\n  }\n};\nvar ImportSheet = (data) => {\n  const importer = new Importer();\n  try {\n    importer.Init(data.data);\n    const count = importer.SheetCount();\n    const results = {\n      sheets: [],\n      names: importer.workbook?.GetNamedRanges(),\n      active_tab: importer.workbook?.active_tab\n    };\n    for (let i = 0; i < count; i++) {\n      const result = importer.GetSheet(i);\n      if (result) {\n        results.sheets.push(result);\n      }\n    }\n    ctx.postMessage({ status: "complete", results });\n  } catch (err) {\n    console.warn("error importing xlsx file");\n    console.info(err);\n    ctx.postMessage({ status: "error", data: err });\n  }\n};\nctx.addEventListener("message", (event) => {\n  if (event.data && event.data.command === "export") {\n    ExportSheets(event.data);\n  } else if (event.data && event.data.command === "import") {\n    ImportSheet(event.data);\n  }\n});\n';

// treb-embed/src/embedded-spreadsheet.ts
var EmbeddedSpreadsheet = class _EmbeddedSpreadsheet {
  /** @internal */
  static treb_base_path = "";
  /* * @internal */
  // public static export_worker_text = '';  
  /** @internal */
  static treb_embedded_script_path = "";
  /* * @internal */
  // public static enable_engine = false;
  /* * @internal */
  // public static enable_formatter = false;
  /** @internal */
  static one_time_warnings = {};
  DOM = DOMContext.GetInstance();
  // default
  /**
   * this flag will be set on LoadDocument. the intent is to be able to
   * know if you have loaded a network document, which may happen before you
   * have the chance to subscribe to events
   * 
   * FIXME: we need to nail down the semantics of this. what does it mean if
   * you call reset? 
   * 
   * @internal
   */
  loaded = false;
  /* *
   * @internal
   */
  // public toolbar_ctl?: ToolbarCtl;
  /**
   * this is a cache of number formats and colors used in the document. it's
   * intended for an external toolbar.
   * 
   * FIXME: should we preferentially use Color objects? (...)
   * 
   * @internal
   */
  document_styles = {
    number_formats: [],
    colors: [],
    theme_colors: []
  };
  /**
   * this is a representation of selection state for an external toolbar.
   * we also use it to manage state changes. this used to be internal only,
   * now we are exposing it. we might want to only expose a copy via an
   * accessor, but for now we'll just expose the actual object.
   * 
   * not sure why this was ever optional, we should just have an empty default
   * 
   * @internal
   */
  selection_state = {};
  /**
   * this is our options object, EmbeddedSpreadsheetOptions but we 
   * narrow the storage key type to a string|undefined (can be boolean 
   * in the input).
   * 
   * @internal
   */
  options;
  /**
   * @internal
   * 
   * this is not public (in the API, at least), for the moment, but 
   * it is accessible. not sure which way we're going to go with this.
   */
  get Localization() {
    return Localization;
  }
  /** loaded language model, if any */
  language_model;
  /** FIXME: fix type (needs to be extensible) */
  events = new EventSource();
  /** 
   * automatic/manual 
   * why is this protected? is there some reason we don't want people to use it?
   */
  calculation = 0 /* automatic */;
  /**
   * this might be something that should travel with the document,
   * as a way to compare different versions... something to think
   * about. we could certainly preserve/restore it on save/load.
   * 
   * UPDATE: we're now storing this with the document, as "revision".
   * for the future we should be able to use this as the basis for
   * dirty flags in various applications.
   */
  file_version = 0;
  /** 
   * this is recordkeeping for "dirty" marking, which also supports
   * undo. if we preserve the file version this will have to track.
   */
  last_save_version = 0;
  /* *
   * this is an attempt to improve our recordkeeping for stuff that
   * has user-generated changes. it means "this is the version that
   * was in the network document or inline document".  it has no 
   * meaning in sheets that start empty.
   * 
   * we use "network version" to mean both network documents and inline
   * documents (Which technically come from the network).
   * 
   * the problem with this is that the only way for it to work would
   * be to store it in the document, but once we start storing this 
   * value it will get stuck and cause problems. there's no way to
   * "only store it in some contexts". I guess in theory we could wipe
   * it if necesssary, but that's weak... something like 
   * 
   * (1) if this document comes from anywhere but local storage, 
   *     dump the value
   * 
   * (2) never save this value unless you're writing to local storage
   * 
   * it's still going to get stuck in places it shouldn't be but we can
   * mitigate problems with it. I'll think about it. we can do the 
   * "can revert" thing in a different way.
   * 
   * /
  protected canonical_network_version = 0;
  */
  /**
   * simpler flag for testing if we can revert
   */
  initial_load_source = void 0;
  /**
   * calculator instance. we may share this if we're in a split view.
   */
  calculator;
  /**
   */
  grid;
  /**
   * model moved from grid. we control it now. grid still maintains
   * its own view, including active sheet.
   */
  model;
  /**
   * dialog is assigned in the constructor, only if there's a containing
   * element (i.e. not when we're just using the engine)
   */
  dialog;
  /** new spinner */
  spinner;
  /** file chooser */
  file_chooser;
  /** file chooser operation */
  file_chooser_operation = 0 /* None */;
  // protected toolbar?: Toolbar;
  /* * caching selection state so we can refer to it if we need it */
  // protected selection_state?: SelectionState;
  /** localized parser instance. we're sharing. */
  get parser() {
    return this.model.parser;
  }
  /** for destruction */
  view;
  /** for destruction */
  key_listener;
  // protected views: EmbeddedSpreadsheetBase[] = [];
  views = [];
  /** focus target if we have multiple views */
  focus_target = this;
  /** parent, if we are a split view child */
  parent_view;
  /**
   * export worker (no longer using worker-loader).
   * export worker is loaded on demand, not by default.
   */
  export_worker;
  /**
   * undo pointer points to the next insert spot. that means that when
   * you push an undo operation, it goes into the slot [undo_pointer].
   *
   * that means if you want to undo, and the pointer is at X, you need
   * to go to the state X-2 -- because X-1 is effectively the _current_ state.
   * and also if you do that (undo), you decrement the pointer by 1.
   *
   * this is confusing.
   */
  undo_pointer = 0;
  undo_stack = [];
  /**
   * ...
   */
  last_selection;
  /**
   * convenience function returns the name of the active sheet. if the 
   * sheet name has spaces or other characters that require quoting, it
   * will be quoted using single quotes.
   */
  get active_sheet() {
    const name = this.grid.active_sheet.name;
    if (QuotedSheetNameRegex.test(name)) {
      return `'${name}'`;
    }
    return name;
  }
  /** 
   * this was added for riskamp.com; it doesn't track modified, really, because
   * it doesn't reflect saves. we need to do that but leave this one as-is for
   * backwards compatibility.
   * 
   * @internal
   */
  get modified() {
    return this.undo_stack.length !== 1;
  }
  /** document name (metadata) */
  get document_name() {
    return this.grid.model.document_name;
  }
  /** document name (metadata) */
  set document_name(name) {
    this.grid.model.document_name = name;
    this.DocumentChange();
  }
  /** 
   * opaque user data (metadata). `USER_DATA_TYPE` is a template
   * parameter you can set when creating the spreadsheet.
   */
  get user_data() {
    return this.grid.model.user_data;
  }
  /** 
   * opaque user data (metadata). `USER_DATA_TYPE` is a template
   * parameter you can set when creating the spreadsheet.
   */
  set user_data(data) {
    this.grid.model.user_data = data;
    this.DocumentChange();
  }
  /** current grid scale */
  get scale() {
    return this.grid.scale;
  }
  /** current grid scale */
  set scale(value) {
    this.grid.scale = value;
  }
  /** headless state */
  get headless() {
    return this.grid.headless;
  }
  /** headless state */
  set headless(value) {
    if (this.grid.headless !== value) {
      this.grid.headless = value;
      if (!value) {
        this.grid.Update(true);
        this.RebuildAllAnnotations();
      }
    }
  }
  /**
   * state is the current revision of the document. it is preserved any
   * time the document is saved. it should be a consistent indication of
   * the document version and can be used to compare versions.
   * 
   * state is an atomically-incrementing integer but rolls over at 2^16.
   */
  get state() {
    return this.file_version;
  }
  /**
   * this flag indicates we can revert the document. what that means is 
   * we loaded a user-created version from localStorage, but there's a 
   * backing network or inline document. or we did load the original version
   * but the user has made some document changes.
   * 
   * it's like `dirty`, but that uses the load source as the ground truth,
   * which means if you load a modified document from localStorage it's 
   * initially considered not-dirty (which is maybe just a bad design?)
   * 
   * the intent of this field is to support enabling/disabling revert 
   * logic, or to add a visual indicator that you are not looking at the
   * canonical version.
   * 
   * @privateRemarks
   * for that to work we need to know that we loaded from localStorage --
   * that's not something we're keeping track of at the moment. 
   * 
   * it might be good to include the "canonical version" when we put stuff
   * in localStorage...
   * 
   */
  get can_revert() {
    if (!this.options.inline_document && !this.options.document) {
      return false;
    }
    if (this.initial_load_source === "local-storage" /* LOCAL_STORAGE */) {
      return true;
    }
    return this.dirty;
  }
  /**
   * indicates the current revision of the document is not equal to the 
   * last-saved revision of the document.
   */
  get dirty() {
    return this.file_version !== this.last_save_version;
  }
  /**
   * explicitly set or clear the dirty flag. it's intended for use by clients 
   * that have their own save routine.
   */
  set dirty(value) {
    if (value) {
      this.file_version++;
    } else {
      this.last_save_version = this.file_version;
    }
  }
  /**
   * returns the names of all sheets in the current document
   */
  get sheet_names() {
    return this.model.sheets.list.map((sheet) => sheet.name);
  }
  /**
   * constructor takes spreadsheet options. type should be implicit, either
   * the default (here) or a subclass
   * 
   * @internal
   */
  constructor(options) {
    if (options.storage_key && !options.local_storage) {
      options.local_storage = options.storage_key;
    }
    this.options = { ...DefaultOptions, ...options, local_storage: this.ResolveStorageKey(options.local_storage, "document") };
    if (typeof this.options.imaginary_value === "string") {
      NumberFormat.imaginary_character = this.options.imaginary_value;
    }
    if (this.options.network_document) {
      console.warn("the option `network_document` is deprecated. please use `document` instead.");
      if (!this.options.document) {
        this.options.document = this.options.network_document;
      }
    }
    if (this.options.document && this.options.inline_document) {
      console.warn("both document and inline-document are provided");
    }
    const network_document = this.options.document;
    let data;
    let source;
    if (this.options.local_storage && !this.options.toll_initial_load && !options.model) {
      data = localStorage.getItem(this.options.local_storage) || void 0;
      if (data) {
        source = "local-storage" /* LOCAL_STORAGE */;
      }
    }
    if (!data && !this.options.toll_initial_load && !options.model && options.inline_document) {
      data = options.inline_document;
      source = "inline-document" /* INLINE_DOCUMENT */;
    }
    if (this.options.local_storage && !options.model) {
      window.addEventListener("visibilitychange", (event) => {
        if (document.visibilityState === "hidden") {
          if (this.options.local_storage && this.dirty) {
            this.SaveLocalStorage(this.options.local_storage);
          }
        }
      });
    }
    let container;
    if (typeof this.options.container === "string") {
      container = document.querySelector(this.options.container);
    } else if (this.options.container) {
      container = this.options.container;
    }
    const grid_options = {
      // expand: false,
      insert_function_button: false,
      // do we have this?
      in_cell_editor: true,
      // if this is always true, why is it an option?
      repaint_on_cell_change: false,
      scrollbars: this.options.scrollbars,
      markdown: !!this.options.markdown,
      formula_bar: this.options.formula_bar,
      expand_formula_button: this.options.expand_formula_button,
      tab_bar: this.options.tab_bar,
      add_tab: this.options.add_tab,
      // delete_tab: this.options.delete_tab,
      expand: this.options.expand
    };
    if (this.options.scale) {
      grid_options.initial_scale = this.options.scale;
    }
    if (this.options.stats) {
      grid_options.stats = this.options.stats;
      grid_options.tab_bar = true;
    }
    if (this.options.scale_control) {
      grid_options.scale_control = true;
      grid_options.tab_bar = true;
      if (this.options.persist_scale) {
        grid_options.persist_scale_key = this.ResolveStorageKey(this.options.persist_scale, "scale");
        if (grid_options.persist_scale_key) {
          const json = localStorage.getItem(grid_options.persist_scale_key);
          if (json) {
            try {
              const obj = JSON.parse(json);
              grid_options.initial_scale = obj.scale || 1;
            } catch (e) {
              console.warn("parsing persisted scale failed");
            }
          }
        }
      }
    }
    if (options.model) {
      this.model = options.model.model;
      this.calculator = options.model.calculator;
      this.DOM = options.model.DOM;
    } else {
      this.model = new DataModel();
      this.model.sheets.Add(Sheet.Blank(this.model.theme_style_properties));
      this.calculator = this.CreateCalculator(this.model, options);
    }
    if (container) {
      this.DOM = DOMContext.GetInstance(container.ownerDocument);
    }
    this.grid = new Grid(grid_options, this.model, void 0, !!container, this.DOM);
    if (this.options.headless) {
      this.grid.headless = true;
    }
    if (container) {
      this.DOM = DOMContext.GetInstance(container.ownerDocument);
      if (!this.parent_view) {
        if (UA.is_windows) {
          container.parentElement?.classList.add("treb-ua-windows");
        } else if (UA.is_mac) {
          container.parentElement?.classList.add("treb-ua-osx");
        }
      }
      const template = container.querySelector(".treb-view-template");
      this.view = template.content.firstElementChild?.cloneNode(true);
      container.prepend(this.view);
      this.view.addEventListener("focusin", () => {
        if (this.focus_target !== this) {
          this.Publish({ type: "focus-view" });
          this.focus_target = this;
        }
      });
      this.key_listener = (event) => this.HandleKeyDown(event);
      container.addEventListener("keydown", this.key_listener);
      const toll_initial_render = !!(data || this.options.document);
      this.grid.Initialize(this.view, toll_initial_render);
      if (this.options.dnd) {
        this.view.addEventListener("dragenter", (event) => this.HandleDrag(event));
        this.view.addEventListener("dragover", (event) => this.HandleDrag(event));
        this.view.addEventListener("drop", (event) => this.HandleDrop(event));
      }
      this.grid.grid_events.Subscribe((event) => {
        switch (event.type) {
          case "error":
            this.dialog?.ShowDialog({
              type: "error" /* error */,
              ...this.TranslateGridError(event.code),
              timeout: 3e3,
              close_box: true
            });
            break;
          case "selection":
            this.UpdateSelection(event.selection);
            this.UpdateSelectionStyle(event.selection);
            break;
          case "sheet-change":
            this.OnSheetChange(event);
            this.UpdateSelectionStyle();
            break;
          case "data":
            {
              const cached_selection = this.last_selection;
              (this.calculation === 0 /* automatic */ ? this.Recalculate(event) : Promise.resolve()).then(() => {
                this.DocumentChange(cached_selection);
              });
            }
            break;
          case "style":
            this.DocumentChange();
            this.UpdateDocumentStyles(false);
            this.UpdateSelectionStyle();
            break;
          case "scale":
            this.RebuildAllAnnotations();
            this.events.Publish({ type: "view-change" });
            break;
          case "annotation":
            if (event.annotation) {
              const view = event.annotation.view[this.grid.view_index] || {};
              this.DocumentChange();
              switch (event.event) {
                case "create":
                  this.InflateAnnotation(event.annotation);
                  this.calculator.UpdateAnnotations(event.annotation, this.grid.active_sheet);
                  this.grid.AnnotationUpdated(event.annotation);
                  break;
                case "delete":
                  this.calculator.RemoveAnnotation(event.annotation);
                  break;
                case "update":
                  if (view.update_callback) {
                    view.update_callback();
                    this.grid.AnnotationUpdated(event.annotation);
                  } else {
                    console.info("annotation update event without update callback");
                  }
                  this.calculator.UpdateAnnotations(event.annotation, this.grid.active_sheet);
                  break;
                case "resize":
                  if (view.resize_callback) {
                    view.resize_callback();
                    this.grid.AnnotationUpdated(event.annotation);
                  }
                  break;
              }
            } else {
              console.info("annotation event without annotation");
            }
            break;
          case "structure":
            {
              const cached_selection = this.last_selection;
              if (event.conditional_format) {
                this.calculator.UpdateConditionals();
                this.ApplyConditionalFormats(this.grid.active_sheet, false);
              }
              if (event.rebuild_required) {
                this.calculator.Reset();
                (this.calculation === 0 /* automatic */ ? this.Recalculate(event) : Promise.resolve()).then(() => {
                  this.DocumentChange(cached_selection);
                });
              } else {
                this.DocumentChange(cached_selection);
              }
            }
            this.UpdateSelectionStyle();
            break;
          case "cell-event":
            this.HandleCellEvent(event);
            break;
        }
      });
      if (this.options.prompt_save) {
        window.addEventListener("beforeunload", (event) => {
          if (this.last_save_version !== this.file_version) {
            event.preventDefault();
            event.returnValue = "";
          }
        });
      }
    } else {
      if (!_EmbeddedSpreadsheet.one_time_warnings.headless) {
        _EmbeddedSpreadsheet.one_time_warnings.headless = true;
        console.info("not initializing layout; don't call UI functions");
      }
    }
    if (options.preload) {
      options.preload.call(0, this);
    }
    if (data) {
      if (typeof data === "string") {
        data = JSON.parse(data);
      }
      if (data) {
        this.LoadDocument(data, { recalculate: !!this.options.recalculate, source });
      } else {
        this.UpdateDocumentStyles();
      }
    } else if (!network_document) {
      this.calculator.RebuildClean(true);
      this.UpdateDocumentStyles();
    }
    this.FlushUndo();
    this.grid.ShowHeaders(this.options.headers);
    if (this.options.scroll && !this.options.document) {
      const address = this.options.scroll;
      requestAnimationFrame(() => {
        this.ScrollTo(address);
      });
    }
    this.UpdateAC();
    if (this.options.global_name) {
      self[this.options.global_name] = this;
    }
    if (container && this.options.spinner) {
      this.spinner = new Spinner(container);
    }
    if (network_document && !options.model && !data) {
      this.LoadNetworkDocument(network_document, this.options);
    }
    if (container) {
      this.dialog = new Dialog(container);
    }
  }
  /**
   * update autocomplete functions. we're breaking this out into a 
   * separate method so we can better manage language translation.
   */
  UpdateAC() {
    let list = this.calculator.SupportedFunctions();
    if (this.language_model) {
      const map = {};
      for (const entry of this.language_model.functions || []) {
        map[entry.base.toUpperCase()] = entry;
      }
      list = list.map((descriptor) => {
        return map[descriptor.name.toUpperCase()] || descriptor;
      });
    }
    this.grid.SetAutocompleteFunctions(list);
  }
  /**
   * initialize calculator instance
   */
  CreateCalculator(model, options) {
    return new Calculator(model, {
      complex_numbers: options.complex
    });
  }
  /**
   * we moved error strings from grid, so we can (at some point) localize 
   * them. returns a message and (optionally) a title for the dialog
   */
  TranslateGridError(code) {
    switch (code) {
      case 0 /* none */:
        return {
          message: `No error`
          // why?
        };
      case 2 /* array */:
        return {
          message: `You can't change part of an array`
        };
      case 5 /* invalid_area_for_paste */:
        return {
          message: "Invalid area for paste"
        };
      case 4 /* invalid_area_for_table */:
        return {
          message: `Invalid area for table`
        };
      case 3 /* data_validation */:
        return {
          message: `Invalid value (data validation)`
        };
      default:
        return {
          message: `Unknown error (${code})`
        };
    }
  }
  /**
   * this will need to get overloaded for subclasses so they can
   * create the correct type
   */
  CreateView() {
    const child = new _EmbeddedSpreadsheet({
      ...this.options,
      global_name: void 0,
      // don't overwrite
      model: this
    });
    child.parent_view = this;
    return child;
  }
  // --- public internal methods -----------------------------------------------
  // these are methods that are public for whatever reason, but we don't want
  // them published to any public API. if we ever get around to encapsulating
  // the API, leave these out.
  /**
   * testing 
   * 
   * @internal
   */
  Unsplit() {
    const target = this.views.pop();
    if (target) {
      const sheet = target.view;
      sheet.grid.grid_events.CancelAll();
      sheet.events.CancelAll();
      if (sheet.view?.parentElement) {
        if (sheet.key_listener) {
          sheet.view.parentElement.removeEventListener("keydown", sheet.key_listener);
        }
        sheet.view.parentElement.removeChild(sheet.view);
      }
      this.view?.focus();
      this.Resize();
    }
  }
  /**
   * set or remove an external editor. external editor is an interface used
   * to support outside tooling by highlighting a list of arguments and 
   * responding to selection.
   */
  ExternalEditor(config) {
    this.grid.ExternalEditor(config);
  }
  /**
   * this is not very efficient atm. we create another whole instance of this
   * class, do a lot of unecssary painting and layout. it works but it could
   * definitely be improved.
   * 
   * @internal
   */
  Split() {
    const view = this.CreateView();
    view.grid.EnsureActiveSheet(true);
    view.view?.addEventListener("focusin", () => {
      if (this.focus_target !== view) {
        this.Publish({ type: "focus-view" });
        this.focus_target = view;
      }
    });
    view.grid.grid_events.Subscribe((event) => {
      if (event.type === "structure") {
        this.grid.EnsureActiveSheet();
        this.grid.UpdateLayout();
        this.grid.tab_bar?.Update();
      }
    });
    view.Subscribe((event) => {
      switch (event.type) {
        case "selection":
          break;
        default:
          view.UpdateAnnotations();
          this.grid.Update(true);
      }
    });
    this.grid.grid_events.Subscribe((event) => {
      if (event.type === "structure") {
        view.grid.EnsureActiveSheet();
        view.grid.UpdateLayout();
        view.grid.tab_bar?.Update();
      }
    });
    const subscription = this.Subscribe((event) => {
      switch (event.type) {
        case "selection":
          break;
        case "load":
        case "reset":
          view.grid.EnsureActiveSheet(true);
          view.UpdateAnnotations();
          view.grid.Update(true);
          break;
        default:
          view.UpdateAnnotations();
          view.grid.Update(true);
      }
    });
    this.views.push({
      view,
      subscription
    });
  }
  //////////////////////////////////////////////////////////////////////////////
  //
  // conditional formatting API (WIP)
  //
  /**
   * list conditional formats. uses the active sheet by default, or pass a 
   * sheet name or id.
   * 
   * @internal
   */
  ListConditionalFormats(sheet) {
    const target = typeof sheet === "undefined" ? this.grid.active_sheet : this.model.sheets.Find(sheet);
    return target?.conditional_formats || [];
  }
  /** @internal */
  ConditionalFormatDuplicateValues(range, options) {
    if (range === void 0) {
      const ref = this.GetSelectionReference();
      if (ref.empty) {
        throw new Error("invalid range (no selection)");
      }
      range = ref.area;
    }
    return this.AddConditionalFormat({
      type: "duplicate-values",
      area: this.model.ResolveArea(range, this.grid.active_sheet),
      ...options
    });
  }
  /**
   * @internal
   */
  ConditionalFormatGradient(range, options) {
    if (range === void 0) {
      const ref = this.GetSelectionReference();
      if (ref.empty) {
        throw new Error("invalid range (no selection)");
      }
      range = ref.area;
    }
    const area = this.model.ResolveArea(range, this.grid.active_sheet);
    const format = typeof options === "object" ? {
      type: "gradient",
      area,
      ...options
    } : {
      type: "gradient",
      area,
      ...StandardGradientsList[options]
    };
    this.AddConditionalFormat(format);
    return format;
  }
  /** @internal */
  ConditionalFormatCellMatch(range, options) {
    if (range === void 0) {
      const ref = this.GetSelectionReference();
      if (ref.empty) {
        throw new Error("invalid range (no selection)");
      }
      range = ref.area;
    }
    const area = this.model.ResolveArea(range, this.grid.active_sheet);
    const format = {
      type: "cell-match",
      area,
      ...options
    };
    this.AddConditionalFormat(format);
    return format;
  }
  /**
   * @internal
   */
  ConditionalFormatExpression(range, options) {
    if (range === void 0) {
      const ref = this.GetSelectionReference();
      if (ref.empty) {
        throw new Error("invalid range (no selection)");
      }
      range = ref.area;
    }
    const area = this.model.ResolveArea(range, this.grid.active_sheet);
    const format = {
      type: "expression",
      area,
      ...options
    };
    this.AddConditionalFormat(format);
    return format;
  }
  /**
   * add a conditional format
   * 
   * @internal
   */
  AddConditionalFormat(format) {
    this.grid.AddConditionalFormat(format);
    return format;
  }
  /**
   * remove conditional format
   * 
   * @internal
   */
  RemoveConditionalFormat(format) {
    this.grid.RemoveConditionalFormat({ format });
  }
  /**
   * clear conditional formats from the target range (or currently selected
   * range). we operate on format objects, meaning we'll remove the whole
   * format object rather than clip the area.
   * 
   * @internal
   */
  RemoveConditionalFormats(range) {
    if (range === void 0) {
      const ref = this.GetSelectionReference();
      if (ref.empty) {
        throw new Error("invalid range (no selection)");
      }
      range = ref.area;
    }
    const area = this.model.ResolveArea(range, this.grid.active_sheet);
    this.grid.RemoveConditionalFormat({ area });
  }
  //////////////////////////////////////////////////////////////////////////////
  /**
   * @internal
   */
  HandleToolbarMessage(event) {
    if (this.focus_target !== this) {
      this.focus_target.HandleToolbarMessage(event);
      return;
    }
    let updated_style = {};
    const insert_annotation = (func) => {
      const selection = this.grid.GetSelection();
      if (selection && !selection.empty) {
        const label = selection.area.spreadsheet_label;
        this.InsertAnnotation(`=${func}(${label},,"${label}")`, void 0, void 0, ",");
      }
    };
    if (/^border-/.test(event.command)) {
      if (event.command === "border-color") {
        try {
          updated_style.border_top_fill = updated_style.border_bottom_fill = updated_style.border_left_fill = updated_style.border_right_fill = event.color || {};
        } catch (err) {
          console.error(err);
        }
      } else {
        let width = 1;
        let command = event.command.substring(7);
        if (event.command === "border-double-bottom") {
          command = "bottom" /* Bottom */;
          width = 2;
        }
        this.grid.ApplyBorders2(
          void 0,
          command,
          event.color || {},
          width
        );
      }
    } else {
      switch (event.command) {
        case "about":
          this.About();
          break;
        case "number-format":
          updated_style.number_format = event.format || "General";
          break;
        case "font-scale":
          {
            const selection = this.grid.GetSelection();
            const area = this.grid.active_sheet.RealArea(selection.area);
            const scale = Number(event.scale || 1);
            if (scale && !isNaN(scale)) {
              this.grid.ApplyStyle(void 0, {
                //font_size_unit: 'em', font_size_value: scale 
                font_size: {
                  unit: "em",
                  value: scale
                }
              }, true);
              const rows = [];
              for (let row = area.start.row; row <= area.end.row; row++) {
                rows.push(row);
              }
              if (!this.selection_state?.merge) {
                this.grid.SetRowHeight(rows, void 0, false);
              }
            }
          }
          break;
        case "update-comment":
          this.SetNote(void 0, event.comment || "");
          break;
        case "clear-comment":
          this.SetNote(void 0, "");
          break;
        case "text-color":
        case "fill-color":
          try {
            const color = event.color || {};
            if (event.command === "text-color") {
              updated_style.text = color;
            } else if (event.command === "fill-color") {
              updated_style.fill = color;
            }
          } catch (err) {
            console.error(err);
          }
          break;
        case "insert-table":
          this.InsertTable();
          break;
        case "remove-table":
          this.RemoveTable();
          break;
        case "insert-row":
          this.InsertRows();
          break;
        case "insert-column":
          this.InsertColumns();
          break;
        case "delete-row":
          this.DeleteRows();
          break;
        case "delete-column":
          this.DeleteColumns();
          break;
        case "insert-sheet":
          this.grid.InsertSheet();
          break;
        case "delete-sheet":
          this.grid.DeleteSheet();
          break;
        case "freeze-panes":
          {
            const freeze = this.grid.GetFreeze();
            if (freeze.rows || freeze.columns) {
              this.Freeze(0, 0);
            } else {
              this.FreezeSelection();
            }
          }
          break;
        case "insert-image":
          this.InsertImage();
          break;
        case "insert-donut-chart":
          insert_annotation("Donut.Chart");
          break;
        case "insert-column-chart":
          insert_annotation("Column.Chart");
          break;
        case "insert-bar-chart":
          insert_annotation("Bar.Chart");
          break;
        case "insert-line-chart":
          insert_annotation("Line.Chart");
          break;
        case "increase-precision":
        case "decrease-precision":
          if (this.selection_state?.style) {
            const format = NumberFormatCache.Get(this.selection_state.style.number_format || "General");
            if (format.date_format) {
              break;
            }
            const clone = new NumberFormat(format.pattern);
            if (format.magic_decimal) {
              let len = 0;
              let rng = this.GetRange();
              if (!Array.isArray(rng)) {
                rng = [[rng]];
              }
              find_number:
                for (let i = 0; i < rng.length; i++) {
                  for (let j = 0; j < rng[i].length; j++) {
                    const value = rng[i][j];
                    if (typeof value !== "undefined" && IsComplex(value)) {
                      const f2 = NumberFormatCache.Get(this.selection_state.style.number_format || "General", true);
                      const real_parts = f2.BaseFormat(value.real);
                      const imaginary_parts = f2.BaseFormat(value.imaginary);
                      if (real_parts.parts && typeof real_parts.parts[1] === "string") {
                        len = real_parts.parts[1].length;
                      }
                      if (imaginary_parts.parts && typeof imaginary_parts.parts[1] === "string") {
                        len = Math.max(len, imaginary_parts.parts[1].length);
                      }
                      break find_number;
                    } else if (typeof value === "number") {
                      const parts = format.BaseFormat(value);
                      if (parts.parts && typeof parts.parts[1] === "string") {
                        len = parts.parts[1].length;
                      }
                      break find_number;
                    }
                  }
                }
              if (event.command === "increase-precision") {
                clone.SetDecimal(len + 1);
              } else {
                clone.SetDecimal(Math.max(0, len - 1));
              }
            } else {
              if (event.command === "increase-precision") {
                clone.IncreaseDecimal();
              } else {
                clone.DecreaseDecimal();
              }
            }
            updated_style.number_format = clone.toString();
          }
          break;
        case "merge-cells":
          this.grid.MergeCells();
          break;
        case "unmerge-cells":
          this.grid.UnmergeCells();
          break;
        case "lock-cells":
          updated_style = {
            locked: this.selection_state?.style ? !this.selection_state.style.locked : true
          };
          break;
        case "wrap-text":
          updated_style = {
            wrap: this.selection_state?.style ? !this.selection_state?.style.wrap : true
          };
          break;
        case "justify-left":
          updated_style = { horizontal_align: "left" };
          break;
        case "justify-center":
          updated_style = { horizontal_align: "center" };
          break;
        case "justify-right":
          updated_style = { horizontal_align: "right" };
          break;
        case "align-top":
          updated_style = { vertical_align: "top" };
          break;
        case "align-middle":
          updated_style = { vertical_align: "middle" };
          break;
        case "align-bottom":
          updated_style = { vertical_align: "bottom" };
          break;
        case "reset":
          this.Reset();
          break;
        case "import-file":
          this.LoadLocalFile();
          break;
        case "save-json":
          this.SaveToDesktop();
          break;
        case "save-csv":
          this.SaveToDesktop("csv" /* csv */);
          break;
        case "export-xlsx":
          this.Export();
          break;
        case "revert":
          this.Revert();
          break;
        case "recalculate":
          this.Recalculate();
          break;
        case "toggle-toolbar":
        case "show-toolbar":
        case "hide-toolbar":
          this.ShowToolbar(event.command === "toggle-toolbar" ? void 0 : event.command === "show-toolbar");
          break;
        case "toggle-sidebar":
        case "show-sidebar":
        case "hide-sidebar":
          this.ShowSidebar(event.command === "toggle-sidebar" ? void 0 : event.command === "show-sidebar");
          break;
        case "revert-indicator":
          this.dialog?.ShowDialog({
            title: `This is a modified version of the document.
You can revert to the original or save your
changes in the sidebar.`,
            close_box: true,
            timeout: 5e3,
            type: "info" /* info */
          });
          break;
        default:
          console.info("unhandled", event.command);
          break;
      }
    }
    if (Object.keys(updated_style).length) {
      this.grid.ApplyStyle(void 0, updated_style, true);
    }
    this.Focus();
  }
  /** 
   * @internal 
   * 
   * @param show - true or false to show/hide, or leave undefined to toggle
   */
  ShowToolbar(show) {
    if (this.options.toolbar && this.options.container instanceof HTMLElement) {
      const layout = this.options.container.parentElement;
      if (layout) {
        if (show === void 0) {
          show = !layout.hasAttribute("toolbar");
        }
        if (show) {
          layout.setAttribute("toolbar", "");
        } else {
          layout.removeAttribute("toolbar");
        }
      }
    }
  }
  /** 
   * @internal 
   *
   * @param show - true or false to show/hide, or leave undefined to toggle
   */
  ShowSidebar(show) {
    if (this.options.toolbar && this.options.container instanceof HTMLElement) {
      const layout = this.options.container.parentElement;
      if (layout) {
        if (show === void 0) {
          show = layout.hasAttribute("collapsed");
        }
        if (show) {
          layout.removeAttribute("collapsed");
        } else {
          layout.setAttribute("collapsed", "");
        }
      }
    }
  }
  /* * 
     * this is public because it's created by the composite sheet. 
     * FIXME: perhaps there's a better way to do that? via message passing? (...) 
     * 
     * @internal
     * /
     public CreateToolbar(container: HTMLElement): Toolbar {
      this.toolbar = new Toolbar(container, this.options, this.grid.theme);
      this.toolbar.Subscribe(event => this.focus_target.HandleToolbarEvent(event));
  
      this.UpdateDocumentStyles(false);
      this.UpdateSelectionStyle(undefined);
  
      return this.toolbar;
    }
    */
  /** 
   * Create (and return) a Chart object.
   * @internal
   */
  CreateChart() {
    if (this.calculator.RegisterLibrary("treb-charts", ChartFunctions)) {
      this.UpdateAC();
    }
    if (this.options.chart_renderer) {
      if (typeof this.options.chart_renderer === "function") {
        return new Chart(this.options.chart_renderer());
      } else {
        return new Chart(this.options.chart_renderer);
      }
    }
    return new Chart();
  }
  // --- public API methods ----------------------------------------------------
  /** 
   * this is not public _yet_ 
   * 
   * @internal
   */
  SetLanguage(model) {
    this.language_model = model;
    if (!model) {
      this.grid.SetLanguageMap();
    } else {
      const map = {};
      for (const entry of model.functions || []) {
        map[entry.base] = entry.name;
      }
      this.grid.SetLanguageMap(map);
    }
    this.UpdateAC();
  }
  /**
   * Use this function to batch multiple document changes. Essentially the 
   * grid stops broadcasting events for the duration of the function call, 
   * and collects them instead. After the function call we update as necessary.
   * 
   * @public
   */
  async Batch(func, paint = false) {
    const cached_selection = this.last_selection;
    const events = this.grid.Batch(func, paint);
    let recalc = false;
    let reset = false;
    for (const event of events) {
      if (event.type === "data") {
        recalc = true;
      } else if (event.type === "structure") {
        if (event.rebuild_required)
          reset = true;
      }
    }
    if (reset) {
      this.calculator.Reset();
    }
    if (recalc || reset) {
      await this.Recalculate();
      this.DocumentChange(cached_selection);
    }
  }
  /** set freeze area */
  Freeze(rows = 0, columns = 0) {
    this.grid.Freeze(rows, columns, true);
  }
  /** freeze at current selection */
  FreezeSelection() {
    const selection = this.grid.GetSelection();
    if (selection.empty) {
      this.grid.Freeze(0, 0);
    } else {
      const area = selection.area;
      if (area.entire_sheet) {
      } else if (area.entire_row) {
        this.grid.Freeze(area.end.row + 1, 0);
      } else if (area.entire_column) {
        this.grid.Freeze(0, area.end.column + 1);
      } else {
        this.grid.Freeze(area.end.row + 1, area.end.column + 1);
      }
    }
  }
  /** return current freeze area */
  GetFreeze() {
    return this.grid.GetFreeze();
  }
  /**
   * Update theme from CSS. Because the spreadsheet is painted, not
   * rendered, you need to notifiy us if external style (CSS) properties
   * have changed. We will update and repaint.
   */
  UpdateTheme() {
    this.grid.UpdateTheme(void 0);
    this.UpdateDocumentStyles();
    for (const sheet of this.model.sheets.list) {
      for (const format of sheet.conditional_formats) {
        format.internal = void 0;
      }
    }
    this.calculator.UpdateConditionals();
    this.ApplyConditionalFormats(this.grid.active_sheet, false);
    this.grid.Update(true);
  }
  /**
   * Get sheet ID, by name (sheet name) or index. This may be useful for
   * constructing references programatically. 
   * 
   * @remarks
   * 
   * Sheet IDs are positive integers. IDs are ephemeral, they should not be 
   * retained after a document is closed or reloaded. They will likely (almost)
   * always be the same, but that's not guaranteed, so don't rely on them. 
   * 
   * @param sheet - sheet name or index. sheet names are matched case-insensitively.
   * 
   * @returns ID, or undefined if the index is not found (0 is not a valid 
   * sheet ID, so you can test for falsy).
   * 
   * @public
   */
  GetSheetID(sheet) {
    if (typeof sheet === "number") {
      const model_sheet = this.grid.model.sheets.list[sheet];
      if (model_sheet) {
        return model_sheet.id;
      }
    } else {
      const entry = this.model.sheets.Find(sheet);
      if (entry) {
        return entry.id;
      }
    }
    return void 0;
  }
  /**
   * insert a table in the given range. optionally include a totals row.
   * this method does not make any changes to content or layout. it just 
   * converts the range to a table.
   * 
   * @param reference 
   */
  InsertTable(range, options = {}) {
    const area = range ? this.model.ResolveArea(range, this.grid.active_sheet) : this.GetSelectionReference().area;
    let theme = options.theme;
    if (typeof theme === "number") {
      theme = ThemeColorTable(theme);
    }
    this.grid.InsertTable(area, options.totals_row, options.sortable, theme);
  }
  RemoveTable(range) {
    const table = this.ResolveTable(range || this.GetSelectionReference().target);
    if (table) {
      this.grid.RemoveTable(table);
    }
  }
  UpdateTableStyle(range, theme = 4) {
    const table = this.ResolveTable(range || this.GetSelectionReference().target);
    if (table) {
      if (typeof theme === "number") {
        theme = ThemeColorTable(theme);
      }
      table.theme = theme;
      this.grid.active_sheet.FlushCellStyles();
      this.grid.Update(true);
      this.PushUndo();
    }
  }
  /**
   * Add a sheet, optionally named. 
   */
  AddSheet(name) {
    this.grid.AddSheet(name);
    const sheet = this.model.sheets.list[this.model.sheets.list.length - 1];
    this.calculator.Reset();
    return sheet.id;
  }
  RemoveConnectedChart(id) {
    const element = this.model.RemoveConnectedElement(id);
    if (element) {
      const removed = this.calculator.RemoveConnectedELement(element);
      if (removed) {
      }
    }
  }
  /**
   * @internal
   * 
   * @returns an id that can be used to manage the reference
   */
  CreateConnectedChart(formula, target, options) {
    let r1c1 = options?.r1c1 || false;
    let argument_separator = options?.argument_separator || this.parser.argument_separator;
    this.parser.Save();
    this.parser.flags.r1c1 = r1c1;
    if (argument_separator === ",") {
      this.parser.argument_separator = "," /* Comma */;
      this.parser.decimal_mark = "." /* Period */;
    } else {
      this.parser.argument_separator = ";" /* Semicolon */;
      this.parser.decimal_mark = "," /* Comma */;
    }
    const result = this.parser.Parse(formula);
    this.parser.Restore();
    if (result.expression) {
      formula = "=" + this.parser.Render(result.expression, { missing: "" });
    } else {
      console.warn("invalid formula", result.error);
    }
    const chart = this.CreateChart();
    chart.Initialize(target);
    const id = this.model.AddConnectedElement({
      formula,
      // this is circular, but I want to leave `this` bound to the sheet
      // instance in case we need it -- so what's a better approach? pass
      // in the formula explicitly, and update if we need to make changes?
      update: (instance) => {
        const parse_result = this.parser.Parse(instance.formula);
        if (parse_result && parse_result.expression && parse_result.expression.type === "call") {
          this.parser.Walk(parse_result.expression, (unit) => {
            if (unit.type === "address" || unit.type === "range") {
              this.model.ResolveSheetID(unit, void 0, this.grid.active_sheet);
            }
            return true;
          });
          const expr_name = parse_result.expression.name.toLowerCase();
          const result2 = this.calculator.CalculateExpression(parse_result.expression);
          chart.Exec(expr_name, result2);
        }
        chart.Update();
      }
    });
    this.calculator.UpdateConnectedElements(this.grid.active_sheet);
    this.UpdateConnectedElements();
    return id;
  }
  /**
   * Insert an annotation node. Usually this means inserting a chart. Regarding
   * the argument separator, see the Evaluate function.
   * 
   * @param formula - annotation formula. For charts, the chart formula.
   * @param type - annotation type. Defaults to `treb-chart`.
   * @param rect - coordinates, or a range reference for layout.
   * @param options - evaluate options. because this function used to take 
   *  the argument separator, we allow that to be passed directly, but this
   *  is deprecated. new code should use the options object.
   */
  InsertAnnotation(formula, type = "treb-chart", rect, options) {
    let target;
    let argument_separator = void 0;
    let r1c1 = false;
    if (typeof options === "object") {
      argument_separator = options.argument_separator;
      r1c1 = !!options.r1c1;
    } else if (options === "," || options === ";") {
      argument_separator = options;
    }
    if (rect) {
      target = Rectangle.IsRectangle(rect) ? rect : this.model.ResolveArea(rect, this.grid.active_sheet);
    }
    if (argument_separator && argument_separator !== this.parser.argument_separator || r1c1) {
      this.parser.Save();
      if (argument_separator === ",") {
        this.parser.argument_separator = "," /* Comma */;
        this.parser.decimal_mark = "." /* Period */;
      } else {
        this.parser.argument_separator = ";" /* Semicolon */;
        this.parser.decimal_mark = "," /* Comma */;
      }
      this.parser.flags.r1c1 = !!r1c1;
      const result = this.parser.Parse(formula);
      this.parser.Restore();
      if (result.expression) {
        formula = "=" + this.parser.Render(result.expression, { missing: "" });
      }
    }
    const { x, y } = this.grid.GetScrollOffset();
    const scale = this.grid.scale || 1;
    const auto_size = { width: 301, height: 301 };
    this.grid.CreateAnnotation({
      type,
      formula
      // class_name,
    }, void 0, void 0, target || { top: y / scale + 30, left: x / scale + 30, ...auto_size });
  }
  /**
   * Insert an image. This method will open a file chooser and (if an image
   * is selected) insert the image into the document.
   */
  InsertImage() {
    this.SelectFile2(".png, .jpg, .jpeg, .gif, .svg", 2 /* InsertImage */);
  }
  /** 
   * Rename a sheet. 
   * 
   * @param index - old name or index of sheet. leave undefined to use 
   * current active sheet.
   * 
   * @public
   */
  RenameSheet(index, new_name) {
    let sheet;
    if (typeof index === "number") {
      sheet = this.grid.model.sheets.list[index];
    } else if (typeof index === "string") {
      sheet = this.model.sheets.Find(index);
    } else {
      sheet = this.grid.active_sheet;
    }
    if (!sheet) {
      return;
    }
    this.grid.RenameSheet(sheet, new_name);
  }
  /**
   * Delete a sheet. 
   * 
   * @param index - sheet name or index. Leave undefined to delete the active sheet.
   * 
   * @public
   */
  DeleteSheet(index) {
    if (typeof index === "string") {
      const sheet = this.model.sheets.Find(index);
      if (sheet) {
        this.grid.DeleteSheetID(sheet.id);
      }
    } else {
      this.grid.DeleteSheet(index);
    }
    this.calculator.Reset();
  }
  /** 
   * Show or hide sheet. This is a replacement for the `ShowSheet` method, 
   * because that name is somewhat ambiguous.
   * 
   * @param index - sheet name or index.
   * 
   * @public
   */
  HideSheet(index = 0, hide = true) {
    this.grid.ShowSheet(index, !hide);
  }
  /**
   * Show or hide sheet. This method is deprecated because it's ambiguous.
   * To set a sheet's visibility, use `HideSheet`. To activate a sheet, use
   * `ActivateSheet`.
   * 
   * @param index - sheet name or index.
   * 
   * @see HideSheet
   * @deprecated Use `HideSheet` instead.
   */
  ShowSheet(index = 0, show = true) {
    this.grid.ShowSheet(index, show);
  }
  /**
   * Activate sheet.
   * 
   * @param index - sheet name or index.
   * 
   * @public
   */
  ActivateSheet(index) {
    this.grid.ActivateSheet(index);
  }
  /**
   * Set width of column(s).
   * 
   * @param column - column, or columns (array), or undefined means all columns
   * @param width - desired width (can be 0) or undefined means 'auto-size'
   * 
   * @privateRemarks
   * 
   * TODO: this method assumes the current sheet. we need a method that can
   * (optionally) specify a sheet.
   * 
   * @public
   */
  SetColumnWidth(column, width) {
    this.grid.SetColumnWidth(column, width);
  }
  /**
   * Set height of row(s).
   * 
   * @param row - row, or rows (array), or undefined means all rows
   * @param height - desired height (can be 0) or undefined means 'auto-size'
   * 
   * @privateRemarks
   * 
   * TODO: this method assumes the current sheet. we need a method that can
   * (optionally) specify a sheet.
   * 
   * @public
   */
  SetRowHeight(row, height) {
    this.grid.SetRowHeight(row, height);
  }
  /**
   * Insert row(s).
   * 
   * @param before_row - leave undefined to use current selection.
   * 
   * @public
   */
  InsertRows(before_row, count = 1) {
    if (typeof before_row === "undefined") {
      const selection = this.grid.GetSelection();
      if (selection.empty) {
        return;
      }
      const area = selection.area;
      before_row = area.entire_column ? 0 : area.start.row;
    }
    this.grid.InsertRows(before_row, count);
  }
  /**
   * Insert column(s).
   * 
   * @param before_column - leave undefined to use current selection.
   * 
   * @public
   */
  InsertColumns(before_column, count = 1) {
    if (typeof before_column === "undefined") {
      const selection = this.grid.GetSelection();
      if (selection.empty) {
        return;
      }
      const area = selection.area;
      before_column = area.entire_row ? 0 : area.start.column;
    }
    this.grid.InsertColumns(before_column, count);
  }
  /**
   * Delete row(s).
   * 
   * @param start_row - leave undefined to use current selection. in this
   * case the `count` parameter will be ignored and all rows in the selection
   * will be deleted.
   */
  DeleteRows(start_row, count = 1) {
    if (typeof start_row === "undefined") {
      const selection = this.grid.GetSelection();
      if (selection.empty) {
        return;
      }
      const area = selection.area;
      start_row = area.entire_column ? 0 : area.start.row;
      count = area.rows;
    }
    this.grid.InsertRows(start_row, -count);
  }
  /**
   * Delete columns(s).
   * 
   * @param start_column - leave undefined to use current selection. in this
   * case the `count` parameter will be ignored and all columns in the 
   * selection will be deleted.
   */
  DeleteColumns(start_column, count = 1) {
    if (typeof start_column === "undefined") {
      const selection = this.grid.GetSelection();
      if (selection.empty) {
        return;
      }
      const area = selection.area;
      start_column = area.entire_row ? 0 : area.start.column;
      count = area.columns;
    }
    this.grid.InsertColumns(start_column, -count);
  }
  /**
   * filter a table. the reference can be the table name, or a cell in the table.
   * if the reference is an area (range), we're going to look at the top-left 
   * cell.
   * 
   * this method uses a function to filter rows based on cell values. leave the
   * function undefined to show all rows. this is a shortcut for "unfilter".
   * 
   * @param column - the column to sort on. values from this column will be
   * passed to the filter function.
   * 
   * @param filter - a callback function to filter based on cell values. this
   * will be called with the cell value (formula), the calculated value (if any),
   * and the cell style. return false to hide the row, and true to show the row.
   * if the filter parameter is omitted, all values will be shown.
   * 
   */
  FilterTable(reference, column = 0, filter) {
    const table = this.ResolveTable(reference);
    if (!table) {
      throw new Error("invalid table reference");
    }
    if (filter) {
      this.grid.FilterTable(table, column, (cell) => {
        return filter.call(0, cell.value, cell.calculated || void 0, JSON.parse(JSON.stringify(cell.style || {})));
      });
    } else {
      this.grid.FilterTable(table, 0, () => true);
    }
  }
  /**
   * sort a table. the reference can be the table name, or a cell in the table.
   * if the reference is an area (range), we're going to look at the top-left 
   * cell.
   */
  SortTable(reference, options = {}) {
    const table = this.ResolveTable(reference);
    if (!table) {
      throw new Error("invalid table reference");
    }
    this.grid.SortTable(table, options);
  }
  /**
   * Merge cells in range.
   * 
   * @param range - target range. leave undefined to use current selection.
   * 
   * @public
   */
  MergeCells(range) {
    this.grid.MergeCells(range ? this.model.ResolveArea(range, this.grid.active_sheet) : void 0);
  }
  /**
   * Unmerge cells in range.
   * 
   * @param range - target range. leave undefined to use current selection.
   * 
   * @public
   */
  UnmergeCells(range) {
    this.grid.UnmergeCells(range ? this.model.ResolveArea(range, this.grid.active_sheet) : void 0);
  }
  /** 
   * Export XLSX as a blob. This is intended for electron clients, who may
   * implement their own file save routines (because they have access to the
   * filesystem).
   * 
   * @internal
   */
  async ExportBlob() {
    if (false) {
      console.warn("this build does not include xlsx support.");
      throw new Error("this build does not include xlsx support.");
    }
    if (!this.export_worker) {
      this.export_worker = await this.LoadWorker("export");
    }
    return new Promise((resolve, reject) => {
      if (this.export_worker) {
        this.export_worker.onmessage = (event) => {
          resolve(event.data ? event.data.blob : void 0);
        };
        this.export_worker.onerror = (event) => {
          console.error("export worker error");
          console.info(event);
          reject(event);
        };
        const serialized = this.grid.Serialize({
          rendered_values: true,
          expand_arrays: true,
          export_colors: true,
          decorated_cells: true,
          tables: true,
          share_resources: false
        });
        serialized.decimal_mark = Localization.decimal_separator;
        this.export_worker.postMessage({
          command: "export",
          sheet: serialized,
          decorated: this.calculator.DecoratedFunctionList()
        });
      } else {
        reject("worker failed");
      }
    });
  }
  /**
   * revert to the network version of this document, if `local_storage` 
   * is set and the create options had either `document` or `inline-document`
   * set.
   * 
   * FIXME: we should adjust for documents that fail to load.
   */
  Revert() {
    if (this.options.inline_document) {
      this.LoadDocument(this.options.inline_document);
      this.initial_load_source = "inline-document" /* INLINE_DOCUMENT */;
      if (this.options.local_storage) {
        this.SaveLocalStorage("reverted_backup");
        localStorage.removeItem(this.options.local_storage);
      }
      return;
    }
    const canonical = this.options.document;
    if (canonical) {
      this.LoadNetworkDocument(canonical);
      this.initial_load_source = "network-file" /* NETWORK_FILE */;
      if (this.options.local_storage) {
        this.SaveLocalStorage("reverted_backup");
        localStorage.removeItem(this.options.local_storage);
      }
      return;
    }
    console.warn("to revert, there must be a document set in options");
    this.dialog?.ShowDialog({
      title: `Can't revert -- no document is set in options`,
      close_box: true,
      timeout: 3e3,
      type: "error" /* error */
    });
  }
  /**
   * Export to XLSX file. 
   * 
   * @remarks 
   * 
   * this requires a bunch of processing -- one, we do this in a worker, and 
   * two, it's demand loaded so we don't bloat up this embed script.
   */
  Export() {
    if (false) {
      console.warn("this build does not include xlsx support.");
      return;
    }
    this.ExportBlob().then((blob) => {
      let filename = "export";
      if (this.grid.model.document_name) {
        filename = this.grid.model.document_name.toLowerCase().replace(/\s+/g, "-");
      }
      if (blob) {
        this.SaveAs(blob, filename + ".xlsx");
        this.last_save_version = this.file_version;
      }
    }).catch((err) => {
      if (/invalid uri/i.test(err.message)) {
        this.dialog?.ShowDialog({
          title: "Error exporting file",
          close_box: true,
          message: "The worker cannot run from the filesystem, please use a web server.",
          timeout: 3e3,
          type: "error" /* error */
        });
      }
      throw err;
    });
  }
  /** 
   * Return "live" reference to selection.
   * 
   * @internal
   */
  GetSelectionReference() {
    return this.grid.GetSelection();
  }
  /**
   * Focus the grid.
   * 
   * @public
   */
  Focus() {
    this.grid.Focus();
  }
  /**
   * Update layout and repaint if necessary.
   * 
   * @remarks 
   * 
   * This method should be called when the container is resized, to 
   * trigger an update to layout. It should be called automatically 
   * by a resize observer set in the containing tag class, but you 
   * can call it manually if necessary.
   * 
   * @public
   */
  Resize() {
    this.grid.UpdateLayout();
    for (const entry of this.views) {
      entry.view.grid.UpdateLayout();
    }
    this.Publish({ type: "resize" });
  }
  /** 
   * Clear/reset sheet. This will reset the undo stack as well, 
   * so it cannot be undone.
   * 
   * @public
   */
  Reset() {
    if (this.parent_view) {
      return this.parent_view.Reset();
    }
    this.grid.Reset();
    this.ResetInternal();
    this.calculator.AttachModel();
    this.UpdateAC();
    this.Publish({ type: "reset" });
  }
  /** 
   * load a document from from local storage, using the given key.
   * this method will also set the local option for the storage key, so the 
   * document will potentially be saved on modification.
   */
  LoadFromLocalStorage(key) {
    this.options.local_storage = key;
    const json = localStorage.getItem(key);
    if (json) {
      try {
        const data = JSON.parse(json);
        this.LoadDocument(data, { source: "local-storage" /* LOCAL_STORAGE */ });
        return true;
      } catch (err) {
        console.error(err);
      }
    }
    return false;
  }
  /**
   * load a network document by URI. CORS headers must be set appropriately
   * on documents originating from different hosts.
   */
  async LoadNetworkDocument(uri, options) {
    const scroll = options ? options.scroll : void 0;
    const recalculate = options ? !!options.recalculate : false;
    const override_sheet = options ? options.sheet : void 0;
    const csv = /csv(?:$|\?|&)/i.test(uri);
    const tsv = /tsv(?:$|\?|&)/i.test(uri);
    try {
      this.spinner?.Show();
      const response = await fetch(uri);
      this.spinner?.Hide();
      if (!response.ok) {
        throw new Error("network error");
      }
      let text = await response.text();
      if (typeof text === "string") {
        if (csv) {
          this.LoadCSV(text, "network-file" /* NETWORK_FILE */);
        } else if (tsv) {
          throw new Error("tsv not supported (TODO)");
        } else {
          if (text.substr(0, 11) === "&&&START&&&") {
            text = text.substr(11);
          } else if (text.substr(0, 8) === "for(;;);") {
            text = text.substr(8);
          }
          const json = JSON.parse(text);
          this.LoadDocument(json, { scroll, recalculate, override_sheet, source: "network-file" /* NETWORK_FILE */ });
        }
      }
    } catch (err) {
      console.info("error loading network document", uri);
      console.error(err);
      this.dialog?.ShowDialog({
        title: "Error loading file",
        close_box: true,
        message: "The network document returned an error",
        type: "error" /* error */,
        timeout: 3e3
      });
      this.Reset();
    }
  }
  /** 
   * Load a desktop file. This method will show a file chooser and open 
   * the selected file (if any). 
   * 
   * @public
   */
  async LoadLocalFile() {
    this.SelectFile2(
      ".treb, .csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/json",
      1 /* LoadFile */
    );
  }
  /**
   * Export sheet as CSV/TSV. This is an internal method called by the save 
   * document methods, but you can call it directly if you want the text as 
   * a string.
   * 
   * @returns string
   * 
   * @public
   */
  ExportDelimited(options = {}) {
    options = { delimiter: ",", ...options };
    if (!options.delimiter || options.delimiter !== "," && options.delimiter !== "	") {
      throw new Error("invalid delimiter");
    }
    let sheet = this.grid.active_sheet;
    switch (typeof options.sheet) {
      case "undefined":
        break;
      case "string":
        sheet = this.model.sheets.Find(options.sheet);
        break;
      case "number":
        sheet = this.grid.model.sheets.list[options.sheet];
        break;
      default:
        sheet = void 0;
        break;
    }
    if (!sheet) {
      throw new Error("invalid sheet identifier");
    }
    const serialized_data = sheet.cells.toJSON({
      nested: false,
      expand_arrays: true,
      calculated_value: true
    });
    const columns = [];
    for (let i = 0; i < serialized_data.columns; i++) {
      columns.push("");
    }
    const rows = [];
    for (let i = 0; i < serialized_data.rows; i++) {
      rows.push(columns.slice(0));
    }
    const delim_regex = new RegExp(`[	
\r"${options.delimiter}]`);
    if (IsFlatDataArray(serialized_data.data)) {
      for (const element of serialized_data.data) {
        let value = "";
        if (!options.formulas && typeof element.calculated !== "undefined") {
          value = IsComplex(element.calculated) ? ComplexToString(element.calculated) : element.calculated.toString();
        } else if (typeof element.value === "string" && element.value[0] === "'") {
          value = element.value.substr(1);
        } else if (typeof element.value !== "undefined") {
          value = IsComplex(element.value) ? ComplexToString(element.value) : element.value.toString();
        }
        if (delim_regex.test(value)) {
          value = value.replace(/"/g, '""');
          value = '"' + value + '"';
        }
        rows[element.row][element.column] = value;
      }
    }
    return rows.map((row) => row.join(options.delimiter)).join("\r\n");
  }
  /**
   * @deprecated - use SaveToDesktop
   * 
   * @param filename 
   * @param additional_options 
   */
  SaveLocalFile(filename = "treb.json" /* trebjson */, additional_options = {}) {
    this.SaveToDesktop(filename, additional_options);
  }
  /** 
   * Save the current document to a desktop file. This is the new version
   * of the method, renamed from SaveLocalFile.
   * 
   * @param filename Filename or extension to use the document name.
   */
  SaveToDesktop(filename = "treb.json" /* trebjson */, additional_options = {}) {
    const document_name = this.grid.model.document_name || "document";
    let data;
    let text;
    const parts = filename.split(/\./).filter((test) => test.trim().length);
    let type = parts.length ? parts[parts.length - 1].toLowerCase() : "treb" /* treb */;
    if (parts.length <= 1 || filename === "treb.json") {
      if (filename === "treb.json") {
        type = filename;
      }
      if ((type === "csv" /* csv */ || type === "tsv" /* tsv */) && this.grid.model.sheets.length > 1) {
        const active_sheet = this.grid.active_sheet.name;
        filename = (document_name + "-" + active_sheet).toLowerCase().replace(/\W+/g, "-") + "." + type;
      } else {
        filename = document_name.toLowerCase().replace(/\W+/g, "-") + "." + type;
      }
    }
    switch (type) {
      case "csv" /* csv */:
        text = this.ExportDelimited({ delimiter: "," });
        break;
      case "tsv" /* tsv */:
        text = this.ExportDelimited({ delimiter: "	" });
        break;
      case "treb" /* treb */:
      case "json" /* json */:
      case "treb.json" /* trebjson */:
        data = this.SerializeDocument({
          ...additional_options
        });
        text = JSON.stringify(data, void 0, additional_options.pretty ? 2 : void 0);
        this.last_save_version = this.file_version;
        break;
      default:
        throw new Error("invalid file type");
    }
    if (text && filename) {
      const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
      this.SaveAs(blob, filename);
    }
  }
  /** 
   * Load CSV from string. This is used internally when loading network 
   * documents and local files, but you can call it directly if you have 
   * a CSV file as text.
   * 
   * @public
   */
  LoadCSV(csv, source) {
    if (this.parent_view) {
      return this.parent_view.LoadCSV(csv, source);
    }
    this.grid.FromCSV(csv);
    this.ResetInternal();
    this.grid.Update(true);
    this.Publish({ type: "load", source });
    this.UpdateDocumentStyles();
  }
  /** 
   * get or set the current scroll offset. scroll offset is automatically 
   * saved if you save the document or switch tabs; this is for saving/
   * restoring scroll if you cache the containing element.
   */
  ScrollOffset(offset) {
    return this.grid.ScrollOffset(offset);
  }
  /**
   * unserialize document from data.
   *
   * @privateRemarks
   * 
   * UPDATE: will no longer recalculate on load if the "rendered_values"
   * flag is set in the document (assuming it's correct), because we can
   * display those values.
   * 
   * UPDATE: default scroll to A1 in open sheet
   * 
   */
  LoadDocument(data, options = {}) {
    if (this.parent_view) {
      return this.parent_view.LoadDocument(data, options);
    }
    if (!this.initial_load_source) {
      this.initial_load_source = options.source;
    }
    options = {
      // scroll: {row: 0, column: 0},
      flush: true,
      recalculate: false,
      ...options
    };
    if (options.override_selection) {
      if (data.sheet_data) {
        const sheets = Array.isArray(data.sheet_data) ? data.sheet_data : [data.sheet_data];
        for (const sheet of sheets) {
          if (sheet.id === options.override_selection.target.sheet_id) {
            sheet.selection = options.override_selection;
            break;
          }
        }
      }
    }
    this.ImportDocumentData(data, options.override_sheet);
    this.calculator.Reset();
    if (data.rendered_values && !options.recalculate) {
      this.calculator.RebuildClean(true);
      this.ApplyConditionalFormats(this.grid.active_sheet, false);
      this.grid.Update();
    } else {
      this.Recalculate();
    }
    this.InflateAnnotations();
    if (options.flush) {
      this.FlushUndo();
    }
    this.Publish({ type: "load", source: options.source });
    this.UpdateDocumentStyles();
    this.loaded = true;
    if (options.scroll) {
      const scroll = options.scroll;
      Promise.resolve().then(() => this.ScrollTo(scroll));
    }
  }
  /**
   * Set note (comment) in cell.
   * 
   * @param address target address, or leave undefined to use current selection.
   * @param note note text, or leave undefined to clear existing note.
   */
  SetNote(address, note) {
    if (typeof address === "string") {
      const reference = this.model.ResolveAddress(address, this.grid.active_sheet);
      address = IsCellAddress(reference) ? reference : reference.start;
    }
    this.grid.SetNote(address, note);
  }
  /**
   * set or clear cell valiation.
   * 
   * @param address - target cell
   * @param validation - a spreadsheet range, list of data, or undefined. pass
   * undefined to remove existing cell validation. 
   * @param error - setting an invalid value in the target cell is an error (and
   * is blocked). defaults to false.
   */
  SetValidation(address, validation, error) {
    if (typeof address === "string") {
      const reference = this.model.ResolveAddress(address, this.grid.active_sheet);
      address = IsCellAddress(reference) ? reference : reference.start;
    }
    if (typeof validation === "undefined" || Array.isArray(validation)) {
      this.grid.SetValidation(address, validation, error);
    } else {
      const range = this.model.ResolveArea(validation, this.grid.active_sheet);
      this.grid.SetValidation(address, range, error);
    }
  }
  /*
    public RemoveValidation(address: AddressReference) {
  
      if (typeof address === 'string') {
        const reference = this.model.ResolveAddress(address);
        address = IsCellAddress(reference) ? reference : reference.start;
      }
  
      this.grid.SetValidation(address, undefined);
  
    }
  
    public SetValidationList(address: AddressReference, list: CellValue[]) {
  
      if (typeof address === 'string') {
        const reference = this.model.ResolveAddress(address);
        address = IsCellAddress(reference) ? reference : reference.start;
      }
  
      this.grid.SetValidation(address, list);
  
    }
  
    public SetValidationRange(address: AddressReference, range: RangeReference) {
  
      if (typeof address === 'string') {
        const reference = this.model.ResolveAddress(address);
        address = IsCellAddress(reference) ? reference : reference.start;
      }
  
      range = this.model.ResolveArea(range);
      this.grid.SetValidation(address, range);
  
    }
    */
  /** 
   * Delete a macro function.
   * 
   * @public
   */
  RemoveFunction(name) {
    const uppercase = name.toUpperCase();
    this.model.macro_functions.delete(uppercase);
    this.UpdateAC();
  }
  /**
   * Create a macro function.
   * 
   * @public
   */
  DefineFunction(name, argument_names = "", function_def = "0") {
    if (!name.length || /^[^A-Za-z]/.test(name) || /[^\w_.]/.test(name)) {
      throw new Error("invalid function name");
    }
    if (typeof argument_names === "string") {
      argument_names = argument_names ? argument_names.split(this.parser.argument_separator).map((arg) => arg.trim()) : [];
    }
    for (const name2 of argument_names) {
      if (!name2.length || /^[^A-Za-z]/.test(name2) || /[^\w_.]/.test(name2)) {
        throw new Error("invalid argument name");
      }
    }
    this.RemoveFunction(name);
    this.grid.model.macro_functions.set(name.toUpperCase(), {
      name,
      function_def,
      argument_names,
      expression: this.parser.Parse(function_def).expression
    });
    this.UpdateAC();
  }
  /**
   * Serialize document to a plain javascript object. The result is suitable
   * for converting to JSON. This method is used by the SaveLocalFile and 
   * SaveLocalStorage methods, but you can call it directly if you want to 
   * save the document some other way.
   * 
   * @privateRemarks
   * 
   * serialize document; optionally include any MC data
   * optionally preserve rendered values
   * UPDATE: default rendered values -> true
   * 
   * @public
   */
  SerializeDocument(options = {}) {
    options = {
      share_resources: true,
      shrink: true,
      ...options
    };
    const grid_data = this.grid.Serialize(options);
    const serialized = {
      app: "@trebco/treb",
      version: "28.10.4",
      revision: this.file_version,
      name: this.grid.model.document_name,
      // may be undefined
      user_data: this.grid.model.user_data,
      // may be undefined
      decimal_mark: Localization.decimal_separator,
      ...grid_data
    };
    if (options.share_resources) {
      let shared_id = 1;
      const resources = /* @__PURE__ */ new Map();
      const sheets = Array.isArray(serialized.sheet_data) ? serialized.sheet_data : [serialized.sheet_data];
      const Store = (source) => {
        let id = resources.get(source);
        if (!id) {
          id = (shared_id++).toString();
          resources.set(source, id);
        }
        return `resource:${id}`;
      };
      for (const sheet of sheets) {
        if (!sheet) {
          continue;
        }
        if (sheet.background_image) {
          sheet.background_image = Store(sheet.background_image);
        }
        for (const annotation of sheet.annotations || []) {
          if (annotation.type === "image" && annotation.data?.src) {
            annotation.data.src = Store(annotation.data.src);
          }
        }
      }
      const shared = {};
      for (const [resource, key] of resources.entries()) {
        shared[key] = resource;
      }
      serialized.shared_resources = shared;
    }
    if (options.rendered_values) {
      serialized.rendered_values = true;
    }
    return serialized;
  }
  /** 
   * Recalculate sheet.
   * 
   * @privateRemarks
   * 
   * the event parameter should not be used if this is called
   * as an API function, remove it from typings
   * 
   * @public
   */
  async Recalculate(event) {
    let area;
    if (event && event.type === "data" && event.area) {
      area = event.area;
    }
    this.calculator.Calculate(area);
    this.ApplyConditionalFormats(this.grid.active_sheet, false);
    this.grid.Update(true);
    this.UpdateAnnotations();
    this.Publish({ type: "data" });
    this.grid.UpdateStats();
  }
  /**
   * Save document to local storage. 
   * 
   * @param key optional storage key. if omitted, the method will use
   * the key from local options (set at create time).
   */
  SaveLocalStorage(key = this.options.local_storage) {
    if (!key) {
      console.warn("not saving, no key");
      return;
    }
    const json = JSON.stringify(this.SerializeDocument({
      rendered_values: true,
      expand_arrays: true
    }));
    localStorage.setItem(key, json);
  }
  /**
   * Revert state one level from the undo stack.
   * 
   * @public
   */
  Undo() {
    if (this.parent_view) {
      return this.parent_view.Undo();
    }
    if (this.undo_pointer <= 1) {
      console.warn("nothing to undo");
      return;
    }
    const undo_entry = this.undo_stack[--this.undo_pointer - 1];
    const selection = undo_entry.selection ? JSON.parse(undo_entry.selection) : void 0;
    this.LoadDocument(JSON.parse(undo_entry.data), {
      flush: false,
      override_selection: selection,
      source: "undo" /* UNDO */
    });
  }
  /** 
   * Show the about dialog.
   * 
   * @public
   */
  About() {
    this.dialog?.ShowDialog({
      type: "about" /* about */
    });
  }
  /**
   * scroll the given address into view. it could be at either side
   * of the window. optionally use smooth scrolling.
   */
  ScrollIntoView(address, smooth = false) {
    if (typeof address === "string") {
      const reference = this.model.ResolveAddress(address, this.grid.active_sheet);
      address = IsCellAddress(reference) ? reference : reference.start;
    }
    this.grid.ScrollIntoView(address, smooth);
  }
  /** 
   * Scroll to the given address. In the current implementation this method
   * will not change sheets, although it probably should if the reference
   * is to a different sheet.
   * 
   * @public
   */
  ScrollTo(address, options = {}) {
    if (typeof address === "string") {
      const reference = this.model.ResolveAddress(address, this.grid.active_sheet);
      address = IsCellAddress(reference) ? reference : reference.start;
    }
    options = {
      x: true,
      y: true,
      smooth: false,
      ...options
    };
    this.grid.ScrollTo(address, options.x, options.y, options.smooth);
  }
  /** 
   * Resolve a string address/range to an address or area (range) object. 
   * 
   * @param reference A string like "A1" or "Sheet1!B2:C3". If a sheet name 
   * is not included, the current active sheet is used. You can also pass a 
   * named range as reference.
   * 
   * @public
   */
  Resolve(reference) {
    const result = this.model.ResolveAddress(reference, this.grid.active_sheet);
    if (IsCellAddress(result)) {
      return result.sheet_id ? result : void 0;
    }
    return result.start.sheet_id ? result : void 0;
  }
  /**
   * Convert an address/range object to a string. this is a convenience
   * function for composing formulas.
   * 
   * @param ref sheet reference as a string or structured object
   * @param [qualified=true] include sheet names
   * @param [named=true] resolve to named ranges, where applicable
   */
  Unresolve(ref, qualified = true, named = true) {
    if (typeof ref === "string") {
      const resolved = this.Resolve(ref);
      if (!resolved) {
        throw new Error("invalid reference");
      }
      ref = resolved;
    }
    return this.calculator.Unresolve(ref, this.grid.active_sheet, qualified, named);
  }
  /**
   * Evaluate an arbitrary expression in the spreadsheet. You should generally
   * use sheet names when referring to cells, to avoid ambiguity. Otherwise
   * cell references will resolve to the active sheet.
   * 
   * @param expression - an expression in spreadsheet language
   * @param options - options for parsing the passed function
   * 
   * @public
   */
  Evaluate(expression, options = {}) {
    return this.calculator.Evaluate(
      expression,
      this.grid.active_sheet,
      options
    );
  }
  /**
   * Returns the current selection, as a string address or range. 
   * 
   * @param qualified include sheet name in result. default true.
   * 
   * @returns selection as a string, or empty string if there's no selection.
   * 
   * @public
   */
  GetSelection(qualified = true) {
    const ref = this.grid.GetSelection();
    if (ref.empty) {
      return "";
    }
    let range = "";
    if (ref.area.count > 1) {
      range = Area.CellAddressToLabel(ref.area.start) + ":" + Area.CellAddressToLabel(ref.area.end);
    } else {
      range = Area.CellAddressToLabel(ref.area.start);
    }
    if (!qualified) {
      return range;
    }
    const sheet_id = ref.area.start.sheet_id || this.grid.active_sheet.id;
    const sheet_name = this.calculator.ResolveSheetName(sheet_id, true);
    return sheet_name ? sheet_name + "!" + range : range;
  }
  /**
   * Parse a string and return a number (if possible).
   * 
   * @privateRemarks
   *
   * We're using ValueParser, which the one used when you type into a grid
   * (not the Parser parser). It's intended to handle things that would look
   * wrong in functions, like currency symbols.
   * 
   * @public
   */
  ParseNumber(text) {
    return ValueParser.TryParse(text).value;
  }
  /**
   * Format a number with an arbitrary formatter.
   *
   * @privateRemarks
   * 
   * FIXME: should this support complex numbers? not sure...
   * 
   * @public
   */
  FormatNumber(value, format = "General") {
    return NumberFormatCache.Get(format).Format(value);
  }
  /**
   * convert a javascript date (or timestamp) to a spreadsheet date
   */
  SpreadsheetDate(javascript_date) {
    if (javascript_date instanceof Date) {
      javascript_date = javascript_date.getTime();
    }
    return UnlotusDate(javascript_date, true);
  }
  /**
   * convert a spreadsheet date to a javascript date
   */
  JavascriptDate(spreadsheet_date) {
    return LotusDate(spreadsheet_date).getTime();
  }
  /**
   * Apply borders to range. 
   * 
   * @param range pass `undefined` as range to apply to current selection.
   * 
   * @remarks 
   * 
   * Borders are part of style, but setting/removing borders is more 
   * complicated than setting other style properties. usually you want
   * things to apply to ranges, rather than individual cells. removing
   * borders needs to consider neighbor borders. and so on.
   * 
   * @public
   */
  ApplyBorders(range, borders, width = 1) {
    this.grid.ApplyBorders2(range ? this.model.ResolveArea(range, this.grid.active_sheet) : void 0, borders, {}, width);
  }
  /**
   * Apply style to range. 
   * 
   * @param range pass `undefined` as range to apply to current selection.
   * @param delta apply over existing properties. default true.
   * 
   * @remarks
   * 
   * Don't use this method to set borders, use `ApplyBorders`.
   * 
   * @public
   */
  ApplyStyle(range, style = {}, delta = true) {
    this.grid.ApplyStyle(
      range ? this.model.ResolveArea(range, this.grid.active_sheet) : void 0,
      style,
      delta
    );
  }
  /**
   * Remove a named range (removes the name, not the range).
   * 
   * @public
   */
  ClearName(name) {
    this.grid.SetName(name);
  }
  /**
   * Create a named range or named expression. A named range refers to an
   * address or range. A named expression can be a value or formula, basically
   * anything you would type into a cell. 
   * 
   * @param value range, value or expression
   * 
   * @remarks 
   * 
   * This function used to support passing `undefined` as the value,
   * which meant "create a named range using current selection". We don't
   * support that any more but you can accompilsh that with 
   * `sheet.DefineName("Name", sheet.GetSelection())`.
   * 
   * @public
   */
  DefineName(name, value) {
    if (typeof value === "undefined" || value === null) {
      throw new Error("invalid value (null or undefined)");
    }
    if (typeof value === "object") {
      if (IsCellAddress(value) || IsArea(value)) {
        this.grid.SetName(name, this.model.ResolveArea(value, this.grid.active_sheet));
        return;
      }
    }
    if (typeof value === "string") {
      const parse_result = this.parser.Parse(value);
      if (!parse_result.expression) {
        throw new Error("invalid expression");
      }
      switch (parse_result.expression.type) {
        case "address":
        case "range":
          this.grid.SetName(name, this.model.ResolveArea(parse_result.expression, this.grid.active_sheet));
          return;
      }
      this.grid.SetName(name, void 0, value);
    } else {
      this.grid.SetName(name, void 0, value.toString());
    }
  }
  /* *
   * define a named expression
   * 
   * @internal
   * /
  public DefineNamedExpression(name: string, expression: string): void {
    this.grid.SetName(name, undefined, expression);
  }
  */
  /**
   * Set or remove a link in a cell. 
   * 
   * @param target http/https URL or a spreadsheet reference (as text). set blank to remove link.
   * 
   * @public
   */
  SetLink(address, target = "") {
    if (typeof address === "string") {
      const reference = this.model.ResolveAddress(address, this.grid.active_sheet);
      address = IsCellAddress(reference) ? reference : reference.start;
    }
    if (!address) {
      const selection = this.GetSelectionReference();
      if (selection.empty) {
        return;
      }
      address = selection.target;
    }
    this.grid.SetLink(address, target);
  }
  /**
   * Select a range. This function will change sheets if your reference
   * refers to a different sheet. if the argument is undefined or falsy
   * it will remove the selection (set to no selection).
   * 
   * @public
   */
  Select(range) {
    let resolved = void 0;
    if (!!range) {
      resolved = this.model.ResolveArea(range, this.grid.active_sheet);
      if (resolved.start.sheet_id) {
        if (resolved.start.sheet_id !== this.grid.active_sheet.id) {
          this.grid.ActivateSheetID(resolved.start.sheet_id);
        }
      }
    }
    this.grid.SelectRange(resolved);
  }
  /** 
   * 
   * @param range target range. leave undefined to use current selection.
   * 
   * @public
   */
  GetRange(range, options = {}) {
    if (!range) {
      const selection = this.GetSelectionReference();
      if (!selection.empty) {
        range = selection.area;
      }
    }
    if (!range) {
      return void 0;
    }
    if (!options.type) {
      if (options.formatted) {
        options.type = "formatted";
      }
      if (options.formula) {
        options.type = "formula";
      }
    }
    return this.grid.GetRange(this.model.ResolveAddress(range, this.grid.active_sheet), options.type);
  }
  /**
   * returns the style from the target address or range. 
   * 
   * @privateRemarks
   * optimally this could be consolidated with the `GetRange` function, but 
   * that requires some gymnastics to manage the return type which I'm not 
   * willing (at the moment) to do.
   * 
   * @param range - target range. leave undefined to use current selection
   * @param apply_theme - include theme defaults when returning style
   * 
   */
  GetStyle(range, apply_theme = false) {
    if (!range) {
      const selection = this.GetSelectionReference();
      if (!selection.empty) {
        range = selection.area;
      }
    }
    if (!range) {
      return void 0;
    }
    return this.grid.GetRangeStyle(this.model.ResolveAddress(range, this.grid.active_sheet), apply_theme);
  }
  /*
    public OffsetFormula(formula: string, base: ICellAddress): string|undefined {
  
    }
    */
  /**
   * Set data in range.
   * 
   * @param range target range. leave undefined to use current selection.
   * 
   * @public
   */
  SetRange(range, data = void 0, options = {}) {
    if (!range) {
      const selection = this.GetSelectionReference();
      if (!selection.empty) {
        range = selection.area;
      }
    }
    if (range) {
      const area = this.model.ResolveArea(range, this.grid.active_sheet);
      if (options.spill && Array.isArray(data)) {
        const rows = data.length;
        const columns = Math.max(0, ...data.map((row) => row.length));
        const target = {
          row: area.start.row + rows + 1,
          column: area.start.column + columns + 1
        };
        area.ConsumeAddress(target);
      }
      return this.grid.SetRange(area, data, options);
    }
  }
  /**
   * Subscribe to spreadsheet events
   * @param subscriber - callback function
   * @returns a token used to cancel the subscription
   */
  Subscribe(subscriber) {
    return this.events.Subscribe(subscriber);
  }
  /**
   * Cancel subscription
   * @param token - the token returned from `Subscribe`
   */
  Cancel(token) {
    this.events.Cancel(token);
  }
  // --- internal (protected) methods ------------------------------------------
  /**
   * 
   */
  ApplyConditionalFormats(sheet, call_update) {
    const areas = [];
    if (sheet.conditional_formats.length || sheet.flush_conditional_formats) {
      for (const entry of sheet.conditional_formats) {
        areas.push(entry.area);
        if (entry.type === "gradient") {
          if (!entry.internal) {
            entry.internal = {};
          }
          if (!entry.internal.gradient) {
            entry.internal.gradient = new Gradient(entry.stops, this.grid.theme, entry.color_space);
          }
        }
      }
      sheet.ApplyConditionalFormats();
    }
    if (call_update) {
      this.grid.Update(true, areas);
    }
  }
  ResolveTable(reference) {
    let table = void 0;
    if (typeof reference === "string") {
      const lc = reference.toLowerCase();
      if (this.model.tables.has(lc)) {
        table = this.model.tables.get(lc);
      }
    }
    if (!table) {
      let address = this.model.ResolveAddress(reference, this.grid.active_sheet);
      if (!IsCellAddress(address)) {
        address = address.start;
      }
      table = this.grid.GetTableReference(address);
    }
    return table;
  }
  /**
   * replacement for (the great) FileSaver lib. we can now rely on all
   * browsers to handle this properly (fingers crossed).
   * 
   * @param blob 
   * @param filename 
   */
  SaveAs(blob, filename) {
    const a = this.DOM.Create("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    URL.revokeObjectURL(a.href);
  }
  Publish(event) {
    this.events.Publish(event);
  }
  /**
   *
   */
  async ImportXLSX(data, source) {
    if (false) {
      console.warn("this build does not include xlsx support.");
      return;
    }
    if (this.parent_view) {
      return this.parent_view.ImportXLSX(data, source);
    }
    if (!this.export_worker) {
      this.export_worker = await this.LoadWorker("export");
    }
    return new Promise((resolve, reject) => {
      if (this.export_worker) {
        this.dialog?.ShowDialog({
          message: "Importing XLSX..."
        });
        this.export_worker.onmessage = (event) => {
          if (event.data) {
            if (event.data.status === "error") {
              return reject(event.data.error || "unknown error");
            }
            this.grid.FromImportData(event.data.results);
            this.ResetInternal();
            this.grid.Update();
            this.UpdateAC();
            this.calculator.AttachModel();
            this.Publish({ type: "load", source });
            this.UpdateDocumentStyles();
            this.InflateAnnotations();
            this.calculator.UpdateConditionals();
            this.ApplyConditionalFormats(this.grid.active_sheet, false);
          } else {
            return reject("unknown error (missing data)");
          }
          this.dialog?.HideDialog();
          resolve();
        };
        this.export_worker.onerror = (event) => {
          console.error("import worker error");
          console.info(event);
          reject(event);
        };
        this.export_worker.postMessage({
          command: "import",
          data
        });
      } else {
        reject("worker failed");
      }
    });
  }
  /**
   * some local cleanup, gets called in various import/load/reset functions
   * this is shrinking to the point of being unecessary... although we are
   * possibly overloading it.
   */
  ResetInternal() {
    this.calculator.Reset();
    this.FlushUndo();
    this.file_version = this.last_save_version = 0;
  }
  HandleCellEvent(event) {
    const type = event.data?.type;
    if (type === "hyperlink") {
      const hyperlink_error = "hyperlink invalid target";
      const data = event.data.data || "";
      if (typeof data === "string") {
        if (/^https{0,1}:\/\//i.test(data)) {
          if (!this.options.hyperlinks) {
            console.warn("hyperlinks are disabled");
            return;
          }
          const a = this.DOM.Create("a");
          a.setAttribute("target", this.options.hyperlinks);
          a.setAttribute("href", data);
          a.setAttribute("noreferrer", "true");
          a.setAttribute("nofollow", "true");
          a.click();
          return;
        } else {
          const parse_result = this.parser.Parse(data);
          if (parse_result.expression) {
            if (parse_result.expression.type === "address") {
              if (parse_result.expression.sheet || parse_result.expression.sheet_id) {
                this.ActivateSheet(parse_result.expression.sheet || parse_result.expression.sheet_id);
              }
              this.Select(data);
              return;
            } else if (parse_result.expression.type === "range") {
              if (parse_result.expression.start.sheet || parse_result.expression.start.sheet_id) {
                this.ActivateSheet(parse_result.expression.start.sheet || parse_result.expression.start.sheet_id);
              }
              this.Select(data);
              return;
            }
          }
        }
        console.warn(hyperlink_error, 2);
        return;
      }
    }
  }
  OnSheetChange(event) {
    for (const annotation of event.activate.annotations) {
      this.InflateAnnotation(annotation);
      this.calculator.UpdateAnnotations(annotation, event.activate);
    }
    this.UpdateAnnotations();
    this.calculator.UpdateConditionals();
    this.ApplyConditionalFormats(event.activate, true);
  }
  HandleDrag(event) {
    if (event.dataTransfer && event.dataTransfer.types) {
      if (event.dataTransfer.types.some && event.dataTransfer.types.some((check) => check === "Files")) {
        event.preventDefault();
      } else {
        for (let i = 0; i < event.dataTransfer.types.length; i++) {
          if (event.dataTransfer.types[i] === "files") {
            event.preventDefault();
            return;
          }
        }
      }
    }
  }
  HandleDrop(event) {
    if (event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files.length) {
      event.preventDefault();
      const file = event.dataTransfer.files[0];
      if (/^image/.test(file.type)) {
        this.InsertImageInternal(file);
      } else {
        this.LoadFileInternal(file, "drag-and-drop" /* DRAG_AND_DROP */).catch(() => void 0);
      }
    }
  }
  /* *
   * replacement for fetch
   * FIXME: move to utils or other lib
   * FIXME: we don't need to do this for ES6, presumably...
   * can this move into the legacy/modern code? or is there a polyfill? (...)
   * /
  protected async Fetch(uri: string): Promise<string> {
    return new Promise<string>((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.onload = () => resolve(xhr.response);
      xhr.onerror = () => reject('load error');
      xhr.ontimeout = () => reject('timeout');
      xhr.open('GET', uri);
      xhr.send();
    });
  }
  */
  /**
   * I'm restructuring the select file routine to simplify, in service
   * of figuring out what's going wrong in OSX/Chrome. the current routine
   * is unecssarily complicated.
   * 
   * the original concern was that you don't receive a "cancel" event from
   * the file chooser dialog; but that is only relevant if you have ephemeral
   * dialogs. if you have a constant dialog (html input element) you don't need
   * to do this asynchronously because the dialog blocks.
   * 
   * the downside is that you can't get a return value from 'LoadFile' or 
   * 'InsertImage'. not sure how much of a problem that is. need to check
   * what RAW does.
   * 
   * 
   * @param accept 
   */
  SelectFile2(accept, operation) {
    if (!this.file_chooser) {
      const file_chooser = this.DOM.Create("input", void 0, void 0, {
        attrs: { type: "file" },
        events: {
          change: () => {
            if (file_chooser.files && file_chooser.files[0]) {
              const file = file_chooser.files[0];
              file_chooser.value = "";
              switch (this.file_chooser_operation) {
                case 2 /* InsertImage */:
                  this.InsertImageInternal(file);
                  break;
                case 1 /* LoadFile */:
                  this.LoadFileInternal(file, "local-file" /* LOCAL_FILE */, true);
                  break;
                default:
                  console.warn("file chooser: no operation");
                  break;
              }
            }
          }
        }
      });
      this.file_chooser = file_chooser;
    }
    if (!this.file_chooser) {
      throw new Error("could not create file chooser");
    }
    this.file_chooser_operation = operation;
    this.file_chooser.accept = accept || "";
    this.file_chooser.click();
  }
  /**
   * Insert an image. This method will open a file chooser and (if an image
   * is selected) insert the image into the document.
   * 
   * @privateRemarks
   * 
   * Should we have a separate method that takes either an Image (node) or 
   * a data URI? 
   */
  async InsertImageInternal(file) {
    if (this.options.max_file_size && file.size > this.options.max_file_size) {
      this.dialog?.ShowDialog({
        type: "error" /* error */,
        message: "This file exceeds the allowed image size. Please try a smaller image.",
        title: "Error adding image",
        timeout: 3e3,
        close_box: true
      });
      return;
    }
    const reference = file;
    await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = async () => {
        try {
          if (reader.result) {
            let contents;
            if (typeof reader.result === "string") {
              contents = reader.result;
            } else {
              contents = "";
              const bytes = new Uint8Array(reader.result);
              for (let i = 0; i < bytes.byteLength; i++) {
                contents += String.fromCharCode(bytes[i]);
              }
            }
            const img = this.DOM.Create("img");
            img.src = contents;
            await Promise.resolve();
            const annotation = this.grid.CreateAnnotation({
              type: "image",
              formula: "",
              data: {
                scale: "",
                src: contents,
                original_size: { width: img.width || 300, height: img.height || 300 }
              }
            }, void 0, void 0, {
              top: 30,
              left: 30,
              width: img.width || 300,
              height: img.height || 300
            });
          }
          resolve();
        } catch (err) {
          reject(err);
        }
      };
      reader.onabort = () => {
        reject("Aborted");
      };
      reader.onerror = () => {
        reject("File error");
      };
      setTimeout(() => {
        reader.readAsDataURL(reference);
      }, 100);
    });
  }
  /** called when we have a file to write to */
  LoadFileInternal(file, source, dialog = true) {
    if (!file) {
      return Promise.resolve();
    }
    const reader = new FileReader();
    return new Promise((resolve, reject) => {
      const finalize = (err) => {
        reader.onload = null;
        reader.onabort = null;
        reader.onerror = null;
        if (err) {
          if (dialog) {
            this.dialog?.ShowDialog({
              title: "Error reading file",
              close_box: true,
              message: true ? "Please make sure your file is a valid XLSX, CSV or TREB file." : "Please make sure your file is a valid CSV or TREB file.",
              type: "error" /* error */,
              timeout: 3e3
            });
            console.error(err);
          }
          reject(err);
        } else
          resolve();
      };
      reader.onload = () => {
        try {
          if (reader.result) {
            if (/\.csv$/i.test(file.name)) {
              this.LoadCSV(reader.result, source);
            } else if (/\.xls[xm]$/i.test(file.name)) {
              if (typeof reader.result === "string") {
                finalize("Unsupported file");
              } else {
                this.ImportXLSX(reader.result, source).then(() => finalize()).catch((err) => finalize(err));
              }
              return;
            } else {
              const data = JSON.parse(reader.result);
              this.LoadDocument(data, { source });
            }
          }
          finalize();
        } catch (err) {
          finalize(err?.toString());
        }
      };
      reader.onabort = () => {
        finalize("Aborted");
      };
      reader.onerror = () => {
        finalize("File error");
      };
      setTimeout(() => {
        if (/\.xls[xm]$/i.test(file.name)) {
          reader.readAsArrayBuffer(file);
        } else {
          reader.readAsText(file);
        }
      }, 100);
    });
  }
  /** testing
   *
   * this is called after recalc, check any annotations
   * (just sparklines atm) and update if necessary.
   */
  UpdateAnnotations() {
    for (const annotation of this.grid.active_sheet.annotations) {
      if (annotation.temp.vertex) {
        const vertex = annotation.temp.vertex;
        if (vertex.state_id !== annotation.temp.state) {
          annotation.temp.state = vertex.state_id;
          for (const view2 of annotation.view) {
            view2.dirty = true;
          }
        }
      }
      const view = annotation.view[this.grid.view_index] || {};
      if (view.dirty) {
        if (view.update_callback) {
          view.update_callback();
        }
        this.grid.AnnotationUpdated(annotation);
      }
    }
    this.UpdateConnectedElements();
  }
  UpdateConnectedElements() {
    for (const element of this.model.connected_elements.values()) {
      const internal = element.internal;
      if (internal?.vertex && internal.vertex.state_id !== internal.state) {
        internal.state = internal.vertex.state_id;
        const fn = element.update;
        if (fn) {
          Promise.resolve().then(() => fn.call(0, element));
        }
      }
    }
  }
  /*
    public SetHeadless(headless = true): void {
      if (this.grid.headless === headless) {
        return;
      }
  
      this.grid.headless = headless;
      if (!headless) {
        this.grid.Update(true);
        this.RebuildAllAnnotations();
        // this.InflateAnnotations();
      }
    }
    */
  /**
   * this method should be called after changing the headless flag
   */
  RebuildAllAnnotations() {
    for (const annotation of this.grid.active_sheet.annotations) {
      this.InflateAnnotation(annotation);
      const view = annotation.view[this.grid.view_index] || {};
      if (view.resize_callback) {
        view.resize_callback();
      }
      if (view.update_callback) {
        view.update_callback();
      }
    }
  }
  /**
   * inflate all annotations. intended to be called after a document
   * load (including undo), which does not send `create` events.
   * 
   * FIXME: why is this public?
   */
  InflateAnnotations() {
    for (const annotation of this.grid.active_sheet.annotations) {
      this.InflateAnnotation(annotation);
    }
  }
  InflateAnnotation(annotation) {
    if (this.grid.headless) {
      return;
    }
    const view = annotation.view[this.grid.view_index] || {};
    if (view.inflated) {
      if (annotation.dirty) {
        if (view.resize_callback) {
          view.resize_callback();
        }
        annotation.dirty = false;
      }
      return;
    }
    view.inflated = true;
    if (annotation.dirty) {
      annotation.dirty = false;
    }
    if (view.content_node) {
      if (annotation.data.type === "treb-chart") {
        {
          const chart = this.CreateChart();
          chart.Initialize(view.content_node);
          const update_chart = () => {
            if (annotation.data.formula) {
              const parse_result = this.parser.Parse(annotation.data.formula);
              if (parse_result && parse_result.expression && parse_result.expression.type === "call") {
                this.parser.Walk(parse_result.expression, (unit) => {
                  if (unit.type === "address" || unit.type === "range") {
                    this.model.ResolveSheetID(unit, void 0, this.grid.active_sheet);
                  }
                  return true;
                });
                const expr_name = parse_result.expression.name.toLowerCase();
                const result = this.calculator.CalculateExpression(parse_result.expression);
                chart.Exec(expr_name, result);
              }
            }
            chart.Update();
          };
          view.resize_callback = () => {
            if (!this.grid.headless) {
              chart.Resize();
              chart.Update();
            }
          };
          view.update_callback = () => {
            if (!this.grid.headless) {
              update_chart();
            }
          };
          if (view.node?.parentElement) {
            if (!this.grid.headless) {
              update_chart();
            }
          }
        }
      } else if (annotation.data.type === "image") {
        if (typeof annotation.data.data?.src === "string") {
          const reference = ValidateURI(annotation.data.data.src);
          if (reference) {
            const img = this.DOM.Create("img");
            img.src = reference;
            if (annotation.data.data.scale === "fixed") {
              img.style.position = "relative";
              img.style.left = "50%";
              img.style.top = "50%";
              img.style.transform = "translate(-50%, -50%)";
            } else {
              img.style.width = "100%";
              img.style.height = "100%";
            }
            view.content_node.appendChild(img);
          }
        }
      }
    }
  }
  /** 
   * save sheet to local storage and trigger (push) undo. our undo system
   * relies on tracking selection after storing the main data, and sometimes
   * we need to manage this explicitly: hence the parameter.
   * 
   */
  DocumentChange(undo_selection) {
    Promise.resolve().then(() => {
      this.file_version++;
      if (this.file_version >= 65536) {
        this.file_version = 1;
      }
      const json = JSON.stringify(this.SerializeDocument({
        optimize: "size",
        rendered_values: true,
        expand_arrays: true
      }));
      if (this.options.undo) {
        this.PushUndo(json, undo_selection, false);
      }
      this.Publish({ type: "document-change" });
    });
  }
  /**
   * if we have a boolean for a storage key, generate a (weak) hash
   * based on document URI. use the prefix to create separate keys
   * when using the autogenerated key (uri hash)
   */
  ResolveStorageKey(key, prefix = "") {
    if (!key) {
      return void 0;
    }
    if (key === true) {
      let hash = 0;
      const data = document.location.href;
      for (let i = 0, len = data.length; i < len; i++) {
        hash = (hash << 5) - hash + data.charCodeAt(i);
        hash |= 0;
      }
      const generated = Math.abs(hash).toString(16);
      return prefix ? prefix + "-" + generated : generated;
    }
    return key;
  }
  /**
   * 
   * @param json -- the serialized data is already calculated. that happens
   * when we are storing to localStorage as part of handling a change; since
   * we already have the json, we can pass it through. although we should
   * switch around the order, it would make it a little easier to manage.
   * 
   * @param increment -- increment the file version. this is a parameter
   * so we can _not_ increment on the initial state push, on load.
   */
  PushUndo(json, last_selection, increment = true) {
    const selection = last_selection || this.last_selection;
    if (this.undo_stack[this.undo_pointer - 1]) {
      this.undo_stack[this.undo_pointer - 1].selection = selection;
    }
    if (increment) {
      this.file_version++;
      if (this.file_version >= 65536) {
        this.file_version = 1;
      }
    }
    if (!json) {
      json = JSON.stringify(this.SerializeDocument({
        optimize: "size",
        rendered_values: true,
        expand_arrays: true
      }));
    }
    this.undo_stack[this.undo_pointer++] = {
      data: json,
      selection: void 0
    };
    const length = this.undo_stack.length;
    if (length > 16) {
      const delta = length - 16;
      this.undo_stack = this.undo_stack.slice(delta);
      this.undo_pointer -= delta;
    }
  }
  /**
   * clear the undo stack, and optionally push an initial state
   */
  FlushUndo(push = true) {
    this.undo_stack = [];
    this.undo_pointer = 0;
    this.last_save_version = this.file_version;
    if (push) {
      this.PushUndo(void 0, void 0, false);
    }
  }
  /** 
   * update selection: used for updating toolbar (i.e. highlight bold button) 
   * 
   * we can also use this to better manage selection in the undo system...
   * 
   */
  UpdateSelection(selection) {
    this.last_selection = JSON.stringify(selection);
    this.Publish({ type: "selection" });
  }
  /** update selection style for the toolbar */
  UpdateSelectionStyle(selection) {
    const freeze = this.grid.GetFreeze();
    const state = {
      frozen: !!freeze.rows || !!freeze.columns
    };
    if (!selection) {
      selection = this.grid.GetSelection();
    }
    if (selection && !selection.empty) {
      state.selection = selection;
      let data = this.grid.active_sheet.CellData(selection.target);
      state.table = !!data.table;
      state.merge = !!data.merge_area;
      if (state.merge && data.merge_area && (data.merge_area.start.row !== selection.target.row || data.merge_area.start.column !== selection.target.column)) {
        data = this.grid.active_sheet.CellData(data.merge_area.start);
      }
      state.comment = data.note;
      state.style = data.style ? { ...data.style } : void 0;
      state.relative_font_size = Style.RelativeFontSize(state.style || {}, this.grid.theme.grid_cell || {});
    }
    this.selection_state = state;
  }
  UpdateDocumentStyles(update = true) {
    const number_format_map = {};
    const color_map = {};
    for (const sheet of this.grid.model.sheets.list) {
      sheet.NumberFormatsAndColors(color_map, number_format_map);
    }
    this.document_styles.colors = Object.keys(color_map);
    this.document_styles.number_formats = Object.keys(number_format_map);
    this.document_styles.theme_colors = [];
    const tints = [0.5, 0.25, 0, -0.25, -0.5];
    for (let i = 0; i < 10; i++) {
      this.document_styles.theme_colors.push(tints.map((tint) => {
        const color = { theme: i, tint };
        const resolved = ThemeColor2(this.grid.theme, color);
        return { color, resolved };
      }));
    }
  }
  /* * overloadable for subclasses * /
  protected InitCalculator(): CalcType {
    return new Calculator();
  }
  */
  /**
   * this function is called when the file locale (as indicated by the
   * decimal separator) is different than the current active locale.
   * 
   * so we know that we want to translate. that's why there are no tests
   * in this function.
   */
  ConvertLocale(data) {
    const parser = new Parser();
    parser.flags = { ...this.parser.flags };
    let target_decimal_mark;
    let target_argument_separator;
    if (data.decimal_mark === ".") {
      parser.decimal_mark = "." /* Period */;
      parser.argument_separator = "," /* Comma */;
      target_decimal_mark = "," /* Comma */;
      target_argument_separator = ";" /* Semicolon */;
    } else {
      parser.decimal_mark = "," /* Comma */;
      parser.argument_separator = ";" /* Semicolon */;
      target_decimal_mark = "." /* Period */;
      target_argument_separator = "," /* Comma */;
    }
    const translate = (formula) => {
      const parse_result = parser.Parse(formula);
      if (!parse_result.expression) {
        return void 0;
      }
      return "=" + parser.Render(
        parse_result.expression,
        {
          missing: "",
          convert_decimal: target_decimal_mark,
          convert_argument_separator: target_argument_separator
        }
      );
    };
    if (data.macro_functions) {
      for (const macro_function of data.macro_functions) {
        const translated = translate(macro_function.function_def);
        if (translated) {
          macro_function.function_def = translated;
        }
      }
    }
    if (data.sheet_data) {
      const sheets = Array.isArray(data.sheet_data) ? data.sheet_data : [data.sheet_data];
      for (const sheet_data of sheets) {
        if (sheet_data.annotations) {
          for (const annotation of sheet_data.annotations) {
            if (annotation.formula) {
              const translated = translate(annotation.formula);
              if (translated) {
                annotation.formula = translated;
              }
            }
          }
        }
        if (sheet_data.data?.length) {
          for (const block of sheet_data.data) {
            const cells = IsFlatData(block) ? [block] : block.cells;
            for (const cell of cells) {
              if (cell.value && typeof cell.value === "string" && cell.value[0] === "=") {
                const translated = translate(cell.value.slice(1));
                if (translated) {
                  cell.value = translated;
                }
              }
            }
          }
        }
      }
    }
  }
  /**
   * compare two semantic versions. returns an object indicating 
   * the greater version (or equal), plus individual component comparisons.
   * 
   * FIXME: move to util lib?
   */
  CompareVersions(a = "", b = "") {
    const av = a.split(".").map((value) => Number(value) || 0).concat([0, 0, 0]);
    const bv = b.split(".").map((value) => Number(value) || 0).concat([0, 0, 0]);
    const levels = [
      0 /* major */,
      1 /* minor */,
      2 /* patch */
    ];
    const result = { match: 0 };
    for (let i = 0; i < 3; i++) {
      if (av[i] !== bv[i]) {
        result.match = av[i] > bv[i] ? 1 : -1;
        result.level = levels[i];
        break;
      }
    }
    return result;
  }
  /**
   * import data from serialized document, doing locale conversion if necessary
   */
  ImportDocumentData(data, override_sheet) {
    this.file_version = data.revision || 0;
    let sheets = [];
    const compare = this.CompareVersions(data.version, "28.10.4");
    if (compare.match > 0) {
      if (compare.level === 0 /* major */ || compare.level === 1 /* minor */) {
        console.warn(`The file you are opening was created with a newer version of TREB (${data.version} vs ${"28.10.4"}).
You may encounter compatibility errors.`);
      }
    }
    if (data.sheet_data) {
      if (Array.isArray(data.sheet_data)) {
        sheets = data.sheet_data;
      } else {
        sheets.push(data.sheet_data);
      }
    }
    if (data.shared_resources) {
      const shared = data.shared_resources;
      const Unshare = (resource) => {
        if (/^resource:/.test(resource)) {
          return shared[resource.substring(9)] || "";
        }
        return resource;
      };
      for (const sheet of sheets) {
        if (sheet.background_image) {
          sheet.background_image = Unshare(sheet.background_image);
        }
        for (const annotation of sheet.annotations || []) {
          if (annotation.type === "image" && annotation.data?.src) {
            annotation.data.src = Unshare(annotation.data.src);
          }
        }
      }
    }
    if (data.decimal_mark && data.decimal_mark !== Localization.decimal_separator) {
      this.ConvertLocale(data);
    }
    const model = this.grid.model;
    model.tables.clear();
    if (data.tables) {
      for (const table of data.tables) {
        model.tables.set(table.name.toLowerCase(), table);
      }
    }
    this.grid.UpdateSheets(sheets, void 0, override_sheet || data.active_sheet);
    for (const [name, table] of this.model.tables.entries()) {
      if (table.area.start.sheet_id) {
        const sheet = model.sheets.Find(table.area.start.sheet_id);
        if (sheet) {
          for (let row = table.area.start.row; row <= table.area.end.row; row++) {
            for (let column = table.area.start.column; column <= table.area.end.column; column++) {
              const cell = sheet.cells.GetCell({ row, column }, true);
              cell.table = table;
            }
          }
        }
      }
    }
    model.document_name = data.name;
    model.user_data = data.user_data;
    model.named_ranges.Reset();
    let named_range_data = data.named_ranges;
    if (!named_range_data && sheets[0] && sheets[0].named_ranges) {
      named_range_data = sheets[0].named_ranges;
    }
    if (named_range_data) {
      model.named_ranges.Deserialize(named_range_data);
    }
    model.named_expressions.clear();
    if (data.named_expressions) {
      for (const pair of data.named_expressions) {
        const parse_result = this.parser.Parse(pair.expression);
        if (parse_result.valid && parse_result.expression) {
          this.parser.Walk(parse_result.expression, (unit) => {
            if (unit.type === "address" || unit.type === "range") {
              if (unit.type === "range") {
                unit = unit.start;
              }
              if (!unit.sheet_id) {
                if (unit.sheet) {
                  const sheet = this.model.sheets.Find(unit.sheet);
                  if (sheet) {
                    unit.sheet_id = sheet.id;
                  }
                }
              }
              if (!unit.sheet_id) {
                unit.sheet_id = this.grid.active_sheet.id;
              }
              return false;
            }
            return true;
          });
          model.named_expressions.set(pair.name.toUpperCase(), parse_result.expression);
        }
      }
    }
    model.macro_functions.clear();
    if (data.macro_functions) {
      for (const macro_function of data.macro_functions) {
        model.macro_functions.set(macro_function.name.toUpperCase(), {
          ...macro_function,
          expression: this.parser.Parse(macro_function.function_def || "").expression
        });
      }
    }
    this.UpdateAC();
  }
  /**
   * load worker. optionally uses an ambient path as prefix; intended for
   * loading in different directories (or different hosts?)
   */
  async LoadWorker(name) {
    if (true) {
      if (index_worker_exports) {
        try {
          const worker = new Worker(
            URL.createObjectURL(new Blob([index_worker_default], { type: "application/javascript" }))
          );
          return worker;
        } catch (err) {
          console.info("embedded worker failed");
          console.error(err);
        }
      }
    } else {
      console.warn("this build does not include xlsx support.");
    }
    throw new Error("creating worker failed");
  }
  /**
   * handle key down to intercept ctrl+z (undo)
   * UPDATE: we're also handling F9 for recalc (optionally)
   * 
   * FIXME: redo (ctrl+y or ctrl+shift+z)
   */
  HandleKeyDown(event) {
    if (event.ctrlKey && (event.code === "KeyZ" || event.key === "z")) {
      event.stopPropagation();
      event.preventDefault();
      this.Undo();
    } else if (event.key === "F9" && this.options.recalculate_on_f9) {
      event.stopPropagation();
      event.preventDefault();
      this.Recalculate();
    }
  }
};

// treb-embed/style/treb-spreadsheet-element.scss
var treb_spreadsheet_element_default = `@charset "UTF-8";
/*
 * This file is part of TREB.
 *
 * TREB is free software: you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *
 * TREB is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with TREB. If not, see <https://www.gnu.org/licenses/>. 
 *
 * Copyright 2022-2024 trebco, llc. 
 * info@treb.app
 * 
 */
/*
 * This file is part of TREB.
 *
 * TREB is free software: you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *
 * TREB is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with TREB. If not, see <https://www.gnu.org/licenses/>. 
 *
 * Copyright 2022-2024 trebco, llc. 
 * info@treb.app
 * 
 */
/* z-index stacking */
/* legacy only */
/*
 * This file is part of TREB.
 *
 * TREB is free software: you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *
 * TREB is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with TREB. If not, see <https://www.gnu.org/licenses/>. 
 *
 * Copyright 2022-2024 trebco, llc. 
 * info@treb.app
 * 
 */
/* shadow for tooltip and (...) */
/*
 * This file is part of TREB.
 *
 * TREB is free software: you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *
 * TREB is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with TREB. If not, see <https://www.gnu.org/licenses/>. 
 *
 * Copyright 2022-2024 trebco, llc. 
 * info@treb.app
 * 
 */
.treb-main.treb-main {
  /**
   * event mask for mouse drag. currently this is added _within_ node 
   * structure, although it covers the whole viewport. we should share
   * with the mouse mask we are using for resize.
   */
}
.treb-main.treb-main .treb-mouse-mask {
  position: fixed;
  top: 0px;
  left: 0px;
  right: 0px;
  bottom: 0px;
  background: transparent;
  z-index: 9999;
  display: none;
  /** style is attached when drag operation is a resize */
  /** style is attached when drag operation is a resize */
  /** when resizing a grid selection via the nub */
  /** for moving annotations */
  /** for resizing annotations */
}
.treb-main.treb-main .treb-mouse-mask.column-resize {
  cursor: col-resize;
}
.treb-main.treb-main .treb-mouse-mask.row-resize {
  cursor: row-resize;
}
.treb-main.treb-main .treb-mouse-mask.nub-select {
  cursor: crosshair;
}
.treb-main.treb-main .treb-mouse-mask.move {
  cursor: move;
}
.treb-main.treb-main .treb-mouse-mask.nw-resize {
  cursor: nw-resize;
}

/*
 * This file is part of TREB.
 *
 * TREB is free software: you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *
 * TREB is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with TREB. If not, see <https://www.gnu.org/licenses/>. 
 *
 * Copyright 2022-2024 trebco, llc. 
 * info@treb.app
 * 
 */
.treb-main.treb-main .treb-note {
  position: fixed;
  padding: 7px 10px;
  border-radius: 2px;
  box-shadow: 0px 1px 4px 2px rgba(109, 109, 109, 0.2);
  z-index: 39;
  line-height: normal;
  top: 100px;
  left: 100px;
  max-width: 15em; /* which em? seems to be way too large */
  min-width: 15em;
  opacity: 0;
  transition: opacity 0.2s;
  /* themeable properties */
  font-family: "BlinkMacSystemFont", "Segoe UI", "Roboto", "Oxygen-Sans", "Ubuntu", "Cantarell", "Helvetica Neue", "sans-serif";
  border: 1px solid var(--treb-note-border-color, var(--treb-ui-border-color, #ddd));
  color: var(--treb-note-color, #333);
  background: var(--treb-note-background, #fff);
  font-size: 10.5pt;
  white-space: pre-line;
}
.treb-main.treb-main .treb-hover-title {
  position: fixed;
  padding: 7px 10px;
  border-radius: 2px;
  box-shadow: 0px 1px 4px 2px rgba(109, 109, 109, 0.2);
  z-index: 39;
  line-height: normal;
  top: 100px;
  left: 100px;
  /* max-width: 15em; / * which em? seems to be way too large */
  min-width: 10em;
  opacity: 0;
  transition: opacity 0.2s;
  /* themeable properties */
  font-family: "BlinkMacSystemFont", "Segoe UI", "Roboto", "Oxygen-Sans", "Ubuntu", "Cantarell", "Helvetica Neue", "sans-serif"; /* can't we inherit? ... */
  border: 1px solid var(--treb-note-border-color, var(--treb-ui-border-color, #ddd));
  color: var(--treb-note-color, #333);
  background: var(--treb-note-background, #fff);
  font-size: 10.5pt;
  white-space: pre-line;
  pointer-events: none;
}

/*
 * This file is part of TREB.
 *
 * TREB is free software: you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *
 * TREB is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with TREB. If not, see <https://www.gnu.org/licenses/>. 
 *
 * Copyright 2022-2024 trebco, llc. 
 * info@treb.app
 * 
 */
.treb-main.treb-main .treb-sort-button {
  z-index: 39;
  border: 1px solid #ccc;
  background: #fff;
  border-radius: 2px;
  width: 1em;
  height: 1em;
  position: absolute;
  top: 100px;
  left: 100px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.1s ease;
}
.treb-main.treb-main .treb-sort-button::after {
  box-sizing: border-box;
}
.treb-main.treb-main .treb-sort-button.asc::after {
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -25%);
  width: 0.8em;
  height: 0.8em;
  border: 0.4em solid transparent;
  border-top-color: currentColor;
  opacity: 0.5;
}
.treb-main.treb-main .treb-sort-button.desc::after {
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -80%);
  width: 0.8em;
  height: 0.8em;
  border: 0.4em solid transparent;
  border-bottom-color: currentColor;
  opacity: 0.5;
}

/*
 * This file is part of TREB.
 *
 * TREB is free software: you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *
 * TREB is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with TREB. If not, see <https://www.gnu.org/licenses/>. 
 *
 * Copyright 2022-2024 trebco, llc. 
 * info@treb.app
 * 
 */
.treb-main.treb-main .treb-tooltip {
  display: none;
  pointer-events: none;
  position: fixed;
  padding: 2px 10px;
  border-radius: 2px;
  box-shadow: 0px 1px 4px 2px rgba(109, 109, 109, 0.2);
  z-index: 39;
  line-height: normal;
}
.treb-main.treb-main .treb-tooltip.arrow-up::after {
  box-sizing: border-box;
  position: absolute;
  top: -8px;
  left: calc(50% - 4px);
  width: 8px;
  height: 8px;
  overflow: hidden;
  content: " ";
  border: 4px solid transparent;
  border-bottom-color: inherit;
}
.treb-main.treb-main .treb-tooltip.arrow-left::after {
  box-sizing: border-box;
  position: absolute;
  left: -8px;
  top: calc(50% - 4px);
  width: 8px;
  height: 8px;
  overflow: hidden;
  content: " ";
  border: 4px solid transparent;
  border-right-color: inherit;
}

/*
 * This file is part of TREB.
 *
 * TREB is free software: you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *
 * TREB is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with TREB. If not, see <https://www.gnu.org/licenses/>. 
 *
 * Copyright 2022-2024 trebco, llc. 
 * info@treb.app
 * 
 */
.treb-main.treb-main {
  /**
   * FIXME: this should move, it's used in dropdowns but it 
   * is more general (should be used for all errors)
   */
}
.treb-main.treb-main .treb-dropdown-caret {
  display: none;
  position: absolute;
  width: 20px;
  height: 20px;
  background: var(--treb-dropdown-caret-background, #fff);
  border: 1px solid var(--treb-dropdown-caret-border-color, #ccc);
  border-radius: 2px;
  box-shadow: 0px 1px 4px 2px rgba(109, 109, 109, 0.2);
  z-index: 39;
}
.treb-main.treb-main .treb-dropdown-caret path {
  fill: none;
  stroke: var(--treb-dropdown-caret-color, #444);
  stroke-linecap: round;
  stroke-linejoin: round;
  stroke-width: 2;
}
.treb-main.treb-main .treb-dropdown-list {
  position: absolute;
  display: none;
  box-shadow: 0px 1px 4px 2px rgba(109, 109, 109, 0.2);
  z-index: 39;
  background: var(--treb-dropdown-background, #fff);
  font-size: 10pt;
  color: var(--treb-dropdown-color, inherit);
  border: 1px solid var(--treb-dropdown-border-color, unset);
  text-align: left;
  max-height: 10em;
  overflow-y: auto;
  outline: none;
}
.treb-main.treb-main .treb-dropdown-list div {
  padding: 2px;
  cursor: default;
}
.treb-main.treb-main .treb-dropdown-list div.selected {
  background: var(--treb-dropdown-selected-background, #555);
  color: var(--treb-dropdown-selected-color, #fff);
}
.treb-main.treb-main .treb-dropdown-caret.active {
  background: var(--treb-dropdown-caret-active-background, #eee);
}
.treb-main.treb-main .treb-dropdown-caret.active + .treb-dropdown-list {
  display: block;
}
.treb-main.treb-main .treb-error-highlight {
  transition: opacity 0.15s ease-in-out;
  background: rgba(255, 0, 0, 0.25);
  opacity: 0;
  pointer-events: none;
  position: absolute;
  z-index: 40;
}

/*
 * This file is part of TREB.
 *
 * TREB is free software: you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *
 * TREB is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with TREB. If not, see <https://www.gnu.org/licenses/>. 
 *
 * Copyright 2022-2024 trebco, llc. 
 * info@treb.app
 * 
 */
/**
 * this is getting attached to the document (why? b/c fixed pos?)
 * so it inherits a lot. that's not good.
 */
/* this is no longer attached to document, we can trim some of these */
/* also a lot of this should move to theme */
.treb-main.treb-main .treb-autocomplete {
  box-sizing: border-box;
  position: fixed;
  top: -1000px;
  font-size: inherit;
  font-weight: 400;
  line-height: normal;
  text-align: left;
  max-height: 10em;
  overflow-y: auto;
  z-index: 39;
}
.treb-main.treb-main .treb-autocomplete * {
  box-sizing: border-box;
}
.treb-main.treb-main .treb-autocomplete ul {
  font-size: inherit;
  font-weight: inherit;
  list-style-type: none;
  padding: 0;
  margin: 0;
  /*
  here we unwind the selected style if there's a hover,
  unless you're hovering over the selection. and so on.
  * /

  &:hover li a.selected {
    background: inherit;
    color: inherit;

    &:hover {
      background: #339966;
      color: #fff;
    }

  }
  */
}
.treb-main.treb-main .treb-autocomplete ul li {
  font-size: inherit;
  font-weight: inherit;
  padding: 0;
  margin: 0;
}
.treb-main.treb-main .treb-autocomplete ul li a {
  font-size: inherit;
  font-weight: inherit;
  display: inline-block;
  width: 100%;
  padding: 3px 6px;
  text-decoration: none;
  cursor: default;
  color: inherit;
}
.treb-main.treb-main .treb-autocomplete-tooltip {
  z-index: 39;
  top: -1000px;
  position: fixed;
  white-space: pre;
}

/*
 * This file is part of TREB.
 *
 * TREB is free software: you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *
 * TREB is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with TREB. If not, see <https://www.gnu.org/licenses/>. 
 *
 * Copyright 2022-2024 trebco, llc. 
 * info@treb.app
 * 
 */
.treb-main.treb-main .treb-formula-bar {
  grid-area: 1/1/2/2;
  display: flex;
  flex-direction: row;
  text-align: left;
  padding: 0px 2px 12px 2px;
  max-width: 100%;
  overflow-x: hidden;
  /* last ditch for IE11 */
  /** label for selection address */
  /** f(x) button, optional */
}
.treb-main.treb-main .treb-formula-bar[hidden] {
  display: none;
}
.treb-main.treb-main .treb-formula-bar .treb-address-label {
  width: 95px;
  min-width: 95px;
  min-height: 1.5em;
  height: 1.75em;
  border: 1px solid var(--treb-formula-bar-border-color, var(--treb-ui-border-color, #ccc));
  border-radius: 2px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  padding-left: 3px;
  margin-right: 6px;
}
.treb-main.treb-main .treb-formula-bar .treb-address-label > div {
  outline: none;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.treb-main.treb-main .treb-formula-bar .expand-button {
  background: transparent;
  border: 0;
  border-radius: 2px;
  margin-left: 2px;
  padding: 1px;
  outline: none;
  height: 1.75em;
}
.treb-main.treb-main .treb-formula-bar .expand-button::after {
  content: " ";
  border: 5px solid transparent;
  position: relative;
  display: inline-block;
  border-top-color: #999;
  padding: 0;
  margin: 0;
  top: -6px;
  transition: transform 0.15s ease;
}
.treb-main.treb-main .treb-formula-bar[expanded] .expand-button::after {
  transform: rotate(180deg) translateY(6px);
}
.treb-main.treb-main .treb-formula-bar .treb-editor-container {
  border: 1px solid var(--treb-formula-bar-border-color, var(--treb-ui-border-color, #ccc));
  border-radius: 2px;
  flex-grow: 1;
  height: 1.75em;
  display: flex;
  min-width: 0px;
  flex-direction: column;
  justify-content: center;
}
.treb-main.treb-main .treb-formula-bar[expanded] .treb-editor-container {
  transition: height 0.1s ease-in-out;
  height: 4.5em;
}
.treb-main.treb-main .treb-formula-bar[expanded] .treb-editor-container > div {
  overflow-y: auto;
}
.treb-main.treb-main .treb-formula-bar .treb-editor-container > div {
  width: 100%;
  margin: 2px;
  outline: none;
  overflow-y: hidden;
  overflow-x: hidden;
  white-space: pre-wrap;
  /** 
   * 1.35 is better on safari, seems like a wash on windows.
   * can we browser-limit this? (...)
   */
  line-height: 1.35;
  /* normal; */
  flex-grow: 1;
  /* keeps content at the top */
  min-height: 1em;
  /* I don't like this, let's figure out a better way w/ wrapping */
  /**
   * FIXME: we're using this for a single-line formula, but
   * it needs to come out for multiline (if we do that).
   */
  /*
  white-space: nowrap;
  text-overflow: ellipsis;

  &:focus {
    text-overflow: clip;
  }
  */
}
.treb-main.treb-main .treb-formula-bar .formula-button {
  border: 1px solid #ccc;
  border-radius: 2px;
  margin-left: 6px;
  height: 1.75em;
  overflow: hidden;
  white-space: nowrap;
}
.treb-main.treb-main .treb-formula-bar .formula-button .text-1 {
  font-style: italic;
  padding-right: 0.1em;
}
.treb-main.treb-main .treb-formula-bar .formula-button .text-1:after {
  content: "f";
}
.treb-main.treb-main .treb-formula-bar .formula-button .text-2 {
  font-size: 0.7em;
}
.treb-main.treb-main .treb-formula-bar .formula-button .text-2:after {
  content: "(x)";
}

/*
 * This file is part of TREB.
 *
 * TREB is free software: you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *
 * TREB is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with TREB. If not, see <https://www.gnu.org/licenses/>. 
 *
 * Copyright 2022-2024 trebco, llc. 
 * info@treb.app
 * 
 */
.treb-main.treb-main .treb-mouse-mask .ghost-tab {
  position: fixed;
}
.treb-main.treb-main .treb-spreadsheet-footer {
  grid-area: 3/1/4/2;
  align-items: center;
  /** don't overflow/ellipsis the add tab button */
  /**
   * for ellipsis to work, it seems like it has to be inside
   * a span in the tab. since we are not using it atm I removed
   * that span, but if we want ellpisis it will need to come back.
   */
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-spreadsheet-tab-container {
  align-self: flex-start;
  overflow: hidden;
  height: 2.2em;
}
.treb-main.treb-main .treb-spreadsheet-footer,
.treb-main.treb-main .treb-spreadsheet-footer .treb-spreadsheet-tabs {
  display: flex;
  flex-direction: row;
  z-index: 2;
  max-width: 100%;
  height: 2.2em;
  color: var(--treb-ui-color, inherit);
  list-style-type: none;
  padding-inline-start: 0;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-spreadsheet-tabs {
  height: auto;
  margin-block-start: 0;
  margin: 0;
  overflow-x: scroll;
  overflow-y: hidden;
}
.treb-main.treb-main .treb-spreadsheet-footer[hidden] {
  display: none;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-spreadsheet-tabs > li {
  display: inline-block;
  position: relative;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-spreadsheet-tabs > li, .treb-main.treb-main .treb-spreadsheet-footer .treb-add-tab, .treb-main.treb-main .treb-spreadsheet-footer .treb-delete-tab {
  font-size: inherit;
  padding: 0.25em 0.75em;
  padding: 0 0.75em;
  height: 100%;
  overflow: hidden;
  color: var(--treb-tab-bar-tab-color, var(--treb-ui-color, #fff));
  cursor: default;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-bottom-left-radius: 5px;
  border-bottom-right-radius: 5px;
  border: 1px solid var(--treb-tab-bar-tab-border-color, var(--treb-ui-border-color, #ccc));
  border-top-width: 0px;
  z-index: 1;
  margin-right: -2px;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-spreadsheet-tabs > li:active, .treb-main.treb-main .treb-spreadsheet-footer .treb-spreadsheet-tabs > li:focus, .treb-main.treb-main .treb-spreadsheet-footer .treb-add-tab:active, .treb-main.treb-main .treb-spreadsheet-footer .treb-add-tab:focus, .treb-main.treb-main .treb-spreadsheet-footer .treb-delete-tab:active, .treb-main.treb-main .treb-spreadsheet-footer .treb-delete-tab:focus {
  z-index: 3;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-spreadsheet-tabs > li {
  height: 2.2em;
  overflow: visible;
  overflow-x: visible;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-spreadsheet-tabs > li:last-of-type {
  margin-right: 0;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-add-tab {
  margin-left: -1px;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-spreadsheet-tabs > li {
  white-space: nowrap;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-spreadsheet-tabs > li[selected] {
  z-index: 2;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-scale-control {
  font-size: inherit;
  height: 2.2em;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  position: relative;
  width: 5em;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-scale-control .treb-scale-input {
  font-size: inherit;
  font-family: inherit;
  width: 4em;
  text-align: center;
  border: 1px solid transparent;
  transition: border-color 0.25s ease, background-color 0.25s ease;
  border-radius: 2px;
  color: inherit;
  background: transparent;
  padding: initial;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-scale-control .treb-slider-container {
  position: absolute;
  border: 1px solid var(--treb-scale-slider-border-color, var(--treb-ui-border-color, #ccc));
  background: var(--treb-scale-slider-background, #fff);
  accent-color: var(--treb-scale-slider-accent-color, undefined);
  width: 10em;
  height: 4em;
  top: 0em;
  left: 0.5em;
  transform-origin: left top;
  transform: rotate(-90deg);
  z-index: 40;
  opacity: 0;
  transition: opacity 0.25s ease;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  pointer-events: none;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-scale-control:hover .treb-scale-input,
.treb-main.treb-main .treb-spreadsheet-footer .treb-scale-control .treb-scale-input:focus {
  border-color: var(--treb-ui-border-color, #ccc);
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-scale-control .treb-slider-container > input[type=range] {
  width: 8.5em;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-scale-control .treb-scale-input:focus + .treb-slider-container, .treb-main.treb-main .treb-spreadsheet-footer .treb-scale-control .treb-slider-container:focus-within, .treb-main.treb-main .treb-spreadsheet-footer .treb-scale-control:hover .treb-slider-container {
  opacity: 0.85;
  pointer-events: initial;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-delete-tab {
  border: none;
  background: transparent;
  color: currentColor;
  font-size: inherit;
  padding: 0.25em 0.75em;
  cursor: default;
  display: inline-flex;
  align-items: center;
  flex-direction: row;
  border-bottom-left-radius: 5px;
  border-bottom-right-radius: 5px;
  /* border: 1px solid #ccc; */
  border-top-width: 0px;
  z-index: 1;
  margin-right: -2px;
  /* margin-right: 1em; */
  min-width: 2.5em;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-delete-tab svg {
  width: 1em;
  height: 1em;
  opacity: 0.75;
  pointer-events: none;
  transition: opacity 0.125s ease-in-out;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-delete-tab:hover svg {
  opacity: 0.75;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-delete-tab path {
  stroke: currentColor;
  stroke-width: 1.5px;
  stroke-linecap: round;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-delete-tab:active, .treb-main.treb-main .treb-spreadsheet-footer .treb-delete-tab:focus {
  z-index: 3;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-stats-panel {
  flex: 1 1;
  text-align: end;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-stats-panel > * {
  margin-left: 0.5em;
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-stats-panel .treb-stats-value {
  border: 1px solid var(--treb-stats-value-border-color, var(--treb-ui-border-color, #ddd));
  background: var(--treb-stats-value-background, #f8f8ff);
  padding: 0 0.3em;
  border-radius: 3px;
}

/*
 * This file is part of TREB.
 *
 * TREB is free software: you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *
 * TREB is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with TREB. If not, see <https://www.gnu.org/licenses/>. 
 *
 * Copyright 2022-2024 trebco, llc. 
 * info@treb.app
 * 
 */
.treb-main.treb-main .treb-grid {
  /** fix for firefox layout bug */
}
.treb-main.treb-main .treb-grid .treb-overlay-container {
  padding: 0;
  margin: 0;
  /* gets positioned to the rect */
  position: absolute;
  /* gets set on edit, along with pointer-events */
  opacity: 0;
  /* probably unecessary */
  outline: none;
  z-index: 24;
}
.treb-main.treb-main .treb-grid .treb-overlay-container.align-right .treb-overlay-inset {
  right: 0px;
  text-align: right;
  padding-right: 3px;
}
.treb-main.treb-main .treb-grid .treb-overlay-container.align-center .treb-overlay-inset {
  text-align: center;
  left: 50%;
  transform: translateX(-50%);
}
.treb-main.treb-main .treb-grid .treb-overlay-inset {
  padding: 0;
  margin: 0;
  padding: 0 4px;
  position: absolute;
  height: 100%;
  min-width: 100%;
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
}
.treb-main.treb-main .treb-grid .treb-overlay-editor {
  outline: none;
  white-space: nowrap;
  position: relative;
  white-space: pre;
}
.treb-main.treb-main .treb-grid .treb-overlay-editor.firefox::before {
  content: "\u200B";
}

.treb-main.treb-main {
  /* 
    * new: we need the rendering buffer to inherit font size. so 
    * we add it as a child of contents, but it's not displayed.
    * still seems to paint OK.
    */
}
.treb-main.treb-main .treb-buffer-canvas {
  position: absolute;
  display: none;
}
.treb-main.treb-main .treb-spreadsheet-body {
  grid-area: 2/1/3/2;
  -webkit-overflow-scrolling: touch;
  -webkit-tap-highlight-color: transparent;
  overflow: hidden;
  display: flex;
  position: relative;
  z-index: 1;
}
.treb-main.treb-main .treb-grid {
  flex-grow: 1;
  order: 2;
  position: relative;
  overflow: scroll;
  -webkit-overflow-scrolling: touch;
  -webkit-tap-highlight-color: transparent;
  outline: none;
  display: grid;
  grid-template-columns: 100px auto;
  grid-template-rows: 20px auto;
  /** selection stacks over the grid but under the cover */
  /** corner node to cover headers as they scroll across/down */
  /** contains row header tiles */
  /** contains column header tiles */
  /** contains main grid tiles */
  /** covers for canvas nodes to intercept events */
  /** selection stacks over the grid but under the cover */
  /** separate selection node for frozen rows/columns (needs different stacking) */
  /** separate annotation node for frozen row/column/corner */
  /**
   * corner node to cover headers as they scroll across/down. this is now
   * used for freeze panes; row/column headers are rendered in the corner
   * and in the case of both frozen rows and columns, the fixed bit is
   * rendered to the corner.
   */
  /** contains row header tiles */
  /** contains column header tiles */
  /** contains main grid tiles */
}
.treb-main.treb-main .treb-grid .tile-cover {
  /** specific layout for main grid cover */
  /** specific layout for column header cover */
  /** specific layout for row header cover */
}
.treb-main.treb-main .treb-grid .tile-cover.grid-cover {
  grid-area: 2/2/3/3;
}
.treb-main.treb-main .treb-grid .tile-cover.column-header-cover {
  grid-area: 1/2/2/3;
  position: -webkit-sticky;
  position: sticky;
  top: 0px;
}
.treb-main.treb-main .treb-grid .tile-cover.row-header-cover {
  grid-area: 2/1/3/2;
  position: -webkit-sticky;
  position: sticky;
  left: 0px;
}
.treb-main.treb-main .treb-grid .treb-grid-selection {
  grid-area: 1/1/2/2;
}
.treb-main.treb-main .treb-grid .treb-corner {
  grid-area: 1/1/2/2;
  position: -webkit-sticky;
  position: sticky;
}
.treb-main.treb-main .treb-grid .treb-left-header {
  grid-area: 2/1/3/2;
  position: -webkit-sticky;
  position: sticky;
  display: grid;
  grid-template-columns: auto;
  grid-template-rows: auto;
}
.treb-main.treb-main .treb-grid .treb-top-header {
  grid-area: 1/2/2/3;
  position: -webkit-sticky;
  position: sticky;
  display: grid;
  grid-template-columns: auto;
  grid-template-rows: auto;
}
.treb-main.treb-main .treb-grid .treb-contents {
  grid-area: 2/2/3/3;
  display: grid;
  grid-template-columns: auto;
  grid-template-rows: auto;
}
.treb-main.treb-main .treb-grid.safari::-webkit-scrollbar {
  -webkit-appearance: none;
  width: 7px;
  height: 7px;
}
.treb-main.treb-main .treb-grid.safari::-webkit-scrollbar-thumb {
  border-radius: 4px;
  background-color: rgba(0, 0, 0, 0.25);
  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, 0.5);
}
.treb-main.treb-main .treb-grid canvas {
  border: 0;
  margin: 0;
  padding: 0;
  background: transparent;
}
.treb-main.treb-main .treb-grid .nub-select {
  cursor: crosshair;
}
.treb-main.treb-main .treb-grid .link-pointer {
  cursor: pointer;
}
.treb-main.treb-main .treb-grid .mock-selection-node {
  background: red;
  position: fixed;
  left: -100px;
  top: -100px;
}
.treb-main.treb-main .treb-grid .tile-cover {
  background: transparent;
  position: relative;
  z-index: 14;
  /** specific layout for column header cover */
  /** specific layout for row header cover */
}
.treb-main.treb-main .treb-grid .tile-cover.column-header-cover {
  /** style is attached when mousing over a column boundary */
  z-index: 22;
}
.treb-main.treb-main .treb-grid .tile-cover.column-header-cover.resize {
  cursor: col-resize;
}
.treb-main.treb-main .treb-grid .tile-cover.row-header-cover {
  /** style is attached when mousing over a row boundary */
  z-index: 22;
}
.treb-main.treb-main .treb-grid .tile-cover.row-header-cover.resize {
  cursor: row-resize;
}
.treb-main.treb-main .treb-grid .treb-annotation-container,
.treb-main.treb-main .treb-grid .frozen-annotation-container {
  position: absolute;
  top: 0px;
  left: 0px;
  /** what is this? */
  z-index: 16;
  pointer-events: none;
}
.treb-main.treb-main .treb-grid .treb-annotation-container .annotation,
.treb-main.treb-main .treb-grid .frozen-annotation-container .annotation {
  position: absolute;
  overflow: hidden;
  pointer-events: auto;
  background: rgba(255, 255, 255, 0.5);
  border: 1px solid #999;
  z-index: 1;
}
.treb-main.treb-main .treb-grid .treb-annotation-container .annotation .annotation-content,
.treb-main.treb-main .treb-grid .frozen-annotation-container .annotation .annotation-content {
  position: absolute;
  top: 0px;
  left: 0px;
  height: 100%;
  width: 100%;
  font-family: inherit;
  font-size: inherit;
  z-index: 1;
}
.treb-main.treb-main .treb-grid .treb-annotation-container .annotation .annotation-move-target,
.treb-main.treb-main .treb-grid .frozen-annotation-container .annotation .annotation-move-target {
  position: absolute;
  z-index: 2;
  cursor: move;
  top: 0px;
  left: 0px;
  height: 10%;
  min-height: 14px;
  width: 100%;
}
.treb-main.treb-main .treb-grid .treb-annotation-container .annotation .annotation-resize-target,
.treb-main.treb-main .treb-grid .frozen-annotation-container .annotation .annotation-resize-target {
  position: absolute;
  z-index: 3;
  cursor: nwse-resize;
  bottom: 0px;
  right: 0px;
  width: 10%;
  height: 10%;
  min-height: 14px;
  min-width: 14px;
}
.treb-main.treb-main .treb-grid .treb-annotation-container .annotation:focus, .treb-main.treb-main .treb-grid .treb-annotation-container .annotation.retain-focus, .treb-main.treb-main .treb-grid .treb-annotation-container .annotation.clone-focus,
.treb-main.treb-main .treb-grid .frozen-annotation-container .annotation:focus,
.treb-main.treb-main .treb-grid .frozen-annotation-container .annotation.retain-focus,
.treb-main.treb-main .treb-grid .frozen-annotation-container .annotation.clone-focus {
  box-shadow: 0px 0px 0px 3px rgba(14, 165, 233, 0.33);
}
.treb-main.treb-main .treb-grid .treb-annotation-container .move-buffer,
.treb-main.treb-main .treb-grid .frozen-annotation-container .move-buffer {
  position: absolute;
  border: 1px solid red;
  height: 10%;
  top: 0px;
  width: 100%;
  left: 0px;
  cursor: move;
}
.treb-main.treb-main .treb-grid .treb-grid-selection {
  background: transparent;
  position: absolute;
  z-index: 10;
  -moz-transform: scale(1);
}
.treb-main.treb-main .treb-grid .frozen-selection {
  /* background: transparent; */
  transition: background 0.33s;
  position: absolute;
  z-index: 12;
  overflow: hidden;
  -moz-transform: scale(1);
  pointer-events: none;
}
.treb-main.treb-main .treb-grid .frozen-selection.frozen-selection-rows {
  border-bottom: 1px solid transparent;
}
.treb-main.treb-main .treb-grid .frozen-selection.frozen-selection-columns {
  border-right: 1px solid transparent;
}
.treb-main.treb-main .treb-grid .frozen-annotation-container {
  position: absolute;
  top: 0px;
  left: 0px;
  overflow: hidden;
  width: 100%;
  height: 100%;
}
.treb-main.treb-main .treb-grid .treb-corner {
  top: 0px;
  left: 0px;
  z-index: 20;
}
.treb-main.treb-main .treb-grid .treb-corner canvas {
  position: absolute;
  top: 0px;
  left: 0px;
  pointer-events: none;
}
.treb-main.treb-main .treb-grid .treb-left-header {
  left: 0px;
  z-index: 18;
  pointer-events: none;
}
.treb-main.treb-main .treb-grid .treb-top-header {
  top: 0px;
  z-index: 18;
  pointer-events: none;
}
.treb-main.treb-main .treb-grid .treb-contents {
  height: 2000px;
  width: 2000px;
}

/*
 * This file is part of TREB.
 *
 * TREB is free software: you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *
 * TREB is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with TREB. If not, see <https://www.gnu.org/licenses/>. 
 *
 * Copyright 2022-2024 trebco, llc. 
 * info@treb.app
 * 
 */
/**
 * we're using variables for selection colors because the colors are used
 * in more than one place; that's a drawback of using CSS, but I think overall
 * the benefits are still worth it.
 *
 * just FYI primary selection color is used in header overlay; and alternate
 * selection color is used to highlight in formula editors (TODO/WIP).
 */
/*
$alternate-selection-color-1: rgb(251, 177, 60);
$alternate-selection-color-2: rgb(64, 192, 64);
$alternate-selection-color-3: rgb(182, 109, 13);
$alternate-selection-color-4: rgb(33, 118, 174);
$alternate-selection-color-5: rgb(254, 104, 71);

/ * *
 * slightly darkening colors for text highlighting
 * algo: convert to HSL; if L > .5, regenerate with L = .5; back to RGB (why?)
 * /
$text-reference-color-1: rgb(250, 155, 5);
$text-reference-color-2: rgb(58, 173, 58);
$text-reference-color-3: rgb(182, 109, 13);
$text-reference-color-4: rgb(33, 118, 174);
$text-reference-color-5: rgb(254, 47, 1);
*/
.treb-main.treb-main {
  --alternate-selection-color-1: rgb(251, 177, 60);
  --alternate-selection-color-2: rgb(64, 192, 64);
  --alternate-selection-color-3: rgb(182, 109, 13);
  --alternate-selection-color-4: rgb(33, 118, 174);
  --alternate-selection-color-5: rgb(254, 104, 71);
  /**
   * slightly darkening colors for text highlighting
   * algo: convert to HSL; if L > .5, regenerate with L = .5; back to RGB (why?)
   */
  --text-reference-color-1: rgb(224, 138, 0);
  --text-reference-color-2: rgb(58, 173, 58);
  --text-reference-color-3: rgb(182, 109, 13);
  --text-reference-color-4: rgb(33, 118, 174);
  --text-reference-color-5: rgb(254, 47, 1);
  /** 
   * move primary selection focus color to focus-within on the top-level 
   * node, and use a (new) unfocused selection color. name?
   *
   * this has to be as specific as the inside version
   */
  /* 

  theme colors (new). these are in addition to the cell text and background,
  which are technically theme colors as well and should maybe move into this
  section? not sure

  */
  /*

  NOTE: much of the theme/style is supplied by the embed lib, which 
  sets things like font. we decided to leave it there because it's applied
  to more than just the treb-main node (also to the dialog), so it's easier
  to keep it consistent over there. 

  We have the children, grid-specific, in here. you can still use a single
  theme to override.

  */
  /* 
   * offset colors. for some special cases (theme tables) we use offsets 
   * against theme colors, selecting a color based on the lightness value 
   * of another color.
   */
  /** offset dark is the DARK color applied against LIGHT backgrounds */
  /** offset light is the LIGHT color applied against DARK backgrounds */
  /** 
   * highlight in the corner of a cell when there's a comment. this is painted.
   */
  /** 
   * grid row/column headers. these are painted, so this CSS is read,
   * instead of applied.
   */
  /** 
   * cells in the grid. background is the unstyled background color 
   * (should probably be in grid, not here). 
   *
   * everything can be overridden by cell/column/row/sheet styles.
   *
   * stroke here is the color for grid lines. that used to be a separate
   * section, but it seems superfluous.
   */
  /* 
   * we stopped using this in favor of sheet backgrounds. although
   * there's a case to be made for the static background as well.
   *
  .grid-background {
    background-image: var(--treb-grid-background-image, none);
  }
  */
  /**
   * this is used for freeze-area highlights
   */
  /** 
   * tooltip when entering formula
   * FIXME: could go into some sort of container with the list? (...) 
   */
  /** 
   * autocomplete for functions (and names)
   */
  /** header overlays (indicate selection) */
  /** 
   * these are highlight colors in editors. we are not consolidating 
   * because we may need to adjust a little bit (some are too light to 
   * be useful).
   */
  /** 
   * selections
   */
  /**
   * column/row size tooltip
   * TODO/FIXME: should this have a box-shadow?
   */
  /**
   * styling the tab bar, at bottom; includes the add-tab tab and
   * remove tab button
   */
  /**
   * formula bar and address label. includes f(x) button which we don't use ATM
   *
   * FIXME: a lot of formula bar styling is in a separate stylesheet
   * (formula-bar.scss); that's OK for layout styling but colors and fonts
   * should centralize here. TODO/WIP.
   */
  /**
   * special override for windows, using calibri (which is too small).
   * you should still be able to override with a regular theme style,
   * or (potentially) also override for windows specifically. fancy!
   */
}
.treb-main.treb-main:focus-within .treb-grid-selection .primary-selection,
.treb-main.treb-main:focus-within .treb-header-overlay {
  color: var(--treb-selection-color, #4caaf1);
}
.treb-main.treb-main .theme-color-1 {
  color: var(--treb-theme-color-1, #E7E6E6);
}
.treb-main.treb-main .theme-color-2 {
  color: var(--treb-theme-color-2, #44546A);
}
.treb-main.treb-main .theme-color-3 {
  color: var(--treb-theme-color-3, #4472C4);
}
.treb-main.treb-main .theme-color-4 {
  color: var(--treb-theme-color-4, #ED7D31);
}
.treb-main.treb-main .theme-color-5 {
  color: var(--treb-theme-color-5, #A5A5A5);
}
.treb-main.treb-main .theme-color-6 {
  color: var(--treb-theme-color-6, #FFC000);
}
.treb-main.treb-main .theme-color-7 {
  color: var(--treb-theme-color-7, #5B9BD5);
}
.treb-main.treb-main .theme-color-8 {
  color: var(--treb-theme-color-8, #70AD47);
}
.treb-main.treb-main .theme-color-9 {
  color: var(--treb-theme-color-9, #0563C1);
}
.treb-main.treb-main .theme-color-10 {
  color: var(--treb-theme-color-10, #954F72);
}
.treb-main.treb-main .treb-offset-dark {
  color: #000;
}
.treb-main.treb-main .treb-offset-light {
  color: #fff;
}
.treb-main.treb-main .note-marker {
  background: var(--treb-note-marker-color, #6FAB20);
}
.treb-main.treb-main .grid-headers {
  font-family: var(--treb-grid-header-font-family, inherit);
  font-size: var(--treb-grid-header-font-size, 10pt);
  font-weight: var(--treb-grid-header-font-weight, normal);
  font-style: var(--treb-grid-header-font-style, normal);
  background: var(--treb-grid-header-background, rgb(238, 238, 242));
  color: var(--treb-grid-header-color, var(--treb-grid-default-color, #666));
  stroke: var(--treb-grid-header-grid-color, var(--treb-grid-grid-color, rgb(204, 204, 212)));
}
.treb-main.treb-main .grid-cells {
  font-family: var(--treb-grid-font-family, inherit);
  font-size: var(--treb-grid-font-size, 14px);
  color: var(--treb-grid-default-color, inherit);
  stroke: var(--treb-grid-grid-color, rgb(204, 204, 212));
  background: var(--treb-grid-background, #fff);
}
.treb-main.treb-main .frozen-selection.highlight-area {
  background: rgba(87, 184, 255, 0.25);
  border-left-color: rgb(33, 118, 174);
  /* not using */
  border-bottom-color: rgb(33, 118, 174);
  /* not using */
}
.treb-main.treb-main .treb-autocomplete-tooltip {
  font-size: 14px;
  /* FIXME: relative */
  border-radius: 2px;
  background: var(--treb-autocomplete-tooltip-background, #fffbb5);
  color: var(--treb-autocomplete-tooltip-color, inherit);
  border: 1px solid var(--treb-autocomplete-tooltip-border-color, unset);
  padding: 3px 8px;
  margin: 4px 0px;
  line-height: normal;
}
.treb-main.treb-main .treb-autocomplete-tooltip .active-argument {
  font-weight: 700;
}
.treb-main.treb-main .treb-autocomplete-tooltip .function-description {
  font-style: italic;
}
.treb-main.treb-main .treb-autocomplete {
  font-size: 14px;
  /* FIXME: relative? could be larger, actually */
  background: var(--treb-autocomplete-background, #fff);
  border-radius: 2px;
  border: 1px solid var(--treb-autocomplete-border-color, var(--treb-ui-border-color, #ccc));
  box-shadow: 0px 1px 4px 2px rgba(109, 109, 109, 0.2);
}
.treb-main.treb-main .treb-autocomplete li {
  color: var(--treb-autocomplete-entry-color, #333);
}
.treb-main.treb-main .treb-autocomplete li a.selected {
  background: var(--treb-autocomplete-selected-entry-background, #2e8dd6);
  color: var(--treb-autocomplete-selected-entry-color, #fff);
}
.treb-main.treb-main .treb-header-overlay {
  stroke: none;
  color: var(--treb-selection-color-unfocused, var(--treb-selection-color, #4caaf1));
}
.treb-main.treb-main .treb-header-overlay .treb-overlay {
  fill: rgb(0, 0, 0);
  /* FIXME: use color? */
  stroke: none;
  opacity: 0.05;
}
.treb-main.treb-main .treb-header-overlay .treb-highlight {
  fill: currentColor;
}
.treb-main.treb-main .treb-editor-container > div,
.treb-main.treb-main .treb-overlay-editor {
  /* span:nth-of-type(1n) { */
  /* span:nth-of-type(2n) { */
  /* span:nth-of-type(3n) { */
  /* span:nth-of-type(4n) { */
  /* span:nth-of-type(5n) { */
}
.treb-main.treb-main .treb-editor-container > div [data-highlight-index="1"],
.treb-main.treb-main .treb-overlay-editor [data-highlight-index="1"] {
  color: var(--text-reference-color-1);
}
.treb-main.treb-main .treb-editor-container > div [data-highlight-index="2"],
.treb-main.treb-main .treb-overlay-editor [data-highlight-index="2"] {
  color: var(--text-reference-color-2);
}
.treb-main.treb-main .treb-editor-container > div [data-highlight-index="3"],
.treb-main.treb-main .treb-overlay-editor [data-highlight-index="3"] {
  color: var(--text-reference-color-3);
}
.treb-main.treb-main .treb-editor-container > div [data-highlight-index="4"],
.treb-main.treb-main .treb-overlay-editor [data-highlight-index="4"] {
  color: var(--text-reference-color-4);
}
.treb-main.treb-main .treb-editor-container > div [data-highlight-index="5"],
.treb-main.treb-main .treb-overlay-editor [data-highlight-index="5"] {
  color: var(--text-reference-color-5);
}
.treb-main.treb-main .treb-editor-container > div span.highlight-1,
.treb-main.treb-main .treb-overlay-editor span.highlight-1 {
  color: var(--text-reference-color-1);
}
.treb-main.treb-main .treb-editor-container > div span.highlight-2,
.treb-main.treb-main .treb-overlay-editor span.highlight-2 {
  color: var(--text-reference-color-2);
}
.treb-main.treb-main .treb-editor-container > div span.highlight-3,
.treb-main.treb-main .treb-overlay-editor span.highlight-3 {
  color: var(--text-reference-color-3);
}
.treb-main.treb-main .treb-editor-container > div span.highlight-4,
.treb-main.treb-main .treb-overlay-editor span.highlight-4 {
  color: var(--text-reference-color-4);
}
.treb-main.treb-main .treb-editor-container > div span.highlight-5,
.treb-main.treb-main .treb-overlay-editor span.highlight-5 {
  color: var(--text-reference-color-5);
}
.treb-main.treb-main .treb-grid-selection,
.treb-main.treb-main .frozen-selection {
  /** common */
  /** common to alternate selections */
  /** 
   * primary selection has a separate fill node, because the "target" is
   * not filled
   */
}
.treb-main.treb-main .treb-grid-selection .selection,
.treb-main.treb-main .frozen-selection .selection {
  stroke-width: var(--treb-selection-stroke-width, 2px);
}
.treb-main.treb-main .treb-grid-selection .selection .outline,
.treb-main.treb-main .frozen-selection .selection .outline {
  stroke: currentColor;
  fill: none;
}
.treb-main.treb-main .treb-grid-selection .selection .fill,
.treb-main.treb-main .frozen-selection .selection .fill {
  stroke: none;
  fill: currentColor;
  opacity: var(--treb-selection-fill-opacity, 0.1);
}
.treb-main.treb-main .treb-grid-selection .alternate-selection,
.treb-main.treb-main .frozen-selection .alternate-selection {
  stroke-dasharray: var(--treb-alternate-selection-dasharray, 3 2);
}
.treb-main.treb-main .treb-grid-selection .alternate-selection:nth-of-type(1n),
.treb-main.treb-main .frozen-selection .alternate-selection:nth-of-type(1n) {
  color: var(--alternate-selection-color-1);
}
.treb-main.treb-main .treb-grid-selection .alternate-selection:nth-of-type(2n),
.treb-main.treb-main .frozen-selection .alternate-selection:nth-of-type(2n) {
  color: var(--alternate-selection-color-2);
}
.treb-main.treb-main .treb-grid-selection .alternate-selection:nth-of-type(3n),
.treb-main.treb-main .frozen-selection .alternate-selection:nth-of-type(3n) {
  color: var(--alternate-selection-color-3);
}
.treb-main.treb-main .treb-grid-selection .alternate-selection:nth-of-type(4n),
.treb-main.treb-main .frozen-selection .alternate-selection:nth-of-type(4n) {
  color: var(--alternate-selection-color-4);
}
.treb-main.treb-main .treb-grid-selection .alternate-selection:nth-of-type(5n),
.treb-main.treb-main .frozen-selection .alternate-selection:nth-of-type(5n) {
  color: var(--alternate-selection-color-5);
}
.treb-main.treb-main .treb-grid-selection .primary-selection,
.treb-main.treb-main .frozen-selection .primary-selection {
  color: var(--treb-selection-color-unfocused, var(--treb-selection-color, #4caaf1));
}
.treb-main.treb-main .treb-grid-selection .primary-selection .nub,
.treb-main.treb-main .frozen-selection .primary-selection .nub {
  stroke: #fff;
  fill: currentColor;
  stroke-width: 1px;
}
.treb-main.treb-main .treb-tooltip {
  font-size: 11pt;
  /** FIXME: relative */
  background: var(--treb-resize-tooltip-background, rgba(0, 0, 0, 0.8));
  color: var(--treb-resize-tooltip-color, #fff);
  border-color: var(--treb-resize-tooltip-background, rgba(0, 0, 0, 0.8));
  /* for arrow */
}
.treb-main.treb-main .treb-spreadsheet-footer {
  /* FIXME: could be relative? */
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-spreadsheet-tabs > li,
.treb-main.treb-main .treb-spreadsheet-footer .treb-add-tab {
  background: var(--treb-tab-bar-tab-background, rgb(238, 238, 242));
  color: var(--treb-tab-bar-tab-color, var(--treb-ui-color, inherit));
}
.treb-main.treb-main .treb-spreadsheet-footer .treb-spreadsheet-tabs > li[selected],
.treb-main.treb-main .treb-spreadsheet-footer .treb-add-tab[selected] {
  background: var(--treb-tab-bar-active-tab-background, #fff);
  color: var(--treb-tab-bar-active-tab-color, var(--treb-ui-color, inherit));
}
.treb-main.treb-main .treb-formula-bar .treb-address-label,
.treb-main.treb-main .treb-formula-bar .treb-editor-container {
  background: var(--treb-formula-bar-background, transparent);
  color: var(--treb-formula-bar-color, var(--treb-ui-color, inherit));
}
.treb-main.treb-main .treb-formula-bar .treb-address-label[locked],
.treb-main.treb-main .treb-formula-bar .treb-editor-container[locked] {
  background: var(--treb-formula-bar-locked-background, rgb(238, 244, 252));
  position: relative;
}
.treb-main.treb-main .treb-formula-bar .treb-address-label[locked]:after,
.treb-main.treb-main .treb-formula-bar .treb-editor-container[locked]:after {
  position: absolute;
  right: 2px;
  top: 2px;
  content: "";
  width: 12px;
  height: 12px;
  opacity: 0.4;
  /**
   * NOTE: recent updates to webpack (v5ish) require a new option
   * to css-loader, otherwise it rewrites this with a URL API function
   * which breaks IE11. 
   *
   * (removed nasty comment about webpack)
   *
   * FIXME: this makes theming the lock icon impossible. use a node.
   */
  --icon: url("data:image/svg+xml,%0A%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Cpath d='M416 224H400V144C400 65 335 0 256 0S112 65 112 144V224H96C61 224 32 253 32 288V448C32 483 61 512 96 512H416C451 512 480 483 480 448V288C480 253 451 224 416 224ZM176 144C176 100 212 64 256 64S336 100 336 144V224H176V144Z' fill='currentColor'/%3E%3C/svg%3E");
  background: var(--treb-formula-bar-lock-icon-color, currentColor);
  mask-position: center;
  -webkit-mask-position: center;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-image: var(--icon);
  -webkit-mask-image: var(--icon);
  mask-size: 12px 12px;
  -webkit-mask-size: 12px 12px;
}
.treb-main.treb-main.treb-ua-windows .grid-cells {
  font-size: var(--treb-grid-font-size-windows, var(--treb-grid-font-size, 12pt));
  font-family: var(--treb-grid-font-family-windows, var(--treb-grid-font-family, "Calibri", "BlinkMacSystemFont", "Segoe UI", "Roboto", "Oxygen-Sans", "Ubuntu", "Cantarell", "Helvetica Neue", "sans-serif"));
}
.treb-main.treb-main.treb-ua-osx .grid-cells {
  font-size: var(--treb-grid-font-size-osx, var(--treb-grid-font-size, 10pt));
  font-family: var(--treb-grid-font-family-osx, var(--treb-grid-font-family, inherit));
}

/*
 * This file is part of TREB.
 *
 * TREB is free software: you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *
 * TREB is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with TREB. If not, see <https://www.gnu.org/licenses/>. 
 *
 * Copyright 2022-2024 trebco, llc. 
 * info@treb.app
 * 
 */
/**
 * we'll add dark theme, and auto support, but not automatically.
 */
.treb-dark-theme {
  --treb-autocomplete-background: #333;
  --treb-autocomplete-border-color: #fff;
  --treb-autocomplete-entry-color: #fff;
  --treb-autocomplete-selected-entry-background: darkred;
  --treb-autocomplete-tooltip-background: darkred;
  --treb-autocomplete-tooltip-border-color: #fff;
  --treb-autocomplete-tooltip-color: #fff;
  --treb-chart-background: #000;
  --treb-chart-grid-color: #976;
  --treb-chart-text-color: #fff;
  --treb-dialog-background: #000;
  --treb-dialog-color: #fff;
  --treb-dropdown-background: #000;
  --treb-dropdown-border-color: #fff;
  --treb-dropdown-caret-active-background: darkred;
  --treb-dropdown-caret-background: #444;
  --treb-dropdown-caret-border-color: #fff;
  --treb-dropdown-caret-color: #fff;
  --treb-dropdown-color: #fff;
  --treb-dropdown-selected-background: darkred;
  --treb-grid-background: #000;
  --treb-grid-default-color: #fff;
  --treb-grid-grid-color: #444;
  --treb-grid-header-background: #444;
  --treb-grid-header-grid-color: #000;
  --treb-note-background: #333;
  --treb-note-border-color: #aaa;
  --treb-note-color: #fff;
  --treb-note-marker-color: pink;
  --treb-resize-tooltip-background: #fff;
  --treb-resize-tooltip-color: #000;
  --treb-scale-slider-accent-color: #fff;
  --treb-scale-slider-background: #333;
  --treb-scale-slider-border-color: #aaa;
  --treb-selection-color: yellow;
  --treb-selection-fill-opacity: .2;
  --treb-sidebar-button-background: #000;
  --treb-sidebar-button-border-color: #888;
  --treb-stats-value-background: #223;
  --treb-tab-bar-active-tab-background: #444;
  --treb-tab-bar-tab-background: #000;
  --treb-tab-bar-tab-color: #fff;
  --treb-theme-color-1: #222;
  --treb-theme-color-2: #ddd;
  --treb-toolbar-active-button-background: #555;
  --treb-toolbar-button-background: #000;
  --treb-toolbar-hover-button-background: #444;
  --treb-ui-color: #fff;
  --treb-table-header-background: #334;
  --treb-table-odd-background: #122;
  --treb-table-header-font-weight: 700;
  --treb-table-header-border-top: #889;
  --treb-table-header-border-bottom: #889;
  --treb-table-footer-border-bottom: #889;
  --treb-table-odd-border-top: #889;
  --treb-table-odd-border-bottom: #889;
  --treb-table-even-border-top: #889;
  --treb-table-even-border-bottom: #889;
  --treb-table-total-border-top: #889;
  --treb-table-total-border-bottom: #889;
  --treb-table-total-background: #334;
  --treb-table-total-font-weight: 700;
  --treb-color-scheme: dark;
  --treb-resize-handle-color: lightblue;
  --treb-resize-frame-color: lightblue;
  --treb-formula-bar-locked-background: #234;
  --treb-grid-background: rgb(30,30,30);
  --treb-grid-header-background: rgb(86,86,86);
  --treb-grid-header-color: rgb(221,221,221);
  --treb-tab-bar-active-tab-background: field;
  --treb-tab-bar-tab-background: transparent;
  --treb-tab-bar-tab-border-color: #444;
  --treb-ui-border-color: #aaa;
  --treb-toolbar-button-background: rgb(86,86,86);
  --treb-toolbar-button-background: rgb(33,33,33);
  --treb-toolbar-border-color: rgb(67,67,67);
  --treb-toolbar-color: rgb(221,221,221);
}

@media (prefers-color-scheme: dark) {
  .treb-light-dark-theme {
    --treb-autocomplete-background: #333;
    --treb-autocomplete-border-color: #fff;
    --treb-autocomplete-entry-color: #fff;
    --treb-autocomplete-selected-entry-background: darkred;
    --treb-autocomplete-tooltip-background: darkred;
    --treb-autocomplete-tooltip-border-color: #fff;
    --treb-autocomplete-tooltip-color: #fff;
    --treb-chart-background: #000;
    --treb-chart-grid-color: #976;
    --treb-chart-text-color: #fff;
    --treb-dialog-background: #000;
    --treb-dialog-color: #fff;
    --treb-dropdown-background: #000;
    --treb-dropdown-border-color: #fff;
    --treb-dropdown-caret-active-background: darkred;
    --treb-dropdown-caret-background: #444;
    --treb-dropdown-caret-border-color: #fff;
    --treb-dropdown-caret-color: #fff;
    --treb-dropdown-color: #fff;
    --treb-dropdown-selected-background: darkred;
    --treb-grid-background: #000;
    --treb-grid-default-color: #fff;
    --treb-grid-grid-color: #444;
    --treb-grid-header-background: #444;
    --treb-grid-header-grid-color: #000;
    --treb-note-background: #333;
    --treb-note-border-color: #aaa;
    --treb-note-color: #fff;
    --treb-note-marker-color: pink;
    --treb-resize-tooltip-background: #fff;
    --treb-resize-tooltip-color: #000;
    --treb-scale-slider-accent-color: #fff;
    --treb-scale-slider-background: #333;
    --treb-scale-slider-border-color: #aaa;
    --treb-selection-color: yellow;
    --treb-selection-fill-opacity: .2;
    --treb-sidebar-button-background: #000;
    --treb-sidebar-button-border-color: #888;
    --treb-stats-value-background: #223;
    --treb-tab-bar-active-tab-background: #444;
    --treb-tab-bar-tab-background: #000;
    --treb-tab-bar-tab-color: #fff;
    --treb-theme-color-1: #222;
    --treb-theme-color-2: #ddd;
    --treb-toolbar-active-button-background: #555;
    --treb-toolbar-button-background: #000;
    --treb-toolbar-hover-button-background: #444;
    --treb-ui-color: #fff;
    --treb-table-header-background: #334;
    --treb-table-odd-background: #122;
    --treb-table-header-font-weight: 700;
    --treb-table-header-border-top: #889;
    --treb-table-header-border-bottom: #889;
    --treb-table-footer-border-bottom: #889;
    --treb-table-odd-border-top: #889;
    --treb-table-odd-border-bottom: #889;
    --treb-table-even-border-top: #889;
    --treb-table-even-border-bottom: #889;
    --treb-table-total-border-top: #889;
    --treb-table-total-border-bottom: #889;
    --treb-table-total-background: #334;
    --treb-table-total-font-weight: 700;
    --treb-color-scheme: dark;
    --treb-resize-handle-color: lightblue;
    --treb-resize-frame-color: lightblue;
    --treb-formula-bar-locked-background: #234;
    --treb-grid-background: rgb(30,30,30);
    --treb-grid-header-background: rgb(86,86,86);
    --treb-grid-header-color: rgb(221,221,221);
    --treb-tab-bar-active-tab-background: field;
    --treb-tab-bar-tab-background: transparent;
    --treb-tab-bar-tab-border-color: #444;
    --treb-ui-border-color: #aaa;
    --treb-toolbar-button-background: rgb(86,86,86);
    --treb-toolbar-button-background: rgb(33,33,33);
    --treb-toolbar-border-color: rgb(67,67,67);
    --treb-toolbar-color: rgb(221,221,221);
  }
}
/*
 * This file is part of TREB.
 *
 * TREB is free software: you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *
 * TREB is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with TREB. If not, see <https://www.gnu.org/licenses/>. 
 *
 * Copyright 2022-2024 trebco, llc. 
 * info@treb.app
 * 
 */
/**
 * rebuilding, try to keep it sane
 *
 * NOTE: this file uses the color-mod() function and a postcss library
 * to translate it. that function is no longer in the spec and will be 
 * implemented differently, so this will probably need to change.
 *
 * originally this file used sass so we used some sass library functions
 * to do the same thing. all we are doing is (1) set alpha on a color and
 * (2) darken a color.
 *
 * UPDATE to support scaling: we won't explicitly set font size (or family).
 * those should be set in containing nodes, possibly from theme or style.
 * we will base our scale 100 at font size 10pt, and scale from there.
 *
 * UPDATE: the color-mod function is no longer used, not sure where it went
 * UPDATE: back to sass, but still using this file (compiles fine)
 */
.treb-main.treb-main .treb-chart, .treb-chart {
  background: var(--treb-chart-background, #fff);
}

/* container style */
.treb-chart {
  /** 
   * default theme. the way we do this now is assign color from the theme, 
   * then optionally set fill/stroke via currentColor. that reduces the number
   * of times we have to define the same colors.
   */
  /* chart title, at top or bottom */
  /* axis labels */
  /* default text color */
  /* legend uses matching series colors */
  /* grid */
  /* mouse elements */
  /* old type of line chart */
  /**
   * area chart has separate parts for line and area
   * (because the line doesn't go up and down the sides)
   */
  /* scatter plot line (and marker -- change that class name) */
  /* donut/pie */
  /* HISTOGRAM NEEDS CLEANUP (IN LAYOUT) */
  /* SO DOES CORRELATION CHART */
}
.treb-chart .series-1 {
  color: var(--treb-chart-color-series-1, #80B1D3);
}
.treb-chart .series-2 {
  color: var(--treb-chart-color-series-2, #8DD3C7);
}
.treb-chart .series-3 {
  color: var(--treb-chart-color-series-3, #BEBADA);
}
.treb-chart .series-4 {
  color: var(--treb-chart-color-series-4, #FB8072);
}
.treb-chart .series-5 {
  color: var(--treb-chart-color-series-5, #FDB462);
}
.treb-chart .series-6 {
  color: var(--treb-chart-color-series-6, #B3DE69);
}
.treb-chart .series-7 {
  color: var(--treb-chart-color-series-7, #FCCDE5);
}
.treb-chart .series-8 {
  color: var(--treb-chart-color-series-8, #D9D9D9);
}
.treb-chart .series-9 {
  color: var(--treb-chart-color-series-9, #BC80BD);
}
.treb-chart .series-10 {
  color: var(--treb-chart-color-series-10, #CCEBC5);
}
.treb-chart .series-11 {
  color: var(--treb-chart-color-series-11, #FFED6F);
}
.treb-chart .series-12 {
  color: var(--treb-chart-color-series-12, #FFFFB3);
}
.treb-chart .chart-title {
  font-size: 1.4em;
}
.treb-chart .axis-group {
  font-size: 0.9em;
}
.treb-chart text {
  fill: var(--treb-chart-text-color, #000);
  stroke: none;
}
.treb-chart .legend {
  font-size: 1.05em;
}
.treb-chart .legend rect {
  fill: currentColor;
}
.treb-chart .chart-grid, .treb-chart .chart-ticks {
  stroke: var(--treb-chart-grid-color, #ddd);
}
.treb-chart .label-target {
  stroke: none;
  fill: transparent;
}
.treb-chart path.label-target {
  transition: fill 0.2s;
}
.treb-chart path.label-target:hover {
  fill: rgba(0, 0, 0, 0.15);
}
.treb-chart .data-label {
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease-in-out;
}
.treb-chart .data-label text {
  fill: #fff;
}
.treb-chart .data-label path {
  fill: #000;
}
.treb-chart .data-label .marker-highlight {
  fill: currentColor;
  stroke: none;
}
.treb-chart .label-target:hover + .data-label {
  opacity: 1;
}
.treb-chart .chart-line {
  stroke: currentColor;
  fill: none;
  stroke-width: 2;
}
.treb-chart .chart-area .line {
  stroke: currentColor;
  stroke-width: 2px;
  fill: none;
}
.treb-chart .chart-area .fill {
  fill: currentColor;
  opacity: 0.5;
}
.treb-chart .bubble-chart {
  stroke-width: 3;
  fill: color-mix(in srgb, currentColor 75%, transparent);
  stroke: currentColor;
}
.treb-chart .scatter-plot {
  stroke-width: 3;
  fill: none;
  stroke: currentColor;
  /**
   * circle marker
   */
}
.treb-chart .scatter-plot .fill {
  fill: currentColor;
  opacity: 0.5;
  stroke: none;
}
.treb-chart .scatter-plot .marker {
  stroke-width: 2.5px;
  fill: #fff;
  transition: stroke-width 0.15s ease-in;
}
.treb-chart .scatter-plot .marker:hover {
  stroke-width: 5px;
}
.treb-chart .donut {
  /* this is the dotted line to callouts */
  /* this is the actual label */
}
.treb-chart .donut path {
  fill: currentColor; /* has to be attached to path for IE11 */
}
.treb-chart .donut path.callout {
  fill: none;
  stroke: #999;
  stroke-dasharray: 2 2;
}
.treb-chart .donut text.callout-label {
  /* font-size: 10pt; */
  font-size: 1em;
}
.treb-chart .chart-column {
  fill: currentColor;
  stroke: none;
}
.treb-chart .mc-correlation {
  stroke: currentColor;
  stroke-width: 1;
}

/*
 * This file is part of TREB.
 *
 * TREB is free software: you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *
 * TREB is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with TREB. If not, see <https://www.gnu.org/licenses/>. 
 *
 * Copyright 2022-2024 trebco, llc. 
 * info@treb.app
 * 
 */
.treb-main.treb-main {
  --treb-icon-svg: url("data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E%3Csvg version='1.1' id='Layer_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='153.073px' height='133.742px' viewBox='0.673 4.629 153.073 133.742' enable-background='new 0.673 4.629 153.073 133.742' xml:space='preserve'%3E%3ClinearGradient id='SVGID_1_' gradientUnits='userSpaceOnUse' x1='0.6729' y1='71.5' x2='153.7461' y2='71.5'%3E%3Cstop offset='0' style='stop-color:%235CB5FF'/%3E%3Cstop offset='1' style='stop-color:%230059B9'/%3E%3C/linearGradient%3E%3Cpath fill='url(%23SVGID_1_)' d='M91.656,28.313c-4.989,0-17.266,6.249-21.305,8.504c-2.344-2.473-2.603-6.162-3.036-10.933 c-2.344,2.429-0.824,9.806,0,12.496c-10.238,7.635-18.83,15.531-27.597,24.471c-2.992-4.729-5.031-8.593-5.726-17.183 c-3.038,6.509,0.867,15.057,3.121,19.784c-9.674,12.193-19.263,25.297-27.03,37.834C-25.405,28.313,82.936-16.248,153.746,14.431 C109.879,43.63,98.554,135.784,21.498,111.274c-5.423,7.809-9.069,18.006-13.538,27.072c-3.73,0.263-6.334-1.646-7.288-3.12 c7.506-18.181,17.183-34.192,27.075-49.984c10.718,0.306,21.346,0.478,30.198-1.04c-7.681-2.038-16.877-0.78-26.032-3.123 c5.597-10.718,13.754-18.876,21.867-27.075c8.808,0.782,17.746,3.21,27.074,1.041c-8.111-1.431-15.966-1.952-22.909-4.165 C65.539,42.502,80.722,33.389,91.656,28.313z'/%3E%3C/svg%3E%0A");
}
.treb-main.treb-main .treb-icon-64 {
  width: 64px;
  height: 64px;
  background: no-repeat center/100% var(--treb-icon-svg);
}
.treb-main.treb-main .treb-dialog-mask {
  position: absolute;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
  z-index: 1000;
  display: flex;
  justify-content: center;
  align-items: center;
  opacity: 0;
  transition: opacity 0.2s;
  pointer-events: none;
}
.treb-main.treb-main .treb-embed-dialog {
  line-height: 1.6em;
  font-size: var(--treb-dialog-font-size, 16px);
  border: 1px solid var(--treb-dialog-border-color, var(--treb-ui-border-color, #999));
  box-shadow: 0 4px 6px -4px rgba(0, 0, 0, 0.3);
  border-top-width: 3px;
  border-top-color: rgb(0, 157, 255);
  border-top-color: rgb(158, 175, 185);
  border-top-color: #999;
  display: flex;
  flex-direction: row;
  align-items: center;
  position: relative;
  padding: 1rem;
  background: var(--treb-dialog-background, #fff);
  color: var(--treb-dialog-color, #000);
  text-align: left;
  border-radius: 3px;
  /* middle: title, message and (maybe) progress bar */
}
.treb-main.treb-main .treb-embed-dialog > * {
  display: none;
}
.treb-main.treb-main .treb-embed-dialog > div {
  position: relative;
}
.treb-main.treb-main .treb-embed-dialog > *:nth-child(2) {
  flex-grow: 1;
  display: block;
  padding: 2px 12px;
  padding-right: 20px;
}
.treb-main.treb-main .treb-embed-dialog > .treb-close-box {
  position: absolute;
  top: 0;
  right: 0px;
  padding: 0;
  background: transparent;
  border: 0;
  padding: 4px;
}
.treb-main.treb-main .treb-embed-dialog > .treb-close-box > svg {
  fill: rgb(115, 130, 140);
  width: 20px;
  height: 20px;
  cursor: default;
}
.treb-main.treb-main .treb-embed-dialog > .treb-close-box > svg:hover, .treb-main.treb-main .treb-embed-dialog > .treb-close-box > svg:active {
  fill: rgb(4, 156, 251);
}
.treb-main.treb-main .treb-embed-dialog small {
  font-size: 0.9em;
  display: block;
}
.treb-main.treb-main .treb-embed-dialog a {
  text-decoration: none;
  color: inherit;
}
.treb-main.treb-main .treb-embed-dialog a:hover, .treb-main.treb-main .treb-embed-dialog a:active {
  color: rgb(4, 156, 251);
}
.treb-main.treb-main .treb-embed-dialog.dialog-type-success {
  border-top-width: 3px;
  border-top-color: rgb(68, 217, 38);
}
.treb-main.treb-main .treb-embed-dialog.dialog-type-about {
  border-top-width: 3px;
  border-top-color: rgb(0, 157, 255);
}
.treb-main.treb-main .treb-embed-dialog.dialog-type-error {
  border-top-width: 3px;
  border-top-color: rgb(249, 47, 6);
}
.treb-main.treb-main .treb-embed-dialog.dialog-type-info {
  border-top-width: 3px;
  border-top-color: rgb(0, 157, 255);
}
.treb-main.treb-main .treb-embed-dialog .treb-embed-dialog-title {
  white-space: pre;
}
.treb-main.treb-main .treb-embed-dialog .treb-embed-dialog-message {
  white-space: pre;
}
.treb-main.treb-main .treb-embed-dialog .treb-embed-progress-container {
  position: relative;
  border: 1px solid red;
  width: 100%;
  height: 6px;
  border: 1px solid #ddd;
  margin: auto;
  margin-top: 1rem;
  margin-bottom: 0.5rem;
}
.treb-main.treb-main .treb-embed-dialog .treb-embed-progress-bar {
  position: relative;
  background: #52880b;
  top: 0px;
  left: 0px;
  height: 100%;
}

/*
 * This file is part of TREB.
 *
 * TREB is free software: you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *
 * TREB is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with TREB. If not, see <https://www.gnu.org/licenses/>. 
 *
 * Copyright 2022-2024 trebco, llc. 
 * info@treb.app
 * 
 */
.treb-main.treb-main .treb-spinner {
  position: absolute;
  top: 0px;
  left: 0px;
  background: transparent;
  width: 100%;
  height: 100%;
  z-index: 1000;
  align-items: center;
  justify-content: center;
  transition: visibility 0.25s, opacity 0.25s ease;
  opacity: 0;
  display: flex;
  visibility: collapse;
}
.treb-main.treb-main .treb-spinner.visible {
  opacity: 1;
  transition: visibility 0s, opacity 1s ease;
  visibility: visible;
}
.treb-main.treb-main .treb-spinner > div {
  display: inline-block;
  position: relative;
  width: 80px;
  height: 80px;
}
.treb-main.treb-main .treb-spinner > div div {
  box-sizing: border-box;
  display: block;
  position: absolute;
  width: 64px;
  height: 64px;
  margin: 8px;
  border: 8px solid #fff;
  border-radius: 50%;
  animation: treb-spinner 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
  border-color: var(--treb-spinner-color, currentColor) transparent transparent transparent;
}
.treb-main.treb-main .treb-spinner > div div:nth-child(1) {
  animation-delay: -0.45s;
}
.treb-main.treb-main .treb-spinner > div div:nth-child(2) {
  animation-delay: -0.3s;
}
.treb-main.treb-main .treb-spinner > div div:nth-child(3) {
  animation-delay: -0.15s;
}
@keyframes treb-spinner {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

/*
 * scope these to the node and we can use shorter names
 */
.treb-main.treb-main {
  /* source: bootstrap-icons-1.8.3/x.svg */
  --icon-x: url("data:image/svg+xml, <svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'><path d='M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z'/></svg>");
  /* source: fontawesome-free-5.15.4-desktop/svgs/solid/external-link-alt.svg */
  --icon-popout: url("data:image/svg+xml, <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 28 28'><path stroke='none' fill='currentColor' d='M22 14.5v5c0 2.484-2.016 4.5-4.5 4.5h-13c-2.484 0-4.5-2.016-4.5-4.5v-13c0-2.484 2.016-4.5 4.5-4.5h11c0.281 0 0.5 0.219 0.5 0.5v1c0 0.281-0.219 0.5-0.5 0.5h-11c-1.375 0-2.5 1.125-2.5 2.5v13c0 1.375 1.125 2.5 2.5 2.5h13c1.375 0 2.5-1.125 2.5-2.5v-5c0-0.281 0.219-0.5 0.5-0.5h1c0.281 0 0.5 0.219 0.5 0.5zM28 1v8c0 0.547-0.453 1-1 1-0.266 0-0.516-0.109-0.703-0.297l-2.75-2.75-10.187 10.187c-0.094 0.094-0.234 0.156-0.359 0.156s-0.266-0.063-0.359-0.156l-1.781-1.781c-0.094-0.094-0.156-0.234-0.156-0.359s0.063-0.266 0.156-0.359l10.187-10.187-2.75-2.75c-0.187-0.187-0.297-0.438-0.297-0.703 0-0.547 0.453-1 1-1h8c0.547 0 1 0.453 1 1z'></path></svg>");
  /* source: fontawesome-free-5.15.4-desktop/svgs/solid/sliders-h.svg */
  --icon-toolbar: url("data:image/svg+xml, <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 28'><path stroke='none' fill='currentColor' d='M5.5 22v2h-5.5v-2h5.5zM11 20c0.547 0 1 0.453 1 1v4c0 0.547-0.453 1-1 1h-4c-0.547 0-1-0.453-1-1v-4c0-0.547 0.453-1 1-1h4zM13.5 14v2h-13.5v-2h13.5zM3.5 6v2h-3.5v-2h3.5zM24 22v2h-11.5v-2h11.5zM9 4c0.547 0 1 0.453 1 1v4c0 0.547-0.453 1-1 1h-4c-0.547 0-1-0.453-1-1v-4c0-0.547 0.453-1 1-1h4zM19 12c0.547 0 1 0.453 1 1v4c0 0.547-0.453 1-1 1h-4c-0.547 0-1-0.453-1-1v-4c0-0.547 0.453-1 1-1h4zM24 14v2h-3.5v-2h3.5zM24 6v2h-13.5v-2h13.5z'></path></svg>");
  /* source: fontawesome-free-5.15.4-desktop/svgs/solid/download.svg */
  --icon-export: url("data:image/svg+xml, <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 26 28'><path stroke='none' fill='currentColor' d='M20 21c0-0.547-0.453-1-1-1s-1 0.453-1 1 0.453 1 1 1 1-0.453 1-1zM24 21c0-0.547-0.453-1-1-1s-1 0.453-1 1 0.453 1 1 1 1-0.453 1-1zM26 17.5v5c0 0.828-0.672 1.5-1.5 1.5h-23c-0.828 0-1.5-0.672-1.5-1.5v-5c0-0.828 0.672-1.5 1.5-1.5h7.266l2.109 2.125c0.578 0.562 1.328 0.875 2.125 0.875s1.547-0.313 2.125-0.875l2.125-2.125h7.25c0.828 0 1.5 0.672 1.5 1.5zM20.922 8.609c0.156 0.375 0.078 0.812-0.219 1.094l-7 7c-0.187 0.203-0.453 0.297-0.703 0.297s-0.516-0.094-0.703-0.297l-7-7c-0.297-0.281-0.375-0.719-0.219-1.094 0.156-0.359 0.516-0.609 0.922-0.609h4v-7c0-0.547 0.453-1 1-1h4c0.547 0 1 0.453 1 1v7h4c0.406 0 0.766 0.25 0.922 0.609z'></path></svg>");
  /* source: fontawesome-free-5.15.4-desktop/svgs/solid/sync-alt.svg */
  --icon-reset: url("data:image/svg+xml, <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 28'><path stroke='none' fill='currentColor' d='M23.609 16.5c0 0.031 0 0.078-0.016 0.109-1.328 5.531-5.891 9.391-11.656 9.391-3.047 0-6-1.203-8.219-3.313l-2.016 2.016c-0.187 0.187-0.438 0.297-0.703 0.297-0.547 0-1-0.453-1-1v-7c0-0.547 0.453-1 1-1h7c0.547 0 1 0.453 1 1 0 0.266-0.109 0.516-0.297 0.703l-2.141 2.141c1.469 1.375 3.422 2.156 5.437 2.156 2.781 0 5.359-1.437 6.813-3.813 0.375-0.609 0.562-1.203 0.828-1.828 0.078-0.219 0.234-0.359 0.469-0.359h3c0.281 0 0.5 0.234 0.5 0.5zM24 4v7c0 0.547-0.453 1-1 1h-7c-0.547 0-1-0.453-1-1 0-0.266 0.109-0.516 0.297-0.703l2.156-2.156c-1.484-1.375-3.437-2.141-5.453-2.141-2.781 0-5.359 1.437-6.813 3.813-0.375 0.609-0.562 1.203-0.828 1.828-0.078 0.219-0.234 0.359-0.469 0.359h-3.109c-0.281 0-0.5-0.234-0.5-0.5v-0.109c1.344-5.547 5.953-9.391 11.719-9.391 3.063 0 6.047 1.219 8.266 3.313l2.031-2.016c0.187-0.187 0.438-0.297 0.703-0.297 0.547 0 1 0.453 1 1z'></path></svg>");
  /* source: fontawesome-free-5.15.4-desktop/svgs/solid/question-circle.svg */
  --icon-about: url("data:image/svg+xml, <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 28'><path stroke='none' fill='currentColor' d='M14 21.5v-3c0-0.281-0.219-0.5-0.5-0.5h-3c-0.281 0-0.5 0.219-0.5 0.5v3c0 0.281 0.219 0.5 0.5 0.5h3c0.281 0 0.5-0.219 0.5-0.5zM18 11c0-2.859-3-5-5.688-5-2.547 0-4.453 1.094-5.797 3.328-0.141 0.219-0.078 0.5 0.125 0.656l2.063 1.563c0.078 0.063 0.187 0.094 0.297 0.094 0.141 0 0.297-0.063 0.391-0.187 0.734-0.938 1.047-1.219 1.344-1.437 0.266-0.187 0.781-0.375 1.344-0.375 1 0 1.922 0.641 1.922 1.328 0 0.812-0.422 1.219-1.375 1.656-1.109 0.5-2.625 1.797-2.625 3.313v0.562c0 0.281 0.219 0.5 0.5 0.5h3c0.281 0 0.5-0.219 0.5-0.5v0c0-0.359 0.453-1.125 1.188-1.547 1.188-0.672 2.812-1.578 2.812-3.953zM24 14c0 6.625-5.375 12-12 12s-12-5.375-12-12 5.375-12 12-12 12 5.375 12 12z'></path></svg>");
  /* source: fontawesome-free-5.15.4-desktop/svgs/solid/chevron-left.svg */
  --icon-chevron-left: url("data:image/svg+xml, <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 21 28'><path stroke='none' fill='currentColor' d='M18.297 4.703l-8.297 8.297 8.297 8.297c0.391 0.391 0.391 1.016 0 1.406l-2.594 2.594c-0.391 0.391-1.016 0.391-1.406 0l-11.594-11.594c-0.391-0.391-0.391-1.016 0-1.406l11.594-11.594c0.391-0.391 1.016-0.391 1.406 0l2.594 2.594c0.391 0.391 0.391 1.016 0 1.406z'></path></svg>");
  /* source: fontawesome-free-5.15.4-desktop/svgs/solid/chevron-right.svg */
  --icon-chevron-right: url("data:image/svg+xml, <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 19 28'><path stroke='none' fill='currentColor' d='M17.297 13.703l-11.594 11.594c-0.391 0.391-1.016 0.391-1.406 0l-2.594-2.594c-0.391-0.391-0.391-1.016 0-1.406l8.297-8.297-8.297-8.297c-0.391-0.391-0.391-1.016 0-1.406l2.594-2.594c0.391-0.391 1.016-0.391 1.406 0l11.594 11.594c0.391 0.391 0.391 1.016 0 1.406z'></path></svg>");
  /* source: fontawesome-free-5.15.4-desktop/svgs/solid/history.svg */
  --icon-revert: url("data:image/svg+xml, <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 28'><path stroke='none' fill='currentColor' d='M24 14c0 6.609-5.391 12-12 12-3.578 0-6.953-1.578-9.234-4.328-0.156-0.203-0.141-0.5 0.031-0.672l2.141-2.156c0.109-0.094 0.25-0.141 0.391-0.141 0.141 0.016 0.281 0.078 0.359 0.187 1.531 1.984 3.828 3.109 6.312 3.109 4.406 0 8-3.594 8-8s-3.594-8-8-8c-2.047 0-3.984 0.781-5.437 2.141l2.141 2.156c0.297 0.281 0.375 0.719 0.219 1.078-0.156 0.375-0.516 0.625-0.922 0.625h-7c-0.547 0-1-0.453-1-1v-7c0-0.406 0.25-0.766 0.625-0.922 0.359-0.156 0.797-0.078 1.078 0.219l2.031 2.016c2.203-2.078 5.187-3.313 8.266-3.313 6.609 0 12 5.391 12 12zM14 9.5v7c0 0.281-0.219 0.5-0.5 0.5h-5c-0.281 0-0.5-0.219-0.5-0.5v-1c0-0.281 0.219-0.5 0.5-0.5h3.5v-5.5c0-0.281 0.219-0.5 0.5-0.5h1c0.281 0 0.5 0.219 0.5 0.5z'></path></svg>");
  /* source: bootstrap-icons-1.8.3/text-left.svg */
  --icon-text-align-left: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path fill-rule='evenodd' d='M2 12.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm0-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5zm0-3a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm0-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5z'/> </svg>");
  /* source: bootstrap-icons-1.8.3/text-center.svg */
  --icon-text-align-center: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path fill-rule='evenodd' d='M4 12.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm-2-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5zm2-3a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm-2-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5z'/> </svg>");
  /* source: bootstrap-icons-1.8.3/text-right.svg */
  --icon-text-align-right: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path fill-rule='evenodd' d='M6 12.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm-4-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5zm4-3a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm-4-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5z'/> </svg>");
  /* source: treb/align-up.svg */
  --icon-text-align-top: url("data:image/svg+xml,<?xml version='1.0' encoding='utf-8'?> <svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='16px' height='16px' viewBox='0 0 16 16' enable-background='new 0 0 16 16' xml:space='preserve'> <path d='M8,15c0.276,0,0.5-0.224,0.5-0.5V5.707l3.146,3.146c0.195,0.195,0.512,0.195,0.707,0s0.195-0.512,0-0.707l-4-4 C8.159,3.951,7.842,3.95,7.647,4.145c0,0,0,0-0.001,0.001l-4,4c-0.195,0.195-0.195,0.512,0,0.707s0.513,0.195,0.708,0L7.5,5.707 V14.5C7.5,14.776,7.724,15,8,15z'/> <line fill='none' stroke='%23000000' stroke-linecap='round' stroke-linejoin='round' stroke-miterlimit='10' x1='3' y1='1.5' x2='13' y2='1.5'/> </svg> ");
  /* source: bootstrap-icons-1.8.3/arrows-collapse.svg */
  --icon-text-align-middle: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path fill-rule='evenodd' d='M1 8a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13A.5.5 0 0 1 1 8zm7-8a.5.5 0 0 1 .5.5v3.793l1.146-1.147a.5.5 0 0 1 .708.708l-2 2a.5.5 0 0 1-.708 0l-2-2a.5.5 0 1 1 .708-.708L7.5 4.293V.5A.5.5 0 0 1 8 0zm-.5 11.707-1.146 1.147a.5.5 0 0 1-.708-.708l2-2a.5.5 0 0 1 .708 0l2 2a.5.5 0 0 1-.708.708L8.5 11.707V15.5a.5.5 0 0 1-1 0v-3.793z'/> </svg>");
  /* source: treb/align-down.svg */
  --icon-text-align-bottom: url("data:image/svg+xml,<?xml version='1.0' encoding='utf-8'?> <svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='16px' height='16px' viewBox='0 0 16 16' enable-background='new 0 0 16 16' xml:space='preserve'> <path d='M8,1C7.724,1,7.5,1.224,7.5,1.5v8.793L4.354,7.146c-0.195-0.195-0.512-0.195-0.707,0s-0.195,0.512,0,0.707l4,4 c0.195,0.195,0.512,0.196,0.707,0.001c0,0,0,0,0.001-0.001l4-4c0.195-0.195,0.195-0.512,0-0.707s-0.513-0.195-0.708,0L8.5,10.293 V1.5C8.5,1.224,8.276,1,8,1z'/> <line fill='none' stroke='%23000000' stroke-linecap='round' stroke-linejoin='round' stroke-miterlimit='10' x1='13' y1='14.5' x2='3' y2='14.5'/> </svg> ");
  /* source: bootstrap-icons-1.8.3/folder.svg */
  --icon-file-menu: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path d='M.54 3.87.5 3a2 2 0 0 1 2-2h3.672a2 2 0 0 1 1.414.586l.828.828A2 2 0 0 0 9.828 3h3.982a2 2 0 0 1 1.992 2.181l-.637 7A2 2 0 0 1 13.174 14H2.826a2 2 0 0 1-1.991-1.819l-.637-7a1.99 1.99 0 0 1 .342-1.31zM2.19 4a1 1 0 0 0-.996 1.09l.637 7a1 1 0 0 0 .995.91h10.348a1 1 0 0 0 .995-.91l.637-7A1 1 0 0 0 13.81 4H2.19zm4.69-1.707A1 1 0 0 0 6.172 2H2.5a1 1 0 0 0-1 .981l.006.139C1.72 3.042 1.95 3 2.19 3h5.396l-.707-.707z'/> </svg>");
  /* source: treb/wrap.svg */
  --icon-wrap-text: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'> <path d='M4,5h8c0.276,0,0.5-0.224,0.5-0.5S12.276,4,12,4H4C3.724,4,3.5,4.224,3.5,4.5S3.724,5,4,5z'/> <path d='M10,8H4C3.724,8,3.5,8.224,3.5,8.5S3.724,9,4,9h6c0.828,0,1.5,0.672,1.5,1.5S10.828,12,10,12v-1.203l-2.953,1.707 L10,14.203V13c1.381,0,2.5-1.119,2.5-2.5S11.381,8,10,8z'/> <path d='M3.75,12.5c0,0.276,0.224,0.5,0.5,0.5H6v-1H4.25C3.974,12,3.75,12.224,3.75,12.5z'/> </svg> ");
  /* source: bootstrap-icons-1.8.3/fullscreen.svg */
  --icon-unmerge-cells: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path d='M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z'/> </svg>");
  /* source: bootstrap-icons-1.8.3/fullscreen-exit.svg */
  --icon-merge-cells: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path d='M5.5 0a.5.5 0 0 1 .5.5v4A1.5 1.5 0 0 1 4.5 6h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5zm5 0a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 10 4.5v-4a.5.5 0 0 1 .5-.5zM0 10.5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 6 11.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zm10 1a1.5 1.5 0 0 1 1.5-1.5h4a.5.5 0 0 1 0 1h-4a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4z'/> </svg>");
  /* source: bootstrap-icons-1.8.3/lock.svg */
  --icon-lock: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path d='M8 1a2 2 0 0 1 2 2v4H6V3a2 2 0 0 1 2-2zm3 6V3a3 3 0 0 0-6 0v4a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2zM5 8h6a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1z'/> </svg>");
  /* source: bootstrap-icons-1.8.3/chat-square.svg */
  --icon-comment: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path d='M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1h-2.5a2 2 0 0 0-1.6.8L8 14.333 6.1 11.8a2 2 0 0 0-1.6-.8H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h2.5a1 1 0 0 1 .8.4l1.9 2.533a1 1 0 0 0 1.6 0l1.9-2.533a1 1 0 0 1 .8-.4H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z'/> </svg>");
  /* source: bootstrap-icons-1.8.3/paint-bucket.svg */
  --icon-fill-color: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path d='M6.192 2.78c-.458-.677-.927-1.248-1.35-1.643a2.972 2.972 0 0 0-.71-.515c-.217-.104-.56-.205-.882-.02-.367.213-.427.63-.43.896-.003.304.064.664.173 1.044.196.687.556 1.528 1.035 2.402L.752 8.22c-.277.277-.269.656-.218.918.055.283.187.593.36.903.348.627.92 1.361 1.626 2.068.707.707 1.441 1.278 2.068 1.626.31.173.62.305.903.36.262.05.64.059.918-.218l5.615-5.615c.118.257.092.512.05.939-.03.292-.068.665-.073 1.176v.123h.003a1 1 0 0 0 1.993 0H14v-.057a1.01 1.01 0 0 0-.004-.117c-.055-1.25-.7-2.738-1.86-3.494a4.322 4.322 0 0 0-.211-.434c-.349-.626-.92-1.36-1.627-2.067-.707-.707-1.441-1.279-2.068-1.627-.31-.172-.62-.304-.903-.36-.262-.05-.64-.058-.918.219l-.217.216zM4.16 1.867c.381.356.844.922 1.311 1.632l-.704.705c-.382-.727-.66-1.402-.813-1.938a3.283 3.283 0 0 1-.131-.673c.091.061.204.15.337.274zm.394 3.965c.54.852 1.107 1.567 1.607 2.033a.5.5 0 1 0 .682-.732c-.453-.422-1.017-1.136-1.564-2.027l1.088-1.088c.054.12.115.243.183.365.349.627.92 1.361 1.627 2.068.706.707 1.44 1.278 2.068 1.626.122.068.244.13.365.183l-4.861 4.862a.571.571 0 0 1-.068-.01c-.137-.027-.342-.104-.608-.252-.524-.292-1.186-.8-1.846-1.46-.66-.66-1.168-1.32-1.46-1.846-.147-.265-.225-.47-.251-.607a.573.573 0 0 1-.01-.068l3.048-3.047zm2.87-1.935a2.44 2.44 0 0 1-.241-.561c.135.033.324.11.562.241.524.292 1.186.8 1.846 1.46.45.45.83.901 1.118 1.31a3.497 3.497 0 0 0-1.066.091 11.27 11.27 0 0 1-.76-.694c-.66-.66-1.167-1.322-1.458-1.847z'/> </svg>");
  /* source: treb/letter.svg */
  --icon-text-color: url("data:image/svg+xml,<?xml version='1.0' encoding='utf-8'?> <svg version='1.1' id='Layer_2' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='16px' height='16px' viewBox='0 0 16 16' enable-background='new 0 0 16 16' xml:space='preserve'> <g> <path d='M12.259,14.001l-1.389-3.727H5.465l-1.354,3.727H2.811L7.609,1.397h1.178l4.772,12.604H12.259z M8.418,3.604 c-0.041-0.111-0.084-0.24-0.127-0.387C8.246,3.07,8.21,2.903,8.181,2.716H8.146C8.11,2.903,8.07,3.07,8.027,3.217 C7.982,3.363,7.94,3.492,7.899,3.604L5.86,9.211h4.614L8.418,3.604z'/> </g> </svg> ");
  /* source: bootstrap-icons-1.8.3/border-bottom.svg */
  --icon-border-bottom: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path d='M.969 0H0v.969h.5V1h.469V.969H1V.5H.969V0zm.937 1h.938V0h-.938v1zm1.875 0h.938V0H3.78v1zm1.875 0h.938V0h-.938v1zM7.531.969V1h.938V.969H8.5V.5h-.031V0H7.53v.5H7.5v.469h.031zM9.406 1h.938V0h-.938v1zm1.875 0h.938V0h-.938v1zm1.875 0h.938V0h-.938v1zm1.875 0h.469V.969h.5V0h-.969v.5H15v.469h.031V1zM1 2.844v-.938H0v.938h1zm6.5-.938v.938h1v-.938h-1zm7.5 0v.938h1v-.938h-1zM1 4.719V3.78H0v.938h1zm6.5-.938v.938h1V3.78h-1zm7.5 0v.938h1V3.78h-1zM1 6.594v-.938H0v.938h1zm6.5-.938v.938h1v-.938h-1zm7.5 0v.938h1v-.938h-1zM.5 8.5h.469v-.031H1V7.53H.969V7.5H.5v.031H0v.938h.5V8.5zm1.406 0h.938v-1h-.938v1zm1.875 0h.938v-1H3.78v1zm1.875 0h.938v-1h-.938v1zm2.813 0v-.031H8.5V7.53h-.031V7.5H7.53v.031H7.5v.938h.031V8.5h.938zm.937 0h.938v-1h-.938v1zm1.875 0h.938v-1h-.938v1zm1.875 0h.938v-1h-.938v1zm1.875 0h.469v-.031h.5V7.53h-.5V7.5h-.469v.031H15v.938h.031V8.5zM0 9.406v.938h1v-.938H0zm7.5 0v.938h1v-.938h-1zm8.5.938v-.938h-1v.938h1zm-16 .937v.938h1v-.938H0zm7.5 0v.938h1v-.938h-1zm8.5.938v-.938h-1v.938h1zm-16 .937v.938h1v-.938H0zm7.5 0v.938h1v-.938h-1zm8.5.938v-.938h-1v.938h1zM0 15h16v1H0v-1z'/> </svg>");
  /* source: bootstrap-icons-1.8.3/border-top.svg */
  --icon-border-top: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path d='M0 0v1h16V0H0zm1 2.844v-.938H0v.938h1zm6.5-.938v.938h1v-.938h-1zm7.5 0v.938h1v-.938h-1zM1 4.719V3.78H0v.938h1zm6.5-.938v.938h1V3.78h-1zm7.5 0v.938h1V3.78h-1zM1 6.594v-.938H0v.938h1zm6.5-.938v.938h1v-.938h-1zm7.5 0v.938h1v-.938h-1zM.5 8.5h.469v-.031H1V7.53H.969V7.5H.5v.031H0v.938h.5V8.5zm1.406 0h.938v-1h-.938v1zm1.875 0h.938v-1H3.78v1zm1.875 0h.938v-1h-.938v1zm2.813 0v-.031H8.5V7.53h-.031V7.5H7.53v.031H7.5v.938h.031V8.5h.938zm.937 0h.938v-1h-.938v1zm1.875 0h.938v-1h-.938v1zm1.875 0h.938v-1h-.938v1zm1.875 0h.469v-.031h.5V7.53h-.5V7.5h-.469v.031H15v.938h.031V8.5zM0 9.406v.938h1v-.938H0zm7.5 0v.938h1v-.938h-1zm8.5.938v-.938h-1v.938h1zm-16 .937v.938h1v-.938H0zm7.5 0v.938h1v-.938h-1zm8.5.938v-.938h-1v.938h1zm-16 .937v.938h1v-.938H0zm7.5 0v.938h1v-.938h-1zm8.5.938v-.938h-1v.938h1zM0 16h.969v-.5H1v-.469H.969V15H.5v.031H0V16zm1.906 0h.938v-1h-.938v1zm1.875 0h.938v-1H3.78v1zm1.875 0h.938v-1h-.938v1zm1.875-.5v.5h.938v-.5H8.5v-.469h-.031V15H7.53v.031H7.5v.469h.031zm1.875.5h.938v-1h-.938v1zm1.875 0h.938v-1h-.938v1zm1.875 0h.938v-1h-.938v1zm1.875-.5v.5H16v-.969h-.5V15h-.469v.031H15v.469h.031z'/> </svg>");
  /* source: bootstrap-icons-1.8.3/border-left.svg */
  --icon-border-left: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path d='M0 0v16h1V0H0zm1.906 1h.938V0h-.938v1zm1.875 0h.938V0H3.78v1zm1.875 0h.938V0h-.938v1zM7.531.969V1h.938V.969H8.5V.5h-.031V0H7.53v.5H7.5v.469h.031zM9.406 1h.938V0h-.938v1zm1.875 0h.938V0h-.938v1zm1.875 0h.938V0h-.938v1zm1.875 0h.469V.969h.5V0h-.969v.5H15v.469h.031V1zM7.5 1.906v.938h1v-.938h-1zm7.5 0v.938h1v-.938h-1zM7.5 3.781v.938h1V3.78h-1zm7.5 0v.938h1V3.78h-1zM7.5 5.656v.938h1v-.938h-1zm7.5 0v.938h1v-.938h-1zM1.906 8.5h.938v-1h-.938v1zm1.875 0h.938v-1H3.78v1zm1.875 0h.938v-1h-.938v1zm2.813 0v-.031H8.5V7.53h-.031V7.5H7.53v.031H7.5v.938h.031V8.5h.938zm.937 0h.938v-1h-.938v1zm1.875 0h.938v-1h-.938v1zm1.875 0h.938v-1h-.938v1zm1.875 0h.469v-.031h.5V7.53h-.5V7.5h-.469v.031H15v.938h.031V8.5zM7.5 9.406v.938h1v-.938h-1zm8.5.938v-.938h-1v.938h1zm-8.5.937v.938h1v-.938h-1zm8.5.938v-.938h-1v.938h1zm-8.5.937v.938h1v-.938h-1zm8.5.938v-.938h-1v.938h1zM1.906 16h.938v-1h-.938v1zm1.875 0h.938v-1H3.78v1zm1.875 0h.938v-1h-.938v1zm1.875-.5v.5h.938v-.5H8.5v-.469h-.031V15H7.53v.031H7.5v.469h.031zm1.875.5h.938v-1h-.938v1zm1.875 0h.938v-1h-.938v1zm1.875 0h.938v-1h-.938v1zm1.875-.5v.5H16v-.969h-.5V15h-.469v.031H15v.469h.031z'/> </svg>");
  /* source: bootstrap-icons-1.8.3/border-right.svg */
  --icon-border-right: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path d='M.969 0H0v.969h.5V1h.469V.969H1V.5H.969V0zm.937 1h.938V0h-.938v1zm1.875 0h.938V0H3.78v1zm1.875 0h.938V0h-.938v1zM7.531.969V1h.938V.969H8.5V.5h-.031V0H7.53v.5H7.5v.469h.031zM9.406 1h.938V0h-.938v1zm1.875 0h.938V0h-.938v1zm1.875 0h.938V0h-.938v1zM16 0h-1v16h1V0zM1 2.844v-.938H0v.938h1zm6.5-.938v.938h1v-.938h-1zM1 4.719V3.78H0v.938h1zm6.5-.938v.938h1V3.78h-1zM1 6.594v-.938H0v.938h1zm6.5-.938v.938h1v-.938h-1zM.5 8.5h.469v-.031H1V7.53H.969V7.5H.5v.031H0v.938h.5V8.5zm1.406 0h.938v-1h-.938v1zm1.875 0h.938v-1H3.78v1zm1.875 0h.938v-1h-.938v1zm2.813 0v-.031H8.5V7.53h-.031V7.5H7.53v.031H7.5v.938h.031V8.5h.938zm.937 0h.938v-1h-.938v1zm1.875 0h.938v-1h-.938v1zm1.875 0h.938v-1h-.938v1zM0 9.406v.938h1v-.938H0zm7.5 0v.938h1v-.938h-1zM0 11.281v.938h1v-.938H0zm7.5 0v.938h1v-.938h-1zM0 13.156v.938h1v-.938H0zm7.5 0v.938h1v-.938h-1zM0 16h.969v-.5H1v-.469H.969V15H.5v.031H0V16zm1.906 0h.938v-1h-.938v1zm1.875 0h.938v-1H3.78v1zm1.875 0h.938v-1h-.938v1zm1.875-.5v.5h.938v-.5H8.5v-.469h-.031V15H7.53v.031H7.5v.469h.031zm1.875.5h.938v-1h-.938v1zm1.875 0h.938v-1h-.938v1zm1.875 0h.938v-1h-.938v1z'/> </svg>");
  /* source: treb/border-double-bottom.svg */
  --icon-border-double-bottom: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' width='16px' height='16px' viewBox='0 0 16 16' > <path d='M0.969,0H0v0.969h0.5V1h0.469V0.969H1V0.5H0.969V0z M1.906,1h0.938V0H1.906V1z M3.781,1h0.938V0H3.78v1H3.781z M5.656,1 h0.938V0H5.656V1z M7.531,0.969V1h0.938V0.969H8.5V0.5H8.469V0H7.53v0.5H7.5v0.469H7.531z M9.406,1h0.938V0H9.406V1z M11.281,1 h0.938V0h-0.938V1z M13.156,1h0.938V0h-0.938V1z M15.031,1H15.5V0.969H16V0h-0.969v0.5H15v0.469h0.031V1z M1,2.844V1.906H0v0.938H1z M7.5,1.906v0.938h1V1.906H7.5z M15,1.906v0.938h1V1.906H15z M1,4.719V3.78H0v0.938L1,4.719L1,4.719z M7.5,3.781v0.938h1V3.78h-1 V3.781z M15,3.781v0.938h1V3.78h-1V3.781z M1,6.594V5.656H0v0.938H1z M7.5,5.656v0.938h1V5.656H7.5z M15,5.656v0.938h1V5.656H15z M0.5,8.5h0.469V8.469H1V7.53H0.969V7.5H0.5v0.031H0v0.938h0.5V8.5z M1.906,8.5h0.938v-1H1.906V8.5z M3.781,8.5h0.938v-1H3.78v1 H3.781z M5.656,8.5h0.938v-1H5.656V8.5z M8.469,8.5V8.469H8.5V7.53H8.469V7.5H7.53v0.031H7.5v0.938h0.031V8.5H8.469z M9.406,8.5 h0.938v-1H9.406V8.5z M11.281,8.5h0.938v-1h-0.938V8.5z M13.156,8.5h0.938v-1h-0.938V8.5z M15.031,8.5H15.5V8.469H16V7.53h-0.5V7.5 h-0.469v0.031H15v0.938h0.031V8.5z M0,9.406v0.938h1V9.406H0z M7.5,9.406v0.938h1V9.406H7.5z M16,10.344V9.406h-1v0.938H16z M0,11.281v0.938h1v-0.938H0z M7.5,11.281v0.938h1v-0.938H7.5z M16,12.219v-0.938h-1v0.938H16z M0,15h16v1H0V15z M0,13h16v1H0V13z' /> </svg> ");
  /* source: bootstrap-icons-1.8.3/border-all.svg */
  --icon-border-all: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path d='M0 0h16v16H0V0zm1 1v6.5h6.5V1H1zm7.5 0v6.5H15V1H8.5zM15 8.5H8.5V15H15V8.5zM7.5 15V8.5H1V15h6.5z'/> </svg>");
  /* source: bootstrap-icons-1.8.3/border-outer.svg */
  --icon-border-outer: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path d='M7.5 1.906v.938h1v-.938h-1zm0 1.875v.938h1V3.78h-1zm0 1.875v.938h1v-.938h-1zM1.906 8.5h.938v-1h-.938v1zm1.875 0h.938v-1H3.78v1zm1.875 0h.938v-1h-.938v1zm2.813 0v-.031H8.5V7.53h-.031V7.5H7.53v.031H7.5v.938h.031V8.5h.938zm.937 0h.938v-1h-.938v1zm1.875 0h.938v-1h-.938v1zm1.875 0h.938v-1h-.938v1zM7.5 9.406v.938h1v-.938h-1zm0 1.875v.938h1v-.938h-1zm0 1.875v.938h1v-.938h-1z'/> <path d='M0 0v16h16V0H0zm1 1h14v14H1V1z'/> </svg>");
  /* source: bootstrap-icons-1.8.3/border.svg */
  --icon-border-none: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path d='M0 0h.969v.5H1v.469H.969V1H.5V.969H0V0zm2.844 1h-.938V0h.938v1zm1.875 0H3.78V0h.938v1zm1.875 0h-.938V0h.938v1zm.937 0V.969H7.5V.5h.031V0h.938v.5H8.5v.469h-.031V1H7.53zm2.813 0h-.938V0h.938v1zm1.875 0h-.938V0h.938v1zm1.875 0h-.938V0h.938v1zM15.5 1h-.469V.969H15V.5h.031V0H16v.969h-.5V1zM1 1.906v.938H0v-.938h1zm6.5.938v-.938h1v.938h-1zm7.5 0v-.938h1v.938h-1zM1 3.78v.938H0V3.78h1zm6.5.938V3.78h1v.938h-1zm7.5 0V3.78h1v.938h-1zM1 5.656v.938H0v-.938h1zm6.5.938v-.938h1v.938h-1zm7.5 0v-.938h1v.938h-1zM.969 8.5H.5v-.031H0V7.53h.5V7.5h.469v.031H1v.938H.969V8.5zm1.875 0h-.938v-1h.938v1zm1.875 0H3.78v-1h.938v1zm1.875 0h-.938v-1h.938v1zm1.875-.031V8.5H7.53v-.031H7.5V7.53h.031V7.5h.938v.031H8.5v.938h-.031zm1.875.031h-.938v-1h.938v1zm1.875 0h-.938v-1h.938v1zm1.875 0h-.938v-1h.938v1zm1.406 0h-.469v-.031H15V7.53h.031V7.5h.469v.031h.5v.938h-.5V8.5zM0 10.344v-.938h1v.938H0zm7.5 0v-.938h1v.938h-1zm8.5-.938v.938h-1v-.938h1zM0 12.22v-.938h1v.938H0zm7.5 0v-.938h1v.938h-1zm8.5-.938v.938h-1v-.938h1zM0 14.094v-.938h1v.938H0zm7.5 0v-.938h1v.938h-1zm8.5-.938v.938h-1v-.938h1zM.969 16H0v-.969h.5V15h.469v.031H1v.469H.969v.5zm1.875 0h-.938v-1h.938v1zm1.875 0H3.78v-1h.938v1zm1.875 0h-.938v-1h.938v1zm.937 0v-.5H7.5v-.469h.031V15h.938v.031H8.5v.469h-.031v.5H7.53zm2.813 0h-.938v-1h.938v1zm1.875 0h-.938v-1h.938v1zm1.875 0h-.938v-1h.938v1zm.937 0v-.5H15v-.469h.031V15h.469v.031h.5V16h-.969z'/> </svg>");
  /* source: bootstrap-icons-1.8.3/palette2.svg */
  --icon-palette: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path d='M0 .5A.5.5 0 0 1 .5 0h5a.5.5 0 0 1 .5.5v5.277l4.147-4.131a.5.5 0 0 1 .707 0l3.535 3.536a.5.5 0 0 1 0 .708L10.261 10H15.5a.5.5 0 0 1 .5.5v5a.5.5 0 0 1-.5.5H3a2.99 2.99 0 0 1-2.121-.879A2.99 2.99 0 0 1 0 13.044m6-.21 7.328-7.3-2.829-2.828L6 7.188v5.647zM4.5 13a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0zM15 15v-4H9.258l-4.015 4H15zM0 .5v12.495V.5z'/> <path d='M0 12.995V13a3.07 3.07 0 0 0 0-.005z'/> </svg>");
  /* source: treb/square.svg */
  --icon-layout: url("data:image/svg+xml,<?xml version='1.0' encoding='utf-8'?> <svg version='1.1' id='Layer_3' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='20px' height='20px' viewBox='0 0 20 20' enable-background='new 0 0 20 20' xml:space='preserve'> <polygon points='3,0 20,17.156 20,17.042 '/> <polygon points='3,0 0,0 0,16 1,16 1,1 2.585,1 19,17.455 19,19 4,19 4,20 20,20 20,17.156 '/> <path d='M6.886,3.922L5.343,5.465c-0.195,0.195-0.195,0.511,0,0.707c0.196,0.195,0.512,0.195,0.708,0l1.539-1.54L6.886,3.922z'/> <path d='M9.702,6.763l-1.53,1.53C7.977,8.488,7.977,8.805,8.172,9c0.195,0.196,0.512,0.196,0.707,0l1.526-1.526L9.702,6.763z'/> <path d='M12.517,9.604L11,11.121c-0.195,0.195-0.195,0.512,0,0.707s0.512,0.195,0.707,0l1.514-1.514L12.517,9.604z'/> <path d='M15.332,12.445l-1.504,1.504c-0.195,0.195-0.195,0.512,0,0.707s0.512,0.195,0.707,0l1.501-1.5L15.332,12.445z'/> <path d='M1,16H0c0,2.209,1.791,4,4,4v-1C2.346,19,1,17.654,1,16z'/> <path d='M5,9v6h6L5,9z M6,11.414L8.586,14H6V11.414z'/> </svg> ");
  /* source: bootstrap-icons-1.8.3/snow.svg */
  --icon-freeze: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path d='M8 16a.5.5 0 0 1-.5-.5v-1.293l-.646.647a.5.5 0 0 1-.707-.708L7.5 12.793V8.866l-3.4 1.963-.496 1.85a.5.5 0 1 1-.966-.26l.237-.882-1.12.646a.5.5 0 0 1-.5-.866l1.12-.646-.884-.237a.5.5 0 1 1 .26-.966l1.848.495L7 8 3.6 6.037l-1.85.495a.5.5 0 0 1-.258-.966l.883-.237-1.12-.646a.5.5 0 1 1 .5-.866l1.12.646-.237-.883a.5.5 0 1 1 .966-.258l.495 1.849L7.5 7.134V3.207L6.147 1.854a.5.5 0 1 1 .707-.708l.646.647V.5a.5.5 0 1 1 1 0v1.293l.647-.647a.5.5 0 1 1 .707.708L8.5 3.207v3.927l3.4-1.963.496-1.85a.5.5 0 1 1 .966.26l-.236.882 1.12-.646a.5.5 0 0 1 .5.866l-1.12.646.883.237a.5.5 0 1 1-.26.966l-1.848-.495L9 8l3.4 1.963 1.849-.495a.5.5 0 0 1 .259.966l-.883.237 1.12.646a.5.5 0 0 1-.5.866l-1.12-.646.236.883a.5.5 0 1 1-.966.258l-.495-1.849-3.4-1.963v3.927l1.353 1.353a.5.5 0 0 1-.707.708l-.647-.647V15.5a.5.5 0 0 1-.5.5z'/> </svg>");
  /* source: treb/column-chart.svg */
  --icon-column-chart: url("data:image/svg+xml,<?xml version='1.0' encoding='utf-8'?> <svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='20px' height='20px' viewBox='0 0 20 20' enable-background='new 0 0 20 20' xml:space='preserve'> <path d='M4.5,17.5C4.5,17.776,4.276,18,4,18l0,0c-0.276,0-0.5-0.224-0.5-0.5v-5C3.5,12.224,3.724,12,4,12l0,0 c0.276,0,0.5,0.224,0.5,0.5V17.5z'/> <path d='M12.5,17.5c0,0.276-0.224,0.5-0.5,0.5l0,0c-0.276,0-0.5-0.224-0.5-0.5v-9C11.5,8.224,11.724,8,12,8l0,0 c0.276,0,0.5,0.224,0.5,0.5V17.5z'/> <path d='M16.5,17.5c0,0.276-0.224,0.5-0.5,0.5l0,0c-0.276,0-0.5-0.224-0.5-0.5v-13C15.5,4.224,15.724,4,16,4l0,0 c0.276,0,0.5,0.224,0.5,0.5V17.5z'/> <path d='M8.5,17.5C8.5,17.776,8.276,18,8,18l0,0c-0.276,0-0.5-0.224-0.5-0.5v-14C7.5,3.224,7.724,3,8,3l0,0 c0.276,0,0.5,0.224,0.5,0.5V17.5z'/> </svg> ");
  /* source: treb/donut-chart.svg */
  --icon-donut-chart: url("data:image/svg+xml,<?xml version='1.0' encoding='utf-8'?> <svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='20px' height='20px' viewBox='0 0 20 20' enable-background='new 0 0 20 20' xml:space='preserve'> <path d='M12,1.23v1.548C14.526,3.479,16.5,5.477,17.203,8h1.565C18.004,4.639,15.362,1.995,12,1.23z'/> <path d='M2.5,10c0-3.51,2.426-6.456,5.688-7.27V1.183C4.085,2.021,1,5.65,1,10c0,1.761,0.513,3.397,1.387,4.784l1.093-1.093 C2.859,12.601,2.5,11.343,2.5,10z'/> <path d='M17.221,12c-0.878,3.166-3.778,5.5-7.221,5.5c-1.343,0-2.601-0.359-3.692-0.979l-1.093,1.093C6.603,18.487,8.24,19,10,19 c4.282,0,7.859-2.993,8.77-7H17.221z'/> </svg> ");
  /* source: treb/bar-chart.svg */
  --icon-bar-chart: url("data:image/svg+xml,<?xml version='1.0' encoding='utf-8'?> <svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='20px' height='20px' viewBox='0 0 20 20' enable-background='new 0 0 20 20' xml:space='preserve'> <path d='M2.5,4.5C2.224,4.5,2,4.276,2,4l0,0c0-0.276,0.224-0.5,0.5-0.5h5C7.776,3.5,8,3.724,8,4l0,0c0,0.276-0.224,0.5-0.5,0.5H2.5z '/> <path d='M2.5,12.5C2.224,12.5,2,12.276,2,12l0,0c0-0.276,0.224-0.5,0.5-0.5h9c0.276,0,0.5,0.224,0.5,0.5l0,0 c0,0.276-0.224,0.5-0.5,0.5H2.5z'/> <path d='M2.5,16.5C2.224,16.5,2,16.276,2,16l0,0c0-0.276,0.224-0.5,0.5-0.5h13c0.276,0,0.5,0.224,0.5,0.5l0,0 c0,0.276-0.224,0.5-0.5,0.5H2.5z'/> <path d='M2.5,8.5C2.224,8.5,2,8.276,2,8l0,0c0-0.276,0.224-0.5,0.5-0.5h14C16.776,7.5,17,7.724,17,8l0,0c0,0.276-0.224,0.5-0.5,0.5 H2.5z'/> </svg> ");
  /* source: treb/line-chart.svg */
  --icon-line-chart: url("data:image/svg+xml,<?xml version='1.0' encoding='utf-8'?> <svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='20px' height='20px' viewBox='0 0 20 20' enable-background='new 0 0 20 20' xml:space='preserve'> <polygon points='1,8 4,5 11,10 19,2 19,4 11,12 4,7 1,10 '/> </svg> ");
  /* source: bootstrap-icons-1.8.3/image.svg */
  --icon-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path d='M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z'/> <path d='M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z'/> </svg>");
  /* source: treb/rotate.svg */
  --icon-recalculate: url("data:image/svg+xml,<?xml version='1.0' encoding='utf-8'?> <svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='20px' height='20px' viewBox='0 0 20 20' enable-background='new 0 0 20 20' xml:space='preserve'> <path d='M9.478,4.022c2.402-0.209,4.583,1.047,5.711,3.014l1.083-0.095c-1.233-2.528-3.912-4.175-6.881-3.916 c-2.97,0.26-5.321,2.347-6.098,5.051l1.083-0.095C5.144,5.849,7.074,4.233,9.478,4.022z'/> <path d='M10.523,15.977c-2.403,0.211-4.585-1.047-5.712-3.013l-1.08,0.095c1.234,2.527,3.91,4.175,6.879,3.914 c2.971-0.259,5.32-2.347,6.095-5.05l-1.08,0.095C14.856,14.15,12.926,15.767,10.523,15.977z'/> <polygon points='2.272,15.616 7.469,12.616 3.371,11.519 '/> <polygon points='17.728,4.384 12.531,7.384 16.629,8.482 '/> <path d='M10,10'/> </svg> ");
  /* source: bootstrap-icons-1.8.3/check2.svg */
  --icon-check: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'> <path d='M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z'/> </svg>");
  /* source: bootstrap-icons-1.8.3/table.svg */
  --icon-table: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' viewBox='0 0 16 16'><path d='M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2zm15 2h-4v3h4V4zm0 4h-4v3h4V8zm0 4h-4v3h3a1 1 0 0 0 1-1v-2zm-5 3v-3H6v3h4zm-5 0v-3H1v2a1 1 0 0 0 1 1h3zm-4-4h4V8H1v3zm0-4h4V4H1v3zm5-3v3h4V4H6zm4 4H6v3h4V8z'/></svg>");
}

.treb-main.treb-main .treb-layout-header {
  overflow: hidden;
  position: relative;
  overflow-x: scroll;
  -ms-overflow-style: none;
  scrollbar-width: none;
}
.treb-main.treb-main .treb-layout-header::-webkit-scrollbar {
  display: none;
}
.treb-main.treb-main .treb-toolbar {
  color: var(--treb-toolbar-color, var(--treb-ui-color, #333));
  font-size: var(--treb-toolbar-font-size, inherit);
  display: flex;
  flex-direction: row;
  gap: 0.5rem;
}
.treb-main.treb-main .treb-toolbar > div {
  display: flex;
  flex-direction: row;
}
.treb-main.treb-main .treb-toolbar > input, .treb-main.treb-main .treb-toolbar > div > input {
  height: 32px;
  background-color: var(--treb-toolbar-button-background, transparent);
  border: 1px solid var(--treb-toolbar-border-color, var(--treb-ui-border-color, rgb(209, 213, 219)));
  text-overflow: ellipsis;
  overflow: hidden;
  padding-left: 0.5em;
  padding-right: 0.5em;
}
.treb-main.treb-main .treb-toolbar > .treb-menu > button {
  border-radius: 3px;
}
.treb-main.treb-main .treb-toolbar > .group > button + button, .treb-main.treb-main .treb-toolbar > .group > input + button, .treb-main.treb-main .treb-toolbar > .group > input + .treb-menu > button, .treb-main.treb-main .treb-toolbar > .group > button + .treb-menu > button, .treb-main.treb-main .treb-toolbar > .group > .treb-menu + button, .treb-main.treb-main .treb-toolbar > [composite] > button + button, .treb-main.treb-main .treb-toolbar > [composite] > input + button, .treb-main.treb-main .treb-toolbar > [composite] > input + .treb-menu > button, .treb-main.treb-main .treb-toolbar > [composite] > button + .treb-menu > button, .treb-main.treb-main .treb-toolbar > [composite] > .treb-menu + button {
  border-left-width: 0px;
}
.treb-main.treb-main .treb-toolbar > .group > button:first-child, .treb-main.treb-main .treb-toolbar > .group > input:first-child, .treb-main.treb-main .treb-toolbar > [composite] > button:first-child, .treb-main.treb-main .treb-toolbar > [composite] > input:first-child {
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}
.treb-main.treb-main .treb-toolbar > .group > button:last-child, .treb-main.treb-main .treb-toolbar > .group > .treb-menu:last-child > button, .treb-main.treb-main .treb-toolbar > [composite] > button:last-child, .treb-main.treb-main .treb-toolbar > [composite] > .treb-menu:last-child > button {
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}
.treb-main.treb-main .treb-toolbar > button, .treb-main.treb-main .treb-toolbar > div > button, .treb-main.treb-main .treb-toolbar .treb-menu > button, .treb-main.treb-main .treb-toolbar button[data-icon], .treb-main.treb-main .treb-toolbar .treb-icon-buttons > button {
  width: 32px;
  height: 32px;
  background-color: var(--treb-toolbar-button-background, transparent);
  border: 1px solid var(--treb-toolbar-border-color, var(--treb-ui-border-color, rgb(209, 213, 219)));
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
}
.treb-main.treb-main .treb-toolbar > button[dropdown], .treb-main.treb-main .treb-toolbar > div > button[dropdown], .treb-main.treb-main .treb-toolbar .treb-menu > button[dropdown], .treb-main.treb-main .treb-toolbar button[data-icon][dropdown], .treb-main.treb-main .treb-toolbar .treb-icon-buttons > button[dropdown] {
  width: 16px;
}
.treb-main.treb-main .treb-toolbar > button[dropdown]::after, .treb-main.treb-main .treb-toolbar > div > button[dropdown]::after, .treb-main.treb-main .treb-toolbar .treb-menu > button[dropdown]::after, .treb-main.treb-main .treb-toolbar button[data-icon][dropdown]::after, .treb-main.treb-main .treb-toolbar .treb-icon-buttons > button[dropdown]::after {
  box-sizing: content-box;
  content: "";
  position: absolute;
  width: 0px;
  height: 0px;
  border: 5px solid transparent;
  border-top-color: currentColor;
  top: 18px;
  left: 50%;
  transform: translate(-50%, -50%);
}
.treb-main.treb-main .treb-toolbar > button:hover, .treb-main.treb-main .treb-toolbar > button[active], .treb-main.treb-main .treb-toolbar > div > button:hover, .treb-main.treb-main .treb-toolbar > div > button[active], .treb-main.treb-main .treb-toolbar .treb-menu > button:hover, .treb-main.treb-main .treb-toolbar .treb-menu > button[active], .treb-main.treb-main .treb-toolbar button[data-icon]:hover, .treb-main.treb-main .treb-toolbar button[data-icon][active], .treb-main.treb-main .treb-toolbar .treb-icon-buttons > button:hover, .treb-main.treb-main .treb-toolbar .treb-icon-buttons > button[active] {
  background-color: var(--treb-toolbar-hover-button-background, #f3f4f6);
}
.treb-main.treb-main .treb-toolbar > button[data-color-bar]::after, .treb-main.treb-main .treb-toolbar > div > button[data-color-bar]::after, .treb-main.treb-main .treb-toolbar .treb-menu > button[data-color-bar]::after, .treb-main.treb-main .treb-toolbar button[data-icon][data-color-bar]::after, .treb-main.treb-main .treb-toolbar .treb-icon-buttons > button[data-color-bar]::after {
  content: "";
  box-sizing: border-box;
  position: relative;
  display: block;
  width: 20px;
  height: 6px;
  border: 1px solid var(--treb-toolbar-border-color, var(--treb-ui-border-color, rgb(209, 213, 219)));
  background: var(--treb-color-bar-color, var(--treb-default-color, unset));
}
.treb-main.treb-main .treb-toolbar > button[data-icon]::before, .treb-main.treb-main .treb-toolbar > button[data-command]::before, .treb-main.treb-main .treb-toolbar > div > button[data-icon]::before, .treb-main.treb-main .treb-toolbar > div > button[data-command]::before, .treb-main.treb-main .treb-toolbar .treb-menu > button[data-icon]::before, .treb-main.treb-main .treb-toolbar .treb-menu > button[data-command]::before, .treb-main.treb-main .treb-toolbar button[data-icon][data-icon]::before, .treb-main.treb-main .treb-toolbar button[data-icon][data-command]::before, .treb-main.treb-main .treb-toolbar .treb-icon-buttons > button[data-icon]::before, .treb-main.treb-main .treb-toolbar .treb-icon-buttons > button[data-command]::before {
  content: "";
  display: block;
  position: relative;
  background: currentColor;
  width: 20px;
  height: 20px;
  mask-position: center;
  -webkit-mask-position: center;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-image: var(--icon);
  -webkit-mask-image: var(--icon);
  mask-size: var(--icon-size, 16px 16px);
  -webkit-mask-size: var(--icon-size, 16px 16px);
}
.treb-main.treb-main .treb-toolbar .treb-split {
  display: flex;
  flex-direction: column;
  gap: 0;
}
.treb-main.treb-main .treb-toolbar .treb-split button[data-command] {
  font-size: 10px;
}
.treb-main.treb-main .treb-toolbar .treb-split button[data-command]::before {
  display: none;
}
.treb-main.treb-main .treb-toolbar .treb-split > button {
  height: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
}
.treb-main.treb-main .treb-toolbar .treb-split > button:first-child {
  border-top-left-radius: 3px;
  border-top-right-radius: 3px;
}
.treb-main.treb-main .treb-toolbar .treb-split > button:last-child {
  border-top: 0;
  border-bottom-left-radius: 3px;
  border-bottom-right-radius: 3px;
}
.treb-main.treb-main .treb-toolbar .treb-menu {
  outline: none;
}
.treb-main.treb-main .treb-toolbar .treb-menu > div {
  display: none;
  margin-top: 0.5rem;
  flex-direction: column;
  background: var(--treb-toolbar-button-background, #fff);
  border: 1px solid var(--treb-toolbar-border-color, var(--treb-ui-border-color, rgb(209, 213, 219)));
  border-radius: 3px;
  position: fixed;
  z-index: 20;
  top: 48px;
  box-shadow: 0 4px 6px -4px rgba(0, 0, 0, 0.4);
}
.treb-main.treb-main .treb-toolbar .treb-menu > div button {
  white-space: nowrap;
  background: transparent;
  border: 0;
  text-align: left;
  padding: 0.4rem 1rem;
  margin: 3px 0;
  transition: background-color 0.125s ease;
}
.treb-main.treb-main .treb-toolbar .treb-menu > div button:hover {
  background: var(--treb-toolbar-hover-button-background, #f3f4f6);
}
.treb-main.treb-main .treb-toolbar .treb-menu > div.treb-icon-buttons > button, .treb-main.treb-main .treb-toolbar .treb-menu > div.treb-icon-buttons > .treb-menu > button {
  padding: 0;
}
.treb-main.treb-main .treb-toolbar .treb-menu > div > [separator] {
  background: var(--treb-toolbar-border-color, var(--treb-ui-border-color, rgb(209, 213, 219)));
  height: 1px;
  margin: 2px 0;
}
.treb-main.treb-main .treb-toolbar .treb-menu:focus-within > div, .treb-main.treb-main .treb-toolbar .treb-menu.visible > div {
  display: flex;
}
.treb-main.treb-main .treb-toolbar [data-icon=file-menu] {
  --icon: var(--icon-file-menu);
}
.treb-main.treb-main .treb-toolbar [data-command=justify-left] {
  --icon: var(--icon-text-align-left);
}
.treb-main.treb-main .treb-toolbar [data-command=justify-right] {
  --icon: var(--icon-text-align-right);
}
.treb-main.treb-main .treb-toolbar [data-command=justify-center] {
  --icon: var(--icon-text-align-center);
}
.treb-main.treb-main .treb-toolbar [data-command=align-top] {
  --icon: var(--icon-text-align-top);
}
.treb-main.treb-main .treb-toolbar [data-command=align-middle] {
  --icon: var(--icon-text-align-middle);
}
.treb-main.treb-main .treb-toolbar [data-command=align-bottom] {
  --icon: var(--icon-text-align-bottom);
}
.treb-main.treb-main .treb-toolbar [data-command=merge-cells] {
  --icon: var(--icon-merge-cells);
}
.treb-main.treb-main .treb-toolbar [data-command=unmerge-cells] {
  --icon: var(--icon-unmerge-cells);
}
.treb-main.treb-main .treb-toolbar [data-command=fill-color] {
  --icon: var(--icon-fill-color);
}
.treb-main.treb-main .treb-toolbar [data-command=text-color] {
  --icon: var(--icon-text-color);
}
.treb-main.treb-main .treb-toolbar [data-command=lock-cells] {
  --icon: var(--icon-lock);
}
.treb-main.treb-main .treb-toolbar [data-command=wrap-text] {
  --icon: var(--icon-wrap-text);
}
.treb-main.treb-main .treb-toolbar [data-icon=comment] {
  --icon: var(--icon-comment);
}
.treb-main.treb-main .treb-toolbar [data-icon=table] {
  --icon: var(--icon-table);
}
.treb-main.treb-main .treb-toolbar [data-icon=layout] {
  --icon: var(--icon-layout);
}
.treb-main.treb-main .treb-toolbar [data-command=freeze-panes] {
  --icon: var(--icon-freeze);
}
.treb-main.treb-main .treb-toolbar [data-command=insert-column-chart] {
  --icon: var(--icon-column-chart);
}
.treb-main.treb-main .treb-toolbar [data-command=insert-donut-chart] {
  --icon: var(--icon-donut-chart);
}
.treb-main.treb-main .treb-toolbar [data-command=insert-bar-chart] {
  --icon: var(--icon-bar-chart);
}
.treb-main.treb-main .treb-toolbar [data-command=insert-line-chart] {
  --icon: var(--icon-line-chart);
}
.treb-main.treb-main .treb-toolbar [data-command=insert-image] {
  --icon: var(--icon-image);
}
.treb-main.treb-main .treb-toolbar [data-command=border-bottom] {
  --icon: var(--icon-border-bottom);
}
.treb-main.treb-main .treb-toolbar [data-command=border-left] {
  --icon: var(--icon-border-left);
}
.treb-main.treb-main .treb-toolbar [data-command=border-right] {
  --icon: var(--icon-border-right);
}
.treb-main.treb-main .treb-toolbar [data-command=border-top] {
  --icon: var(--icon-border-top);
}
.treb-main.treb-main .treb-toolbar [data-command=border-outside] {
  --icon: var(--icon-border-outer);
}
.treb-main.treb-main .treb-toolbar [data-command=border-all] {
  --icon: var(--icon-border-all);
}
.treb-main.treb-main .treb-toolbar [data-command=border-none] {
  --icon: var(--icon-border-none);
}
.treb-main.treb-main .treb-toolbar [data-command=border-double-bottom] {
  --icon: var(--icon-border-double-bottom);
}
.treb-main.treb-main .treb-toolbar [data-icon=palette] {
  --icon: var(--icon-palette);
}
.treb-main.treb-main .treb-toolbar [data-command=recalculate] {
  --icon: var(--icon-recalculate);
  --icon-size: 20px 20px;
}
.treb-main.treb-main .treb-toolbar .treb-font-scale {
  width: 4em;
}
.treb-main.treb-main .treb-toolbar .treb-number-format {
  width: 8em;
}
.treb-main.treb-main .treb-toolbar .treb-color-chooser button[data-command=set-color] {
  padding: 0;
  display: flex;
  align-items: center;
  width: 32px;
  justify-content: center;
}
.treb-main.treb-main .treb-toolbar .treb-color-chooser > div {
  padding: 0.75rem 0.75rem;
}
.treb-main.treb-main .treb-toolbar .treb-color-chooser > div + div {
  padding-top: 0;
}
.treb-main.treb-main .treb-toolbar .treb-color-chooser > div:last-child {
  display: flex;
  flex-direction: row;
  gap: 0.5rem;
  align-items: center;
}
.treb-main.treb-main .treb-toolbar .treb-color-chooser > div:last-child input {
  flex-grow: 1;
  padding: 0 0.5rem;
}
.treb-main.treb-main .treb-toolbar .treb-color-chooser > div:last-child input, .treb-main.treb-main .treb-toolbar .treb-color-chooser > div:last-child button {
  border: 1px solid var(--treb-toolbar-border-color, var(--treb-ui-border-color, rgb(209, 213, 219)));
  border-radius: 3px;
  height: 32px;
}
.treb-main.treb-main .treb-toolbar .treb-color-chooser .treb-swatches {
  display: grid;
  grid-template-columns: repeat(10, 1fr);
  gap: 0.5rem;
}
.treb-main.treb-main .treb-toolbar .treb-color-chooser .treb-swatches button {
  width: 18px;
  height: 18px;
  padding: 0;
  margin: 0;
  border: 1px solid var(--treb-toolbar-border-color, var(--treb-ui-border-color, rgb(209, 213, 219)));
  border-radius: 2px;
}
.treb-main.treb-main .treb-toolbar .treb-color-chooser .treb-swatches .treb-default-color::before {
  opacity: 0.7;
  content: "";
  display: block;
  position: relative;
  background: currentColor;
  width: 100%;
  height: 100%;
  mask-position: center;
  -webkit-mask-position: center;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  mask-image: var(--icon-x);
  -webkit-mask-image: var(--icon-x);
  mask-size: 24px 24px;
  -webkit-mask-size: 24px 24px;
}
.treb-main.treb-main .treb-toolbar .treb-comment-box textarea {
  font: inherit;
  resize: both;
  border: 1px solid var(--treb-toolbar-border-color, var(--treb-ui-border-color, rgb(209, 213, 219)));
  padding: 0.25rem;
  line-height: 1.5;
  margin: 0.5rem;
  height: 10rem;
}
.treb-main.treb-main .treb-toolbar .treb-comment-box textarea + div {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  padding: 0 0 0.5rem 0;
}
.treb-main.treb-main .treb-toolbar .treb-comment-box textarea + div button {
  border: 1px solid var(--treb-toolbar-border-color, var(--treb-ui-border-color, rgb(209, 213, 219)));
  border-radius: 3px;
}
.treb-main.treb-main .treb-toolbar .treb-font-scale {
  padding-left: 2em;
  width: 5em;
  text-align: right;
}
.treb-main.treb-main .treb-toolbar [composite][font-scale] {
  position: relative;
}
.treb-main.treb-main .treb-toolbar .treb-font-scale-icon {
  position: absolute;
  top: 50%;
  left: 0.5em;
  transform: translateY(-50%);
  opacity: 0.9;
  border-radius: 3px;
  pointer-events: none;
  line-height: 1;
}
.treb-main.treb-main .treb-toolbar .treb-font-scale-icon::before, .treb-main.treb-main .treb-toolbar .treb-font-scale-icon::after {
  content: "A";
  position: relative;
}
.treb-main.treb-main .treb-toolbar .treb-font-scale-icon::before {
  font-size: 1.2em;
}
.treb-main.treb-main .treb-toolbar .treb-font-scale-icon::after {
  font-size: 0.9em;
  left: -0.125em;
}

/*
 * switching to a double-selector to increase specificity. the particular
 * issue we were running into was some general :where ... :is selectors that 
 * were breaking into our styles. this is not optimal but it does prevent
 * at least inadvertent overrides.
 */
.treb-main.treb-main {
  /*============================================================================
   *
   * Reset
   * 
   * Since we cannot use a shadow DOM, we're using this reset to start from
   * a blank-ish slate. Using \`revert\` should reset styles back to the browser
   * stylesheet (or user stylesheet, if anyone actually does that).
   *
   * Per MDN, "revert is just a value" -- so it can still be overridden by
   * specificity. So it is possible for styles to leak in. We're encapsulating
   * everything so there's not a lot of concern about leaking out. Once we are 
   * three-four levels deep in specificity we probably don't need to worry too 
   * much above stuff leaking in, so the first couple of layers should use 
   * prefixed names just to be sure, and wrap up all the styles.
   * 
   * Known issues (WIP)
   * 
   * this reset breaks contenteditable on chrome, because it unsets the 
   * css property "-webkit-user-modify", which should be "read-write".
   *
   * that's a nonstandard property which is no longer in use (?) but gets
   * set by the contenteditable attribute. chrome/webkit is probably using 
   * this internally to manage editability.
   *
   * it seems like the attribute should take priority over our reset. not sure 
   * why it does not. in any event the fix _seems_ to be setting that property 
   * on contenteditable elements. I say _seems_ because it is working, but we 
   * should keep an eye out for stability issues. 
   * 
   * [update] firefox has the same issue, same fix but with a -moz prefix.
   * weird how that works.
   *
   *===========================================================================*/
  all: revert;
  box-sizing: border-box;
  text-align: start;
  font-family: var(--treb-default-font, system-ui, "BlinkMacSystemFont", "Segoe UI", "Roboto", "Oxygen-Sans", "Ubuntu", "Cantarell", "Helvetica Neue", "sans-serif");
  line-height: normal;
  /**
   * this is kind of a global property but we don't actually want
   * to inherit from the page, so we should set a font explicitly
   * here (in fact that should be the treb UI font).
   */
  /**
   * fix for chrome (webkit?) and also firefox
   */
  color-scheme: var(--treb-color-scheme, unset);
  font-family: "BlinkMacSystemFont", "Segoe UI", "Roboto", "Oxygen-Sans", "Ubuntu", "Cantarell", "Helvetica Neue", "sans-serif";
  font-style: normal;
  font-weight: normal;
  color: inherit;
  font-size: 14px;
  height: 100%;
  width: 100%;
  position: relative;
  display: grid;
  grid-template-rows: auto minmax(0, 1fr);
  grid-template-columns: minmax(0, 1fr) auto;
  /**
   * toolbar is visible when attribute is set
   */
  /**
   * dialog is visible when attribute is set. when dialog 
   * is visible, we want to fade all content -- including
   * toolbar, which also uses opacity (above) so we need
   * to out-specify
   */
  /*
  .treb-layout-resize-container {
    overflow: hidden;
    position: relative;
    display: flex;
    box-shadow: 0 4px 6px -4px rgba(0, 0, 0, .4);
    flex-grow: 1;
  }
  */
}
.treb-main.treb-main div, .treb-main.treb-main button, .treb-main.treb-main input, .treb-main.treb-main ul, .treb-main.treb-main ol, .treb-main.treb-main li, .treb-main.treb-main a, .treb-main.treb-main textarea, .treb-main.treb-main svg {
  all: revert;
  box-sizing: border-box;
  font-family: var(--treb-default-font, system-ui, "BlinkMacSystemFont", "Segoe UI", "Roboto", "Oxygen-Sans", "Ubuntu", "Cantarell", "Helvetica Neue", "sans-serif");
}
.treb-main.treb-main button, .treb-main.treb-main input {
  font: inherit;
  color: inherit;
}
.treb-main.treb-main * {
  box-sizing: border-box;
}
.treb-main.treb-main [contenteditable] {
  -webkit-user-modify: read-write;
  -moz-user-modify: read-write;
}
.treb-main.treb-main[animate] .treb-layout-header {
  transition: height var(--treb-sidebar-transition, 0.2s ease), opacity var(--treb-sidebar-transition, 0.2s ease);
}
.treb-main.treb-main .treb-layout-header {
  grid-row: 1;
  grid-column: 1/3;
  height: 1px;
  opacity: 0;
}
.treb-main.treb-main[toolbar] .treb-layout-header {
  height: 42px;
  opacity: 1;
}
.treb-main.treb-main[dialog] > *, .treb-main.treb-main[dialog] .treb-layout-header {
  opacity: 0.6;
}
.treb-main.treb-main[dialog] .treb-dialog-mask {
  pointer-events: auto;
  opacity: 1;
}
.treb-main.treb-main .treb-layout-spreadsheet {
  grid-row: 2;
  grid-column: 1;
  position: relative;
  z-index: 5;
  display: flex;
  flex-direction: row;
  gap: 1em;
  transition: opacity 0.2s ease;
}
.treb-main.treb-main .treb-views.treb-can-revert .treb-view .treb-revert-indicator {
  opacity: 1;
  pointer-events: initial;
}
.treb-main.treb-main .treb-view {
  position: relative;
  display: grid;
  grid-template-columns: minmax(0, 1fr);
  grid-template-rows: auto minmax(0, 1fr) auto;
  flex: 1 1 0px;
}
.treb-main.treb-main .treb-view .treb-spreadsheet-backdrop {
  grid-row: 2;
  grid-column: 1;
  z-index: 2;
  box-shadow: 0 4px 6px -4px rgba(0, 0, 0, 0.4);
}
.treb-main.treb-main .treb-view .treb-spreadsheet-body {
  z-index: 4;
  position: relative;
}
.treb-main.treb-main .treb-view .treb-spreadsheet-footer {
  z-index: 5;
  position: relative;
}
.treb-main.treb-main .treb-view .treb-layout-resize-handle {
  display: none;
}
.treb-main.treb-main .treb-view .treb-revert-indicator {
  display: none;
}
.treb-main.treb-main .treb-view:first-of-type .treb-revert-indicator {
  display: block;
  grid-area: 2/1/3/2;
  justify-self: start;
  align-self: start;
  width: 1rem;
  height: 1rem;
  position: relative;
  overflow: hidden;
  opacity: 0;
  transition: opacity 0.125s ease;
  pointer-events: none;
  /* rounded style
  &::after {
    content: '';
    position: absolute;
    display: block;
    top: -1rem;
    left: -1rem;
    border-radius: 1rem;
    border: 1rem solid orange;
  }
  */
  /* triangular style */
  border: 0.5em solid orange;
  border-right-color: transparent;
  border-bottom-color: transparent;
  /* end styles */
  z-index: 20;
}
.treb-main.treb-main .treb-view:last-of-type .treb-layout-resize-handle {
  display: block;
  grid-area: 2/1/3/2;
  justify-self: end;
  align-self: end;
  border: 0.5rem solid var(--treb-resize-handle-color, #0059B9);
  border-top-color: transparent;
  border-left-color: transparent;
  z-index: 20;
  width: 1rem;
  height: 1rem;
  cursor: nw-resize;
}
.treb-main.treb-main[animate] .treb-layout-sidebar {
  transition: width var(--treb-sidebar-transition, 0.2s ease), opacity var(--treb-sidebar-transition, 0.2s ease);
}
.treb-main.treb-main .treb-layout-sidebar {
  grid-row: 2;
  grid-column: 2;
  padding-top: 1rem;
  grid-row: 2;
  grid-column: 2;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  justify-content: flex-start;
  overflow: hidden;
  width: 2.5rem;
  padding-top: 3rem;
  width: 3rem;
  align-items: center;
}
.treb-main.treb-main[collapsed] .treb-layout-sidebar {
  width: 0px;
  opacity: 0;
}
.treb-main.treb-main[collapsed] .treb-toggle-sidebar-button {
  border-color: var(--treb-toolbar-border-color, var(--treb-ui-border-color, rgb(209, 213, 219)));
  border-right-color: var(--treb-toolbar-button-background, transparent);
  right: 0px;
  border-top-right-radius: 0px;
  border-bottom-right-radius: 0px;
  background: var(--treb-toolbar-button-background, #fff);
}
.treb-main.treb-main[collapsed] .treb-toggle-sidebar-button::after {
  mask-image: var(--icon-chevron-left);
  -webkit-mask-image: var(--icon-chevron-left);
}
.treb-main.treb-main .treb-layout-sidebar > button, .treb-main.treb-main .treb-toggle-sidebar-button {
  padding: 0;
  margin: 0;
  border: 0;
  background: transparent;
  /*
  &:not(.sidebar-disabled):hover::after{
    background: #666; // FIXME
  }
  */
}
.treb-main.treb-main .treb-layout-sidebar > button::after, .treb-main.treb-main .treb-toggle-sidebar-button::after {
  display: block;
  height: 24px;
  width: 24px;
  content: "";
  background: #ccc;
  mask-position: center;
  -webkit-mask-position: center;
  mask-repeat: no-repeat;
  -webkit-mask-repeat: no-repeat;
  transition: background-color 0.1s ease;
  mask-image: var(--icon);
  -webkit-mask-image: var(--icon);
}
.treb-main.treb-main .treb-layout-sidebar > button[data-can-revert=false], .treb-main.treb-main .treb-toggle-sidebar-button[data-can-revert=false] {
  display: none;
}
.treb-main.treb-main .treb-layout-sidebar > button:hover::after, .treb-main.treb-main .treb-toggle-sidebar-button:hover::after {
  background: #666;
}
.treb-main.treb-main .treb-layout-sidebar > button[data-command=recalculate], .treb-main.treb-main .treb-toggle-sidebar-button[data-command=recalculate] {
  --icon: var(--icon-reset);
}
.treb-main.treb-main .treb-layout-sidebar > button[data-command=toggle-toolbar], .treb-main.treb-main .treb-toggle-sidebar-button[data-command=toggle-toolbar] {
  --icon: var(--icon-toolbar);
}
.treb-main.treb-main .treb-layout-sidebar > button[data-command=revert], .treb-main.treb-main .treb-toggle-sidebar-button[data-command=revert] {
  --icon: var(--icon-revert);
}
.treb-main.treb-main .treb-layout-sidebar > button[data-command=export-xlsx], .treb-main.treb-main .treb-toggle-sidebar-button[data-command=export-xlsx] {
  --icon: var(--icon-export);
}
.treb-main.treb-main .treb-layout-sidebar > button[data-command=about], .treb-main.treb-main .treb-toggle-sidebar-button[data-command=about] {
  --icon: var(--icon-about);
}
.treb-main.treb-main .treb-toggle-sidebar-button {
  position: absolute;
  right: 0.5rem;
  bottom: 6rem;
  background: transparent;
  border: 0;
  border: 1px solid transparent;
  height: 24px;
  width: 24px;
  right: calc(1.5rem - 12px);
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  margin: 0;
  z-index: 39;
}
.treb-main.treb-main .treb-toggle-sidebar-button::after {
  height: 12px;
  width: 12px;
  mask-image: var(--icon-chevron-right);
  -webkit-mask-image: var(--icon-chevron-right);
}
.treb-main.treb-main .treb-resize-rect {
  z-index: 9998;
  position: fixed;
  top: 0px;
  left: 0px;
  border: 1px dotted var(--treb-resize-frame-color, blue);
  width: 100%;
  height: 100%;
  display: block;
}
.treb-main.treb-main .treb-resize-mask {
  z-index: 9999;
  position: fixed;
  top: 0px;
  left: 0px;
  width: 100vw;
  height: 100vh;
}

/**
 * default styles for custom element. we basically want 
 * it to act like a div.
 */
treb-spreadsheet {
  display: block;
  position: relative;
  overflow: hidden;
}

/**
 * if we don't find a height/width on the element when it's 
 * created, we will add this class to set a default size.
 */
.treb-default-size {
  width: 800px;
  height: 550px;
}`;

// treb-embed/markup/layout.html
var layout_default = `
<div class="treb-main treb-theme">
  
  <div class="treb-layout-header treb-animate">
    <div class="treb-toolbar">

      <!-- toolbar layout is in a separate file -->

      <!-- 

        should we have an include syntax? 
        ...
        actually I'd rather not, atm we use pure html and not
        templates. if you want to use templates we should use
        something that already exists, rather than reinventing
        that particular wheel.

      -->

    </div>
  </div>

  <!-- 
      dialog plus a mask... do we need the mask? it's used to 
      center the dialog. we can use the grid to put the mask 
      in the right place.
    -->

  <div class='treb-dialog-mask'>
    <div data-bind='dialog' class='treb-embed-dialog'>
      <div data-bind='left'>
        <a href='https://treb.app' target='_blank'>
          <div class='treb-icon-64'></div>
        </a>
      </div>
      <div data-bind='middle'>
        <div data-bind='title' class='treb-embed-dialog-title'></div>
        <div data-bind='message' class='treb-embed-dialog-message'></div>
        <div data-bind='about' class='treb-embed-dialog-body'></div>
      </div>
      <button type='button' title='Close dialog' data-bind='close' class='treb-close-box'>
        <svg viewBox='0 0 16 16'>
          <path d='M11.854 4.146a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708-.708l7-7a.5.5 0 0 1 .708 0z'/>
          <path d='M4.146 4.146a.5.5 0 0 0 0 .708l7 7a.5.5 0 0 0 .708-.708l-7-7a.5.5 0 0 0-.708 0z'/>
        </svg>
      </button>
    </div>
  </div>

  <div class="treb-layout-spreadsheet treb-views">

    <!-- I rather like <template/>. perhaps we could make more use of them. -->
    
    <!-- 
      how about we move the view template (or raw html) into the spreadsheet class? 
      as it stands now, if we have two spreadsheets on a page we'll have two templates
      as well. seems unecessary.
    -->

    <template class="treb-view-template">
      <div class="treb-view">

        <div class="treb-formula-bar notranslate" hidden>
          <div class="treb-address-label"><div></div></div>
          <div class="treb-editor-container">
            <div contenteditable="true"></div>
          </div>
        </div>

        <div class="treb-spreadsheet-backdrop"></div>

        <!-- shouldn't grid be on the next one? which has a tabindex? -->
        <div class="treb-spreadsheet-body" role="grid">
          <div class="treb-grid" tabindex="-1">

            <!-- 
              this used to be dynamically created, but optionally; what
              happens now if we _don't_ want the overlay editor? we should 
              probably remove it, at least from flow.
            -->

            <div class="treb-overlay-container notranslate" translate="no">
              <div class="treb-overlay-inset">
                <div class="treb-overlay-editor" contenteditable tabindex="-1" spellcheck="true" role="gridcell"></div>
              </div>
            </div>

          </div>
        </div>

        <div class="treb-spreadsheet-footer" hidden>

          <!-- 
            add/remove tab should both be buttons, or at least have tabindexes 
          -->
  
          <!-- converted to button, more appropriate -->
          <button class="treb-delete-tab" title="Delete current sheet" data-command="delete-tab" data-conditional="delete-tab">
            <svg tabindex="-1" viewbox='0 0 16 16'><path d='M4,4 L12,12 M12,4 L4,12'/></svg>
          </button>
  
          <!-- list of tabs for sheets -->
          <div class="treb-spreadsheet-tab-container">
            <ol class="treb-spreadsheet-tabs" role="tablist"></ol>
          </div>

          <!-- converted to button, more appropriate -->
          <button class="treb-add-tab" data-command="add-tab" data-conditional="add-tab" title="Add sheet">+</button>
  
          <!-- 
            we removed the junk node with "flex grow" to split the layout, in
            favor of giving stats panel \`margin-left:auto\` which consumes all
            available space. but that means you cannot remove this node from
            layout, or it will get out of alignment. if this is empty it should
            take up no space, so it should be harmless.
          -->
          
          <div class="treb-stats-panel"></div>
  
          <div class="treb-scale-control" data-conditional="scale-control"></div>
  
        </div>

        <div class="treb-layout-resize-handle" data-conditional="resize"></div>
        
        <div class="treb-revert-indicator" 
              data-command="revert-indicator"
              title="This document has been modified from the original version."></div>

      </div> <!-- /treb-view -->
    </template>

  </div>

  <div class="treb-layout-sidebar treb-animate">
    <button data-command="recalculate" title="Recalculate"></button>
    <button data-command="toggle-toolbar" data-conditional="toolbar" title="Toggle toolbar"></button>
    <button data-command="export-xlsx" data-conditional="export" title="Export as XLSX"></button>
    <button data-command="revert" data-conditional="revert" title="Revert to original version"></button>
    <button data-command="about" title="What's this?"></button>
  </div>

  <button class="treb-toggle-sidebar-button" title="Toggle sidebar"></button>

</div>
`;

// treb-embed/markup/toolbar.html
var toolbar_default = `
  <div class="treb-menu" title="File menu" file-menu>
    <button data-icon="file-menu" menu-target></button>
    <div>
      <button data-command="reset">New document</button>
      <div separator></div>
      <button data-command="import-file">Open file...</button>
      <button data-command="save-json">Save JSON</button>
      <div separator xlsx-support></div>
      <button data-command="export-xlsx" xlsx-support>Export XLSX</button>
    </div>
  </div>

  <div composite narrow>
    <button data-command="justify-left" data-target="justify" title="Left-align text"></button>
    <div class="treb-menu">
      <button dropdown title="Text justify options"></button>
      <div class="treb-icon-buttons" data-replace="justify">
        <button data-command="justify-left" title="Left-align text"></button>
        <button data-command="justify-center" title="Center-align text"></button>
        <button data-command="justify-right" title="Right-align text"></button>
      </div>
    </div>
  </div>

  <div composite narrow>
    <button data-command="align-top" data-target="align" title="Align to top"></button>
    <div class="treb-menu">
      <button dropdown title="Text align options"></button>
      <div class="treb-icon-buttons" data-replace="align">
        <button data-command="align-top" title="Align to top"></button>
        <button data-command="align-middle" title="Align to middle"></button>
        <button data-command="align-bottom" title="Align to bottom"></button>
      </div>
    </div>
  </div>

  <div class="group" wide>
    <button data-command="justify-left" title="Left-align text"></button>
    <button data-command="justify-center" title="Center-align text"></button>
    <button data-command="justify-right" title="Right-align text"></button>
  </div>

  <div class="group" wide>
    <button data-command="align-top" title="Align to top"></button>
    <button data-command="align-middle" title="Align to middle"></button>
    <button data-command="align-bottom" title="Align to bottom"></button>
  </div>

  <div class="group">
    <button data-command="wrap-text" title="Wrap text"></button>
    <button data-command="merge-cells" data-id="merge" data-title="Merge cells" data-active-title="Unmerge cells"></button>
    <button data-command="lock-cells" data-title="Lock cells" data-active-title="Unlock cells"></button>
    <button data-command="freeze-panes" data-title="Freeze panes" data-active-title="Unfreeze panes" freeze-button></button>
    <button data-command="insert-table" data-icon="table" data-title="Insert table" data-active-title="Remove table" table-button></button>
    <div class="treb-menu">
      <button data-icon="comment" data-title="Comment" data-active-title="Update comment"></button>
      <div class="treb-comment-box">
        <textarea></textarea>
        <div>
          <button data-command="clear-comment">Clear</button>
          <button data-command="update-comment">Save</button>
        </div>
      </div>
    </div>
  </div>

  <div composite>
    <button data-command="border-bottom" data-target="border" title="Bottom border"></button>
    <div class="treb-menu">
      <button dropdown title="Border options"></button>
      <div class="treb-icon-buttons" data-replace="border">
        <button data-command="border-top" title="Top border"></button>        
        <button data-command="border-left" title="Left border"></button>        
        <button data-command="border-right" title="Right border"></button>        
        <button data-command="border-bottom" title="Bottom border"></button>        
        <button data-command="border-double-bottom" title="Double bottom border"></button>        
        <button data-command="border-outside" title="Outside borders"></button>        
        <button data-command="border-all" title="All borders"></button>        
        <button data-command="border-none" title="Clear borders"></button>        
        <div separator></div>
        <div class="treb-menu treb-color-menu treb-submenu" data-color-command="border-color" data-replace-color="border" title="Border color" data-default-color-text="Default border color">
          <button data-icon="palette" data-color-bar="border" data-color="{}"></button>
        </div>
      </div>
    </div>
  </div>

  <div composite>
    <button data-command="fill-color" data-color-bar="fill" data-color="{}" title="Fill color"></button>
    <div class="treb-menu treb-color-menu" data-color-command="fill-color" data-replace-color="fill" data-default-color-text="No fill">
      <button dropdown title="Color options"></button>
      <div class="treb-color-chooser">
        <div class="treb-caption">Theme colors</div>
        <div class="treb-swatches"></div>
        <div class="treb-caption">Other colors</div>
        <div class="treb-swatches"></div>
        <div>
          <input placeholder="New color" class="treb-color-input">
          <button data-command="set-color" data-color="">
            <!-- source: bootstrap-icons-1.8.3/check2.svg -->
            <svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='currentColor' viewBox='0 0 16 16'>
              <path d='M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z'/> 
            </svg>
          </button>
        </div>
      </div>
    </div>
  </div>

  <div composite>
    <button data-command="text-color" data-color-bar="text" data-color="{}" title="Text color"></button>
    <div class="treb-menu treb-color-menu" data-color-command="text-color" data-replace-color="text" data-default-color-text="Default text color">
      <button dropdown title="Color options"></button>
    </div>
  </div>

  <div composite font-scale>
    <div class="treb-font-scale-icon"></div>
    <input class="treb-font-scale" title="Font scale">
    <div class="treb-menu">
      <button dropdown title="Font scale options"></button>
      <div>
        <button data-command="font-scale" data-scale="0.8">0.80</button>
        <button data-command="font-scale" data-scale="0.9">0.90</button>
        <button data-command="font-scale" data-scale="1.0">1.00</button>
        <button data-command="font-scale" data-scale="1.1">1.10</button>
        <button data-command="font-scale" data-scale="1.2">1.20</button>
        <button data-command="font-scale" data-scale="1.5">1.50</button>
        <button data-command="font-scale" data-scale="2.0">2.00</button>
      </div>
    </div>
  </div>

  <div composite>
    <input class="treb-number-format" title="Number format">
    <div class="treb-menu">
      <button dropdown title="Number formats"></button>
      <div class="treb-number-format-menu"></div>
    </div>
  </div>

  <div class="treb-split">
    <button data-command="decrease-precision" title="Decrease precision"></button>
    <button data-command="increase-precision" title="Increase precision"></button>
  </div>

  <div class="treb-menu">
    <button data-icon="layout" title="Rows & columns"></button>
    <div>
      <button data-command="insert-row">Insert row</button>
      <button data-command="insert-column">Insert column</button>
      <button data-command="delete-row">Delete row</button>
      <button data-command="delete-column">Delete column</button>
      <div separator add-remove-sheet></div>
      <button data-command="insert-sheet" add-remove-sheet>Add sheet</button>
      <button data-command="delete-sheet" add-remove-sheet>Delete sheet</button>
    </div>
  </div>

  <div composite chart-menu>
    <button data-command="insert-column-chart" data-target="annotation" title="Insert column chart"></button>
    <div class="treb-menu">
      <button dropdown title="Chart options"></button>
      <div class="treb-icon-buttons" data-replace="annotation">
        <button data-command="insert-column-chart" title="Insert column chart"></button>
        <button data-command="insert-donut-chart" title="Insert donut chart"></button>
        <button data-command="insert-bar-chart" title="Insert bar chart"></button>
        <button data-command="insert-line-chart" title="Insert line chart"></button>
        <div separator></div>
        <button data-command="insert-image" title="Insert image"></button>
      </div>
    </div>
  </div>

  <button data-command="recalculate" title="Recalculate" recalculate-button></button>
`;

// treb-embed/src/custom-element/spreadsheet-constructor.ts
var SpreadsheetConstructor = class {
  /** container, if any */
  root;
  /** spreadsheet instance */
  sheet;
  /** current border color. will be applied to new borders. */
  border_color;
  /** color bar elements, since we update them frequently */
  color_bar_elements = {};
  /** some menu buttons change icons from time to time */
  replace_targets = {};
  /** root layout element */
  layout_element;
  /** views container */
  views;
  /** 
   * handle to the revert button, so we can adjust it. we can use
   * container classes for the most part but we are updating the title.
   * (FIXME: double-up the button, no reference required)
   */
  revert_button;
  revert_state = false;
  /** cached controls */
  toolbar_controls = {};
  /** swatch lists in color chooser */
  swatch_lists = {};
  DOM;
  // 
  constructor(root) {
    if (typeof root === "string") {
      root = document.querySelector(root);
    }
    this.DOM = DOMContext.GetInstance(root?.ownerDocument);
    if (this.DOM.view && root instanceof this.DOM.view.HTMLElement) {
      this.root = root;
      const style_node = this.DOM.doc?.head.querySelector("style[treb-stylesheet]");
      if (!style_node) {
        this.DOM.doc?.head.prepend(
          this.DOM.Create("style", void 0, void 0, { text: treb_spreadsheet_element_default, attrs: { "treb-stylesheet": "" } })
        );
      }
    }
  }
  /** 
   * coerce an attribute value into a more useful type. for attributes,
   * having no value implies "true". false should be explicitly set as
   * "false"; we don't, atm, support falsy values like '0' (that would be 
   * coerced to a number).
   */
  CoerceAttributeValue(value) {
    if (value === null || value.toString().toLowerCase() === "true" || value === "") {
      return true;
    } else if (value.toLowerCase() === "false") {
      return false;
    } else {
      const test = Number(value);
      if (!isNaN(test)) {
        return test;
      }
    }
    return value || "";
  }
  /**
   * get options from node attributes. we're still working on final 
   * semantics but at the moment we'll translate hyphen-separated-options
   * to our standard snake_case_options.
   * 
   * we also support the old-style data-options
   * 
   * @returns 
   */
  ParseOptionAttributes() {
    const attribute_options = {};
    if (this.root) {
      const names = this.root.getAttributeNames();
      for (let name of names) {
        switch (name) {
          case "class":
          case "style":
          case "id":
            continue;
          case "data-options":
          case "options":
            {
              const value = this.root.getAttribute(name) || "";
              const elements = value.split(",");
              for (const element of elements) {
                const parts = element.split(/=/);
                if (parts.length === 1) {
                  attribute_options[parts[0]] = true;
                } else {
                  attribute_options[parts[0]] = this.CoerceAttributeValue(parts[1]);
                }
              }
            }
            continue;
          case "data-treb":
            continue;
          case "inline-document":
            continue;
          case "src":
            attribute_options.document = this.root.getAttribute("src") || void 0;
            continue;
        }
        name = name.replace(/-/g, "_");
        attribute_options[name] = this.CoerceAttributeValue(this.root.getAttribute(name));
      }
    }
    return {
      ...attribute_options
    };
  }
  /**
   * attach content to element. for custom elements, this is called via 
   * the connectedCallback call. for elements created with the API, we 
   * call it immediately.
   */
  AttachElement(options = {}) {
    options = {
      ...this.ParseOptionAttributes(),
      ...options
    };
    if (this.root) {
      if (!options.headless) {
        const rect = this.root.getBoundingClientRect();
        if (!rect.width || !rect.height) {
          this.root.classList.add("treb-default-size");
        }
      }
      if (this.root.hasAttribute("inline-document")) {
        const inline_name = this.root.getAttribute("inline-document") || "";
        for (const element of Array.from(this.root.children)) {
          if (this.DOM.view && element instanceof this.DOM.view.HTMLScriptElement) {
            if (element.type === "application/json") {
              const name = element.getAttribute("name") || "";
              if (name === inline_name || !name && inline_name === "true") {
                const content = element.textContent;
                if (content) {
                  try {
                    options.inline_document = JSON.parse(content);
                  } catch (err) {
                    console.error(err);
                  }
                }
                break;
              }
            }
          }
        }
        if (!options.inline_document) {
          console.warn("inline document failed");
        }
      }
      this.root.innerHTML = layout_default;
      options.container = this.root.querySelector(".treb-layout-spreadsheet");
    }
    if (false) {
      options.export = false;
    }
    this.sheet = new EmbeddedSpreadsheet(options);
    if (this.root) {
      this.CreateLayout(this.sheet, this.root);
    }
  }
  CreateLayout(sheet, root) {
    const resizeObserver = new ResizeObserver(() => sheet.Resize());
    resizeObserver.observe(root);
    this.layout_element = root.querySelector(".treb-main");
    const button = root.querySelector(".treb-toggle-sidebar-button");
    if (button && this.layout_element) {
      const element = this.layout_element;
      button.addEventListener("click", () => {
        const value = element.getAttribute("collapsed");
        const state = typeof value === "string" && (value === "" || value === "true");
        if (state) {
          element.removeAttribute("collapsed");
        } else {
          element.setAttribute("collapsed", "");
        }
      });
    }
    if (sheet.options.toolbar === "show" || sheet.options.toolbar === "show-narrow") {
      this.layout_element?.setAttribute("toolbar", "");
    }
    if (sheet.options.collapsed) {
      this.layout_element?.setAttribute("collapsed", "");
    }
    const revert_indicator = root.querySelector("[data-command=revert-indicator]");
    if (this.DOM.view && revert_indicator instanceof this.DOM.view.HTMLElement) {
      if (sheet.options.revert_indicator) {
        revert_indicator.addEventListener("click", () => {
          sheet.HandleToolbarMessage({
            command: "revert-indicator"
          });
        });
      } else {
        revert_indicator.style.display = "none";
      }
    }
    const sidebar = root.querySelector(".treb-layout-sidebar");
    sidebar?.addEventListener("click", (event) => {
      const target = event.target;
      if (target.dataset.command) {
        switch (target.dataset.command) {
          case "toggle-toolbar":
            this.ToggleToolbar();
            break;
          default:
            sheet.HandleToolbarMessage({
              command: target.dataset.command
            });
            break;
        }
      }
    });
    if (sheet.options.toolbar) {
      this.AttachToolbar(sheet, root);
    }
    const conditional_map = {
      // 'file-menu': !!sheet.options.file_menu,
      "table-button": !!sheet.options.table_button,
      // 'chart-menu': !!sheet.options.chart_menu,
      // 'font-scale': !!sheet.options.font_scale,
      "revert": !!sheet.options.revert_button,
      "toolbar": !!sheet.options.toolbar,
      "export": !!sheet.options.export,
      // the following won't work as expected in split, because this
      // code won't be run when the new view is created -- do something
      // else
      // resize should actually work because we're hiding new view 
      // resize handles via positioning
      "resize": !!sheet.options.resizable,
      // add-tab and delete-tab will still work for the menu
      "add-tab": !!sheet.options.add_tab,
      "delete-tab": !!sheet.options.delete_tab || !!sheet.options.add_tab
      // we actually don't want to remove stats if it's not in use, because
      // we need it for layout
      // 'stats': !!sheet.options.stats,
      // scale control is not (yet) declarative, so this isn't effective anyway
      // 'scale-control': !!sheet.options.scale_control,
    };
    for (const [key, value] of Object.entries(conditional_map)) {
      if (!value) {
        const elements = this.layout_element.querySelectorAll(`[data-conditional=${key}]`);
        for (const element of Array.from(elements)) {
          element.style.display = "none";
        }
      }
    }
    if (sheet.options.revert_button) {
      this.revert_button = this.layout_element.querySelector("[data-command=revert]") || void 0;
    }
    if (sheet.options.resizable) {
      const size = { width: 0, height: 0 };
      const position = { x: 0, y: 0 };
      const delta = { x: 0, y: 0 };
      this.views = root.querySelector(".treb-views") || void 0;
      let mask;
      let resizer;
      const resize_handle = root.querySelector(".treb-layout-resize-handle");
      const mouseup = () => finish();
      const mousemove = (event) => {
        if (event.buttons === 0) {
          finish();
        } else {
          delta.x = event.screenX - position.x;
          delta.y = event.screenY - position.y;
          if (resizer) {
            resizer.style.width = size.width + delta.x + "px";
            resizer.style.height = size.height + delta.y + "px";
          }
        }
      };
      const finish = () => {
        if (delta.x || delta.y) {
          const rect = root.getBoundingClientRect();
          if (!sheet.options.constrain_width) {
            root.style.width = rect.width + delta.x + "px";
          }
          root.style.height = rect.height + delta.y + "px";
        }
        if (mask) {
          mask.removeEventListener("mouseup", mouseup);
          mask.removeEventListener("mousemove", mousemove);
          mask.parentElement?.removeChild(mask);
          mask = void 0;
        }
        resizer?.parentElement?.removeChild(resizer);
        resizer = void 0;
      };
      resize_handle.addEventListener("mousedown", (event) => {
        event.stopPropagation();
        event.preventDefault();
        const resize_parent = root.querySelector(".treb-main");
        resizer = this.DOM.Div("treb-resize-rect", resize_parent);
        mask = this.DOM.Div("treb-resize-mask", resize_parent, {
          attrs: {
            style: "cursor: nw-resize;"
          },
          events: { mouseup, mousemove }
        });
        position.x = event.screenX;
        position.y = event.screenY;
        delta.x = 0;
        delta.y = 0;
        const layouts = this.views?.querySelectorAll(".treb-spreadsheet-body");
        const rects = Array.from(layouts || []).map((element) => element.getBoundingClientRect());
        if (rects.length) {
          const composite = JSON.parse(JSON.stringify(rects.shift()));
          for (const rect of rects) {
            composite.top = Math.min(rect.top, composite.top);
            composite.left = Math.min(rect.left, composite.left);
            composite.right = Math.max(rect.right, composite.right);
            composite.bottom = Math.max(rect.bottom, composite.bottom);
          }
          const width = composite.right - composite.left;
          const height = composite.bottom - composite.top;
          resizer.style.top = composite.top + "px";
          resizer.style.left = composite.left + "px";
          resizer.style.width = width + "px";
          resizer.style.height = height + "px";
          size.width = width;
          size.height = height;
        }
      });
    }
    setTimeout(() => this.layout_element?.setAttribute("animate", ""), 250);
  }
  ToggleToolbar() {
    if (this.layout_element) {
      const value = this.layout_element.getAttribute("toolbar");
      const state = typeof value === "string" && (value === "" || value === "true");
      if (state) {
        this.layout_element.removeAttribute("toolbar");
      } else {
        this.layout_element.setAttribute("toolbar", "");
      }
    }
  }
  UpdateSelectionStyle(sheet, toolbar, comment_box) {
    const state = sheet.selection_state;
    comment_box.value = "";
    for (const [key, value] of Object.entries(this.toolbar_controls)) {
      if (value) {
        value.removeAttribute("active");
        if (value.dataset.title) {
          value.title = value.dataset.title;
        }
      }
    }
    const Activate = (element) => {
      if (element) {
        element.setAttribute("active", "");
        if (element.dataset.activeTitle) {
          element.title = element.dataset.activeTitle;
        }
      }
    };
    if (state.comment) {
      Activate(this.toolbar_controls.comment);
      comment_box.value = state.comment;
    }
    if (state.style?.locked) {
      Activate(this.toolbar_controls.locked);
    }
    if (state.frozen) {
      Activate(this.toolbar_controls.freeze);
    }
    if (state.style?.wrap) {
      Activate(this.toolbar_controls.wrap);
    }
    if (this.toolbar_controls.table) {
      if (state.table) {
        Activate(this.toolbar_controls.table);
        this.toolbar_controls.table.dataset.command = "remove-table";
      } else {
        this.toolbar_controls.table.dataset.command = "insert-table";
      }
    }
    if (this.toolbar_controls.merge) {
      if (state.merge) {
        Activate(this.toolbar_controls.merge);
        this.toolbar_controls.merge.dataset.command = "unmerge-cells";
      } else {
        this.toolbar_controls.merge.dataset.command = "merge-cells";
      }
    }
    const format = this.toolbar_controls.format;
    if (format) {
      if (state.style?.number_format) {
        format.value = NumberFormatCache.SymbolicName(state.style.number_format) || state.style.number_format;
      } else {
        format.value = "General";
      }
    }
    const scale = this.toolbar_controls.scale;
    if (scale) {
      scale.value = sheet.FormatNumber(state.relative_font_size || 1, "0.00");
    }
    switch (state.style?.horizontal_align) {
      case "left":
        Activate(this.toolbar_controls.left);
        break;
      case "center":
        Activate(this.toolbar_controls.center);
        break;
      case "right":
        Activate(this.toolbar_controls.right);
        break;
    }
    switch (state.style?.vertical_align) {
      case "top":
        Activate(this.toolbar_controls.top);
        break;
      case "middle":
        Activate(this.toolbar_controls.middle);
        break;
      case "bottom":
        Activate(this.toolbar_controls.bottom);
        break;
    }
  }
  UpdateDocumentStyles(sheet, format_menu) {
    {
      let fragment2 = this.DOM.Fragment();
      const length = sheet.document_styles.theme_colors.length;
      const themes = ["Background", "Text", "Background", "Text", "Accent"];
      if (length) {
        const depth = sheet.document_styles.theme_colors[0].length;
        for (let i = 0; i < depth; i++) {
          for (let j = 0; j < length; j++) {
            const entry = sheet.document_styles.theme_colors[j][i];
            const style = `background: ${entry.resolved};`;
            let title = themes[j] || themes[4];
            if (entry.color.tint) {
              title += ` (${(entry.color.tint > 0 ? "+" : "") + entry.color.tint * 100}%)`;
            } else {
              if (j === 0) {
                this.color_bar_elements.fill?.style.setProperty("--treb-default-color", entry.resolved);
              } else if (j === 1) {
                this.color_bar_elements.text?.style.setProperty("--treb-default-color", entry.resolved);
                this.color_bar_elements.border?.style.setProperty("--treb-default-color", entry.resolved);
              }
            }
            this.DOM.Create("button", void 0, fragment2, {
              attrs: { style, title },
              data: { command: "set-color", color: JSON.stringify(entry.color) }
            });
          }
        }
      }
      this.swatch_lists.theme?.replaceChildren(fragment2);
      fragment2 = this.DOM.Fragment();
      this.DOM.Create("button", "treb-default-color", fragment2, {
        attrs: { title: "Default color" },
        data: { command: "set-color", color: JSON.stringify({}) }
      });
      const colors = ["Black", "White", "Gray", "Red", "Orange", "Yellow", "Green", "Blue", "Violet"];
      const lc = colors.map((color) => color.toLowerCase());
      const additional_colors = sheet.document_styles.colors.filter((test) => {
        return !lc.includes(test.toLowerCase());
      });
      for (const text of [...colors, ...additional_colors]) {
        const style = `background: ${text.toLowerCase()};`;
        this.DOM.Create("button", void 0, fragment2, {
          attrs: { style, title: text },
          data: { command: "set-color", color: JSON.stringify({ text: text.toLowerCase() }) }
        });
      }
      this.swatch_lists.other?.replaceChildren(fragment2);
    }
    const number_formats = [
      "General",
      "Number",
      "Integer",
      "Percent",
      "Fraction",
      "Accounting",
      "Currency",
      "Scientific"
    ];
    const date_formats = [
      "Timestamp",
      "Long Date",
      "Short Date"
    ];
    for (const format of sheet.document_styles.number_formats) {
      if (NumberFormatCache.SymbolicName(NumberFormatCache.Translate(format))) {
        continue;
      }
      const instance = NumberFormatCache.Get(format);
      if (instance.date_format) {
        date_formats.push(format);
      } else {
        number_formats.push(format);
      }
    }
    const Button = (format) => this.DOM.Create("button", void 0, void 0, {
      text: format,
      data: { format, command: "number-format" }
    });
    const fragment = this.DOM.Fragment();
    fragment.append(...number_formats.map((format) => Button(format)));
    fragment.append(this.DOM.Div(void 0, void 0, { attrs: { separator: "" } }));
    fragment.append(...date_formats.map((format) => Button(format)));
    format_menu.textContent = "";
    format_menu.append(fragment);
  }
  /**
   * setting explicit state on the revert button (if enabled).
   * 
   * @param sheet 
   */
  UpdateRevertState(sheet) {
    const state = sheet.can_revert;
    if (this.revert_state === state) {
      return;
    }
    this.revert_state = state;
    if (this.revert_button || sheet.options.revert_indicator) {
      if (this.revert_state) {
        this.views?.classList.add("treb-can-revert");
      } else {
        this.views?.classList.remove("treb-can-revert");
      }
      if (this.revert_button) {
        this.revert_button.dataset.canRevert = state ? "true" : "false";
        if (state) {
          this.revert_button.classList.remove("sidebar-disabled");
          this.revert_button.title = "Revert to original version";
        } else {
          this.revert_button.classList.add("sidebar-disabled");
          this.revert_button.title = "This is the original version of the document";
        }
      }
    }
  }
  /**
   * replace a given template with its contents.
   */
  ReplaceTemplate(root, selector, remove = true) {
    const template = root.querySelector(selector);
    if (template && template.parentElement) {
      for (const child of Array.from(template.content.children)) {
        template.parentElement.insertBefore(child, template);
      }
      if (remove) {
        template.parentElement.removeChild(template);
      }
    } else {
      console.warn("template not found", selector);
    }
  }
  AttachToolbar(sheet, root) {
    const scroller = root.querySelector(".treb-layout-header");
    const toolbar = root.querySelector(".treb-toolbar");
    toolbar.innerHTML = toolbar_default;
    const remove = [];
    if (sheet.options.toolbar === "narrow" || sheet.options.toolbar === "show-narrow") {
      remove.push(...Array.from(toolbar.querySelectorAll("[wide]")));
    } else {
      remove.push(...Array.from(toolbar.querySelectorAll("[narrow]")));
    }
    if (!sheet.options.file_menu) {
      remove.push(toolbar.querySelector("[file-menu]"));
    }
    if (!sheet.options.font_scale) {
      remove.push(toolbar.querySelector("[font-scale]"));
    }
    if (!sheet.options.chart_menu) {
      remove.push(toolbar.querySelector("[chart-menu]"));
    }
    if (!sheet.options.freeze_button) {
      remove.push(toolbar.querySelector("[freeze-button]"));
    }
    if (!sheet.options.table_button) {
      remove.push(toolbar.querySelector("[table-button]"));
    }
    if (!sheet.options.add_tab && !sheet.options.delete_tab) {
      remove.push(...Array.from(toolbar.querySelectorAll("[add-remove-sheet]")));
    }
    if (!sheet.options.toolbar_recalculate_button) {
      remove.push(toolbar.querySelector("[recalculate-button]"));
    }
    if (false) {
      remove.push(...Array.from(toolbar.querySelectorAll("[xlsx-support]")));
    }
    for (const element of remove) {
      if (element) {
        element.parentElement?.removeChild(element);
      }
    }
    const color_chooser = toolbar.querySelector(".treb-color-chooser");
    const comment_box = toolbar.querySelector(".treb-comment-box textarea");
    for (const [key, value] of Object.entries({
      // for align/justify make sure we are collecting the wide 
      // versions. narrow versions don't highlight.
      "top": "[wide] [data-command=align-top]",
      "middle": "[wide] [data-command=align-middle]",
      "bottom": "[wide] [data-command=align-bottom]",
      "left": "[wide] [data-command=justify-left]",
      "right": "[wide] [data-command=justify-right]",
      "center": "[wide] [data-command=justify-center]",
      "wrap": "[data-command=wrap-text]",
      "merge": "[data-id=merge]",
      "comment": "[data-icon=comment]",
      "locked": "[data-command=lock-cells]",
      "freeze": "[data-command=freeze-panes]",
      "table": "[data-icon=table]",
      "format": "input.treb-number-format",
      "scale": "input.treb-font-scale"
    })) {
      const element = toolbar.querySelector(value);
      if (element) {
        this.toolbar_controls[key] = element;
      } else {
      }
    }
    const swatch_lists = color_chooser.querySelectorAll(".treb-swatches");
    this.swatch_lists = {
      theme: swatch_lists[0],
      other: swatch_lists[1]
    };
    let button = root.querySelector("[data-command=increase-precision");
    if (button) {
      button.textContent = this.sheet?.FormatNumber(0, "0.00") || "";
    }
    button = root.querySelector("[data-command=decrease-precision");
    if (button) {
      button.textContent = this.sheet?.FormatNumber(0, "0.0") || "";
    }
    button = toolbar.querySelector("[data-command=update-comment]");
    comment_box.addEventListener("keydown", (event) => {
      if (event.key === "Enter" && (event.shiftKey || event.ctrlKey)) {
        button.click();
      }
    });
    for (const entry of ["border", "annotation", "align", "justify"]) {
      this.replace_targets[entry] = toolbar.querySelector(`[data-target=${entry}`);
    }
    for (const entry of ["fill", "text", "border"]) {
      this.color_bar_elements[entry] = toolbar.querySelector(`[data-color-bar=${entry}]`);
    }
    toolbar.addEventListener("click", (event) => {
      const target = event.target;
      const props = {
        format: target.dataset.format,
        scale: target.dataset.scale
      };
      let command = target?.dataset.command;
      if (command) {
        const replace = target.parentElement?.dataset.replace;
        if (replace) {
          const replace_target = this.replace_targets[replace];
          if (replace_target) {
            replace_target.dataset.command = command;
            replace_target.title = target.title || "";
          }
        }
        if (/^border-/.test(command)) {
          props.color = this.border_color || {};
        }
        switch (command) {
          case "text-color":
          case "fill-color":
            props.color = {};
            try {
              props.color = JSON.parse(target.dataset.color || "{}");
            } catch (err) {
              console.error(err);
            }
            break;
          case "set-color":
            command = color_chooser.dataset.colorCommand || "";
            props.color = {};
            try {
              props.color = JSON.parse(target.dataset.color || "{}");
            } catch (err) {
              console.error(err);
            }
            if (command === "border-color") {
              this.border_color = props.color;
            }
            if (color_chooser.dataset.target) {
              const replace2 = this.color_bar_elements[color_chooser.dataset.target];
              if (replace2) {
                replace2.style.setProperty("--treb-color-bar-color", target.style.backgroundColor);
                replace2.dataset.color = target.dataset.color || "{}";
              }
            }
            break;
          case "update-comment":
            props.comment = comment_box.value;
            break;
        }
        sheet.HandleToolbarMessage({
          command,
          ...props
        });
      }
    });
    const CreateInputHandler = (selector, handler) => {
      const input = toolbar.querySelector(selector);
      if (input) {
        let cached_value = "";
        input.addEventListener("focusin", () => cached_value = input.value);
        input.addEventListener("keydown", (event) => {
          switch (event.key) {
            case "Escape":
              input.value = cached_value;
              sheet.Focus();
              break;
            case "Enter":
              if (!handler(input.value)) {
                input.value = cached_value;
                sheet.Focus();
              }
              break;
            default:
              return;
          }
          event.stopPropagation();
          event.preventDefault();
        });
      }
    };
    CreateInputHandler("input.treb-number-format", (format) => {
      if (!format) {
        return false;
      }
      sheet.HandleToolbarMessage({
        command: "number-format",
        format
      });
      return true;
    });
    CreateInputHandler("input.treb-font-scale", (value) => {
      const scale = Number(value);
      if (!scale || isNaN(scale)) {
        console.warn("invalid scale value");
        return false;
      }
      sheet.HandleToolbarMessage({
        command: "font-scale",
        scale
      });
      return true;
    });
    const color_input = color_chooser.querySelector("input");
    const color_button = color_chooser.querySelector("input + button");
    color_input.addEventListener("input", (event) => {
      if (event instanceof InputEvent && event.isComposing) {
        return;
      }
      color_button.style.background = color_input.value || "";
      const resolved = color_button.style.backgroundColor || "#fff";
      const bytes = Measurement.MeasureColor(resolved);
      const hsl = ColorFunctions.RGBToHSL(bytes[0], bytes[1], bytes[2]);
      color_button.style.color = hsl.l > 0.5 ? "#000" : "#fff";
      color_button.dataset.color = JSON.stringify(
        color_button.style.backgroundColor ? { text: color_button.style.backgroundColor } : {}
      );
    });
    color_input.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.stopPropagation();
        event.preventDefault();
        color_button.click();
      }
    });
    if (/firefox/i.test(navigator.userAgent)) {
      scroller.addEventListener("scroll", () => {
        if (this.DOM.view && this.DOM.doc?.activeElement instanceof this.DOM.view.HTMLElement) {
          this.DOM.doc.activeElement?.blur();
        }
      });
    } else {
      scroller.addEventListener("scroll", () => sheet.Focus());
    }
    let handlers_attached = false;
    const escape_handler = (event) => {
      if (event.key === "Escape") {
        event.stopPropagation();
        event.preventDefault();
        Promise.resolve().then(() => sheet.Focus());
      }
    };
    const focusout_handler = (event) => {
      if (handlers_attached) {
        if (event.relatedTarget instanceof Node && toolbar.contains(event.relatedTarget)) {
          return;
        }
        toolbar.removeEventListener("keydown", escape_handler);
        toolbar.removeEventListener("focusout", focusout_handler);
        handlers_attached = false;
      }
    };
    const PositionMenu = (event) => {
      let target = event.target;
      let parent = target?.parentElement;
      if (target?.classList.contains("treb-menu")) {
        parent = target;
        for (const child of Array.from(parent.children)) {
          if (child.tagName === "BUTTON") {
            target = child;
            break;
          }
        }
      } else if (!parent?.classList.contains("treb-menu")) {
        return;
      }
      if (target && parent) {
        if (!handlers_attached) {
          toolbar.addEventListener("focusout", focusout_handler);
          toolbar.addEventListener("keydown", escape_handler);
          handlers_attached = true;
        }
        if (parent.dataset.colorCommand) {
          color_chooser.querySelector(".treb-default-color")?.setAttribute("title", parent.dataset.defaultColorText || "Default color");
          parent.appendChild(color_chooser);
          color_chooser.dataset.colorCommand = parent.dataset.colorCommand;
          color_chooser.dataset.target = parent.dataset.replaceColor || "";
        }
        const menu = parent.querySelector("div");
        const scroller_rect = scroller.getBoundingClientRect();
        const target_rect = target.getBoundingClientRect();
        let { left } = target_rect;
        const group = parent.parentElement;
        if (group?.hasAttribute("composite")) {
          const element = group.firstElementChild;
          const rect = element.getBoundingClientRect();
          left = rect.left;
        }
        const menu_rect = menu.getBoundingClientRect();
        if (parent.classList.contains("treb-submenu")) {
          menu.style.top = target_rect.top - menu_rect.height / 2 + "px";
          if (left + target_rect.width + 6 + menu_rect.width > scroller_rect.right) {
            menu.style.left = left - 6 - menu_rect.width + "px";
          } else {
            menu.style.left = left + target_rect.width + 6 + "px";
          }
        } else {
          menu.style.top = target_rect.bottom + "px";
          if (left + menu_rect.width > scroller_rect.right - 6) {
            menu.style.left = target_rect.right - menu_rect.width + "px";
          } else {
            menu.style.left = left + "px";
          }
        }
        const focus = menu.querySelector("textarea");
        if (focus) {
          requestAnimationFrame(() => focus.focus());
        }
      }
    };
    const format_menu = this.root?.querySelector(".treb-number-format-menu");
    if (format_menu) {
      this.UpdateDocumentStyles(sheet, format_menu);
      this.UpdateSelectionStyle(sheet, toolbar, comment_box);
      sheet.Subscribe((event) => {
        switch (event.type) {
          case "focus-view":
            break;
          case "data":
          case "document-change":
          case "load":
          case "reset":
            this.UpdateDocumentStyles(sheet, format_menu);
            this.UpdateSelectionStyle(sheet, toolbar, comment_box);
            this.UpdateRevertState(sheet);
            break;
          case "selection":
            this.UpdateSelectionStyle(sheet, toolbar, comment_box);
            break;
        }
      });
    }
    const safari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    toolbar.addEventListener("focusin", (event) => {
      PositionMenu(event);
    });
    if (safari) {
      const elements = Array.from(toolbar.querySelectorAll(".treb-menu"));
      for (const element of elements) {
        element.tabIndex = 0;
      }
      toolbar.addEventListener("mousedown", (event) => {
        PositionMenu(event);
      });
    }
  }
};

// treb-embed/src/custom-element/treb-global.ts
var TREBGlobal = class {
  /** 
   * Package version 
   * 
   * @privateRemarks
   * 
   * we know this string won't be undefined at run time, but ts doesn't know
   * because we're using process.env as a placeholder. so we add the default
   * empty string to force type generation as a string, otherwise it would 
   * be string|undefined.
   * 
   * esbuild (or any other compiler) should remove the default value after 
   * building so it won't cost us anything.
   */
  version = "28.10.4";
  /** 
   * Create a spreadsheet. The `USER_DATA_TYPE` template parameter is the type 
   * assigned to the `user_data` field of the spreadsheet instance -- it can
   * help simplify typing if you are storing extra data in spreadsheet
   * files. 
   * 
   * Just ignore this parameter if you don't need it.
   * 
   * @typeParam USER_DATA_TYPE - type for the `user_data` field in the 
   * spreadsheet instance
   */
  CreateSpreadsheet(options) {
    const container = options.container;
    const instance = new SpreadsheetConstructor(container);
    instance.AttachElement(options);
    if (!instance.sheet) {
      throw new Error("construction failed");
    }
    return instance.sheet;
  }
};
var TREB = new TREBGlobal();

// treb-embed/src/custom-element/treb-spreadsheet-element.ts
if (typeof HTMLElement !== "undefined") {
  class TREBElement extends HTMLElement {
    /** access the embedded spreadshet object via the element */
    get sheet() {
      return this.instance.sheet;
    }
    /** 
     * instance of the constructor class 
     */
    instance;
    constructor() {
      super();
      this.instance = new SpreadsheetConstructor(this);
    }
    connectedCallback() {
      this.instance.AttachElement();
    }
  }
  if (typeof customElements !== "undefined") {
    if (customElements.get("treb-spreadsheet")) {
      console.info(`custom element treb-spreadsheet is already defined.`);
    } else {
      customElements.define("treb-spreadsheet", TREBElement);
    }
  }
}
export {
  TREB,
  TREBGlobal
};
